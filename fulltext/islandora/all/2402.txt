NOTE TO USERS

This reproduction is the best copy available.

UMI

C O N C U R R E N T T R A N S A C T IO N L O G IC W IT H P R IO R IT Y A N D T IM IN G C O N S T R A IN T S
by JIWEN GE B.Eng Hangzhou, ZheJiang, P.R.China, 1989 A thesis presented to Ryerson University

in partial fulfillment of the requirement for the degree of Master of Applied Science in the Program of Electrical and Computer Engineering Toronto, Ontario, Canada, 2004 G^JPATDN GE2004

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

UMI Number: EC52923

INFORMATION TO USERS

The quality of this reproduction is dependent upon the quality of the copy submitted. Broken or indistinct print, colored or poor quality illustrations and photographs, print bleed-through, substandard margins, and improper alignment can adversely affect reproduction. In the unlikely event that the author did not send a complete manuscript and there are missing pages, these will be noted. Also, if unauthorized copyright material had to be removed, a note will indicate the deletion.

UMI
UMI Microform EC52923 Copyright 2009 by ProQuest LLC. All rights reserved. This microform edition is protected against unauthorized copying under Title 17, United States Code. ProQuest LLC 789 E. Eisenhower Parkway PC Box 1346 Ann Arbor, Ml 48106-1346

Borrower's Page
Ryerson University requires the signatures of all persons using or photocopying this thesis. Please sign below, and give address and date.

N am e

Signature

A ddress

D ate

Ill

Reproduced with permission of the copyright owner. Further reproduction prohibited without perm ission.

C O N C U R R E N T T R A N S A C T IO N LOGIC W IT H P R IO R IT Y A N D T IM IN G C O N ST R A IN T S
Master of Applied Science 2004 JIWEN GE Electrical and Computer Engineering Ryerson University

Abstract
Concurrent Transaction Logic {CTTZ) is a deductive language for programming database transaction applications th a t integrates queries, updates, and transaction composition in a complete logical framework. The language supports all the properties of classical trans actions and the properties found in some new transaction models, e.g., sub-transactions, transaction rollback, and concurrent transactions. The contributions of this thesis are twofold. First, it extends CTTZ to account for timing-event-based prioritized concurrent systems in which transactions may have pri ority and timing constraints. This extension of CTTZ, here called TV-CTTZ, provides a high-level logic programming framework for specifying and simulating executions of timed transactions and trigger-events commonly present in real-time concurrent appli cations. Second, it describes a Prolog implementation of TV-CTTZ. The implemented TV-CTTZ prototype supports the translation from TV-CTTZ to CTTZ. Underlying this protocol, we use a simplified Rate-Monotonic algorithm [10] to schedule the execution of constraint concurrent transactions and built-in timing predicates to handle transaction time-r dations.

IV

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without permission.

Acknowledgment
I appreciate the support and encouragement from Dr. Marcus Vinicius Santos , my supervisor. His expertise in Transaction Logic and Logic programming was instrumental for this work. I would hke to thank all the committee members for their participation in my thesis defense. I would like to thank the Electrical and Computer Engineering Department at Ryerson University for the financial support of my study and research. I would like to thank all staff of the Electrical and Computer Engineering at Ryerson University for their kind help. I wish to convey the warmest thanks to my family for their endless support.

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without permission.

C on ten ts

1 2

Introduction A n introduction to CTTZ 2.1 2.2 S y n ta x .................................................................................................................... Database States and Elementary Updates 2.2.1 2.3 2.4 .....................................................

1 5 5 7 7 8 13 16 16 22 22 23

The Relational O r a c l e ............................................................................

Examples oî CTTZ F o rm u la s.............................................................................. CTTVs Inference S y s te m .....................................................................................

3 T he CTTZ P rototyp e 3.1 3.2 System Description of the CTTZ P ro to ty p e ..................................................... Executing CTTZ Prototype F o rm u la s ............................................................... 3.2.1 3.2.2 3.3 4 Sequential E x e c u tio n ............................................................................... Concurrent Execution ............................................................................

State Updates and Q u eries......................................................................................24 26 27 28 30 33

TV-CTTZ 4.1 4.2 4.3 4.4 Syntax of TV-CTTZ Priority and Timing C o n stra in ts................................... Informal Semantics of T V -C T T Z ........................................................................ Inference S y s t e m .................................................................................................. Interpreting Constraint Concurrent Horn Rules 4.4.1 4.4.2 ............................................

Compiling Priority C o n s tr a in ts ................................................................ 33 Using the Inference System to Execute Transactions......................... vi 34

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

4.4.3 5

Compiling Timing C on strain ts.............................................................. 34 36 36

The T V -C T T l P ro to ty p e 5.1 The T V -C T T l Prototype C o m p ile r................................................................... 5.1.1 5.1.2

Transaction Base Internal S y n ta x ........................................................ 38 The T V -C T T l Prototype D a ta b a s e ..................................................... 41 42 43

5.2 The T V -C T T l Prototype I n te r p r e te r ............................................................... 5.2.1 5.2.2 5.2.3 6 Underlying Scheduling Algorithm in the TP-C TT i Interpreter . . .

Interpreting and Scheduling Priority C onstraints................................... 44 Interpreting Timing C o n strain ts............................................................ 47 49 49 52 55 57 57 57 58 58 59 59 59 60 61 61 61 62

Tim e-based P rioritized T V -C T T l Program Exam ples 6.1 A Time-based Financial Transaction A pplication.............................................

6.2 A Simplified Elevator Logic Control A p p licatio n ............................................. 7 A C onclusions and Future W orks T V -C T T l Tutorial A.l T V -C TTl Prototype File S y s te m ......................................................................

A.2 Getting S t a r t e d ...................................................................................................... A.3 T V -C T T l Prototype Commands and Program F ile s ...................................... A.3.1 Compiling Commands in T V - C T T l ...................................................... A.3.2 Execution C o m m a n d ................................................................................ A.4 The T V -C T T l Prototype S y n t a x ...................................................................... A.4.1 Transaction R u le s...................................................................................... A.4.2 Database R u l e s ...................................................................... A.5 Built-in T V -C T T l P r e d ic a te s ............................................................................ A.5.1 Database D eclaration................................................................................ A.5.2 Built-in Predicates in T ransaction-base................................................ A.6 Programming Examples ......................................................................................

YU

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

Bibliography

vui

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without permission.

List o f F igu res
3.1 3.2 3.3 3.4 3.5 5.1 5.2 5.3 Use case diagram for the CTTZ. s y s t e m ............................................................ The CTTZ p r o to t y p e ........................................................................................... The CTTZ In te rp rete r............................................................................................ The CTTZ program files ........................................ 17 17 18 18 21 37 46 48

CTTZ prototype use case s c e n a rio ...................................................................... The TV-CTTZ compiler......................................................................................... The list priority L ist in TV-CTTZ interpreter................................................... Timing logic handled in the TV-CTTZ interpreter............................................

IX

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without permission.

List o f T ables
2.1 3.1 4.1 A deduction for program ( 2 .2 ) ........................................................................... Corresponding notations used in the CT7?. prototype and C T T ^ ............... A deduction for program ( 4 .3 ) ........................................................................... 15 19 34

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

C h ap ter 1 In tro d u ctio n

T

h i s thesis introduces concurrent transaction logic with priority and timing constraints(T7^-CT7?.), an extension of Concurrent Transaction Logic {CTTZ). T V -

CTTZ is designed to provide a high-level logic programming framework for specifying and simulating the control logic of time-related concurrent systems. Concurrent Transaction Logic is a recently proposed deductive database language, introduced by Bonner and Kifer in [1]. It is based on Transaction Logic (TTZ) [3], also known as sequential Transaction Logic. CTTZ extends TTZ with connectives for modeling the concurrent execution of complex processes, in the sense th a t it integrates concurrency, communication, and database updates ir a complete logic framework. In CTTZ., concurrency is accomplished by interleaving the execution of concurrent transactions. Such mechanism is implemented in the CTTZ prototype in terms of a pure Round-Robin algorithm [10]. Hence, in CTTZ, the underlying scheduling algorithm for the selection of next executed transaction component from a concurrent transaction execution does not follow any explicit priority-based scheme. As for sequential transactions, CTTZ uses the sequential conjunction operator ( ® ) to denote the order of transaction execution, e.g., a ® b ® c means: first executes transaction a, then transaction h, then transaction c. Exception handling excluded, in CTTZ, there is no other mechanism one can use to force a particular execution sequence of transactions. Moreover, CT% does not provide any timing constraint type predicate which is necessary

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

2

for embedding scheduled events m a database transaction application system, e.g., a real-time database application in which some events can trigger expected transactions at specified times. The study on the use of logics in real-time systems has been the subject of substantial research in the past and nowadays. In [4], Bellirl and Mattolini reviewed a selection of the most representative temporal logics designed for real-time systems. For the specification of a real-time system behaviour, the time behaviour of a system is naturally described with constraints on event occurrences in [5]. Chen and Tsai present a modification of a pure tem poral logic in [6], describing the system behaviours in terms of absolute timing of events as well as their relative ordering which can tell when the state actually occur. Torp and Jensen even assigned d ata with time properties in [7] . As well, Ulusoy and Sivasankaran studied the use of logics to specify priority properties in real-time systems [8, 9] respectively. More specifically they focus on the design of scheduling algorithms to improve the protocol efficiency and maximize the number of transactions satisfying their real-time constraints. However, these works focus either on priority constraints or on timing constraints. They do not combine these two types of constraints in one logic framework. We deem this greatly limits their application as formalism for specifying timing-related systems. In our approach, on the other hand, we are able to handle both types of constraints. To be able to provide a formalism for specifying and simulating timing-event-based systems w ith explicit priority, in this thesis we extend CTTVs inference system by defining a priority-constraint-based inference system, which allows us to formally execute formu las using a SLD-style refutation mechanism. Such inference system is implemented in the interpreter in terms of a simplified Rate-Monotonic Scheduling algorithm instead of a pure Round Robin scheduling algorithm. Our logical framework also introduces tim ing constraint formulas for specifying timing properties commonly found in real-time application domains. This improved timing-event-based concurrent transaction logic we call TV-CTTZ. Like CTTZ, TV-CTTZ is a language for programming database transac

R eproduced with perm ission of th e copyright owner. Further reproduction prohibited without perm ission.

3

tions and applications. T V -C T 7V s timing and priority constraints enable programmers simulate real-time features in TV-CTTZ, e.g., time-event-driven and interrupt. The timeevent-driven feature can be simulated by the TV-CTTZ's timing constraints. Also, the key feature of real-time software system, interrupt, can be created by combining these two constraints: timing constraints and priority constraints. These features extend the use of logic programming languages to timing-event-based real-time database transaction apphcations. A lot of real-time simulation platforms, current in use or under research, use procedure languages to design the real-time system, such as c in VxWorks [11] and RT-Linux [12]. It is unquestionable th a t the solutions designed by procedural languages usually provide high performance for real-time applications. But this is not always the case. To some real time systems, e.g., real-time database applications, real-time systems with complicated control logic, simulations designed with procedural languages appear to be difficult and timing-consuming jobs. This is because procedural languages focus on com putation result. B ut complicated logic include numerous computation results corresponding to the large amount of composite scenarios of pre-conditions. In such cases, simulating with procedural language is timing-consuming and low efficient. On the other hand, logic programming shows its advantages on this problem since logic programming focuses on the nature of control logic and explores every possible solution of it. As a type of logic programming, TV-CTTZ not only has the natural advantages of logic programming to handle complicated control logic problems, but also includes real-time functionalities. By combining priority and tim ing constraints, and the high-level logic programming framework provided by CTTZ-has&à approaches in a complete logic framework, TV-CTTZ provides a possible better solution to handle these real-time applications with complicated control logic over procedural language c. Along with the introduction of TV-CTTZ, the thesis also presents an implementation of TV-CTTZ in Prolog, based on the CTTZ prototype. It is assumed th a t the reader is already familiar with Prolog. The prototype runs on the XSB prolog interpreter [15, 16],

R eproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

currently the most efficient deductive database system.

Thesis Outline
The thesis is organized as follows: · Chapter 2 briefly presents the essentials of CTTVs syntax and semantics. Those readers more acquainted with CTTZ could skip this chapter. · Chapter 3 describes a system view of the CTTZ prototype software, and gives a detailed description of how program execution and scheduling take place in the prototype. · Chapter 4 introduces TT^-CTTZ, its priority and timing constraints syntax, infor mal semantics and inference engine, and shows how the inference engine is used to execute constraint concurrent transaction Horn rules. · Chapter 5 presents the developed TV-CTTZ prototype, focusing on the differences between the TV-CTTZ prototype and the CTTZ prototype. · Chapter 6 provides TV-CTTZ program examples on two different application areas, namely, time-based database transaction, and real-time control system. · Chapter 7 concludes the work and elaborates on possible improvements. Besides, the thesis includes one appendix, which presents a tutorial on how to use the software application developed in this thesis.

R eproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

C hapter 2 A n in tro d u ctio n to CTTZ

action Logic [3], integrates concurrency, communication, and database updates in a com plete logic framework. This chapter outlines the language using the terminolog}^ of de ductive databases. Details are available in [1, 2].

C

o n c u r r e n t Transaction Logic is a deductive database language for program ming database transactions and applications. The language, an extension of Trans

2.1

Syntax

The syntax of Concurrent Transaction Logic is similar to th a t of first order logic, ex cept th a t it extends first-order logic with three new logical connectives; ® , called sequential conjunction-, | , called concurrent conjunction-, and a modality of isola

tion, O , for specifying atomic actions th at executes atomically and in isolation, i.e., it does not communicate or interact with other programs. These operators are used to spec ify queries and to combine simple transactions into complex ones. The resulting logical formulas are called transaction form ulas. In certain im portant situations, CTTZ has an elegant, top-down, SLD-style proof pro cedure th a t can be expressed within CTTZ itself. The definition below, lists the conditions th at characterizes these situations. The subset of CTTZ th a t satisfies these conditions is called the Horn fragment of CTTZ.

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

6

D e fin itio n 1 (T h e H a m fr a g m e n t o f CTTZ) The syntax of the Horn fragment of CTTZ is defined recursively as follows: · An atomic formula is an expression of the form p(ti, symbol, and ti, are terms. where p is a predicate

· A concurrent sequential goal is in any formula of the form: -- An atomic formula; or -- ai ® ... ® af, or -- Ui I ... 1 a,; or
-- O Ui

where each Uj is a concurrent sequential goal, and i > 0. · If a is a concurrent sequential goal and t is an atomic formula, then t < -- a, is a concurrent Horn rule. · A transaction base is a set of concurrent Horn rules.


If a and b are transaction formulas, then informally: · a ® b means: first execute a, then execute b. · a \ b means: execute a and b concurrently. · Qa means: execute a "atomically" , i.e., without interleaving with other transactions. ®t · * -- a means: to execute t is sufficient to execute a.

\

Reproduced with perm ission of the copvriqht owner. Further reproduction prohibited without permission.

2.2

Database States and Elementary Updates

7

In CTTZ, a pair of oracles, called state data oracle and state transition oracle, specify elementary database operations. The state data oracle specifies a set of database state queries, and the state transition oracle specifies a set of database elementary updates. These oracles are not fixed because any pair of oracles can be plugged into a CTTZ theory. For ease of reference, below we present the definition of these oracles, introduced in [3]. D e fin itio n 2 (s ta te d a ta oracle) A state transition oracle O'^, is a mapping from sets of state identifiers to sets of first-order formulas. 

Intuitively, if Dj is a state identifier, then O'^(Di) is the set of formulas considered to be all the truths known about the state Dj. In practice, it is not necessary to materialize all these truths. Because, given a logical formula 4 > and a state identifier Di, the proof theory for CTTZ only needs to know whether (p E 0 `^(Di). Thus, to do inference in CTTZ, an enumeration of 0 ` ^(Di) is all th a t is needed. D e fin itio n 3 (s ta te tr a n s itio n oracle) A state transition oracle is a mapping

from pairs of state identifiers to sets of ground atomic formulas. These ground atoms are referred to as elementary transitions. 

Intuitively, if D i and Dg are two state identifiers, and h 6 0*(D i, Dg), then h is the set of elementary updates th at change state D% into state Dg. An elementary update can thus be non-deterministic, since for each update, the transition oracle defines a binary relation on states. In practice, this relation does not have to be materialized. Instead, for a given update u, and a given state D%, the proof theory of CT'IZ only needs an enumeration of the possible successoi tes, Dg.

2.2.1

T he R ela tio n a l Oracle

The examples in this thesis use the notion of relational databases, in which a state is a set of tuples, and elementary transactions consist of the insertion and deletion of individual

Reoroduced with perm ission of the coovriaht owner. Further reproduction prohibited without permission.

tuples from the database. In [1, 2, 3], Bonner and Kifer represent relational databases in the usual way as sets of ground atomic formulas. Moreover, they use two predicates, ins and del, to insert and delete atoms from the database. The definition of Relational Oracles formalizes this idea. D e fin itio n 4 (R e la tio n a l O racles) : A state D is a set of ground atomic formulas. The data oracle simply returns all these formulas. Thus O'^(D) = D. Moreover, for each p in D, the transition oracle defines two new predicates, ms(p) and del{p), representing the insertion and deletion of single atom p in D respectively as follows; ins{p)  0 `(D i, D 2 ) iff D 2 = D i + {p} del{p) E O ^ D i,D 2 ) iff D 2 = D i - {p}


It should be noted, however, that CTTL is restricted neither to relational databases, nor to update operations based on single tuple. Forinstance,databases could be deductive,

object-oriented, disjunctive, or a collection of scientific objects, such as matrices or DNA sequences. Likewise, database operations could include SQL-style bulk updates, or the insertion and deletion of rules, or complex scientific calculations, such as the Fourier transformation and matrix inversion. In CTTZ, the set of states is determined by the data oracle. Changing the oracles can change the set of states, and thus the set of semantic structures. This is one way in which different oracles give rise to different versions of CTTZ. In this thesis, we used the relational oracle for the simplicity.

2.3

Examples of CTTZ Formulas

This section gives some examples to illustrate CTTZ's syntax and informal semantics. The full description of CTTZ semantics is available in [1, 3]. We start with simple examples of sequential goals and concurrent sequential goals.

Reoroduced with oerm ission of the coovriaht owner. Further reoroduction orohibited without oerm ission.

9

S e q u e n tia l c o n ju n c tio n a n d d a ta b a s e u p d a te p re d ic a te s:

The formula below il

lustrates the sequential conjunction ( 0 ) combined with the elementary update predicates del and m s; del{r{a)) ® ins{s{a)) "Delete r{a) from the database, and then insert s(a)" . C o n c u rre n t se q u e n tia l goal: The formula below illustrates the use of the concurrent

and sequential conjunctions, | and 0 , respectively, in the specification of concurrent transactions:

(^ 1®" A ; )I

®
®

"Execute concurrently the transactions (f)i 0 ÿg and (/?i ® ip2 - To execute (j)i0 (p2 , first do tpi then cp2 , and similarly for

H o rn ru les: Like classical logic, CTTZ has a Horn-like fragment with both a procedural and a declarative semantics. The formula: q{X) < -- r{X ) 0 del{r{X)) 0 ins{s{X )) defines a subroutine with name q and parameter X. Given the parameter value a, q{a) commits if the atom r(a) exists in the databases before the updates execute and assuming r{X ) is a updatable database tuple. In the following examples, we show how CTTZ can be used to combine elementary operations into complex transactions. E x a m p le 1 (D a ta b a se tra n s a c tio n s for o p e ra tin g a n o n lin e sto re ) Assume a re lation inventory(Name, Am t) represents the amount of available goods in a store's inven tory, where N am e is the goods' name and A m t is an integer rep' renting the amount available. To simplify, we ignore the price and other factors. The rules below define three transactions in the transaction base:

Reoroduced with oerm ission of the coovriaht owner. Further reproduction prohibited without permission.

10

processjorder{C ustom Info, N am e^Am t)  < -- O ( inventory{Narae, OldAmt) ® O ldAm t > Ami < g ) N ew A m t is OldAmt -- Am t ® change-inventory{Name, OldAmt, N ew Am t) ® ins{record{C ustom Inf a, Nam e, Am t))) supply[SupplierInfo, Nam e, A m t) < -- 0 ( not inventory{Name, OldAmt) ® ins{inventory{Name, Amt)) ® ins{supplier{SupplierInfo, N am e, A m t))) supply{SupplierInfo, Nam e, A m t) < -- 0 ( inventory{N^ame, OldAmt) 0 N ew A m t is O ldAm t + A m t 0 change-inventory{Name, O ldAm t, N ew A m t) 0 ins{supplier{SupplierInfo, N am e, Am t))) change-inventory{Nam.e, OldAmt, N ew A m t) + -- 0 ( del{inventory{Name, OldAmt)) 0 ins{inventory{Name, N ew Am t)))

The first rule specifies: to sell an amount A m t of goods Name to a customer CustomerInfo, first check how many goods are available in the store's inventory database. If the available amount, OldAmt, is no less than the requested amount, A m t, then deduct A m t from the available amount O ldAm t, and update the latest inventory amount, and then record this transaction in the database; othervfise the process-order transaction should fail since the available amount of goods can not meet I'w demand of the order. The sec ond rule specifies the supplying transaction: to supply an amount A m t of goods into the inventory, if the goods' name are new to the inventory, add a new inventory record with the goods' name and amount, and then add another supplying record to the supplier's account; Otherwise, if the goods have already a record in the inventory, add the amount into th a t inventory record, and add another record to the supplier's account in the same way. The last rule is in charge of changing the amount of a goods in the inventory record: first delete the old record with the OldAmt, then insert a new record wi h Nam e and

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without permission.

11

N ew A m t. Due to the O operator, process-order, supply, and changeAnventory are all executed "atomically". T hat is , they execute either entirely or not at all. The transaction below specifies the concurrent execution of supply and procès sing-order: supply {supplier 1, tapel, A m tl) j processing-order{customerl, tapel, Am t2) That is, an amount A m tl of goods tapel is supplied by supplierl while a customer places an order for tapel. Because this is intended to be a transaction, if one sub-transaction fails, then both sub-transactions are rolled back whatever the other sub-transaction succeeds or fails. Notice that, the CTTZ program behaves correctly while an equivalent Prolog program could not; updates in Prolog are not logical. If the execution fails after an update

is performed, the update cannot be undone. So although execution in Prolog can be backtracked, the database does not roll back to its initial state if updates are involved. Thus transaction fail in a Prolog program will lead to database inconsistency. 

The above example illustrates the combination of concurrency and updates th at CTTZ supports. The next example shows how CTTZ also supports communication, where two processes synchronize themselves by exchanging messages via communication signals.

E x a m p le 2 ("Synchronization b etw een tw o e lev a to r c o n tro l p ro cesses) Assume stopRequest-control and moving-control are two processes specified to control the stop request control system and the moAng control system of an elevator model, respectively. Here, our goal is to illustrate the communication between the two concurrent processes. Hence, we simplif): our model to enable one round processing of these two control pro cesses, without considering the loop condition.

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

12

stopRequest-control < -- ta sku ® send{requestSignal, FloorN um ) (g) receive{stopSignal, Fir) ® taski2 moving-control task 2 i ® receive{requestSignal, FloorN um ) < S ) moveTo{FloorNum) ® send(stopSignal, Fir) ® task22

where ta sk u and task 2 \ are initialization tasks of sto p R req u est-C o n tro l and m o v in g -c o n tro l, respectively; ta sk i2 and task22 are the post-handling tasks of sto p R e q u e s t-c o n tr o l and
m oving-control, respectively.

The next transaction specifies the concurrent execution of sto p R e q u e s t-c o n tr o l and
m ovin g-C ontrol:

stop Request-control | moving-control During execution, stopRequest-Control and moving-control can communicate and syn chronize the execution of their tasks effectively by sending and receiving messages along channel requestSignal and stopSignal. Note: send{Ch, M sg) and receive{Ch, Msg) are two communication predicates, which are used to send and receive a message M sg along a channel Ch, as shown in [1]. m oveTo cannot start moving the elevator to a specific floor until ta skn finishes and a F loorN um message is received along the requestSignal chan nel from the stop request control process. Likewise, stopRequest-control process cannot continue until moveTo finishes and a stop message F ir is received along the stopSignal channel. In such a way, the two processes communicate with each other and synchronize their execution steps.



Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission

2.4

CTTVs Inference System

13

This section first introduces the SLD-style resolution of the CTTZ inference system. This inference system is used to formally execute transactions. In Chapter 4, we will introduce an extension of this inference system, which allow us to formally execute transactions involving constraints.

S L D -style re so lu tio n The inference system manipulates expressions called sequents, which have the form P,Dh(3)(^ where P is a program, D is any legal database state, and ç i> is a concurrent sequential goal. The informal meaning of such a sequent is that, based on program P the formula (3) (j) can be proved from state D. Let the concurrent sequential goal clause be the expression -G o where Go is the sequent P ,D i h (3) < p

( 2 . 1)

A SLD-style refutation of -- Go is a sequence of goal clauses -- Go · ·  -- G,, where Gn is the empty clause, i.e., the sequent P ,D ,, H (), where D,, is a database state, and ( ) denotes the empty formula. This sequent is an axiom of the inference system, and this axiom states th a t the empty formula is true on any database state. Each + --Gi+i is obtained from + --Gi by using the inference system later presented in this section. Before presenting CTTZ's inference system, we deem relevant to also present the notion of hot components introduced in [1]. Summarily, hot components of a transaction (j), denoted hot{4>), is the set of transactions ready for execution in (j). Formally: D e fin itio n 5 (H o t c o m p o n e n ts ) Let ^ b e a concurrent sequential goal. Its set o^ not components, hot{(j)), is defined recursively as follows:

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

14

hot{{ )) = { } , where ( ) denotes the empty goal; hot{b) = {6}, if b is an atomic formula;
#

(g) - · · ® l/'n) = hot{'ipi)\ hot{ipi 1 · · · I ipn) = U · · U hot{i)n)\

· hot{Qi)) = {©0}


D e fin itio n 6 (CTTZ's In feren ce s y s te m ) The inference system consists of one axiom and four inference rules. A xiom : P ,D h (), for any state D Inference rules: In rules 1-4, a is a substitution, 0 and ip' are concurrent sequential goals, and hot {ip) -- a. 1. Applying rule definitions: Suppose 6  < -- /? is a rule in P whose variables have been renamed so th at the rule shares no variables with ip. lî a and b unify with mgu cr, then P , D h (3) ip'a P,D b(3)0 where 0 ' is obtained from ip by replacing an element of a by fi. 2. Querying the database: If then P ,D h (3 )0 V P,D h(3)0 where ip' is obtained from ip by deleting an element of a. 3. Executing elementary updates: If 0^(D i,D g) j=" (3)au, and aa and ip' share no variables, then j=^ (3)acr, and aa and ip'a share no variables,

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

15

P,D 2l- (3)^V

P,Dif-(3)V'
where 'tp' is obtained from ip by deleting an element of a. 4. Executing atomic transactions: If ©a- is the hot component in ip, then P ,D I - ( 3 ) (aigiV;') P , D h (3 ) ^ where ip` is obtained from ip by deleting an element of ©a.


Based on these inference rules, one can prove the execution sequence of both sequential executions and concurrent executions. Let us consider the following program.
P  < -- C l I 0 2

01 < -- m s (a) 02 < -- ins{b)

(2 .2)

The deduction of the transaction p is illustrated in Table 2.1.
T ab le 2.1: A deduction for program (2.2)

Sequents P , {} h ai 1 0 2 P , {} 1- ins{a) 1 0 2 P , {o} h 0 2 P , {o} h ins{b) P ,{ o ,6 } P 0

Inference rule Hot components
1 1

3
1

3 A xiom

{P} {o i, 02} {m s(o ), 02} {02} {m s (6)} {}

Each sequent in the table is derived from the one below by an inference rule. The deduction succeeds because the bottom-most sequent is an axiom. Carried out top-down, the deduction corresponds to an execution of the transaction p in which atoms o and b are inserted into the empty database in the order, first a, then b.

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

C h a p ter 3 T h e CTTZ P r o to ty p e

T

h e CTTZ prototype [13, 17] is an implementation of the Horn fragment of CT77. and CTTZ's inference system.

To facilitate the understanding of the TV-CTTZ prototype later introduced in Chapter 5, in this chapter we outline the CTTZ prototype by presenting a system view of the software application available in [17]. This chapter is organized as follows. First it presents a system description of the CTTZ prototype, describing its major components. Then it shows how the prototype handles sequential execution, concurrent execution, and database updates and queries.

3.1

System Description of the CTIZ Prototype

Figure 3.1 shows a use case diagram of the CTTZ prototype. As such, it shows the system functionalities seen from the user's viewpoint. These functionalities are two: to compile a CTTZ program into an internal program; and to execute transactions based on the translated internal program.

16

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

17

Figi

' ,.1; Use case diagram for the CT7Z system

CTR Prototype

Compile CT Programs

Execute Transactions^

To handle these functions, the CTTZ prototype system can be seen as consisting of a compiler and an interpreter, as shown in Figure 3.2 .

F ig u re 3.2: The CTTZ prototype

[CTR prototype

Compiler

Interpreter

The role of the CTTZ compiler introduced in [17] is to translate a CTTZ program into an internal format recognizable to the CTTZ interpreter. The CTTZ interpreter is an

R eproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

18

implementation of the CTTL inference engine, which is used to prove transactions based on the relational oracle and the translated CTTZ programs. Figure 3.3 shows the two most im portant components of the CTTZ interpreter: the inference engine and the relational oracle.

F ig u re 3.3: The CTTZ Interpreter

interpreter

Inference Engine

Relational Oracle

In the CTTZ prototype, a CTTZ program consists of a transaction base file and a database file, as shown in figure 3.4.

F ig u re 3.4: The CTTZ program files

CTR program

transaction base (.ctr)

database (.db)

Transaction-base files have the extension .ctr and database files have the extension .db. A transaction base is a program consisting of a set of concurrent Horn rules. Table

R eproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

19

3.1 illustrates the notations used in the CTTZ prototype and the corresponding notations used in CT7Z. Table 3.1: Corresponding notations used in the CTTZ prototype and CTTZ CTTZ Prototype * #
0

CTTZ

1

G

Meaning Logical implication Sequential conjunction Concurrent conjunction M odality o f isolation

A CTTZ prototype database is a Prolog rulebase, consisting of database rules and database tuple declarations. A database rule is a normal Prolog rule, which has one of the following forms: · an atomic formula; or · (f)  - A, where (j) is an atomic formula and a is a clause. There are two main reasons for putting rules in a CTTZ database: 1. to update them (only those rules in the CTTZ database can be changed at runtime).
2

. to express queries with negation-as-failure.

To illustrate, below we show an excerpt of a CTTZ database: finished unfinished not (unfinished), a(X). -- o(l). a(0).

u(lOO). <z(99).

The first and second rules specify a query with negation as failure. The atomic formulas a(_) specify which atoms are true in the initial database state. To update a database atom during execution, it must be declared as an updatable database tuple. Database tuple declarations are of the form

Reproduced with perm ission of the copvriflht owner. Further reproduction prohibited without perm ission.

20

updatable B./n. For instance, considering the database formulas above, the database tuple declaration below specifies th a t the tuple a with arity one, is updatable. updatable a/1. The example below illustrates the functionality of declarations and ground atomic for mulas. E x a m p le 3 (A s im p le book o rd e r a p p lica tio n ) The CT 7 ?. program below exempli fies a simple book order system. The book inventory is represented by the tuple book/1 in the database. · The transaction-base file book.ctr: order{X) order{X) o{book{X) * del(book{X))) * writeln{succeeded). w riteln{failed).

· The database file book.db: updatable bookjl. book{l). book{2). The transaction base specifies how orders of books are placed. The database defines an updatable tuple book/1, and includes two initial instantiations of the tuple hook, book{l) and book{2). 

Figure 3.5 shows a use case scenario describing how the user interacts with the CTTZ prototjTJe to compile and interpret a CTTZ program:

· The user compiles a CTTZ program. -- The CTTZ prototype compiler translates the Horn rules in the CTTZ program's transaction base.

Reoroduced with oerm ission of the coovriaht owner. Further reoroduction orohibited without oerm ission.

21

F ig u re 3.5: CTTZ prototype use case scénario

C om piler

Interpreter

tra n sa c tio n -b a se

d a ta b a s e

Compile a CTR program

translate CTR t ansaction base translate CTR database

Execute

consult consult answer answer

Result

-- The CTTZ prototype compiler translates the rules in the CTTZ program's database. · Wlien the user executes a transaction, the CTTZ prototype interpreter executes the transaction with inference engine. In each resolution step, the CTTZ prototype interpreter communicates with the transaction base and the database according to the executed transaction component in the following ways; -- Consulting the transaction base. -- Consulting the database. -- Updating the database. -- The CTTZ interpreter outputs the result to the user.

Reoroduced with oerm ission of the coovriaht owner. Further reoroduction orohibited without oerm ission.

^

3.2

Executing CTIZ Prototype Formulas

22

The CTTZ prototype interpreter uses a Round-Rohin scheduling algorithm to schedule multi-processes in concurrent transaction executions. This algorithm assumes that each transaction process in a concurrent execution has the same priority level. Thus, in the CTTZ prototype, these concurrent processes have the same opportunity to execute. In the CTTZ prototype, the hot component set introduced in Chapter 2 is implemented as a Prolog list. The transaction in the head of the list is selected for execution. If this transaction is defined as a rule in the transaction base, then the transaction formula in the body of the rule replaces the transaction, and then is inserted at the end of the list. When a transaction is selected, the CTTZ prototype interpreter executes one element of the transaction, and then feeds the remaining elements of the transaction back into the end of the list. This is consistent with the CTTZ inference system presented in Chapter
2

. In this way, the concurrent sequential transactions in the queue are able to execute in

equal turn. In the rest of this section, we analyze sequential executions and concurrent executions in the CTTZ prototype respectively.

3.2.1

Sequential E xecu tion

Sequential execution is the simpler type of execution, where transactions are connected with sequential conjunction operators. These transactions are executed in sequential order from left to right. When executing a sequential conjunction, such a.spi * P2 *   * Pn, the CTTZ prototype interpreter starts the execution from pi, then p 2 , and repeats until p,, is completed. If any given transaction pi fails, the whole transaction will roll back. Also, any transaction Pi could have been defined by rules. For instance, pi could have been defined as another sequential conjunction, i.e., pi a * b. During execution, the

CTTZ prototype interpreter would decompose any composite operation, e.g., replacing p\

Reoroduced with oerm ission of the coovriaht owner. Further reoroduction orohibited without oerm ission.

23

with a * b.

3.2.2

C oncurrent E xecu tion

The prototype simulate concurrency by interleaving the execution of concurrent processes with a Round-Robin scheduling algorithm. Consider the concurrent transaction execution: task a i* a2 * ... * an bi * b2 * * ... * bn-

To run this transaction, first, the Round-Robin algorithm picks up the first element from the first concurrent sub-transaction, ai- and executes it, then followed by the first element from the other concurrent sub-transaction,
61.

After that, the Round-robin algorithm

continues to pick up elements from the two concurrent sub-transactions in the same fashion and execute them until all the elements in the two sub-transactions are executed. The resulting execution sequence is: Oi, 6 1 , 0 2 , 6 2 , ···, «n, This applies for transactions consisting of more than two concurrent transactions, e.g., task Oi * 0 2 #
61

^ 62 # Cl * C 2.

The resulting execution sequence is Oi, ùi, ci, 0 2 , 6 2 , C 2 . And for transactions defined as concurrent rules, e.g., task
. '- O i * a # * 63.

a
j3

02

* 03.

bi * 62.

After replacing transactions a and P with their respective definitions, the resulting exe cution sequence is : task oi * 0 2 * 0 3 #
61

* 62 * 6 3 .

In this way, a composite transaction can be decomposed to an execution sequence con sisting of elementary operations.

Reoroduced with oerm ission of the coovriaht owner. Further reoroduction prohibited without oerm ission.

3.3

State Updates and Queries

24

In CTTZ, the semantics of database states queries and updates are defined by a pair of relational oracles, called, state data oracle and state transition oracle. The CTTZ prototype uses the following predicates to implement the state queries and updates defined in the oracles. · db{p) determines whether atom p is true in the current database state. · ins{p) inserts atom p in the database. · del{p) deletes atom p in the database. To be able to preserve the database consistency when a transaction that updates the database fails, the CTTZ prototype uses a backtracking mechanism for undoing updates, i.e., to rollback the failed execution and enable re-execution. It performs a relative commit of the updates, as opposed to an absolute commit, which commits only after the entire transaction succeeds. Considering the following transaction; ins{a) * db{b) * ins{c) Assume atom a and c are not in the initial database. The first update ins(a) inserts the atom a into the database. Then, the second operation queries the database. If the atom b exists in the database, then the third operation, ins{c), will take place and thus the three atoms are all in the final database. However, if the atom b is not in the database, then the transaction execution fails, and the update ins{a) is undone. In this case, although the update performed by ins{a) has been already executed, the database is able to restore to its initial state and the database consistency is thus guaranteed. The undo is possible because the commit was not absolute, but was relative to the overall transaction. To undo updates in a failed transaction, the CTTZprototype actually introduces

two underlying atom tags to represent the existence of an updatable atom p, namely, inserted{p) and deleted{p).

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without permission.

25

The atom p is true in the database if inserted{p) is true and deleted{p) is not true in the database. The atom p is not true in the database if deleted{p) is true or inserted{p) is not true. By implementing these two atom tags, the technique in [17] leads to transaction roll back or partial rollback, and re-execution when a failure occurs, and thus prevents the Prolog database from being corrupted by backtracking through updates.

Reproduced with permission of the copyright owner. Further reproduction prohibited without perm ission.

C hapter 4

rv-crn

A

l t h o u g h CTTI is a logic for specifying and executing database processes involv ing queries and updates concurrently aS' well as serially, CTTi, does not support

explicit priority constraints in its logic framework. In CTTZ, the programmer ^ uses the sequential and concurrent connectives to specify the ordering of a transaction execution. In a concurrent conjunction, there is no preference over which transaction will be selected for execution. Hence, CTTZ's orientation is towards logic eventuality rather than real time immediacy. This particular feature of the logic has limited its application extended to real-time domains. Also, CTTZ can not handle timing-related applications due to lack of timing constraints, e.g., a timing relation to specify when to execute a process. To overcome this limitation, and extend concurrent transaction logic to the real-time domain, we extend the CTTZ logic framework to a so-called timing-event-based priori tized concurrent transaction logic {T'P-CTTZ), which provides a high-level formalism for specifying priority constraints and timing constraints in timing-event-based transaction applications. Summarily, T'P-CTTZ extends CTTZ in the sense th a t it introduces con straints in concurrent Horn rules, a translation mechanism to translate such rules, and an inference system to handle prioritized transactions. In this chapter, we describe the TT^-CTTZ's syntax, informal semantics, the inference system and the interpretation of constraint concurrent Horn rules.
^Like C'TTZ, 'T'P-C'T'IZ is a logic for programming transactions. program m ers are considered synonyms Hence in this thesis, users and

26

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

4.1

Syntax of T V -C T IZ Priority and Timing Con straints

27

CTTZ does not include priority constraints in its logic framework. In CTTZ, the program mer uses the sequential and concurrent connectives to specify the transaction execution order in programs. For instance, in a concurrent conjunction, all the concurrent processes have the same opportunity to be selected for execution. This feature of the logic has limited its apphcation in real-time domains. T'P-CTTZ, an extension of CTTZ, is designed to provide a high-level framework for specifying priority constraints and timing constraints in concurrent transaction logic sys tems. To allow the specification of priority constraints and timing constraints th a t may be used to trigger or interrupt other transactions, we use constraint concurrent Horn rules. In T'P-CTTZ, b -r-- < j) : -ip is a. constraint concurrent Horn rule if
6

t-- 0 is a concurrent

Horn rule and ip is a constraint formula. A TP-CTTZ program is composed of a set of constraint concurrent Horn rules. The definition of the concurrent Horn rule
6

^ here

is the same as th a t in CTTZ, as shown in definition 1. Below is the definition of the constraint formula ip. D e fin itio n 7 ('C o n strain t form ula) A Constraint formula is any formula of the form: » priority{a,p), where a is an atomic formula in (p and p is an integer number, rep resenting the priority level of the atomic formula a. · tim eElapsedit) an atom in (p. · ipi A · · · A ipk, where each ipi is a constraint formula, and K >t). triggerE vent(a), where t is a positive integer number, and a is


With the above extended syntax definition, we can use constraint concurrent Horn rules to specify priority and timing constraints, which may be used to trigger or interrupt other transactions.

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

28 W hen a constraint concurrent Horn rule has no constraint formula, it becomes a concurrent Horn rule. A TV-C TH . program consists of both a set of concurrent Horn rules and a set of constraint concurrent Horn rules.

4.2

Informal Semantics of T V -C T T l

Next we introduce the informal semantics of constraint concurrent Horn rules from the users' viewpoint.

P r io rity c o n stra in ts In TV-CTTZ, priority constraints specify the execution priority of transactions occurring in a concurrent goal formula. For instance, the constraint concurrent Horn rule below specifies the execution priorities of the concurrent transactions p, q, and r. g < -- p 19 1r : priorityip, 2) A priority{q, 1) A priority{r, 1) "To execute s, execute p, q, and r concurrently, observing th at p has higher priority th an q and r, and q has the same priority as r." Notice th a t the second argument of the priority predicate represents the execution priority level of the predicate occurring in its first argument. The bigger the number representing the priority level, the higher its execution priority is. Priority levels ranges from 1 to 100. The default priority level of a transaction predicate is 1, i.e., if a constraint concurrent Horn rule does not specify the priority of a transaction predicate explicitly, then it is given the lowest execution priority. B ut then one might ask: why use the complicated formula above when one can more succinctly write the equivalent and more straightforward formula below? s < -- p ® (g I r) (4.1)

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without permission.

29 This is because priority constraints like the ones in Expression (4.1) are useful specially when combined w ith timing constraints. The examples in the rest of this section illustrate the point.

T im ing C onstraints Timing properties are usually specified by the timing relations among events. In [5], the timing relations refer to terms of time th at specify constraints among events. We are interested in these timing properties and adopt some of them into our system . Below we illustrate some examples involving timing constraints. Let b, c, and d be transactions. T he rule below specifies a timing constraint for b: a < -- fe I c I d : timeElapsed{100) triggerEvent{b) (4.2)

The rule above specifies the following: to execute a, execute b, c, and d concurrently, but delaying the execution of b 100 seconds. T h at is, for the first 100 seconds, only c and d should run concurrently, and then after
100

seconds, transaction b should be triggered,

and thus added to the concurrent execution. The example below illustrates how priority and timing constraints can be combined to provide interesting real-time interrupt behavior. Let again b, c, and d denote transactions. The constraint concurrent Horn rule below, specifies timing and priority constraints for transaction b. a  f-- h \ c \ d : timeElapsed(lQ^i) -- ^ triggerEvent{b) A priority{b, 2) The priority constraint specifies th a t b has execution priority over c and d. Notice th at no constraint is specified for c or d, i.e., they run as a flat concurrency (with the default priority level 1). The timing constraint specifies th at the execution of b should start 100 seconds after a is activated. Let's assume th a t c and d represent complex transactions whose respective execution times last for more than 200 seconds time. Given these assumptions, since b has high

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

30

execution priority, the activation of b should interrupt the execution of c and d. T hat is to say, after
100

seconds, b starts execution, and c and d are suspended because of their

lower priority level. Until b finishes its execution, the execution of c and d can be resumed. This behavior of concurrent transaction execution, created by the combined use of timing and priority constraints, illustrates the interrupt functionality. This is what often happens in a real-time domain scenarios, and the reason why we introduce the priority constraint into the extended system. Some comments on the use of constraints in T'P-CTTZ: one may have noticed th at priority constraints are not suitable for all transactions in a concurrent sequential goal. For example, suppose a, 6 , and c are transactions, and r is defined by the rule below;
r < --a ® 60 c

It does not make sense to specify a priority for the transactions occurring in the body of the rule above, since the semantics of the the goal o
0 6 0 0

connective specifies the execution order of

c. Priority constraints only make sense when thev refer to transactions

occurring in a concurrent conjunction, since it can change the execution sequence of the transactions involved in the conjunction.

4.3

Inference System

The inference system introduced here differs from the inference system introduced in CTTZ in the sense th a t in CTTZ, there is no criteria for selecting which transaction in a concurrent goal will be executed. This means in CTTZ, the execution order of concurrent transactions is non-deterministic. In T'P-CTTZ, on the other hand, a simplified Rate Monotonie scheduling algorithm based on the priority level of a predicate, is employed as the selection criteria. Thus, the execution order of concurrent transactions with different priority levels is deterministic. The next definition formalizes this idea. It defines the transaction to be executed amongst the candidates for execution. We refer to it as the "hott( st" component of a

R eproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

31

concurrent sequential goal. D e fin itio n 8 (H o tte s t c o m p o n e n t) Let be a concurrent sequential goal. Its hottest

component, denoted hottest{(p), is defined recursively as follows: · hottest{{ )) = {}, where ( ) is the empty goal; · hottest{b) = {6 }, if &is a atomic form.ula;
#

hottest(ipi ® · · · < g ) 'ipk) -- hottest^il)])-, , i î pLevel{hottest{'tpi)) > pLevel{hottest{ip 2 | " - | ipk)) , hottest{ip 2 \ \ ipk) , otherwise where pLevel{<p) denotes the priority level of (p.

(

hottest^ipi)

» hottest{Qip) = Qip.


Since the compiler adds an extra first param eter to all prioritized predicates and encodes in this param eter the priority level of the predicate, one can obtain the priority level of a sequential goal as follows: · pLevel{p{priority{l), ···)) = I, if p{- ·) is an atomic formula; · pLevel{ipi (g) · · · ® '^/.) = pLevel{ipi)

Like CTTZ, T'P-CTTZ also uses the SLD-style resolution introduced in Chapter 2, the only difference between them being the inference rules and the notion of hot component used in CTTZ, and hottest component used in TP-CTTZ. In CTTZ, hot component is a set representing the sub-transactions ready for execution. In TP-CTTZ, hottest component is the first highest priority-level component of the CTTZ hot component set.

A xiom : P , D h ( ), for any state D

R eoroduced with oerm ission of the coovriaht owner. Further reoroduction orohibited without oerm ission.

32

In fere n c e ru les: In rules 1-3, cr is a substitution, ijj and 'tp' are concurrent sequential goals, and hottest{ip) -- a. 1. Applying rule definitions: Suppose b fi is a rule in P whose variables have

been renamed so th a t the rule shares no variables with ip. If a and b unify with mgu cr, then P ,D h {3) Ip'a P ,-D \-{3)iP where ip' is obtained from ip by replacing a by fi. 2. Querying the database: If O'^ÇDi) then P ,D h {3) Ip'a P ,-D b {3 )iP where ip' is obtained from ip by deleting a. 3. Executing elementary updates: If no variables, then P , D 2 l - ( 3 ) iP 'a Dg) (3)acr, and aa and ip' share (3)acr, and aa and ip'a share no variables,

P,Dil-(3)V
where ip' is obtained from ip by deleting a. 4. Executing atomic transactions: If © a is the hottest component in ip, then P , D I - ( 3 ) { a ® Ip') P,D h(3)V ' where ip' is obtained from ip by deleting
0

a.

Each inference rule consists of two sequents, and has the following interpretation; if the upper sequent (Gj+i) can be inferred, then the lower sequent (Gj) can also be inferred.

R eoroduced with oerm ission of the coovriaht owner. Further reoroduction orohibited without oerm ission.

4.4

Interpreting Constraint Concurrent Horn Rules

33

Based on the constraint formalism presented in the above sections, here we initially present how the TV-CT'R, interpreter translates constraint concurrent Horn rules into concurrent Horn rules. Then we show how to formally execute prioritized constraint concurrent Horn rules using the SLD-style resolution procedure. Finally we illustrate how the TV-CTTZ compiler translates the concurrent Horn rules with timing constraints.

4.4.1

C om p iling P riority C onstraints

To illustrate how the translation takes place, we use the following example: let the pro gram below define transactions s, p, and q. s< r- p I q: priorityip, 2 ) p< -- ins{ria)) q< -- ins{rih))

(4.3)

Notice th at the first rule specifies: to execute s,execute p and qconcurrently. Its constraints specify: in the concurrent sequential goal p \ q, p has higher priority than q.

The second and third rules specify: to execute p, insert the atom r(a) in the database; to execute q, insert the atom r ( 6 ) in the database. In essence, the compilation consists of translating the priority predicates occurring in the constraint formula into function terms. These function terms are added as an extra argument to the respective predicates in the head and body of the concurrent Horn rules. Below we present the result of the translation of program (4.3). s< -- p{priorityi2)) | q{priority{!)) p{priority{2)) + --ins{r(a)) q{priority{l)) < -- ins{r{h)) Notice th a t the compiler assigned the default priority level 1 to transaction q.

(4.4)

Reoroduced with oerm ission of the coovriaht owner. Further reoroduction orohibited without oerm ission.

34

4.4.2

U sin g th e Inference S ystem to E x ecu te Transactions

W ith the TV-CTTZ four inference rules, we can deduce the transaction s defined in program (4.3) as in the Table 4.1. Notice in program (4.3) and on Table 4.1 that if no priority constraints is used in the specification of s, then there are two possible sequence of database states when s executes: one in which r(a) is inserted first and then r{b) is inserted, and the other in which r{b) is inserted first and then r{b). However, because of the priority constraints bound to transaction p and q, they force the transaction s to run in a definite sequence, which causes r(a) to be inserted before r{b) is inserted in the database.
T able 4.1: A deduction for program (4.3)

Sequents Inference rule Hottest component s 1 P ,{}H s p{priority{2)) 1 P ,{ } h p(priority(2)) | q{priority{\)) ins{r[a)) P , {} h ins{r{a)) j q{priority{l)) 3 q{priority{l)) P , {r(n)} h q{priority{l)) 1 ins{r{b)) P , { r ( a ) } h ins{r(b)) 3 P , { r ( a ) , r ( 6 )} h () A xiom {}

4.4.3

C om piling T im in g C onstraints

The program below specifies a timing constraint for transaction b. o s -- 6 I c j d ; timeElapsed{WO) -- ) triggerEvent{b) b< -- ins{r{e)) c in s{r{f)) d < -- ins{r{g)) The TV-CTTZ interpreter translates it into the following program a < -- 6 1c 1d b *-- timeElapsed{100) ® ins{r{e)) c ins{r{f)) d 4- ins(r(g))

(4.5)

Reoroduced with oerm ission of the coovriaht owner. Further reoroduction orohibited without oerm ission.

35

where tim eElapsed{t) is a built-in predicate, which is satisfied when t seconds have elapsed since the execution of concurrent rule a has started. This predicate is interpreted by the TV-CT'JZ prototype interpreter in a specific way in the chapter 5. Here, we present the logical definition of the predicate tim eElapsed below: tim eElapsed{D elayTim e) < -- startT im e ( In itia lT ime) 0 now (PresentTim e) 0 (P resentTim e > In itia lT im e -t- DelayTim e) tim eElapsed{D elayTim e) sta rtT im e(InitialT im e) 0 now{PresentTim e) 0 {PresentTim e < In itia lT im e + D elayTim e) 0 tim eElapsed{DelayTim e) In the above definition, you can notice th a t if pre-condition (PresentTime > Initial Time + DelayTime) fails, then tim eElapsed{DelayTim e) stays in a sort of while-loop until the condition {P resentTim e > In itia lT im e -(- D elayTim e) is satisfied, and the corresponding transaction is then triggered.

R eoroduced with oerm ission of the coovriaht owner. Further reoroduction orohibited without oerm ission.

C hapter 5 T h e 'TV-C 'TTZ P ro to ty p e

T

h e TV-CTTZ prototype is an implementation of the Horn fragment of TV-CTTZ and the inference system, both introduced in Chapter 4. In Chapter 3 we have pre

sented the outline of the CTTZ prototype. Since the TV-CTTZ prototype is an extension of the CTTZ prototype, here we focus on their diflFerences. As the CTTZ prototype shown in Figure 3.2, the TV-CTTZ prototype also has two major components; the compiler and the interpreter. Both have been extended to handle the timing and priority constraints introduced in TV-CTTZ. In this chapter, we first present how the TV-CTTZ prototype compiler translates a TV-CTTZ program. Then we show how the TV-CTTZ prototype interpreter works.

5.1

The T V -C T T t Prototype Compiler

Before executing a TV-CTTZ program, a user first has to compile the transaction base and database files. In a TV-CTTZ program, priority constraints and timing constraints are, in fact, a syntax sugar, which we call constraint concurrent Horn rules. Unlike the CTTZ prototype, the TV-CTTZ prototype compiler first translates these constraint concurrent Horn formulas into CTTZ recognizable formulas. Figure 5.1 shows how this process takes place. This translation consists of two stages, carried on by compiler I and compiler II,

36

Reoroduced with perm ission of the coovriaht owner. Further reoroduction orohibited without oerm ission.

37

F ig u re 5.1: The T'P-CTTZ compiler.
C om p iler

CTR program TP-CTR programCompiler Compiler

respectively, as illustrated in Figure 5.1. Compiler I translates the constraint concurrent Horn rules in a T'P-CTTZ program into an intermediate CTTZ program. Then compiler II translates this intermediate program into an internal notation format. The reason why the T'P-CTTZ prototype compiler translates a TV-CTTZ program into a CTTZ recognizable program instead of using CTTZ recognizable program at the beginning is because the translated CTTZ recognizable syntax looks clumsy, unlike a typical neat Prolog-like syntax. For example, assigning every transaction a priority level and distributing timing constraints to the triggered transactions. To make formulas neat and clear to users, the TV-CTTZ prototype puts all these constraints in the syntax sugar format and leaves the compiler to do the translation. Moreover, compiler I takes care of this part of the translation, only. Hence, introducing more complicated timing constraints and priority constraints into the system would require only extending compiler I. This improves the flexibility of the TV-CTTZ prototype compiler. The example below illustrates the idea of compiler I. Suppose we have the following rules in the transaction base: task : - in ü T im e * taskA : tim e E la p se d {1 0 )trig g e rE v e n t{ta sk A ). task A :- m onitor {'task A complete'). Compiler I creates a temporary transaction-base file, which is added an extension .temp to the end of the old transaction-base file. Below are the corresponding translated rules: task :- in itT im e * taskA . taskA timeElapsed{10) * m onitor{'taskA complete').

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without permission.

38 If a rule in the original transaction base does not have a constraint, the translated rule is the same as the original one. The compiling process carried on by compiler 11 is more elaborate, and thus deserves a more detailed analysis of the processes and notations used within. The next two sections provide this analysis.

5.1.1

Transaction B ase Internal Syntax

Like a CTTi, program, a TV-CTTZ program consists of a transaction-base and a database too. We saw in Section 5.1 th a t ultimately a TV-CTTZ program is translated into an internal notation format. This subsection introduces the internal notation format. The transaction base of a TV-CTTZ program has two kinds of components: atomic formulas and rules. Atomic formulas do not change after translation. On the other hand, constraint concurrent Horn rules in transaction-base are in the form of a ;- /? :
7

, where a is an atomic formula, ^ is a transaction formula, and

7

is

a constraint formula, which can include both priority constraints and timing constraints. The head a is translated into the internal notation trans{a). Transaction formula no tations involving sequential conjunction and concurrent conjunction, are translated into internal notations as follows: · Sequential conjunction: seq([ai, 0 2 , --, < % »]) is the internal representation of transac tion formula Ui * aa * ... * a,,. · Concurrent conjunction: conc([ai, aa,..., a,,]) is the internal representation of the transaction formula a i# a a # ...# a ,, . · Modality operator: isolateiO) is the internal representation of o{0). Constraint formula notations involving priority and timing constraints are translated as follows:

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without permission.

39

· Priority constraint: a{priority{Level)) is the internal representation of the transac tion a with the priority constraint priority{Level, a). · Timing constraint: seq([timeElapsed(a, Time),or{[seq{[isolate{seq{[event{a, T im e),n o w {X ), db{startM m e{Y)), X > = T im e + Y, del(event{a, Time))])) , b]), seq{[event{a, T im e), a])])]) is the internal representation of the rule body of a the timing constraint timejBZapsed(Time) b, where a is triggered by

triggerEvent{a). Note: the predicate

timeElapsed(Time) in the translated intermediate file is replaced by this internal notations with the TV-CTTZ prototype interpreter recognizable built-in predicate tim eElapsedia, Tim e). The next examples illustrate these translation methods of internal syntax. E x a m p le 4 (T ra n sla tin g seq u e n tia l a n d c o n c u rre n t goals) Suppose a goal con nected with sequential and concurrent conjunctions is as the form of: p a * bftc.

Like the CTTZ compiler, TV-CTTZ compiler translates it into the following internal syn tax: trans{p) conc([seg([a, 6 ]),c]). D

If a rule has priority constraints, it is translated as shown in the example below: E x a m p le 5 (T ra n sla tin g p r io r ity c o n stra in ts) Suppose in a transaction-base, there is the following simple priority constraint concurrent Horn rule: p a#
6

; priority {a, 8).

which has the following intermediate and internal representations during and after com pilation:

Reproduced with permission of the copyright owner. Further reproduction prohibited without perm ission.

40

p a{priority{8)) # 6 . - Intermediate syntax, i.e., equivalent CTTZ rule trans{p) conc{[a{priority{8)),b]). - TP-CTT?. internal syntax


The following example shows the original, intermediate and internal syntax in the case of a timing constraint concurrent Horn rule. E x a m p le 6 ( T ra n sla tio n o f tim in g c o n stra in t ru les) The rules below specify the concurrent execution transactions a and b. For the sake of easy understanding, the two transactions are just assigned simple tasks. The transaction formula a is scheduled to execute ten seconds after the execution begins. p :-in itT im e * {a^b) : tim e E la p se d (1 0 )trig g e rE v e n t{ a ). a b monitor {^transaction a completed'), monitor {'transaction b completed').

As the first step, the 'TV-CT7Z compiler I translates the TV-CTTZ program above into the following CTTZ program: p :-in itT im e * (u # 6 ). a b timeElapsed{10) * m onitor {^transaction a completed'), monitor {^transaction b completed').

Then the TV-CT'fZ compiler II translates the CTTZ program into an internal notation. trans{p) trans{a) seq{[initTime, conc{[a, 6 ])]). seq{[timeElapsed{a, 10), or{[seq{[isolate{seq{[event{a, 10),now{X), db{startiim e{Y)), X >= 10 + Y, del{event{a, 10))])), m.onitor{'transaction a completed')]), seq{[event{a, 1 0 ), a])])]). trans{b) m onitor {^transaction b completed').



Reproduced with permission of the copyright owner. Further reproduction prohibited without perm ission.

41

\%en a TV-CT'R, program combines timing constraints and priority constraints, it is translated in the way as shown in the example below. E x a m p le 7 (T ra n s la tin g p r io r ity a n d tim in g c o n str a in t) Suppose we add a con straint to the rule p shown in Example 6, resulting in the following rule; p in itT im e * (a#b) : timeElapsed(lQ)
A

triggerEvent{a)

priority{a,8).

First, the TV-CTTZ compiler I translates them into the following CT7Z program: p :- in itT im e * (a{priority{8))i^b). a{priority{Z)) : -- timeElapsed(10) * monitor{'transaction a completed'), b m onitor (transaction b completed').

Then the TV-CTTZ compiler II translates the CTTZ program above into the following internal notation: transip) seq{[initTime., conc{{a{priority{8)), &])]). seq{[timeElapsed{a{priority{Z)), 10), or{[seq{[isolate{seq{[

trans{a{priority{Z)))

event{a{priority{Z)), 10), now {X ), db{startJim e{Y )), X > = 10 -f- Y, del{event{a{priority{Z)), 10))])), monitor{'transactionacompleted')]) , seq{[event{a{priority{Z)), 10),a(pHority(2'))])j)]). trans(b) m onitor{'transaction b completed').


By recursively applying the translation rules above, the TV-CTTZ compiler translates a transaction-base file into a TV-CTTZ transaction-base object file.

5.1.2

T h e T V -C T T l P ro to ty p e D atab ase

The syntax and semantics of the TV-CTTZ prototype database is the same as in the CTTZ prototype database. The only difference is that internally, the system uses a couple of

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

42

other system predicates. In the TV-CTTZ prototype databases, there are three systemrequired database tuple declarations in TV-CTTZ prototype databases, namely: · updatable event/2. - the declaration of timing-event-to-be-triggered list

· updatable priority L is t/I . - the declaration of concurrent transaction priority list · updatable startJtim e/1. - the declaration of execution start time

5.2

The T V -C T T Z Prototype Interpreter

The TV-CTTZ prototype interpreter consists of inference engine and relational oracle, as the CTTZ prototype interpreter shown in Figure 3.3. Although both the CTTZ prototype and the TV-CTTZ prototype use the same relational oracle, the TV-CTTZ prototype interpreter use a different inference engine. Compared to the CTTZ inference engine, it implements the notion of hottest component instead of hot component, as shown in Chap ter 4. During execution, the TV-CTTZ inference engine picks up the hottest transaction component, i.e., the first highest-priority-level element in the hot component queue. The interpreter is the key module of the TV-CTTZ prototype. The user interacts with the prototype by presenting transaction goals to be executed, execute{Goal). The interpreter then picks up the hottest component of the goal for execution. If the pro gram in the transaction base does not include any constraints, the priority level of all transactions is considered as the default lowest priority level. In this case, the no

tion of hottest component introduced in TV-CTTZ system is analogous to the notion of hot component introduced in CTTZ system because the underlying simplified RateMonotonic algorithm handles the non-priority-constraint goals in the same way as that of the Round-Robin algorithm. The inference engine of TV-CTTZ uses the underlying scheduling algorithm to pick up the hottest component in a concurrent transaction execution. It also interprets the prior ity and timing constraints and drives the execution of the transactions. The rest of this

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

43

îction is organized as follows: Next we introduce the adopted underlying scheduling algo rithm - simplified Rate Monotonie Algorithm(SRMA)[10]. Then we present how priority constraints are interpreted, and how the S R M A schedules the concurrent transactions. Finally, we present how the TV-CTTZ timing constraints are interpreted.

5.2.1

U n d erly in g S ch ed uling A lgorith m in th e TV-CTTZ In ter preter

Before introducing the underlying scheduling algorithm in the TV-CTTZ interpreter, we first give a brief introduction of the Round-Robin scheduling algorithm used in the CTTZ interpreter. R ound-R obin Scheduling A lgorithm The Round-Robin algorithm is one of the oldest, simplest and most widely used schedul ing algorithms, designed especially for time-sharing systems. It assigns each concurrent process an unit of time in a one-by-one sequence and feeds the process th a t has used up its share of time back to the end of the sequence. In CTTZ, Bonner made a small adjustment: using one step transaction execution instead of one unit of cpu time, to simplify trans action execution in a concurrent sequence. Thus, the Round Robin scheduling algorithm in the CTTZ system assigns one execution step time to the selected transaction, which is in the head of the concurrent transaction sequence. In CTTZ, one execution step means one inference step. In this way, the CTTZ scheduler picks up the first hot component, executes one inference step, feeds the unfinished transaction component back to the end of the sequence, and releases CPU resource to the scheduler in the mean time. The Round-Robin scheduling algorithm is a simple and effective algorithm for a concur rent transaction system without priority demands. However, in reality, many concurrent transaction systems need to assign priority level to some special transactions. For exam ple, in a classified-customer financial system, a transaction request from a higher level customer always has preference over th a t from a lower level customer. W hen faced with such requirements, the Round-Robin scheduling algorithm shows its application limita

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

44

tion. In order to handle such types of applications, the TV-CTTZ system uses a simplified version of Rate monotonie algorithm. Sim plified R a te -M onoton ie Scheduling A lgorithm In the SRMA, each concurrent transaction is assigned a fixed priority by user or by default. Assuming task a and task b are concurrent execution transactions, during execution, the SRMA schedules tasks a and b in the following way: · Task a can not be executed before task b finished, if task b has a higher priority level than task a. · Task a has an equal chance to execute as task b, if task a and b have the same priority level. In the design of TV-CTTZ, our main goal is to verify the logic of time-event-based prior itized transaction systems, while introducing features of real-time systems, i.e., priority constraints and timing constraints. However, we do not include a great variety of real time features a t current stage. More precisely, we ignore an im portant feature of real-time systems, deadline, which improves the efhciency of concurrent systems by giving up some tasks running over deadlines. Moreover, the fixed priorities of the system are assigned by users when writing TV-CTTZ programs. These adjustments simplify the Rate Monotonie algorithm in our system by ignoring the transaction execution period assessment and cor responding automatic priority assignment, which is not im portant in a timing-event-based transaction verification system.

5.2.2

In terp retin g and S ch ed uling P rio rity C on strain ts

Section 5.1 shows how the TV-CTTZ compiler translates a concurrent Horn rule with priority constraints. This subsection presents how the TV-CTTZ prototype interpreter interprets priority constraints represented in internal notations.

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

45 After the translation by th e TV-CTTi, prototype compiler, a priority constraint is dded as the first param eter of the corresponding transaction, as shown in the example 5. Then the T V-CTTZ prototype interpreter uses a SRMA to schedule constraint concurrent Horn rules. Each concurrent transaction in a TV-CTTZ program has a priority level, which is used to determine their execution priority. To find the first highest priority level transaction from a concurrent sequence, the SRMA needs to know both the priority level of a transaction and the highest priority level of the concurrent transaction sequence. In the TV-CTTZ prototype, lists are used to store these variants. · The list p rio rityL ist stores all priority levels of the concurrent transactions in a priority descending order. For example, p rio rityL ist [3, 2,2] means there are three transactions in the concurrent sequence, and their priority levels are 3, 2 and 2, respectively. · During interpretation, a transaction's priority level is indicated by the last element of the transaction list, e.g., [seg([a, 5]), 2] means the seq{[a,b]) has priority level 2. The priority level will not disappear before this sequential transaction execution finishes. The example below illustrates how priority constraints are interpreted by the TV-CTTZ interpreter according to the simplified RMA. E x a m p le 8 (I n te r p r e tin g a TV-CTTZ p ro g ra m ) Consider the following transaction base; ta sk ta skA ta s k B ta skC : -- taskA ((-taskB i(ta skC : priority (task A, 1) A priority (task B, 2) A priority (taskC, 2). :- ins{in(a)). :- ins(in{b)). :- ins{in{c)).

When interpreting the concurrent transaction task, the sub-transaction ta skA , ta skB and ta skC are converted to .ne following cone list in the TV-CTTZ prototype interpreter:

R eproduced with perm ission of the copyright ovmur. Further reproduction prohibited without perm ission.

46

conc([[ins(in(a)),l},[ins(in(b)),2],[ins(in(c)),2}]) where the respective priority level of each execution transaction is the last element of their list. The list prio rityL ist is used to store the three transaction priority levels, as shown in Figure 5.2:
F ig u re 5.2: The list p r io r ity L is t in TV-C TTZ interpreter.

Ievel2 levels levelt

priorityList

taékB priority
Ievel2

taskC priority
levels

taskA
priority levelt

where levell is the taskA's priority level 1, level2 is the taskB's priority level 2, and level3 is the taskC 's priority level 2. The elements of the priority L ist sort in an descending order, from higher priority level to lower priority level. 

During interpretation, the SRMA uses the following steps to determine the hottest component: 1. Picks up the first element of the execution transaction list 2. Gets the priority level of the first element from the execution transaction list 3. Gets the highest priority level from the priority L ist {the first element) 4. If the current element's priority level is not the highest priority level, puts it in the end of the execution transaction list, then returns to the first step, and repeats steps 1 to 4.

R eproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

47

5. Otherwise, the element is the hottest component and the interpreter should execute one step of this element. · If this step is the last step of the belonged transaction execution, deletes the first element of priorityL ist. Then returns to the step 1 if there is still transactions in the execution queue; or ends execution if no other transaction is left in the execution sequence. · Otherwise, returns the remaining of this element to the end of the execution transaction list, and then returns to the step 1. In such a way, the TV-CTTZ interpreter implements the inference system using a SRMA to formally execute TV-CTTZ programs.

5.2.3

In terp retin g T im in g C onstraints

At current stage, the TV-CTTZ prototype has two timing constraints: tim eElapsed/1 and delay/I. tim eElapsed is used to set an absolute timing relation, where a transaction is set to be triggered at an absolute time instant, delay is used to set a relative timing relation, where a transaction is set to start a period of time after the end of another transaction. Actually, the timing constraints tim eElapsed and delay are similar from a logic view point. The only difference is the start time instant. Figure 5.3 illustrates the underlying logic for these two timing relations. Both timing constraints are handled using such logic within the TV-CTTZ interpreter. The timing constraint tim eElapsed uses the sta rt-tim e{X ) to retrieve the start time, which stores the start time instant of the whole execution. In TV-CTTZ, we use timingevent-based mechanism for this timing constraint: satisfaction of the constraint precondi tion is used to trigger another transaction event. The TV-CTTZ interpreter uses an atom event to specify the triggered transaction. After the timing condition is satisfied and the

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

48
F ig u re 5.3: Timing logic handled in the TV-C TTZ interpreter.

G et start time X

Get current time Y Note: D is the specified delay No

Y >= X + D?
Yes Next transaction

specified transaction is triggered, the atom event corresponding to this transaction is deleted from the database system. The other timing constraint of the current TV-CTTZ prototype, delay, is used to define a delay relationship between two transactions. Thus, its start time is not the start time of the execution, but the start time of itself. W hen the specified delay time goes, the delay loop will end and it will go to the second transaction execution.

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without permission.

C hapter 6 T im e-b ased P rio ritized T V - C T IZ P rogram E xam p les

T
6.1

o illustrate how

TV-CTTZ can be used to specify priority and timing constraints

in timing-event-based prioritized transaction system, this chapter presents two ex

amples in different application areas. More specifically, the first example regards financial transaction. The second example regards real-time logic control system.

A Time-based Financial Transaction Application

Example 9 is an extension of the financial transaction application presented in [1], where Bonner and Kifer illustrate how CTTZ can be used to specify the atomicity of financial transactions. Here we show how timing features and priority features in TV-CTTZ is used to schedule tasks in a long-run financial transaction application.

E x a m p le 9 (S pecifying tim e -b a s e d p rio ritiz e d fin an cial tra n s a c tio n s ) For the sake of understanding, first we briefly introduce the rules used in Bonner and Kifer's financial transaction example in [1]. tran sfer{A m t, A cctl, Acct2) < -- © {withdraw[Amt, Acctl) ® deposit{Amt, Acct2))

49

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without permission.

50

w ithdraw{Am t, Acct)

balance{Acct, Bal) ® Bal > Arat ® changeJbalance{Acct, Bal, Bal -- Am t)

deposit{Amt, Acct) < -- balance{Acct, Bal) ® changeJbalance{Acct, Bal, Bal + Am t) changeJ)lance{Acct, B a ll, Bal2)  < -- del{balance{Acct, B all)) ® ins(balance[Acct, Bal2)) The first predicate, tra n sfe r, specifies how a money transfer transaction is accomplished, i.e., by withdrawing an amount A m t from one bank account A cctl and then depositing the A m t into another bank account Acct2. The next two predicates, withdraw and de posit, define the withdraw transaction and the deposit transaction, respectively. Both of them use the predicate changeJbalance to update an account's balance via the built-in elementary updates del(balance{Acct, Bal) and ins(balance{Acct, Bal). Based on the above basic transaction rule definitions, the TV-CTTZ program below simulates a long-run time-based financial transaction scenario: to a source account, higher priority level transfer requests can always be answered even when normal transfer trans actions are executing. In the program, a timed prioritized transfer transaction is assigned with a higher execution priority. Another transfer transaction process, assigned with the default priority level, runs recursively every two seconds until the remaining amount in the account is not enough for another transfer. trans f er-process + --transfer-queue{F eel, Client, Broker) I trans fer-urgent{Fee2, Client, Urgent-Acct) : timeElapsed{100) tirggerE vent{transferjurgent

(Fee2, Client, Ur gent-Acct)) Apriority {transfer.urgent {Fee2, Client, Ur gent-Acct), 2) transfer-queue{A m t, Acctl, Acct2) < --balance{Acctl, Bal)

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

51

0 {Bal > Am t) 0 trans fe r {Amt, Acctl, Acct2) 0 delay{2) 0 transfer-queue{A m t, Acctl, Acct2) transfer-queue{A m t, A cctl, Acct2) + --monitorif trans f er ends') tr a n sa f erjurgent{Am t, Acctl, Acct2)  « -- tra n sfer{A m t, Acctl, Acct2) The first constraint concurrent Horn rule specifies the simulation process. It consists of two predicates, transfer-queue{F eel. Client, Broker) and transafer^ urgent(Fee2, Client, Urgent-Acct), which runs concurrently. The constraint formula specifies a timing event for transafer-urgent, which has priority in this concurrent execution and is scheduled to take place 100 seconds after the simulation starts. The transaction transfer.queue implements a long-run series of bank account transfer transactions, in which an amount F e e l is transferred from one account Client to another account Broker, and the transfer process is called recursively every two seconds until the balance of C lient is smaller than the amount F eel. In this example, we adjust the initial amount of the account Client and the transferred amount F e e l to ensure the transaction tra n sfer-u rg en t is triggered during the execution of the transaction transfer-queue. The result shows th at the specified prioritized event takes place right at 100 seconds, and the transaction tr a n sa f er-urgent is triggered and then interrupts the normal transfer process by becoming the hottest component of the concurrent conjunction. As expected, the amount Fee2 is thus transferred from the Client's account to the urgent account Urgent-Acct with priority. Only after this prioritized transfer transaction is completed, the interrupted normal transfer process can then resume its normal execution.



Reproduced with perm ission of the copyright owner. Further reproduction prohibited without permission.

6.2A Simplified Elevator Logic Control Application

52

Besides the area of database transaction, applications, TV-CTTZ can also be used to simulate real-time control systems. Working with priority constraints, a timeElapsed timing-event-based constraint can create an interrupt functionality, which is scheduled to take place at specified time. The interrupt is one key feature of a real-time control system. Example 10 presents how to use TV-CTTZ to simulate the interrupt in an elevator logic control system. E x a m p le 10 (S im u la tin g a sim p lifie d eleva to r co n tro ller) For the sake of under standing, below we present the assumptions for a simplified elevator controller model and basic control logic rules: · The elevator is for a ten-floor building with one stop button on each floor. When the button is pushed, a stop request is sent to the controller. · The elevator cage takes about 3 seconds to go up or down one floor.

· Every floor has a location sensor to indicate the elevator's position. · In any exceptional case, the elevator should take stop action immediately. Based on these assumptions, the program below specifies the simplified control logic for the elevator controller: sim ulate  t--moving-control{stop) I userjrequest | accident : timeElapsed{Sl) -- >  triggerEvent{accident) A priority {accident, 2) userjrequest reg(5) | req(8] j req(2) : timeElapsed(lO) trigger E vent {req{5)) A timeElapsed{30) -- > triggerEvent{req{8)) A timeElapsed{5Q) triggerEvent{req{2)) req(Level) * -- ins{stopjreq{Level))

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

m.ovingj2.onirol{3tatus) < -- Status = stop ® stopjreq{Level) ® moveto{Level) ® dei{stopjreq{Level)) ® moving-.control^stop) m oving-control{Status) · « -- moving-control{stop) accSignal ® stop-handle maueto{Level)  * --not accSignal ® getLocation{X) ® X <> Level ® moveto{Level) moveto{Level) + --not accSignal ® getLocation{X) ® X = Level ® stop-handle accident ins{accSignal) maveto{Level)

53

where basic atomic formulas and built-in predicates in the specification have the following definition: · The atomic formula stop-req{Level) is used to store the stop requests to be an swered. · stopJiandle is a built-in predicate to stop the elevator. · getLocation{X] is a built-in predicate to retrieve the current elevator location. · The atom accSignal is used to denote an urgent exceptional event. In the program, the first constraint concurrent Horn rule specifies the entire simula tion process. It consists of three concurrent transactions, moving-control^ userjrequest and accident. The constraint formula specifies an exceptional event: an accident which is scheduled to take place at 31 seconds after the simulation starts. The predicates

moving-control and userjrequest implement the normal elevator control logic. The pred icate userjrequest simulates use case scenario: three stop requests are scheduled to take

Reproduced with permission of the copyright owner. Further reproduction prohibited without perm ission.

54

place at specified times. The predicate moving-control is used to control the elevator: moving to a floor according to the stop requests. The predicate moveto{Level) performs the elevator moving action, and monitors any exceptional accident as well. "Wdien the specified accident takes place at the 31 seconds time instant, because of its priority, the predicate accident works as an interrupt and notifies the system at once by inserting the atom accSignal into the database. In our case, the elevator is still moving from 5th floor to 8th floor at that time. The predicate moveto{Level) receives this signal, then correspondingly executes the predicate stopJiandle to stop the elevator at once.  This example demonstrates th a t TV-CTTZ can be used to simulate some intrinsically real-time phenomena, e.g., the interrupt effect and timing relations. By elaborately com bining priority constraints and timing constraints in different ways, we can verify different elevator logic control cases with the TV-CTTZ program.

Reproduced with permission of the copyright owner. Further reproduction prohibited without perm ission.

C h ap ter 7 C on clu sion s and Future W orks

I

N the previous chapters, we presented an extension of Concurrent Transaction Logic, a formalism originally designed to handle state changes in deductive databases. We

extended CTTZ by defining a logic framework in which the user can not only specify concurrent transaction processes as logic programs, but also define priority and timing constraints on these processes. This increases the flexibility and power of the language. Users are no longer forced to schedule the transaction order only by the sequential con junction and concurrent conjunction. The execution order of concurrent transactions can also be specified or changed by extra ways: assigning timing constraints and priority con straints to these transactions. The interrupt effect created by combining the event-driven feature of the timing constraint tim eElapsed with priority constraints schedules trans actions in a more flexible and powerful way, and thus opens the logic to a new range of advanced application, e.g., real-time domain application, long-run time-related applica tion, digital circuit design with clock-driven and continuous-simulation of the designed digital circuit, etc. To allow the formal execution and thus the simulation of such programs, we introduced an inference system th a t is able to handle priority constraints with the underlying sim plified Rate-Monotonic scheduling algorithm. The formal execution of programs works as SLD-style refutation mechanism. By this way, our approach provides a high-level framework for specifying and executing transaction logic programs involving priority and

55

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without permission.

56 timing properties. Also, we have shown how logic programming techniques can be used to implement real-time database application domains. To make theory meet practice, we have implemented our TV-CTTZ prototype in XSB Prolog and have tested the examples presented in this thesis. There are still some issues left open, especially real-time issues. Below we elaborate on them. · Sophisticated Timing Constraints. The timing properties in our timing constraint are quite straight-forward at present stage. It only handles the timing property of a transaction when to be triggered, and a delay relation between two transactions. However, in reality, timing properties of a real-time system are much diverse, such as described in [4, 5, 6]. Some of them relate to the deadline of a transaction as well as the initial time instant. Adopting these ideas into the TV-CTTZ timing constraint will be valuable to expand its real-time application domain. · Underlying scheduling algorithm. The current TV-CTTZ possible prototype uses a simplified Rate Monotonie Scheduling algorithm to schedule concurrent transac tions. In real-time domain, this algorithm is straight-forward and may be inefficient in some cases. It should be possible to adopt a more sophisticated scheduling algo rithms, to improve the performance of the TV-CTTZ prototype in real-time domains.

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

A p p e n d ix A

T V - C T n T u torial
A .l 'TV-CTTZ Prototype File System

The TV-CTTZ prototype in this thesis is extended on the base of Concurrent Transaction Logic with Recovery prototype available in [17]. It consists of the following models: · ctr.P - the basic TV-CTTZ interpreter · parser.P - a parser for TV-CTTZ rules · updates.P - the code for back-trackable updates · load.P - startup routine th a t loads the prototype modules · upload.P - a module including rules to load a TV-CTTZ transaction-base and a database into X S B system. · tim er.P - including TV-CTTZ system rules regarding timing constraints

A .2

Getting Started

The TV-CTTZ prototype was implemented in XSB Prolog, and consists of the modules introduced above. To run the implementation, at query prompt, the load module must first be consulted, then invoke the predicate ctrA nit. The predicate c tr.in it is defined 57

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

58 in the module to load all necessary files into XSB Prolog and initialize the necessary parameters. Below we illustrate how the user interacts with the system. $xsb -i XSB Version 2.5 (Okocim) of March 11, 2002 [i686-pc-linux-gnu; mode; optimal; engine: slg-wam; gc: indirection; scheduling: local] I ? -- [load]. [load loaded] yes
I? --

ctr-init.

[ctr loaded] - basic TV-CTTZ interpreter [updates loaded] - code for back-trackable updates [parser loaded] - parser fo r prototype rules [upload loaded] - compilers for loading and translating rules [timer loaded] - embedded timing constraints [scrptutl loaded] - necessary X SB system module fo r system timing predicates yes

A.3

T V-C T7Z Prototype Commands and Program Files

Like CTTZ programs, T'P-CTTZ programs are also stored in the transaction-base and database with filename extensions .ctr and .dh, respectively. Although in some cases the database file maybe empty, it is still needed in our prototype.

A .3.1

C om p iling C om m an ds in TV-CTTZ

The TV-CTTZ programs are compiled with the following three commands:
·

ctr-Comp{programjname). - to compile both the transaction-base and database;

· com p-transiprogram jnam e). - to compile the transaction-base only;

R eproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

59 ' comp-db{programjname). - to compile the database only. where program_name is the filename of the TV-CTTZ program w ithout extension. After compiled, a TV-CTTZ transaction-base file generates two files: prograrri-name. ctr. temp program-name. ctr. o where program-na.me.ctr.tem p is an intermediate compiled file, in which the timing con straints and priority constraints have been translated into a recognizable CTTZ program. The program-nam e.ctr.o file is the final transaction object file via the underlying T V CTTZ compiler. Like the CTTZ database object file, a TV-CTTZ compiler creates a TV-CTTZ database object file w ith the name; program-uame.db.o where the extension .db.o denotes the file to be a database object file.

A .3.2

E x e cu tio n C om m and

To execute a transaction in the TV-CTTZ program after compilation, the user uses the following command: execute (transaction-name). where transaction-nam e is the head of one of the rules in the transaction-base file.

A .4
A .4,1

The T V -C T 7 1 Prototype Syntax
T ran saction R u les

The constraint concurrent Horn rules consists of three parts: a rule head, a rule body, and a constraint body. Head Body : Constraint Body.

R eproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

60

or Head or Head. where · H ead is an atomic-formula; · Body is a sequence of transaction actions (or queries) connected by any of the following conjunction operators: -- sequential conjunction(+), -- concurrent conjunction(#), -- isolation (o). · Constraint Body is a sequence of the following constraints connected by conjunction(A) : -- timing constraint tim eE lapsed{X ) < --triggerE vent{Transactionjnam e), -- priority constraint priority {Transaction-name, Priority.Level) Body.

A .4.2

D a ta b a se R u les

A database is any Prolog rule or atom in the forms of format: Head or Head. Body.

R eproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

.5

Built-in 'TV-C'T'IZ Predicates

The prototype has some built-in predicates, which are used in the transaction-base or database. These predicates should not be re-defined by the user.

A .5.1

D a ta b a se D ecla ra tio n

Database atoms represent tuples in a relation. Like table in relational database, a relation should be declared before it can be accessed. The statem ent below declares a database relation N am e with arity N Args: updatable Name/Nargs. By default the following basic system database declarations and tuples are always declared for any TV-CTTZ program; updatable event/2 - timing driven event list

updatable start-tim e/1 - start time instant of an execution updatable priorityList/1 - a current executed transaction priority list in descending order priority List ([ ]) - the initial empty list

A .5.2

B u ilt-in P red ica tes in T ransaction-base

For the declared database atoms, there are three built-in predicates for accessing them: · db{p{x)) and empty{p{x)) - query atomp(æ) in the database · ins{p{x)) - inserts atom p{x) into the database · del{p{x)) - deletes atom p{x) from the database At present stage, there are the following built-in constraint predicates:

R eproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

62

· tim eElpased{X) - a timing constraint based on an absolute timing instant · delay{X) - a timing constraint based on a relative timing instant · priority{Transactionjnam e, priorityJevel) - priority constraint Besides, in the TV-CTTZ prototype we have kept the useful CTTZ m onitor command below, which can be used to trace a transaction execution. m onitor (Task). where Task is a name or a term. Note th at monitor {Task) does not execute Task, it only displays messages. W hen the monitor executes, it displays one of the messages: · Completed Task - when m onitor{Task) is executed. · undoing Task - when m onitor {Task) is rolled back.

A. 6

Programming Examples

The following examples illustrate some simple TV-CTTZ programs and their execution. They are executed in XSB Prolog, with the loaded TV-CTTZ prototype. E xam ple A .l C oncurrent Processes w ith P riority C onstraints The following program executes three concurrent non-interacting transactions. The three transactions have different priority levels and has two tasks respective. The program name is interleave. Below are the contents of the database file and transaction file. Database file inter leave.db: updatable event/2, updatable priorityL ist/1. priority List ([]). Transaction Base file interleave.ctr:

R eproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

63

parent ta s k A # ta s k B # ta s k C : priority (taskA, 2) A priority {taskB, 2) A priority (taskC, 1). taskA taskB taskC m onitor (taskA 1) * monitor (taskA2). monitor (taskB 1) * monitor (taskB 2). monitor(taskCl) * monitor(taskC2).

Compiling the program and executing a transaction: 1 ?- ctr_comp(interleave). yes 1 ?- execute (parent). completed taskA 1 completed taskB 1 completed taskA2 completed taskB2 completed taskC l completed taskC2 yes E x a m p le A .2 I n te r r u p t in C o n c u rre n t P ro cesses This example shows how the interrupt is created by combining a timing constraint and a priority constraint in a long-run program. The initial process is timed to start at 1 sec after the execution start, and the three concurrent sub-processes of the process parent have the same priority level. The subprocess of the initial process, interrupt, has higher priority level in the concurrent execution. Database file interrupt.db: updatable event/2, updatable startAim e/1. updatable a/1. - execute the parent goal - complete the first task of taskA - complete the first task of taskB - complete the second task o f taskA - complete the second task o f taskB - complete the first task of taskC - complete the second task o f taskC - compile the program

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without permission.

64

updatable priority L ist/1. priority List ([]). finished unfinished not (unfinished), a(X). - - a(l). a(0).

a(lOO). a(99).

Transaction Base file interrupt.ctr parent in itT im e * {long-runJtransactionij^initialfi^shortJtransaction) : tim eE lapsed{\)-- > triggerEvent{initial) Apriority (long jrun-transaction, 2) Apriority (initial, 2) Apriority(short-transaction, 2). long-run-transaction:-o(del(a(X)) * m onitor(X )) * longsun-trausaction. longjrum transaction initial finished.

m onitor (interrupt Jn it-ta sk) * interrupt : priority(d, 5). m onitor(interruptJaskA ) * m onitor (interrupt JtaskJl). m onitor(short-transaciotnJ,ask-\) *monitor(short-transactionJask-2) *monitor(short-transaction-task-3) *m onitor(short-transaction-taskA).

interrupt

short-transaction

Compiling the program and executing a transaction: I ?- ctr.comp(interrupt). yes I ?- execute(parent). completed 100 - execute the parent goal - shows one round of longer un-transaction is completed completed short_transaction_task_l completed short_transaction_task_2 - shows one round of short-transaction is completed - compile the program

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

65 impleted 99 impleted short_transaction_task_3 completed short_transaction_task_4 completed 98

completed 75 completed interrupt jnit_task completed 74 completed interrupt_task_l completed interrupt _task_2 completed 73 shows the initial task of the interrupt is completed shows one task of the interrupt is completed

completed 0 yes

Reproduced with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

B ibliography
[1] Anthony J. Bonner and Michael Kifer, "Concurrency and Communication in Trans action Logic", Proceedings of the Joint International Conference and Symposium on Logic Programming(JICSLP), Sep. 2-6 1996, Pages 142-156. MIT Press. [2] Anthony J. Bonner, "Concurrency Transaction Logic", Presented at the Dagstuhl Seminar on Transaction Workflows, July, 15-19 1996, International Conference and Research Center for Computer Science, Schloss Dagstuhl, Wadern, Germany. [3] Anthony J. Bonner and Michael Kifer, "Transaction Logic programming (or a logic of declarative and procedural knowledge)",Tec/micaZ Report CSRI-323, Uni versity of Toronto, November 1995. http://www.cs.toronto.edu/ bonner/ transactionlogic.html. [4] P. Bellini, R. Mattolini, and P. Nesi, "Temporal Logics for real-Time System Speci fication," AC M Computing Surveys, Vol.32, No.l, March 2000. [5] B. Dasarathy, "Timing Constraints of Real-Time Systems: Constructs for Expressing Them, Methods of Validating Them" , IEEE Trans. Software Engineering, Vol. SE-11, No. 1, January 1985, PP.80-86. [6] Horng-Yuan Chen and Jeffrey J.P. Tsai and Yaodong Bi, "An Event-Based RealTime Logic to Specify the Behavior and Timing Properties of Real-Time Systems," IEEE, 0-8186-2300-4/91 (c)1991.

66

Reproduced with permission of the copyright owner. Further reproduction prohibited without perm ission.

67

[7] Kristian Torp, Christian S. Jensen, Richard T. Snodgrass, "Effective timestamping in databases," The VLDB Journal, (c)Spring-Verlag 2000. [8] Ogur Ulusoy, Geneva G. Belford, "Concurrency Control in Real-Time Database Systems," ACM, 089791-472-4/92/0002/0181, 1992. [9] Rajendran M. Sivasankaran, John A. Stankovic, Don Towsley, Bhaskar Purimetla, KritM Ramamritham, "Priority assignment in real-time active databases," The VLDB Joum.al , (c) Spring-Verlag 1996. [10] Wayne Wolf, "Computer as Components: Principles of Embedded Computing Sys tem Design", Morgan Kaufman Publishers, 2001, ISBN 1-55860-541-X. [11] Neugass H., Espin G., Nunoe H., Thomas R., Wilner D., "VxWorks: an interactive development environment and real-time kernel for Gmicro," TRO N Project Symposium,lQ91. Proceedings,, Eighth , 21-27 Nov. 1991 Page(s): 196 -207 [12] Terrasa, A.; Garcia-Pornes, A , "Real-time synchronization between hard and soft tasks in RT-Linux" Real-Time Computing Systems and Applications, 1999. RTCSA '99. Sixth International Conference on , 13-15 Dec. 1999 Page(s): 434 -441 [13] Amalia F. Sleghel, "An Optimizing Interpreter for Concurrent Transaction Logic" Thesis for degree of Master of Science in University o f Toronto, 2000. [14] Jiwen Ge, Marcus Vinicius Santos, "Using logic programming techniques to han dle timing and priority constraints in real-time systems" Seventh World Conference On Integrated Design &Process Technology IDPT Vol.2 2003, ISSN No. 1090-9389, Page(s): 800-806 [15] Konstantinos Sagonas, Terrance Swift, David S. Warren, Juliana Preire, Prasad Rao, Baoqiu Cui, Ernie .Johnson, "The XSB System Version 2.5 Volume I: Programmer's Manual" SU N Y at Stony Brook, 2002.

Reproduced with permission of the copyright owner. Further reproduction prohibited without perm ission.

68 [16] Konstantinos Sagonas, Terrance Swift, David S. Warren, Juliana Freire, Prasad Rao, Baoqiu Cui, Ernie Johnson, "The XSB System Version 2.5 Volume II: Programmer's Manual" SU N Y at Stony Brook, 2002. [17] Anthony Bonner,"CT77. prototype with recovery" , ftp://ftp.cs.toronto.edu/cs/ftp /pub/bonner/papers/transaction.logic/prototype/recoverable/.

Reproduced with permission of the copyright owner. Further reproduction prohibited without perm ission.

