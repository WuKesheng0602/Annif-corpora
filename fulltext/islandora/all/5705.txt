COPS, ROBBERS, AND BARRICADES

by Erin Kathleen McKenna Meger Bachelor of Science, Wilfrid Laurier University, 2014

A thesis presented to Ryerson University in partial fulfillment of the requirements for the degree of Master of Science in the Program of Applied Mathematics

Toronto, Ontario, Canada, 2016

c Erin Meger 2016

AUTHOR'S DECLARATION FOR ELECTRONIC SUBMISSION OF A THESIS

I hereby declare that I am the sole author of this thesis. This is a true copy of the thesis, including any required final revisions, as accepted by my examiners.

I authorize Ryerson University to lend this thesis to other institutions or individuals for the purpose of scholarly research.

I further authorize Ryerson University to reproduce this thesis by photocopying or by other means, in total or in part, at the request of other institutions or individuals for the purpose of scholarly research.

I understand that my thesis may be made electronically available to the public.

ii

Cops, Robbers, and Barricades Master of Science, 2016 Erin Kathleen McKenna Meger Applied Mathematics Ryerson University Abstract Cops, Robbers, and Barricades is a new variant of the game on graphs, Cops and Robbers. In this variant, the robber may build barricades that restrict the movements of the cops. The minimum number of cops required to capture the robber on a graph G is called the barricade-cop number, denoted cB (G). If cB (G) = 1, then G is called barricade-cop-win. The game can be generalized so that the robber may build b(k )-many barricades on vertices during her k th turn, in accordance with barricade rules that dictate the permissible positions of these barricades. The barricade-cop number is determined exactly for complete graphs, cycles, and paths, and we provide bounds on trees and locally-path-like graphs. We compare and contrast variants on the barricade rules, and give an algorithmic characterization of barricade-cop-win graphs with any set of barricade rules.

iii

Acknowledgements I would like to thank my family first and foremost for their continued support throughout my mathematics education, and for encouraging me to believe in the power of my dreams. I am thankful for the unending support and guidance from my supervisor Dr. Anthony Bonato. My appreciation goes to Dr. Dejan Deli´ c and Dr. Pawel Pralat for their time and energy in participating in my thesis committee. I also thank Dr. Peter Danziger, whose small side project I never truly got a chance to work on. I acknowledge the Queen Elizabeth II Graduate Scholarship for Science and Technology and the Ryerson Graduate Fellowship for partially funding this thesis.

iv

Contents List of Figures Chapter 1. Introduction 1. Motivation 2. Introduction to Graph Theory 3. Graph Parameters and Domination 4. Introduction to Cops and Robbers 5. A Brief Discussion on Algorithms 6. Outline of Thesis Chapter 2. Cops, Robbers, and Barricades 1. An Introduction to the Game 2. Preliminary Results 3. Trees 4. Complete m-ary Trees 5. Locally Path-Like Graphs 6. Meyniel's Conjecture and Domination Chapter 3. Variations of the Barricade Rules 1. Introduction
v

vii 1 1 3 10 12 14 16 18 18 20 27 28 34 36 41 41

2. Three Variants of the Barricade Rules 3. Relating the Three Variants Chapter 4. Characterizing Barricade-Cop-Win Graphs 1. A relation on cop-win graphs 2. Characterization 3. Algorithm 4. Complexity Chapter 5. Conclusion and Open Problems 1. Conclusion 2. Open Problems Bibliography

41 46 52 54 55 57 59 61 61 62 64

vi

List of Figures 1 2 3 4 An example of Cops and Robbers: rounds 1 and 2. An example of Cops and Robbers: rounds 3 and 4. On the left, a multi-graph. On the right, a simple graph. An example of a subgraph, an induced subgraph, and a spanning subgraph. 5 6 7 8 9 10 11 12 1 2 3 A disconnected graph. The graph Kn for n = 1, 2, 3, 4. Independent set on 4 vertices. The graph P6 . The graph C6 . On the left a bipartite graph. On the right K3,3 . Examples of trees. The Petersen graph. Example: Cops, Robbers and Barricades on P8 . Example 2. The cops play on either end of the path. CRB on P8 where the cops are placed optimally and win.
vii

2 2 4

5 6 7 7 7 8 8 9 11 21 23 24

4 5 6

A cycle with a sample of the cop placement for CRB. An example of a robber-star. Complete 3-ary tree of height 2. The height of each vertex is labelled.

25 26

28 30

7 8

A row in a complete m-ary tree. An example of a locally path like graph G, and its corresponding weighted multi-graph W (G).

35

9

The initial set up. The blue edges may exist but are of no consequence to the proof, and the red edges cannot exist due to the girth of the graph being greater than or equal to 7. 38 39 42 44 45 48 48

10 1 2 3 4 5 6

The first move of the cops, before the robber moves. Example of the global variant. Example of the slug variant of CRB. The second-to-last move in the slug version example. A particular necklace graph with eight pearls. The initial positions for the local game of CRB on this graph. Game play of the local version of CRB on this particular section of a necklace graph.

49

7

Game play of the global version of CRB, on this particular section of a necklace graph.
viii

51

1

An example of CRB played on a 5 × 5 strong product grid with b(k ) = 2 with a vertex cut of size four. 53 54

2

Gk = G V (G)\Bk for the example played in Figure 31.

ix

CHAPTER 1

Introduction 1. Motivation In 1978 Quilliot introduced in his doctoral thesis a game that would pioneer a new area of graph theory [19]. When Nowakowski and Winkler independently defined this game it catapulted the topic into the main stream of graph theory [17]. This game is called Cops and Robbers, and it has been of increasing interest to graph theorists since its inception. Researchers have studied the original game, investigating the cop number of a graph, as well as many variants of the original game, such as tandemwin Cops and Robbers, distance-k Cops and Robbers, and Zombies and Survivors; see [1, 4, 5, 6, 8, 11, 14]. The game of Cops and Robbers is a vertex-pursuit game played on a graph. For now, we can think of a graph as a game board. The game is played as follows. We have two players, the robber and the cops. It is permissible for the cop player to have a set of cops at their disposal. First, the cops are placed on the "board", which are simply vertices of the graph. Then the robber places herself on another vertex. The two players alternate turns. If we have more than one cop, then the cop player moves all the cops in each turn. In any given round, either player
1

may "pass" by remaining on their vertex. The cop wins if he captures the robber, and the robber wins if she can avoid capture indefinitely. In order to know if this is possible, we will need to know much about the structure of the game board; that is, the graph on which the game is played. We will provide a more thorough explanation of the game in the last section of this chapter. For now, let us provide an example of the game. We begin with a graph below, playing with a single cop and a single robber. The cop places himself on the left most vertex first, and the robber will place herself as far away from the cop as possible.
R R C C

Figure 1. An example of Cops and Robbers: rounds 1 and 2.

R C C,R

Figure 2. An example of Cops and Robbers: rounds 3 and 4. 2

In the second round, the cop moves first and he moves closer to the robber. The robber has only one place she can go, but this will bring her closer to the cop. So she will stay put and await capture. 2. Introduction to Graph Theory 2.1. Basic Graph Theory Terminology. We define basic graph theoretic notation, and summarize basic results in graph theory used in the thesis. A graph is a pair G = (V, E ), where V is the non-empty set of vertices {v0 , v1 , ..., vn }, and E is the set of edges {e0 , e1 , ..., em }, where each edge is a pair of vertices ek = {vi , vj } with i = j . We can represent vertices, often called nodes, by dots and we draw an edge between vertices vi , and vj if the edge {vi , vj } is in E (G). To denote edges we will use the notation vi vj . It is possible to have graphs with an infinite number of vertices; however, for the remainder of this thesis we will only consider finite graphs. Additionally, we make the notational convention: N represents the natural numbers including zero, and N+ is the natural numbers excluding zero. When {vi , vj }  E (G), we say that vi is adjacent to vj , or that they are neighbours. We can denote this vi  N (vj ), where N (vj ) is the neighbourset of vj . Additionally, we use the notation N [vj ] to denote the set of N (vj )  {vj }, called the closed neighbour set. We say that an edge is incident to a vertex, that is ek is incident to vi . We define the degree of a vertex, written deg(vi ), to be the number of edges incident to vi . We
3

denote the minimum degree of all vertices in G as  (G), and we denote the maximum degree of all vertices in G as (G). The k th -neighbour set of a vertex u, denoted Nk (u), as the set of vertices v such that the distance between u and v is at most k . In Figure 2 above, we notice that we have two edges from the left vertex to the top vertex (and from the left to the bottom as well). When we have multiple edges, we call this graph a multi-graph. In a multigraph, it is also permissible to have an edge where both endpoints are the same vertex, called a loop. Typically, we consider only graphs with single edges between pairs of vertices, with no loops. This kind of graph is called a simple graph. From now on, assume we are discussing simple graphs when we say the word "graph" unless otherwise specified.

Figure 3. On the left, a multi-graph. On the right, a simple graph.

A subgraph H  G is the graph such that V (H )  V (G) and E (H )  E (G). That is, we take some vertices of G, and only choose some edges between those vertices. An induced subgraph H of G that is induced by
4

the set U  V (G), denoted G U , is the graph such that V (H ) = U and {u, v }  E (H ) if and only if u  U and v  U . That is, H is the graph where we consider vertices in the set U , and include all edges where both endpoints are in U . We call a subgraph with V (H ) = V (G) a spanning subgraph. In the example below we have a graph, G, on the upper left. The graph on the upper right is a subgraph of G but is not an induced subgraph since it is missing the edge {1, 2}. The graph on the bottom left is an induced subgraph using the set U = {1, 2, 3}, and the graph on the bottom right is a spanning subgraph of G.
1 4 1

2 1

3

2 1

3 4

2

3

2

3

Figure 4. An example of a subgraph, an induced subgraph, and a spanning subgraph.

A graph G is called connected if and only if for every pair of vertices u, v  V (G), there exists a path from u to v , that is there is a list of edges we can follow to get from u to v . It is possible that a graph contains an
5

isolated vertex, that is a vertex with no incident edges (that is a vertex with degree 0). Up until this point, we have not explored graphs that are not connected. Below is an example.

Figure 5. A disconnected graph.

Notice there are two parts to this graph. We call each of these a connected component. A connected component is a maximal connected induced subgraph; that is we cannot add any more vertices to the subgraph without disconnecting the graph). Unless otherwise stated, we will assume all graphs discussed in this thesis are connected.

2.2. Basic Types of Graphs. A complete graph on n vertices, written Kn , is the graph such that there is an edge between every vertex, and n(n - 1) all other vertices. The graph Kn has n vertices and edges. Com2 plete graphs are sometimes called clique graphs. This term is used more frequently when talking about subgraphs.
6

Figure 6. The graph Kn for n = 1, 2, 3, 4.

An independent set on n vertices is the graph G with |V (G)| = n and |E (G)| = 0.

Figure 7. Independent set on 4 vertices.

A path on n vertices, written Pn , is defined as the graph with V (G) = {v1 , ..., vn } and with edges {vi , vi+1 } for 1  i  n - 1. The graph Pn has n vertices and n - 1 edges.
v1 v2 v3 v4 v5 v6

Figure 8. The graph P6 .

A cycle on n vertices, written Cn , is defined as the graph with V (G) = {v1 , ..., vn } and with edges {vi , vi+1 } for 1  i  n - 1 and the edge {vn , v1 }. The graph Cn has n vertices and n edges. We define a bipartite graph as a graph whose vertex set can be partitioned into sets X and Y such that there are no edges {u, v } with u and v in the same partition. We define the complete bipartite graph, denoted Km,n with |X | = n, |Y | = m, as the bipartite graph that has all possible edges from X to Y . Note that a graph is bipartite if and only if it contains no odd cycle as a subgraph; see, for example, [22].
7

v1 v6 v2

v5 v4

v3

Figure 9. The graph C6 .

Figure 10. On the left a bipartite graph. On the right K3,3 .

2.3. Trees. A tree is a graph that is connected and has no cycles. A forest is a graph that has no cycles, but is not necessarily connected. That is, each connected component in a forest is a tree. Each of the trees in the figure below is drawn in a manner so it appears "rooted." It does not matter what sort of formation the edges and vertices are drawn in, so long as adjacency is preserved. In a rooted tree, we have a sense of vertices above, and other vertices below. For some internet vertex v , we call the neighbour of a vertex v that occur above v , there is only one, the parent of v . All vertices below v , of which there are (deg(v ) - 1)-many, are the children of v . This also gives us a notion
8

of grandparents and cousins, although they are much less frequently discussed. Some vertices have only parents and no children, thus they have degree one. We call these vertices leaves. We demonstrate this nomenclature in the following figure. Each root is labeled v , each leaf is labeled l, and we have labelled the parents and grandparents of the leaves p and g , respectively.
v g p l l l l p l l p l g p l

v v g l l l l l l p

Figure 11. Examples of trees.

The tree in the middle is called a binary tree. Each vertex has at most two children. We can define an m-ary tree in a similar way by saying every vertex has at most m children. In the above example, this is a complete binary tree as every vertex, other than the leaves, has exactly two children. To indicate at what point we have the leaves, we define the height of a tree. The root occurs at height 0, and we count down each level from there. That is, if an internal vertex, a vertex that is neither the root nor a leaf, x has height h, then the parent of x has height h - 1, and the children of x has height h + 1.
9

The tree on the left is the complete bipartite graph, K1,5 , and it is called a star. We have a general formula for a star of K1,n .The tree on the right is simply a path. Graphs G = (V (G), E (G)) and H = (V (H ), E (H )) are said to be isomorphic, written G  = H , if there is a bijection f : V (G)  V (H ) such that any edge {u, v } is in E (G) if and only if {f (u), f (v )} is in E (H ). Isomorphic graphs share all the same properties. h We include the following result on trees, whose proof can be found in any basic graph theory text; see [12, 22].

Theorem 1. Given a connected graph G = (V, E ) with |V (G)| = n, the following are equivalent. 1) G is a tree. 2) G has n - 1 edges. 3) There is a unique path between any pair of vertices, u, v  V (G).

3. Graph Parameters and Domination The clique number of a graph, denoted  (G), is the maximum size of a subgraph H in G, where H is a clique. The independence number of a graph, denoted (G), is the maximum size of a subgraph H in G, where H is an independent set, that is there are no edges in H . We define the girth of a graph to be the length of the smallest possible induced cycle subgraph of G. We define a dominating set to be a set of vertices,
10

S  V (G) such that every vertex not in S is adjacent to a vertex in S . For every v  V (G)\S , there exists a u  S such that {u, v }  E (G). The domination number of a graph, denoted  (G), is the minimum size of a dominating set. The following is the Petersen graph.

Figure 12. The Petersen graph.

In the Petersen graph G, (G) = 4. The girth of the graph is 5, and a largest clique is simply an edge,  (G) = 2. Further,  (G) = 3. In the game of Cops and Robbers, we focus on the parameter of cop number, denoted c(G). Cop number is the minimum number of cops required to guarantee that the cops will capture the robber. To relate the previous parameters, we have that, for any graph G, c(G)   (G). Cop number will be more thoroughly discussed in the following section. The following bound on the domination number is part of folklore, and the proof is included for completeness.
11

Theorem 2. For a graph G of order n, we have that  (G)  n-(G).

Proof: We begin by adding every vertex in V (G) to a dominating set S . Take some vertex v of maximum degree. We can remove all neighbours of this vertex from S . Then the only vertices not in S are the ones adjacent to v . All of these vertices are adjacent to something in S , so S is sill a dominating set. For any dominating set, S , we have  (G)  |S |. Thus,  (G)  n - (G). A distance-k dominating set is a set of vertices Sk  V (G), such that every vertex not in Sk is connected to a vertex in Sk by a path of length no longer than k . We call the minimum size of all possible distance-k dominating sets to be the distance-k domination number, denoted k (G).

4. Introduction to Cops and Robbers Cops and Robbers is a vertex pursuit game played on a graph, G. We often consider G to be a reflexive graph; that is, each vertex has a loop, this allows players to stay on their current vertex during their turn. The two players are the cop, C , and the robber R. In the 0th round C places himself on some vertex of the graph, then R places herself on a vertex. Each player then takes one turn in each round beginning with the cop, by moving from their current vertex to an adjacent vertex. Since we play on a reflexive graph, staying on the same vertex is permitted.
12

In the original definition of the game in [17], only one cop is in play. However, we can also play with a set of cops C , where in each turn of the cops, all cops move simultaneously throughout the graph. The minimum number of cops required to capture the robber is called the cop number, denoted c(G). Graphs with c(G) = 1 are called cop-win. Cop-win graphs were first characterized for the finite case in [19], and later a characterization for all cop-win graphs was found in [17]. For any graph G, we define the relation r , for each r  N, on the set of vertices of G, V (G), as follows: (1) x 0 y if and only if x = y (2) For each r > 0, we say x r y if and only if  v  N (x),  u  N (y ) such that u p v for some p < r. We define  as  where  is the least non-negative integer such that  =+1 . This relation provides a characterization of cop-win graphs. Theorem 3 ([17]). If for every x, y  V (G) x  y , then G is cop-win. More simply put, Theorem 3 says that no matter what starting position is chosen, the cop is able to chose a vertex so that wherever the robber chooses to move, the cop will be closer to the robber than he was previously. Eventually, the cop will capture the robber. This characterization is the basis for the main result in Chapter 4. For now, we will move on to more structural results along with some examples (all known in folklore [9]).
13

Theorem 4. 1. For a graph G, we have that c(G)   (G). 2. If G is a tree, then c(G) = 1. 3. For n  4 and integer, c(Cn ) = 2. Proof. For item (1), note that every vertex in a dominating set is adjacent to every vertex outside the set. If the cops play on all vertices of a dominating set, then they will capture the robber on their first move. For item (2), note that for a tree there exists a unique path between any pair of vertices u, v  V (G). The cop follows the unique path between himself and the robber. This path will never increase in length, and will eventually decrease until the robber is captured (via an inductive argument). For the final item, observe that for a cycle, if a cop attempts to follow the robber, then they will simply go around the cycle in circles indefinitely. Thus, we need one cop to chase the robber in one direction, and a second cop to come around the cycle in other direction, eventually closing in on the robber from both sides.

5. A Brief Discussion on Algorithms In Chapter 4 of this thesis we will discuss graph algorithms, and utilize Dijkstra's algorithm. An algorithm is a way of answering a YES or NO question given a certain input. Essentially, it is a set of steps that guides us without fail from an input to a certain output [9, 12, 22].
14

For example, you could create an algorithm to answer the question: "Is there a vertex of degree three in G?" The algorithm could check the degree of each vertex and output YES if and only if there is a vertex of degree three. Such a vertex (if it exists) is a certificate. We denote this algorithm as follows. DEGREE 3: Is there a vertex of degree three in G? The study of algorithms is a growing field of mathematics and computer science, and is far more complex than what is presented in this thesis. The basic knowledge discussed in this section is sufficient for the reader for the remainder of the thesis. For further discussion on algorithms and Cops and Robbers, the reader may consult [9]. We continue our discussion on algorithms with Dijkstra's algorithm. We present the algorithm as follows. DIJKSTRA: Is there a path between two vertices u and v ? This algorithm gives a certificate of a shortest path whenever one exits. As input to the algorithm, we are given a graph G, a specified starting vertex u, an ending vertex v , and nonnegative edge weights.

(1) Let S be the set of visited vertices, thus V (G)\S to be the set of unvisited vertices. Set S = . Assign tentative distances of  to all unvisited vertices, and set the tentative distance of u to zero. Assign u to be the current vertex.
15

(2) For each neighbour v of u, add the weight of the edge {u, v } and the current distance of u. If this value is less than the tentative distance of v , then reassign the tentative distance of v to this value. Otherwise, do nothing. (3) Once all neighbours of the current vertex have been visited, move the current vertex to S and remove the label of current vertex. Set some unvisited vertex to be the current vertex and repeat steps 2 and 3 until S = V (G). (4) If the distance of v is finite, then there exists a path between u and v . Otherwise, u and v are in different components of the graph G.

6. Outline of Thesis Now that we have presented an introduction to basic graph theory, as well as provided an overview of the original game of Cops and Robbers, we provide a summary of the thesis. In Chapter 2 where we will formally introduce Cops, Robbers, and Barricades. Here we will present basic results on the game with examples. In Chapter 3, we will provide general bounds to the barricade-cop number of the graph. There will also be examples of modifications to the parameters of the original game. We introduce three modifications and show the large impact of small changes to the rules of the game.
16

In Chapter 4, a characterization of barricade-cop-win graphs will be given, along with an algorithm for determining the barricade-cop number of a graph. There will be a brief discussion on the complexity of these results. In the final chapter, we highlight our results and state open problems collected from the thesis.

17

CHAPTER 2

Cops, Robbers, and Barricades 1. An Introduction to the Game It is a long tradition in the study of Cops and Robbers to examine variants of the game. There have been many variants that give power to the cops such as tandem-win Cops and Robbers, distance k Cops and Robbers, and photo radar Cops and Robbers [1, 5, 6, 11]. There have also been some variants that give power to the robber, such as Zombies and Survivors, and decoy Cops and Robbers. [8, 10, 14]. We define a new variant of the game of Cops and Robbers that gives more power to the robber. In this variant, the robber is able to change the structure of the graph in each round of the game. Definition 1.1. Cops, and Robbers, and Barricades, denoted CRB , is a game played on a reflexive graph G. We have two players: the set of cops, C , and the single robber R. Analogous to the original game of cops and robbers, in the initial round C places all the cops on some set on vertices of the graph, then R places herself on a vertex. Each player then takes one turn in each round beginning with the cops, each of whom, simultaneously, move from their current vertex to an adjacent vertex. Since we play on a reflexive graph, it is permissible for a player to remain
18

on the same vertex. Let b be a function b : N+  N. The robber, on her turn, is allowed to move to any adjacent vertex, or instead of moving is permitted to build b(k ) many barricades on vertices, where k is the index of the current round. A barricade on a vertex forbids any player from entering that vertex. This is equivalent to deleting the vertex, although we will consider them as barricaded vertices and not deleted vertices. These barricades must be built in accordance with specified barricade rules which permit prescribed configurations of barricades to be built in each round.

In the present chapter, we will play with b(k ) = 1 and we only consider the barricade rule that all barricades must be built on vertices adjacent to the robber. In Chapter 3, we will examine other barricade rules such as placing barricades on any vertex of the graph. In Chapter 4, we will consider the general case where b(k ) is an arbitrary function on the positive integers, and allow the building of barricades on any vertices. The barricade-cop number of a graph, denoted cB (G), is the minimum number of cops required to guarantee capture. We say a graph is barricade-cop-win if cB (G) = 1. We first consider the following elementary but useful result.

Lemma 5. For any graph G, c(G)  cB (G).
19

Proof. Given any graph G with c(G) = 1, 0 cops will always lose, so cB (G)  1. Otherwise, given any graph G with c(G)  2, and (c(G) - 1)many cops, we play CRB. The robber will chose to move each round and use the same strategy from the original game and never place a barricade in order to evade capture indefinitely. Thus, we need at least c(G)-many cops to capture the robber when playing CRB. We can also find an upper bound for cB (G) by using a winning strategy for the cops via a dominating set. This result was first mentioned in Chapter 1, Theorem 4.1.

Theorem 6. For any graph G, cB (G)   (G), where  (G) is the domination number of G.

Proof. The set of cops play on all the vertices of a dominating set of minimum size. For any initial placement of the robber, a cop will be able to capture R in the first round.

2. Preliminary Results Now that we have a definition of the game, we consider cB (G) for some elementary classes of graphs. We first consider the path on eight vertices, P8 . We notice c(P8 ) = 1. We label the vertices on the graph such that v1 is the leftmost vertex, and we count up as we move towards the other end of the path, so that the final vertex is labeled v8 .
20

We begin by attempting the strategy used for paths in the original game using only one cop [9]. Then we show another example where the cops fail to win, which helps illustrate the subsequent proof.

C C C

R R R

Figure 1. Example: Cops, Robbers and Barricades on P8 . 21

In the first round, the cop will go on the middle vertex of the path, and then the robber will go to an end-vertex of the path to maintain as much distance between herself and the cop. In the next round, the cop will move one vertex closer to the robber. However, this time the robber will lay a barricade in the second-to-last vertex, protecting himself from the cop indefinitely. Thus, the robber wins. Now, we attempt a strategy with two cops placed initially at each endpoint v1 and v8 . The robber will try to stay as far away as possible from both cops, and place herself close to the middle, on v4 without loss of generality. In the first round, both cops move one step closer to the robber, to v5 and v7 , respectively. but the robber places a barricade to her left on v3 , which prevents the cop on the left from ever reaching the robber. The robber will not choose to move since moving in either direction brings her closer to the cops. The cop on the right, is able to take another step toward the robber to v6 . However, the robber is able to place another barricade on v5 and has blocked both cops from ever reaching her, thus, winning the game. In order for two cops to close in on the robber, we require that there must be fewer than six vertices in between two cops. Theorem 7. For a path with n  N+ vertices Pn , we have that cB (Pn ) =
22

n+1 . 6

Proof. We begin by providing a winning strategy for the cops, then we will count the required number of cops. We will show that this number of cops is best possible. Label the vertices of Pn such that v1 is the left most vertex, and counts upwards to the right. We place a cop on v3 , and notice a cop here can guard v1 , v2 . However, a cop starting at v4 would not be able to guard v1 , since R could build a barricade on v2 in round 2, when the cop is still too far away at v3 . From this point forward, we place a cop on every sixth vertex. If R plays optimally, then she will place herself exactly halfway between two cops resulting in the following gameplay. If we placed the cops further than every sixth vertex, then robber would have sufficient time to build both barricades before either cop is able to reach the robber. Thus, this is the minimum number of cops required.

C C C C C

R R R R R C C C C

C

Figure 2. Example 2. The cops play on either end of the path. 23

C C C C

R R R R C C C

C

Figure 3. CRB on P8 where the cops are placed optimally and win.

When we reach the end of the path, we will have n - 3 (mod 6) vertices remaining to guard. If this is at most two, then our last cop will be able to guard the remaining two vertices using the same argument the first cop was able to guard v1 , v2 . However, if there are three or more vertices remaining, then we will require an additional cop. Therefore, we have a winning strategy for the cops by placing them six vertices apart (up to the arrangements on the leaves). Hence, we have that (n - 3) + 4 n+1 = . 6 6

cB (Pn ) 

We now show that fewer cops will allow the robber to win. Suppose we have
n+1 6

- 1 cops. If this is equal to 0, the robber wins. If this

is more than 1, the cops will begin play by attempting to minimize the distance between themselves. If there is a gap between two cops greater than six, then the robber will play there and win (as per the previous example). If there is a gap between a cop and an endpoint greater than 2, again the robber can place herself on the leaf and win. Hence,
24

cB (Pn ) 

n+1 . 6

In the original game of Cops and Robbers, paths (which are a certain type of tree) are all cop-win. In the CRB variant, we need to guard a significant portion of the graph in order to keep the robber from winning. Note that cB is distinct from the domination number on paths, which is
n 3

. The case for trees in fact becomes significantly more difficult and

will be discussed in the following section. We next consider cycles. Theorem 8. For a cycle with n  3  N+ vertices Cn , we have that cB (Cn ) = n . 6

Figure 4. A cycle with a sample of the cop placement for CRB.

Proof. We follow the strategy used in Theorem 3. Since there are no leaves, we place a cop at some vertex of Cn , which we will call v1 , then
25

continue around the cycle placing a cop on every sixth vertex. At the end, we will always have at most five vertices between the last placed cop and the cop on v1 . This results in a winning strategy for the cops. If we were to use fewer cops, then there would be a distance between some pair of cops that is greater than five, resulting in the robber winning by building herself into a win. These examples demonstrate that the barricade-cop number to be quite large, especially in comparison to the original cop number. We define a robber-star as follows. A vertex x  V (G) is called a robber-star if for all vertices v  N (x), there exists a vertex u  Ndeg(x) (x) such that at least one path of length at most deg(x) from u to v passes through N (x) uniquely through v . We call u a star vertex.

C

C

R

C

Figure 5. An example of a robber-star.

Theorem 9. If there exists a robber-star, then we require a cop on the path between x and each star vertex.
26

Proof. Suppose there is some star vertex u that does not have a cop on the path between x and u. That is, there is some vertex adjacent to x that will remain unguarded after deg(x) many rounds. On her first move, the robber R will play on x and build barricades on each neighbour other than the unique neighbour that corresponds to the path from the unguarded vertex u. Since there is no cop on u, on the deg(x)th round, R will be able to build a barricade on vertex v , and win the game. 3. Trees We begin this section with two theorems on general trees. Theorem 10. For a tree T of height at least 2 with set of leaves , we have that

cB (T )  |N2 ( )|. Proof: All grandparents must be covered by cops in order to guard the leaves. If one leaf is not guarded, then R will place herself on that vertex. In the second round, the cops can move closer, then R can build and win. Theorem 11. A tree T is barricade-cop-win if and only if there exists a vertex v such that, when T is rooted at v , T has height at most 2. Proof: For a tree with height 2, we place a cop on the root of the tree. Since the robber is playing optimally she will place herself on a leaf
27

in order to lengthen the game play. In the first round, the cop will move down the unique path between himself and the robber. The robber will have no place to move or build a barricade that round and will need to stay put. The cop will capture the robber in the following round. If a tree is barricade-cop-win, then we know that it can only have one grandparent of all the leaves. This grandparent is then a root for the tree such that the tree has height 2.

4. Complete m-ary Trees A complete m-ary tree with height h is a rooted tree such that each internal vertex has exactly m children, and the leaves are at a distance of exactly k from the root.
0

1

1

1

2

2

2

2

2

2

2

2

2

Figure 6. Complete 3-ary tree of height 2. The height of each vertex is labelled.

We consider the root to be at height 0, and the children of the root have height 1, we continue counting as such, then we will say leaves have height h.
28

Theorem 12. If T is a complete m-ary tree with height h, then we have that
c

cB (T ) 
i=0

m(c-i)(m+4)+m+1 ,

where c =

h-m-3 m+4

.

Proof. We will place cops to occupy all vertices of a given height, and they will all move together up or down the tree as a whole. We call the set of cops at height less than the robber the above cops, and we call the set of cops at a height greater than the robber the below cops. The strategy we are about to describe is called the row strategy. To block the robber from entering a leaf on his first turn, we place cops at all vertices at height h - 2, of which there are mh-2 . If R were to enter a leaf in the first round, then the cops would move down in the next round and be adjacent to the robber. The only move the robber can make is to stay still as he has no where to build any barricades, thus, she will be captured by the cops in the second round. If a robber enters any internal vertex on the first round, then there are m children and 1 parent for the robber to block off with barricades if he is going to win the game. Cops from the bottom must climb the tree to capture the robber before he has time to build all m barricades on the children; thus, if the robber is at height j the cops must be at height j + m + 1. Notice that it takes m + 1 robber moves to be totally
29

Figure 7. A row in a complete m-ary tree.

blocked in; thus, within the (m + 1)st move the cops must be adjacent to the robber so he can no longer build. We place cops starting from the height of h - 2 at every m + 5th row until we reach a row that is at a height of m + 1 or less. Consider the following two cases regardless of where the robber plays between the two layers of cops. Case 1: If the robber builds a barricade above first, then the cops below are at a distance at most m. Eventually, a cop will occupy the non-barricaded child of the robber, thus, R will be captured in the next round. Case 2: If the robber builds a barricade below first, the cops above (specifically the cop that has R as a descendent) are now at a distance at most m away. If R continues to only build below, the cop above will eventually be adjacent to R. However, if R at any point chooses to build
30

above, he wastes a time-step, and the cops below are able to reach R before R can build all her barricades. It is important to note that the robber will never chose to move. If she does chose to move, then she decreases the distance between herself and either the above cops or the below cops depending on her choice of movement. The respective set of cops is able to reach the cop in a small enough number of rounds so that R will not have sufficient time to build enough barricades to block herself off entirely before the cops are able to capture her. This proves our result.

Theorem 13. If the cops are forced to play the row strategy, then we have that
c

cB (T ) =
i=0

m(c-i)(2m+4)+m+1 ,

where c =

h-m-3 2m+4

.

Proof. Here, it will not be possible for the cops to play any strategy other than the row strategy. In a sense we are altering the rules of the game. We now show that if we increase the spacing between the rows of cops, the robber will be able to win. Suppose the cops play with a distance of more than m + 5. Then, there is some row where R could play such that
31

she is more than m + 2 rows away from the below cops, and more than 3 rows away from the above cops. From this position, R is able to build above first, blocking all above cops from reaching her. However, all the cops below are still more than m + 1 rows away from R, and R will be able to barricade all her neighbours before the cops can reach her. Now that we know we have the proper distance between rows of cops, we consider two cases where we are missing a single cop from a single row. Case 1: If a cop is missing from above the robber, then she will build all barricades below first. However, a sibling of the missing cop will move up to the parent, and then back down to the missing location in order to try to capture to robber. This however, takes too much time (m + 2 moves) and R is able to build a barricade above himself first. Case 2: If a cop is missing from below the robber, then we notice that in the first move of the cops, each vertex in that row has m cops on it, except the parent of the missing cop, which has only m - 1. There will still be at least one cop on the child of R after the mth move, thus, the cops can win. If there is only one cop missing from the row strategy, the robber is always able to find a vertex below the missing cop to place herself. Playing below the missing cop, guarantees a win for the robber.

32

Any tree of height h with maximum degree m + 1 is a subgraph of the complete m-ary tree of height h. Thus, an examination of these trees, will additionally provide an upper bound for any tree.

Theorem 14. If a tree T has height h and maximum degree m + 1, then we have that
c

cB (T ) 
i=0

m(c-i)(2m+4)+m+1 ,

where c =

h-m-3 2m+4

.

33

Proof. We play the row strategy as above, however, we may be missing vertices in some rows. We add multiple cops to vertices in the same height, so that as they travel up or down the graph they act in the same manner as they did in the case of the complete m-ary trees. This will result in a win for analogous reasons.

5. Locally Path-Like Graphs Definition 5.1. We call a graph G locally path-like if between every pair of vertices vi , vj with deg(vi ), deg(vj ) = 2 there are at least five successive vertices with degree of two. We call this path of vertices of degree two a local path.

Definition 5.2. We can represent locally path-like graphs with a weighted multi-graph, named W (G). For each v  V (G) with deg(V ) = 2 we have a vertex, v in W (G). For any local path with endpoints u, v for length m, we add an edge u , v in W (G) with weight m. For a locally path-like graph G, we denote the edge set of W (G) as E (W ).
34

12 12 9 8 10 7 10 7 12 13 12 6 10

6 8 7

Figure 8. An example of a locally path like graph G, and its corresponding weighted multi-graph W (G).

Theorem 15. For a locally path like graph G we have that cB (G) 
eE (W )

w(e) - 1 + |V (W (G))|, 6
35

where w(e) denotes the weight of an edge e in W (G). Proof. Initially, we place cops on all vertices in W (G). For each edge {u, v } in our new graph W (G), they are paths in our original graph G. This path has a length of w({u, v })-many vertices in G. However, the first six vertices are guarded by the cop on u; thus, we have a path of length w({u, v }) - 6 to guard. We must guard every 6th vertex. At the end of each local path, we will have at most five vertices left over, which will be guarded by the cop on v . The number of cops we require w({u, v }) is -1 . 6 For each loop, {u, u}, we use the same strategy, and the final vertices are simply guarded by u as well. 6. Meyniel's Conjecture and Domination 6.1. Meyniel's Conjecture. One of the most famous conjectures in the study of Cops and Robbers is Meyniel's conjecture. In 1985, Meyniel conjectured in a personal communication with Peter Frankl, that the cop number for a connected graph G with at most n vertices must have  that c(G) = O( n) [9, 15]. Put more simply, there is some constant d, such that for any connected graph G, with at most n vertices, such that  c(G)  d n. 6.2. Domination Number. Recall from Chapter 1, the domination number of a graph is the minimum size of a set, S  V (G), such that
36

every vertex in G is either a member of the set S , or in the neighbour set of some vertex u  S . We can denote this as N [S ] = V (G), where N [S ] is the union of the closed neighbour sets for each vertex i  S . The set S is called a dominating set. We can extend this definition to define the distance k domination number. First we define a distance k dominating set, S  V (G) such that every vertex in G is either a member of the set S , or in the k th neighbour set of some vertex u  S . This is also to say, that for every v  V (G) there exists a u  S such that v  Nk [u]. The minimum size of all distance k dominating sets is the distance k domination number, and it is denoted k (G). In 2002, Sridharan et al. proved the following theorem. Theorem 16 ([21]). If a graph G with V (G) = n and no isolated vertices, then 2 (G)  n-+1 . 2

6.3. Results. It has already been shown in Chapter 1 that for any graph c(G)   (G) [9]. We prove the following new result. Theorem 17. If G, with V (G) = n has girth greater than or equal to 7, then c(G)  2 and cB (G)  2 . Proof Consider the following figure.
37

Figure 9. The initial set up. The blue edges may exist but are of no consequence to the proof, and the red edges cannot exist due to the girth of the graph being greater than or equal to 7.

In the initial set up, we place cops on each vertex of a distance 2 dominating set of minimum size. The robber is dominated by cops at most distance 2, and all of her neighbours are dominated by cops at most distance 2, as show in the above figure. For the first move of the cops, they will all move on the unique shortest paths connecting themselves and the robber (using that the girth is at least 7). The robber must now move in order to avoid capture in the following round. If we are playing with barricades, then she must also move since she cannot lay a barricade without immediately being captured. However, if R moves to any neighbour she will be adjacent to a cop. Thus, R will be captured in the second round. Therefore, 2 -many cops can win when G has girth greater than or equal to 7.   Theorem 18. If G has   ( n - 1)2 , then 2  n.
38

C R

C

C

Figure 10. The first move of the cops, before the robber moves.

Proof. We note the following derivation, which follows from the bound in Theorem 13:

2   = = = The proof now follows.

(n -  + 1) 2  n - ( n - 1)2 + 1) 2  n - (n - 2 n + 1) + 1 2  2 n 2  n.

39

Corollary 19. If G has girth greater than or equal to 7 and     ( n - 1)2 , then c(G)  n. Proof. The proof follows by Theorems 14 and 15.

40

CHAPTER 3

Variations of the Barricade Rules 1. Introduction In the previous chapter we restricted ourselves to the following rules: the robber was allowed to build b(k ) = 1 barricade each turn, and with the barricade rule of building only on adjacent vertices. Recall that the barricade rules dictate where the robber is permitted to build each turn. In this chapter, we will examine the changes in the game when we vary the barricade rules of the game, while keeping b(k ) = 1. There are three particular examples that we will define and provide examples. We conclude the chapter by examining the relationship between the three variants.

2. Three Variants of the Barricade Rules 2.1. Global Version. We begin this section with the global version of the barricade rules. With the global barricade rules, the robber may place a barricade on an unoccupied and non-barricaded vertex anywhere on the graph. We denote the barricade-cop number of this version as c1 B . This variant makes it easier for the robber to barricade vertex cuts
41

C R

C

R

Figure 1. Example of the global variant.

without requiring her to move. Consider the following example with the given initial positions for both the cop and the robber. First, the cop will move one step towards the robber. However, on her turn, the robber will build a barricade on the cut-vertex that separates herself from the cop. This results in a win for the robber. We make the following definition required for further study of this variant. A robber cut is a set of vertices that separates the set of cops from the robber. Notice, that a robber cut is not necessarily a minimum vertex cut. Given a graph G, if there exists a robber cut of size k , where k <  (G\[N (C )]), then the global barricade rules provide an advantage to the robber.

Theorem 20. Given a graph G with a particular starting placement of cops and the robber such that there exists a robber cut of size k . If the minimum distance between all cops and any vertex in the cut is strictly
42

greater than k , then the robber wins when playing with global barricade rules. Proof. The cops must eventually cross the robber cut in order to capture the robber. Thus, on their first move at least one cop will move towards the cut. In her first move, the robber will lay a barricade on one vertex of the cut. In this fashion, the cops continue moving one step closer to the cut, while the robber barricades the successive vertices of the cut. This proceeds until the second-to-last-move. Since the distance from any cop to the cut is more than k , on their k th turn no cop will be on a vertex in the cut. On her final turn, the last vertex of the cut is unoccupied, and the robber builds herself in, winning the game. Theorem 1 gives rise to the notion that we must restrict cops from being too far from a robber cut at all times. However, it does not yield an efficient lower bound. There are n ·
n k

many starting positions when

we play with k -many cops. In order to determine the optimal k we would need to check each starting position with each number of k cops. The number of starting arrangements grows quickly from n2 , when k = 1  to 2n / n when k = n/2 [20]. An algorithmic argument would be impractical for determining a lower bound in this manner. 2.2. Local Version. The local version of the barricade rules is exactly the rules we used in Chapter 2, the robber may only place barricades on adjacent vertices. We denote the barricade-cop number, cB (G) as c2 B
43

for the remainder of the chapter. For further discussion on this version, please reference Chapter 2 of this thesis. 2.3. Slug Version. As one may have noticed from earlier discussion, the aforementioned barricade rules do not necessarily require movement by the robber during game play. In the slug version the robber must move to a vertex, then move off it in order to leave a barricade. Just like a slug, the robber leaves a trail not of biological matter, but of barricades. It is not necessary for the robber to leave a barricade on a previous vertex. Let us proceed with an example.
C R C

C

R

C

C

R

C

C

R

C

C

R

C

Figure 2. Example of the slug variant of CRB.

The cops and the robber begin in the given initial positions. Then as the cops move in, the robber moves first to her right and then to her left, placing barricades as she returns to her starting vertex. Notice that the robber builds barricades slowly, while the cops are able to quickly close in on the robber.
44

Consider the movement of the robber as she defends her starting vertex. In order to fully barricade herself in, it requires not N (R)-many turns, but 2 · N (R)-many. In the following example, we have each cop at a distance of at most 2 ·  (G) - 1 from R. The robber then begins moving to a neighbour, building a barricade, and moving back to the starting vertex, v . On odd moves the robber will be on a neighbour and on even moves the robber will be on v . Round 2 ·  (G) - 2 will end with the robber on v . Each cop has moved along its dominating path towards the neighbours of v . There will be exactly one neighbour that is free of barricades. The cop moves to that vertex trapping the robber on v , and capturing her in the next round. Unfortunately, this does not give us an upper-bound for c3 B . In the second-to-last move as described above we would have the following set up.

C R x v

Figure 3. The second-to-last move in the slug version example.

Here, R is able to move to vertex x which is not necessarily currently guarded by cops.
45

3. Relating the Three Variants Each of the previous variants of the game relate together in the following theorem. Theorem 21. For any graph G, we have that
2 1 c(G)  c3 B (G)  cB (G) = cB (G)  cB (G).

Below, we consider each of the inequalities in Theorem 2. Lemma 22. For any graph G, we have that c(G)  c3 B (G). Proof. We require at least c(G)-many cops when playing with the slug barricade rules. If we did not have c(G)-many cops, then the robber would play her winning strategy in the original game. Lemma 23. For any graph G, we have that
2 c3 B (G)  cB (G).

Proof. We play the local game using c3 B (G) - 1 cops. The robber can play the slug strategy by resting in the round the slug would move, then placing the barricade in the same turn the slug robber would. Since there are fewer than c3 B (G)-many cops, the robber will be able to win.
46

Lemma 24. For any graph G, we have that
1 c2 B (G)  cB (G).

1 Proof. We show that c2 B (G) is a lower bound for cB (G) by contradic-

tion. Suppose we have fewer than c2 B (G)-many cops in the global game. The robber can then use her winning strategy from the local game in order to win in the global game since it is possible to place barricades on only neighbouring vertices in the global game. We now provide two examples, the first showing that we can have
1 c2 B (G) equal to cB (G), and the second showing that it is possible for 2 c1 B (G) to be strictly greater than cB (G). For this, we define a family of

graphs called a necklace graph, denoted Ni (G1 , ..., Gi , k ). We take any cop-win graphs G1 , ...Gi (not necessarily distinct) that are diameter k , and chain them together by overlapping them on a single vertex. More specifically, we choose a vertex u in Gj and v in Gj +1 , then we delete v from the graph, and any edge that was incident to v we now make incident to u. For any set of graphs, we can choose a different set of vertices to chain them together, so for any set of graphs, we have a family of necklace graphs. We also make the restriction that each subgraph, or pearl, in the chain has minimum degree at least two. Below, we have an example of a family of necklace graphs with diameter k , and six graphs in the chain.

47

In the following necklace graph, we have each graph in the chain is the same, with eight pearls. It is important to note that this graph is cop-win, and each pearl subgraph of the necklace is also cop-win.

Figure 4. A particular necklace graph with eight pearls.

In order to show the necessary inequality, we will show that, in the
1 graph G in Figure 3.5 c2 B (G)  3 and cB (G)  4.

To show that c2 B (G)  3, we first consider the starting positions of the cops. One cop must guard each end graph in the necklace by being on the chain vertex itself, or on a neighbour of the chain vertex in the adjacent graph. If not, then the robber would be able to build a barricade on the chain vertex in her first round. We place our third cop in the middle of the necklace, this minimizes the distance between this cop and the other two.
C C R Figure 5. The initial positions for the local game of CRB on this graph. C

We now consider the section of the graph beginning from the left-most cop to the right-most cop, for sake of simplicity.
48

C C R C R C R C C R C C R Figure 6. Game play of the local version of CRB on this particular section of a necklace graph. C C

In the second to last move of the cop, it is without loss of generality that the cop chooses to go to the top most vertex, since both vertices leave the robber stuck in a corner. Additionally, the second to last move of the robber is also symmetric. Following this last image, it is the cops' turn, and the cop is able to capture the robber. Thus, we have that three cops are sufficient to win in the local version of Cops, Robbers, and Barricades on this particular graph.
49

For the next example, we must show that three cops are not sufficient to guarantee a win for the cops. We begin with the same initial set up, and initial positions for the cops and the robber, as in Figure 3.6. Notice that if there were a greater distance between any two cops, then the robber would still be able to win using the same strategy. If the robber can win when the cops play on the neighbour of the end chain vertices, then the robber can also win when the cops play on the chain vertices themselves. We will show the game play of the former, again on the section of the graph between two cops containing the robber. At the end of the rounds in Figure 3.7, the robber has barricaded both chain vertices and there are no cops in the same component of the graph as the robber. Thus, R wins the game, and this demonstrates that
2 c1 B (G) < 3 but cB = 3 as required.

50

C C R

C

C

R

C

C

R Figure 7. Game play of the global version of CRB, on this particular section of a necklace graph.

51

CHAPTER 4

Characterizing Barricade-Cop-Win Graphs In the previous chapter, we examined the difference in game play when we varied the barricade rules, yet kept the barricade number constant at one barricade placed per turn. In this chapter, we will get examine a more general barricade number and provide a characterization for barricadecop-win graphs. We begin with some useful notation. Definition 0.1. In the k th round, there is some set of vertices that contain barricades; we call this set Bk  V (G). That is, for each round k , we have a set Bk indicating which vertices of G contain barricades. Notice that |Bk |  k · b(k ) since at most b(k )-many barricades are being added each round. Additionally, we are not able to remove barricades from the graph, so for each k , we have Bk-1  Bk . Thus, |BK | is strictly nondecreasing. We define the barricade graph, written Gk as the subgraph of G induced by V (G)\Bk for each round k ; that is, Gk = G V (G)\Bk . The barricade graph does not necessarily need to be connected. In the original game of Cops and Robbers, we restrict play to a connected graph. Here, we begin with a connected graph, but since Bk can be
52

any subset of V (G), it is entirely possible that Bk contains a vertex cut, thus, leaving Gk disconnected. Of course, if C and R are in different components of Gk , then we could not have a barricade-cop-win graph. In previous examples we have seen what happens when there is a single cut vertex, such as when R plays on a leaf. In Chapter 3 we saw a scenario where there was a vertex cut of size two when we compared the local and global variants of the game. We now proceed with an example where there is a much larger vertex cut, and b(k ) = 2. We start with the initial position of the cop being in the bottom left hand corner, and the robber being one vertex down the top left corner. The positions after the first round are shown.

R

C

R

C

Figure 1. An example of CRB played on a 5 × 5 strong product grid with b(k ) = 2 with a vertex cut of size four. 53

The robber in Figure 1 is now disconnected from the component of the cop. Consider the graph Gk = G V (G)\Bk , shown in Figure 2.

R

C

Figure 2. Gk = G V (G)\Bk for the example played in Figure 31.

Hence, we consider the minimum size of a vertex cut of G, and call it µ; that is, G is µ-connected. If we are able to complete the game before |Bk |  µ, then we will never have a disconnected graph during game play. We say that if some vertex v is in the same component as R in a graph G, then v  compG (R). 1. A relation on cop-win graphs In this section we will define a relation that is analogous to the ones in [7, 17]. For any graph Gk we define the relation r , for each r  N, on V (Gk ) as follows:
54

(1) x 0 y if and only if x = y . (2) For each r > 0, we say x r y if and only if for all v  N (x), there exists a u  N (y ) such that u q v for some q < r. Item 2 requires that for any position of the cop on a vertex y , and robber on a vertex x, for any movement of the robber from x to v , the cop is able to move to a vertex u in order to bring himself closer to the robber, where q is the number of moves left before capture. Of course, we notice there will be some minimum non-negative integer  such that  =+1 . We let  be the largest of such smallest .

2. Characterization We derive the following relational characterization of barricade-copwin graphs. Theorem 25. A graph G is barricade-cop-win if and only if for every play of the game, and for all rounds k  1 with corresponding barricade sequence Bk , there is some vertex u  NGk-1 (C ) such that u  compGk (R) for any k , such that u  R for some finite . Proof. We begin by proving the forward direction. Thus, we assume G is barricade-cop-win. From Lemma 2.1 we have that G must be copwin in the original game, so in round k = 0, we have that R  C for some . Furthermore, the cop is in the same connected component as the
55

robber (recall our global assumption in Chapter 1 that we only consider connected graphs, unless otherwise stated). Assume the result holds for a given fixed k  0. In the k th round we consider the move of the cop. Since we know he will eventually capture the robber, there must be some vertex v  NGk-1 (C ) that is in the same component of R that is not also in Bk . If the only such v were to also be in Bk , then all other vertices in the neighbour set of C are disconnected from R. Thus, R would remain free from capture indefinitely making G robber-win. After R makes her selection to move or add to Bk-1 , we have C now on v and R on some vertex u both in the same component of Gk . Since C eventually captures R we must have some finite r, as defined in the relation, such that u r v in Gk as required. We now consider the other direction. Hence, assume that for any sequence of Bk , C is able to enter in Gk-1 , the same component of R in Gk on some vertex u, for any k , such that u  R for some finite . We describe a strategy for C . There are two types of moves for C , which are based on whether or not R adds to Bk . Type 1: In round k , if R adds to Bk-1 , then by hypothesis, in round k + 1, C will move to the vertex u in compGk+1 (R). Type 2: In round k , if R does not add to Bk-1 , but she instead moves to some vertex v  NGk-1 (R) noting that Gk-1 = Gk , then C is on some vertex u  compGk-1 (R) with R r u for some finite r. Thus, for any
56

choice of v there exists some vertex y  NGk-1 (u) such that v q y with q < r. In round k + 1, C moves to this y . By making a combination of Type 1 and Type 2 moves, C will capture R by moving into compGk (R), for some k via R itself, or C will follow the strategy using the relations to capture R within its component.

3. Algorithm As input for the algorithm we are given a graph G. The output of the algorithm will state whether the cop wins in the game of Cops, Robbers, and Barricades or not. In each round R is allowed to build b(k ) =  many barricades, where  is a constant. Note that the first round of the game, round 0 has B0 = , thus, G0 = G. There are between 1 and (2n)! many choices of sequences (Bj ). BARRICADE-COP-WIN: Is G barricade-cop-win? Fix some sequence (Bj ). Assign a starting position to both C and R in round 0. For each i  1: (1) If Bi-1 = Bi , then R has added at most b(k )-many new barricades: (a) For each u  NGi-1 (C ) determine if there exists a path in Gi from u to R as follows: (i) In G, assign all edges to have weight one.
57

(ii) For every vertex v  Bi , change the weight of all incident edges to . (iii) Apply Dijkstra's Algorithm, discussed in Chapter 1, to find a shortest path between C and R, or determine no path exists. Find u's that are connected to R. (b) Check if R  u for some finite , for some u from above. (c) C moves to any such vertex, the choice is arbitrary. (2) If Ti-1 = Ti , then R did not delete a vertex and instead moved from vR in Gi-1 to vR  NGi-1 (vR ) in Gi : (a) We know there is some finite  such that vR  C ; thus, for any x  NGi (R) there is some u  NGi (C ) such that x q u for some q < . (b) Since R has moved to vR , there is some corresponding u , to which C must move.

If for any sequence (Bj ) we are always able to have R 0 C (that is, C captures R), then G is barricade-cop-win. If for any particular sequence (Bj ) we cannot capture the robber, then R will play that strategy and win. This algorithm verifies the necessary and sufficient conditions for barricade-cop-win graphs outlined in Theorem 4.1.
58

Note that the cop number of Gi for any i must be one. Otherwise, R would simply form Gi and then play her winning strategy in the original game. 4. Complexity When discussing algorithms we would be amiss to omit a discussion on complexity. Although, it should be noted that a thorough analysis of the complexity of the proceeding algorithm is outside the scope of this thesis. We notice that there are an exponential number of choices for the barricade sequence. Hence, if given a sequence, then we are able to run the algorithm in polynomial time, but when having to create the sequences, that algorithm becomes exponential. In the preceding algorithm there are most n steps, where n = |V (G)|. In each step, we apply Dijkstra's algorithm which is known to be in polynomial time [12, 22], or compute the relation which is also in polynomial time [7]. As we are given the barricades in advance, the complexity is bounded above by the sum of n polynomial functions, which in turn is polynomial. However, when you are not given the sequence of barricades as input, it is necessary to compute the above for each possible barricade sequence, of which there is an exponential number. This yields an algorithm with exponential complexity. It may in fact be that to determine if a given
59

graph is barricade-cop-win without the barricade sequence as input is NP-hard. The determination of the complexity of the BARRICADECOP-WIN problem is open.

60

CHAPTER 5

Conclusion and Open Problems 1. Conclusion In this thesis, we introduced a new variant of the game Cops and Robbers called Cops Robbers and Barricades (or CRB). In Chapter 2, we introduced the game with a few examples, and provided the exact barricade-cop number for particular graph families. We presented an upper bound for m-ary trees that also extends as an upper bound to all trees. After defining locally-path-like graphs, we provided a discussion of CRB on those graphs. We concluded Chapter 2 by discussing conditions  that ensure the cop number of a graph is at most n. In Chapter 3, we examined the impact of changing the barricade rules. We defined three new rules: the local rule where barricades can be placed only on neighbours, the global rule where barricades can be placed anywhere, and the slug rule where barricades can only be placed once the robber has moved away from a vertex. We considered the relationship between these games. In Chapter 4, we gave a characterization of barricadecop-win graphs given any barricade rules and any b(k ) function.

61

2. Open Problems We conclude this thesis by collecting a number of open problems on CRB.

(1) We conjecture that the row strategy is the optimal strategy for the cops when playing on m-ary trees. The upper bound on cB we proved for trees is likely not tight, since we currently use the bound for m-ary trees as an upper bound for all trees. Can we utilize graph packings to determine a lower bound for general trees? (2) In the version of the CRB game where we play with the slug variant, we would like to consider the possibility that the robber must build a barricade on every turn. This would imply the robber can never return to a previously visited vertex. How would this affect the barricade-cop number? (3) There is much to investigate in regards to the complexity of the algorithm presented in Chapter 4. What is the exact time complexity of computing cB ? Would it be possible to determine if a graph is barricade-cop-win in polynomial time, or is the problem NP-hard? (4) Can we extend the barricade-cop-win characterization in Chapter 4 to the case of k -barricade-cop-win graphs, where k > 1?
62

(5) A question that was not touched in the thesis would be to add randomness to this game. What is the barricade-cop number on the binomial random graph G(n, p)? When playing on deterministic graphs, what happens if the barricades are placed by the robber at random? (6) It would be interesting to play the CRB game on infinite graphs. For which graphs do we require an infinite number of cops? Is it possible for the robber to build enough barricades to reduce gameplay to a finite graph?

63

Bibliography
[1] M. Aigner, M. Fromme, A game of cops and robbers, Discrete Applied Mathematics 8 (1984) 1-11. [2] G.L. Alexanderson, About the cover: euler and konigsberg's bridges: a historical view. American Mathematical Society Bulletin 4 (2006) 567-573. [3] T. Andreae, Note on a pursuit evasion game played on graphs, Discrete Mathematics 9 (1984) 111-115. [4] A. Berarducci, B. Intrigilia, On the cop number of a graph, Advances in Applied Mathematics 14 (1993) 398-403. [5] A. Bonato, WHAT IS ... Cop Number? Notices of the American Mathematical Society 59 (2012) 1100-1101. [6] A. Bonato, E. Chiniforooshan, P. Pralat, Cops and robbers from a distance, Theoretical Computer Science 411 (2010) 3834-3844. [7] A. Bonato, G. McGillivary, Characterizations and algorithms for generalized cops and robber games, accepted to Contributions to Discrete Mathematics. [8] A. Bonato, D. Mitsche, X. Perez Gimenez, P. Pralat, A probabilistic version of the game of zombies and survivors on graphs, accepted to Theoretical Computer Science. [9] A. Bonato, R.J. Nowakowski, The Game of Cops and Robbers on Graphs, American Mathematical Society, 2011. [10] N. Clarke, Cops, Robbers, and Decoys, Preprint 2016. [11] N. Clarke, R.J. Nowakowski, Tandem-win graphs, Discrete Mathematics 299 (2005) 56-64. [12] R. Diestel, Graph Theory, Springer-Verlag, New York (1997). [13] L. Euler, Solutio problematis ad geometriam situs pertinentis, Commentarii Academiae Scientiarum Imperialis Petropolitanae 8 (1741) 128-140. [14] S.L. Fitzpatrick, J. Howell, M.E. Messinger, D.A. Pike, A deterministic version of the game of zombies and survivors on graphs, Preprint 2016. [15] P. Frank, Cops and robbers in graphs with large girth and cayley graphs, Discrete Applied Mathematics, 17 (1987) 301-305.
64

[16] M. Maamoun, H. Menial, On a game of policeman and robber, Discrete Applied Mathematics 17 (1987) 307-309. [17] R.J. Nowakowski, P. Winkler, Vertex-to-vertex pursuit in a graph, Discrete Mathematics 43 (1983) 235-239. [18] D. Offner, K. Ojakian, Variations of cops and robber on the hypercube, Australasian Journal of Combinatorics 59 (2014) 229-250. [19] A. Quilliot, Jeux et pointes fixes sur les graphes, Th` ese de 3` eme cycle, Universit´ e de Paris VI (1978). [20] N.J.A. Sloane, Central binomial coefficients, Online Encyclopedia of Integer Sequences A000984 (1991). [21] N. Sridharan, V.S.A. Subramanian, M.D. Elias, Bounds on the distance two-domination number of a graph, Graphs and Combinatorics 18 (2002) 667-675. [22] D.B. West, Introduction to Graph Theory, Prentice Hall, 1996.

65

