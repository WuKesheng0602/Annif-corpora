DESIGN AND IMPLEMENTATION OF PORTABLE AND CONFIGURABLE RISC PROCESSOR ARCHITECTURE
by
Volodymyr Sergeyev, B.Eng, Odessa Polytechnic University, 1987

A project presented to Ryerson University , in partial fulfillment of the requirement for the degree of Master of Engineering in the Program of Electrical and Computer Engineering

Toronto, Ontario, Canada, 2010
© Volodymyr Sergeyev 2010

PAOPERlYOF RYERSON UNIVERSITY LIBRARY

Author's Declaration
I hereby declare that I am the sole author of this project.

I authorize Ryerson University to lend this project to other institutions or individuals for the purpose of scholarly research.

I further authorize Ryerson University to reproduce this project by photocopying or by other means, in total or in part at the request of other institutions or individuals for the purpose of scholarly research.

Instructions on Borrowers
Ryerson University requires the signatures of all persons using or photocopying this project. Please sign below, and give address and date.
Name Signature

Address

Date

·

I

iii

DESIGN AND IMPLEMENTATION OF PORTABLE AND CONFIGURABLE RISC PROCESSOR ARCHITECTURE Volodymyr Sergeyev Master of Engineering Department of Electrical and Computer Engineering Ryerson University, Toronto, 2010

Abstract
This project presents the configurable microprocessor design based on the MIPS architecture. The level of configurability includes a choice of the pipe lined or unpipelined architecture, number of pipeline stages, data path bit-width, instruction subsetting, program and data memory size. The microprocessor design flow is supported by the set of standard and custom software tools. The wide spectrum of the microprocessor configurations provides an opportunity to optimize hardware for the specific application. The HDL design of the microprocessor is independent of the hardware platform. The portability of the design was verified on the competitive FPGA platforms and ASIC. The selected microprocessor configuration running the test application was successfully implemented and verified on the FPGA development board. The obtained implementation results were compared to the existing comm·erdal and research microprocessors and critical advantages of the presented design were outlined.

v

Acknowledgments
It is a pleasure to thank those who made this project possible. I want to convey my deepest gratitude to my supervisor Dr. Adnan Kabbani whose assistance, encouragement and expertise significantly contributed to this work. Through the duration of project-writing period, he provided inspiration, guidance, and good advice. Work under his supervision gave me an invaluable experience. I would like to thank the many people who have taught me during my graduate studies. I am especially grateful to professors Reza Sedaghat, Fei Yuan, Gul Khan, Vadim Geurkov, and Lev Kirischian. Their devotion, professional attitude, and teaching skills had a remarkable influence on the completion of my studies.
I wish to thank the Department of Electrical and Computer Engineering for providing

research resources and technical facilities required for completion of this project. My special thanks to Jason Naughton whose knowledge and technical expertise helped me efficiently use the department resources. Most of all lowe my thanks to my family for their patience, support, and understanding during my graduate study. Especially, I am grateful to my wife Iryna whose encouragement and endless love helped me finish this work.

vii

Contents
1 INTRODUCTION ............................................................................................................................. 1

1.1 Motivation ..................................................................................................................... 1 1.2 Objectives and Contributions ........................................................................................ 3 1.3 Project Organization ...................................................................................................... 4
1

BACKGROUND ................................................................................................................................ 5

2.1 2.2 2.3 2.4
3

Introduction ................................................................................................................... 5 Basic MIPS Processor Architecture .............................................................................. 5 Closely Related Work .................................................................................................. 11 2.3.1 Architecture Description Languages ............................................................... 11 2.3.2 Configurable Processors .................................................................................. 13 Summary...................................................................................................................... 19 Datapath Components ................................................................................................. 21 3.1.1 ALU ................................................................................................................. 21 3.1.2 Register File ..................................................................................................... 22 3.1.3 Instruction Memory ......................................................................................... 24 3.1.4 Data Memory ................................................................................................... 25 3.1.5 Program Counter ............................................................................................. 26 3.1.6 Sign Extension ................................................................................................. 27 Control Unit Design .............................:...................................................................... 27 Pipelihed Architecture Design ..................................................................................... 28 3.3.1 Five Stages Pipe lined Processor ....................................................................... 29 3.3.2 Four Stages Pipelined Processor ..................................................................... 31 Unpipelined Architecture Design ................................................................................ 33 3.4.1 One-Cycle Processor ....................................................................................... 33 3.4.2 Multi-Cycle Processor ..................................................................................... 35 Configuration Control ................................................................................................. 37 Configurable Features ................................................................................................. 37 3.6.1 Data Path Width Parameterization .................................................................. 38 3.6.2 Instructions Set Parameterization .................................................................... 38 3.6.3 Data Memory Parameterization ....................................................................... 39 3.6.4 Instruction Memory Parameterization ............................................................. 39 3.6.5 I/O Memory Parameterization ......................................................................... 39 3.6.6 FPGA Optimization ......................................................................................... 40

CONFIGURABLE PROCESSOR PROPOSED DESIGN .......................................................... 20

3.1

3.2 3.3
3.4

3.5 3.6

ix

3.7 Input/Output Interface ................................................................................................. 42 3.8 Configuration GUI ....................................................................................................... 43 3.9 Summary...................................................................................................................... 45
4 IMPLEMENTATION ..................................................................................................................... 46

4.1 4.2 4.3

Hardware Components and Development Tools ........................................................ .46 Design and Implementation Flow ............................................................................... 47 FPGA Implementation ................................................................................................. 50 4.3.1 Project Files ..................................................................................................... 50 4.3.2 Architecture ..................................................................................................... 53 4.3.3 BRAM Optimization ....................................................................................... 54 4.3.4 Timing Constraints .......................................................................................... 54 4.3.5 Xilinx Platform Implementation ...................................................................... 55 4.3.6 Altera Platform Implementation ...................................................................... 57 4.4 ASIC Implementation .................................................................................................. 59 4.5 Demo Platform Design and Implementation ............................................................... 61 4.5.1 Hardware Platform Description ....................................................................... 61 4.5.2 Processor Core Configuration ......................................................................... 63 4.5.3 Demo Platform Interface Design ..................................................................... 64 4.5.4 SofuvarelHardware Co-Design ....................................................................... 64 4.5.5 Demo Design Implementation ......................................................................... 65 4.6 Summary ...................................................................................................................... 66
5 DESIGN VERIFICATION ............................................................................................................. 67

Testbench Design ........................................................................................................ 68 5.1.1 Fibonacci Number Test Program ..................................................................... 69 5.1.2 Verilog Testbench ........................................................................................... 70 5.2 Pipe lined Architecture Verification ............................................................................. 72 5.3 Multi-Cycle Design Verification ................................................................................. 75 5.4 One-Cycle Design Verification ................................................................................... 76 5.5 Demo Platform Design Verification ............................................................................ 76 5.6 Summary ...................................................................................................................... 77
6 RESULT ANALYSIS ...............................................................................................;...................... 78

5.1

6.1 Xilinx FPGA Implementation Evaluation ................................................................... 78 6.2 Altera FPGA Implementation Evaluation ................................................................... 80 6.3 ASIC Implementation Evaluation ............................................................................... 83 6.4 Evaluation Against Existing Solutions ........................................................................ 84 6.5 Summary...................................................................................................................... 86
7 CONCLUSION AND FUTURE WORK .......................................................................................87

7.1 Conclusion ................................................................................................................... 87 7.2 Future Work................................................................................................................. 88
A DEMO DESIGN PROGRAM CODE ............................................................................................90 B PROCESSOR CONFIGURA TION FILE ..................................................................................... 95

B.1

Base Configuration File Template................................................................... 95
x

8.2

Automatically Generated Part of Configuration File .................................... 102

C II\-IPLEMENTATION REPORTS ............................................................................................... 104

C.l Xilinx Summary Reports ........................................................................................... 104 C.2 BRAM Utilization Reports ........................................................................................ 111
D TSMC 0.18 11M PROCESS IMPLEMENTATION .................................................................... 112 E F DEMO DESIGN CONSTRAINTS AND REPORT.................................................................... 114 FIBONACCI TEST PROGRAM ................................................................................................. 118

G CONFIGURABLE PROCESSOR VERIFICA TION ................................................................ 120

G.l Verification Reports .................................................................................................. 120 G.2 Simulation Waveforms .............................................................................................. 120
H IMAGES OF DEMO DESIGN EXAMPLE ................................................................................ 125 I ALTERA FPGA II\-1PLEMENTION ........................................................................................... 130

BIBLIOGRAPHY ................................................................................................................................ 133

xi

List of Tables
Table 2.1. MIPS instruction fonnat ............................................................................................ 7 Table 2.2. MIPS instruction set ................................................................................................. 7 Table 2.3: MicroBlaze Processor v7.2 Perfonnance Levels .................................................... 15 Table 2.4. Nios II different version features ............................................................................. 16 Table 3.1: Supported ALU operations...................................................................................... 21 Table 3.2: ALU signals ............................................................................................................. 22 Table 3.3: Data memory signals ............................................................................................... 25 Table 3.4: Set of configuration features available for the processor core ................................ 38 Table 4.1: Implementation and development tools ................................................................. .46 Table 4.2: MIPS_DLX project files description ....................................................................... 51 Table 4.3: MIPS interface signals ............................................................................................ 53 Table 4.4: Clock period timing constraints (ns) ....................................................................... 55 Table 4.5: Maximum clock speed (MHz) ofthe processor configurations implemented in Xilinx FPGA ............................................................................................................................. 56 Table 4.6: Xilinx FPGA resources (LUTs) used for the implementation of the different processor configurations ........................................................................................................... 57 Table 4.7: Implementation results of 512-bit 5-stages pipelined processor configuration ...... 57 Table 4.8: Maximum clock speed (MHz) of the processor implemented in Altera FPGA ...... 58 Table 4.9: Altera FPGA resources (ALMs) used for the implementation of the different processor configurations ........................................................................................................... 59 Table 4.10: Maximum clock speed (MHz) of the processor configurations implemented using 0.18 J-lm technology process ..................................................................................................... 60 Table 4.11: Total cell area (J-lm2) occupied by the processor configurations implemented using 0.18 J-lm technology process ..................................................................................................... 61 Table 4.12: Mapping of the Demo design signals in 110 memory address space ................... 64 Table 5.1: Verification matrix for the processor configurations set ......................................... 68 Table 5.2: Mapping oftestbench in 110 memory address space .............................................. 71 Table 5.3: Data hazards handled by forwarding and stalling in the pipelined architectures .... 74 Table 5.4: FSM action description ........................................................................................... 75 Table 6.1: Configurable MIPS processor variants vs. Altera Nios II1s/e ................................. 85 Table 6.2: Configurable MIPS processor vs. Xilinx Microblaze and Leon3 ........................... 86

xiii

List of Figures

Figure 2.1. Block diagram of the multi-cycled MIPS processor.............................................. 10 Figure 2.2. Block diagram of the pipelined MIPS processor ................................................... 10 Figure 3.1: Processor ALU symbol .......................................................................................... 22 Figure 3.2: Register file symbol ............................................................................................... 23 Figure 3.3: Regfile Read-First block diagram .......................................................................... 23 Figure 3.4: Regfile Write-First block diagram ......................................................................... 23 Figure 3.5: Regfile Write-First mode timing diagram .............................................................. 24 Figure 3.6: Regfile Read-First mode timing diagram .............................................................. 24 Figure 3.7: Instruction memory symbol ................................................................................... 24 Figure 3.8: Data memory symbol ............................................................................................. 25 Figure 3.9: Data memory read/write timing diagram ............................................................... 26 Figure 3.10: Program counter symbol ...................................................................................... 26 Figure 3.11: Program counter timing diagram ......................................................................... 26 Figure 3.12: Sign Extension symbol ........................................................................................ 27 Figure 3.13: Block diagram offive stages pipe lined processor ............................................... 30 Figure 3.14: Block diagram of four stages pipelined processor ............................................... 32 Figure 3.15: One-cycle processor architecture ......................................................................... 34 Figure 3.16: Multi-cycle processor architecture ....................................................................... 36 Figure 3.17: BRAM logic diagram ........................................................................................... 40 Figure 3.18: BRAM optimization for five stages architecture ................................................. 41 Figure 3.19: Block diagram of the input/output interface organization .................................. .42 Figure 3.20: Configuration GUI wizard screenshot ................................................................. 44 Figure 4.1: The configurable MIPS processor design flow ..................................................... .48 Figure 4.2: Format of the pseudo code inserted in the instruction memory module by the proposed custom conversion tool ............................................................................................. 48 Figure 4.3: MIPS_DLX project modules hierarchy................................................................ 51 Figure 4.4: 32-bit MIPS processor module .............................................................................. 53 Figure 4.5: Demo platform block diagram ............................................................................... 62 Figure 4.6: Spartan-3E startup kit FPGA board ....................................................................... 62 Figure 5.1: Block diagram ofthe Fibonacci number testbench ................................................ 71 Figure 5.2: Forwarding WB-7EX and MEM-7 EX in the pipeHned architecture (ModelSim waveform) ................................................................................................................................. 73 Figure 5.3: Stalling and forwarding MEM -7 ID in the pipelined architecture (ModelSim waveform) ................................................................................................................................. 73 Figure 5.4: Waveform ofthe multi-cycle architecture simulation ........................................... 75

xv

Figure 6.1: Evaluation chart of the architecture variants of 32-bit processor implemented in Xilinx FPGA ............................................................................................................................. 79 Figure 6.2: Evaluation chart of the architecture variants of 32-bit processor implemented in Altera FPGA ............................................................................................................................. 81 Figure 6.3: Evaluation chart of the architecture variants of 32-bit processor implemented using 0.18 f.1m technology process ........................................................................................... 84 Figure G.l: Post-route simulation waveforms of the 32-bit configuration of multi-cycle architecture ............................................................................................................................. 121 Figure G.2: Post-route simulation waveforms of the 32-bit configuration of one-cycle architecture ............................................................................................................................. 122 Figure G.3: Post-route simulation waveforms of the 32-bit configuration of four-stage architecture ............................................................................................................................. 123 Figure G.4: Post-route simulation waveforms of the 32-bit configuration of five-stage architecture ............................................................................................................................. 124

xvi

List of Abbreviations
ASIC ASIP ASP FPGA

Application Specific Integrated Circuit Application Specific Instruction set Processor Application Specific Processor Field Programmable Gate Array Floating Point Unit Graphic User Interface Integrated Development Environment Integrated Software Environment Logic Element Look-Up Table Memory 9-Kbit Block Microprocessor without Interlocking Pipe Stages Memory Logic Array Block Memory Management Unit Read After Write Reduced Instruction Set Computer Read Only Memory Translation Look-aside Buffer Unit Under Test Very High Speed Integrated Circuit (VHSIC) Hardware Description Language Write After Read Write After Write

FPU
GUI IDE ISE LE LUT M9K MIPS MLAB MMU

RAW
RISC ROM TLB

UUT
VHDL

WAR
WAW

xvii

Chapter 1
Introduction
1.1 Motivation

The contemporary microprocessor market offers a vast variety of chips for new designs. The right choice of a microprocessor to fit for a specific application is a challenging task nowadays. Utilization of a configurable processor can facilitate this problem. A hardware designer can choose the configuration of a microprocessor which precisely matches design requirements. The advantage of FPGA configurable computing has brought the idea of implementing a general-purpose microprocessor on an FPGA chip [1]. This concept along

with the growing demands for customization of the processor and its peripherals inspires FPGA vendors to include microprocessors in FPGA architecture. Manufacturers offer this feature in a form of hard or soft core. More then 32% of hardware developers use embedded FPGA microprocessors in their designs [2]. Configurable hard microprocessors also follow this trend. Customizable microprocessors form Tensilica, ARC and Improv for ASIC implementation offer a broad range of microprocessor optional features. Designers can choose the instruction set architecture to suit the application requirements. The microprocessor data path and pipeline structure are also customizable in order to meet the design constrains. In the ladder of the microprocessor solutions the configurable microprocessors occupy a niche in the middle between implementation on the dedicated hardware and the software running on general-purpose microprocessors [3]. Most of commercially available solutions for configurable microprocessors are oriented on the particular technology. A designer has to choose the target technology up-front. It may be a choice of FPGA from different manufacturers or technology process. But since the design is implemented and verified on a

chosen target platfonn it becomes very difficult to migrate the design to a different platfonn. The common situation is when a verified, proven design is to be upgraded due to additional new requirements or obsolescence of the target chip. Another challenge is the verification of an ASIC implemented microprocessor on FPGA platfonn. Design seamless transition from FPGA to ASIC is nonnally offered within technologies provided by the same manufacturer (e.g. Altera Stratix to HardCopy [4]). Beside of the problems related to a market-oriented engineering, the configurable processor architecture with a versatile set of configuration features offers the fine grain optimization of hardware resources required the specific application. The combination of the possible processor configurations creates the exploration space which provides the opportunity for the research on decision making in the selection of the specific configuration features. Moreover, the flexibility of the configurable and portable design provides an opportunity to obtain the architecture with features not available in general purpose processor architectures. The motivation of this project is to develop a configurable microprocessor architecture independent of the target technology. This architecture facilitates the optimization of the microprocessor architecture for a specific user application. The choice of the microprocessor architecture is provided by the set of user selectable features. The application set of the proposed microprocessor architecture may include the following: · The applications where operation with non-standard data bitwidth (256+) is required · · The applications with limited number of the allocated hardware resources The algorithm intensive low speed applications where implementation of Finite State Machine (FSM) is very complicated. · The prototyping applications where the portability of the design is critical

The tenns processor and microprocessor are used in this project to identify the same object, since in modem technical literature the tenn microprocessor is frequently contracted to just a processor.

2

1.2

Objectives and Contributions
rusc

The focus of this project is to develop, implement, and verify a portable configurable processor architecture. The following goals are to be achieved in this project:

1) To develop a processor architecture configurabJe for a user specification by selection of required features provided in the design. 2) To implement configurabJe

rusc

processor using Verilog HDL [5] as independent

module suitable for integration as a processor core in the processor-based digital systems. 3) To develop GUI that facilitates the choice of features for the processor configuration. 4) To select and implement a testbench for verification of generated processor configurations. 5) To generate a set of the distinguished processor configurations. 6) To verify the set of generated processor configurations.
7) To verify the portability of the design by implementing the set of processor

configurations on several FPGA and ASIC platforms. 8) To implement one processor configuration in hardware using FPGA development board. 9) To test and verify the demo application on the FPGA development board. The following contributions were made into the development of the Portable and Configurable rusc Processor Architecture project: 1) The development of the specific tool for the conversion of the compiled software code into Verilog HDL. 2) The conduction of the literature review on the configurable processor systems. 3) The development of the specific design flow for the configuration and implementation of the proposed processor architecture 4) The development of the Configuration Manager, the GUI-based tool for the facilitating the right choice of the configuration options of the proposed processor architecture 5) The development and implementation of the Verilog description of portable and configurable processor design based on the MIPS processor architecture.

3

6) The development and implementation of the demonstration example implementing the proposed processor design as a part of the Fibonacci number computation and visualization system. 7) The utilization of the proposed processor configuration framework as an educational platfonn for the processor organization teaching courses.

1.3

Project Organization

The rest section of the project is organized as follows: Chapter 2 provides a background on the processor architecture and reviews related research studies. Chapter 3 describes the design ofthe proposed configurable processor. The chapter shows implementation of configurable features for different processor architectures. The development of support software tools is also covered in this chapter. Chapter 4 describes synthesis and implementation of the processor core on different hardware platfonns i.e. FPGA and ASIC. Various combinations of configurable features and processor architectures implemented on different platfonns create an exploration space. The chapter shows the subset of variants in that space. The included demo design illustrates a practical utilization ofthe processor core. Chapter 5 describes the verification methods used to prove the functionality of the design on behavioral and hardware levels. The development of the testbenches and their properties are discussed and analyzed .. Chapter 6 analyzes results of the processor implementation on different platfonns. Implementation of the processor variants are compared and evaluated. Chapter 7 summarizes the conducted work and accomplishments ofthis project.

4

Chapter 2
Background
2.1 Introduction

In this chapter the relevant background in the processor architecture is presented. The chapter focuses on the description of MIPS RISC processor which is adopted as a base architecture for this project. The following sections review the research development in the area related to the project theme. The state-of-art of research and commercial configurable processors is outlined and analyzed in order to determine a niche taken by the presented project in a domain of available solutions.

2.2

Basic MIPS Processor Architecture

J. L. Hennessy et al. designed MIPS (Microprocessor without Interlocking Pipe Stages) in 1981. It was a result of their research of the processor architecture optimization for pipelining. The MIPS architecture proposed in [6] was used as a teaching example in their classical academic textbook [7] about the processor architecture design. Nowadays MIPS is widely used for the educational purposes [8]. Further development of MIPS architecture brought a row of the revisions of this architecture MIPS-I, MIPS-II, MIPS-III, MIPS-IV, MIPS32, MIPS64 [9]. The major market of the latest MIPS processor is embedded applications. They are implemented in numerous Cisco and Linksys routers, ADSL modems, Sony PlayStation 2, Sony Playstation Portable and many handheld computers[lO] [11]. The choice of the MIPS processor architecture as a template for the configurable processor design in this project is justified by following reasons. The MIPS pipeline structure and organization is very well studied and described [12][13]. The MIPS microprocessor becomes very popular for academic purposes. Many researchers implemented [14][15] and enhanced it [16][17]. Therefore, the modification of the existing simple MIPS to a

5

configurable architecture is easier than modification of a sparely specified commercial processor. As any processor with unique instruction set, MIPS requires a custom software compiler. In order to complete the set of development tools for the MIPS, several opensource compilers and simulators have been developed [18][19]. Utilization to the open source software tools facilitates the development of the configurable processor. The classic pipelined or unpipelined MIPS is a 32-bit RISe processor. The instruction set has 32-bit width for all instructions. Load/store MIPS Instruction Set Architecture (lSA) contains register file, which consists from 32 registers 32 bits long each. Two of them are assigned as special purposes registers. Register 0 is read-only and carries 0 values. It is used as a zero operand eliminating necessity to keep zero value in memory. Register 31 is used by special jump instructions to store return address. These instructions are used for calls and returns from subroutines. MIPS program counter has a width of 32 bit similar to the data path. The potential MIPS address space is up to 2 GB. MIPS instructions are divided into three types R-type, I-type and J-type. The instruction format is shown in Table 2.1. R-type defines instructions operating with registers only. The instruction contains addresses of two operand registers Rs and Rt, address of the destination register Rd for result storing and the code of the executed operation. The I-type instruction also contains Rs and Rd but instead of the second source register it carries the 16-bit constant value immediate. This constant is used as an operand in arithmetic operations and as an address offset in load/store operations. J-type instructions represent jumps which change the program counter with 26-bit address enclosed in the instruction. The instruction opcode has 6-bits width with possible opportunity of 64 basic operations. This instruction spare space allows adding of extended instructions such as FPU support. The simplified instruction set of MIPS processor is shown in Table 2.2. The basic set includes only two branch, four jump, and two memory instructions. Other instructions are arithmetical. The supported data types are 8-bit bytes, 16-bit half words, and 32-bit words for integer data. Bytes and half words are loaded into 32-bit in two ways: extra bits are filled with sign extension or with zeros. After the load transaction they are processed as 32-bit integer operands.

6

Table 2.1. MIPS instruction format Format

25
1J-

21 20
Rs Rs Rt Rt

Bits 16 15 Rd
address

11

10 6 shamt immediate

o

Table 2.2. MIPS instruction set Instr. Description Format

Opcodel Func (hex)

Operation (Verilog-styJe coding) R rd]=R[rs]+R[rtl R rt]=R[rs]+SignExtImm R[ rt]=R[rs]+SignExtImm R rd}=R[rs]+R[rt] R rdl=R[rs]-R[rt] R[rd]=R[rs]-R[rt] R rd]=R[rs]&R[rt] R rtl=R[rsl&ZeroExtImm R rd]= _(R[rs]IR[rtl) I R[rdl=R[rslIR[rtl R rtl=R[rslIZeroExtImm R rd]=R[rsfR[rt] R rtl=R[rsrZeroExtImm R[rd]=R[rt]«shamt R[rd]=R[rt]»shamt R[rd]=R[rt]»>shamt R[rd]=R[rt]«R[rs] >R[rs] R[rt]»>R[rs] Rrrsl<Rrrtl)?1:0 R[rs ]<SignExtImm)?1:0 R[rt]=(R[rs]<SignExtlmm)?1:0 R[rd]=(R[rs]<R[rt])?1 :0 ifiRrrsl=Rrrtl) PC=PC+4+BranchAddr

add addi addiu addu sub subu and andi nor or ori xor xori sIl sri sra sllv srlv srav sit slti sltiu situ beq

Add Add Immediate Add Imm. Unsigned Add Unsigned Subtract Subtract Unsigned And And Immediate Nor Or Or Immediate Xor Xor Immediate Shift Left Logical Shift Right Logical Shift Right Arithmetic Shift Left Logical Var. Shift Right Logical Var. Shift Right Arithmetic Var. Set Less Than Set Les ..,.,.Imm. Set Less Than Imm. Unsign. Set Less Than Unsigned Branch On

R I I R R R R I R R I R I R R R R R R R I
I

0/20 8
9

0/21 0/22 0/23 0/24

c

tn6
e

0/00 0/02 0/03 0/04 0/06
0/07

0/2a
a b

R
I

0/2b
4

7

Equal if(R[rs]!=R[rtD PC=PC+4+BranchAddr I Branch On Not 5 Equal PC=JumpAddr Jump 2 J :i i jal R[31]=PC+8; PC=JumpAddr Jump And Link J 3 Jump Register R 0/08 ir ~sl =PC+8; PC=R[rs] jalr Jump And Link R 0/09 Register R[rt]={ imm, 16'bO} lui Load Upper I f Imm. R[rt]=M[R[rs]+SignExtImm] Load Word I 23 lw sw Store Word I 2b MrRrrsl+SignExtlmml=Rrrtl SignExtImm = {16 {immediate[15]} ,immediate} - extension of the immediate operand with bne the sign bit; ZeroExtImm ={16{lb'0},immediate } - extension of the immediate operand with "0" bit; BranchAddr = {14 {immediate[ I5]} ,immediate, 2 'bO } - extension of the immediate operand with the sign bit and multiplication by 4; JumpAddr = {PC[31:28], address, 2'bO } - concatenation of the immediate operand with four MSBs of program counter and mUltiplication by 4; The ISA architecture of MIPS defines the organization of the processor data path. The simplified 5·cyc1e implementation without pipeline is shown in Figure 2.1. The following actions are performed during each cycle:
1. Instructionfetch cycle (IF):
IR f- Mem[PC] NPC f- PC + 4

2. Instruction decode/register fetch cycle (ID):
A f- Regs[IR6 ·· 10]i B f- Regs[IR11 ·· 15]i Imm f- ((IR16) 16##IR16 .. 31

3. Execution/effective address cycle (EX):
ALUOutput or ALUOutput or ALUOutput or ALUOutput Cond f-(A f- A + Imm; f- A func B; f- A op Imm: f- NPC + Imm: op 0)

4. Memory access/branch completion cycle (MEM):
LMD f- Mem[ALUOutput] or

8

Mem[ALUOutput] ~ Bi if (cond) PC ~ ALUOutput

5. Write-back cycle (WB):
Regs[IR16 .. 20] Regs[IRll .. 15] Regs[IRll .. 15]
~

~ ~

ALUOutputi ALUOutputi LMDi

The design of MIPS is refined for pipelining. The multi-cycle version of the MIPS can be smoothly augmented with a pipeline. In a pipe lined architecture all instructions are executed in the same number of cycles. This organization allows one instruction per cycle throughput. The block diagram of the pipelined MIPS processor is shown in Figure 2.2. The standard MIPS processor incorporates 5-stages pipeline. A drawback of pipelining is hazards. The most common type of hazard is the data hazard. The data hazard is a situation when a fetched instruction reads the same operand as one of preceding instructions writes. If the preceding instruction still propagates through the pipeline, the fetched instruction may read a wrong value. This data hazard is called Read-After-Write (RAW). There are two ways to handle data hazard - stalling and forwarding. Stalling means an artificial insertion ofNOP instruction in the pipeline. The processor stalls the pipeline until a hazard is over. This technique results in wasting of processor clock cycles. Whereas, the forwarding does not have that disadvantage. Forwarding uses the pipeline property when the result of the instruction is available in one of pipeline stages but not written yet in a register. An additional hardware supports forwarding of the result to the stage to another stage where it is required. Another type of hazard, the control hazard is caused by branch instructions. The next fetched instruction after a branch may not be executed due to a result of branching. This would cause the pipeline to flash its contents and to stall. As a result the processor's speed slows down which is called the branch penalty. There are many methods to reduce the branch penalty. The simplest is a delay slot. It is efficient when delay penalty is one clock cycle. An execution algorithm of the processor with delay slot presumes that a next instruction after the branch is executed regardless of the branching result, whether the branch is taken or not. The compiler has to reorder the instructions and put in the delay slot an instruction which is to be executed despite a result of the branch instruction.

9

Ins1rucIion decodel register felch

ExeaJlel address calculation

Memory

aa::ess

4

Instruction
memory

Figure 2.1. Block diagram of the multi-cycled MIPS processor.

IDIEX

EXlMEM

MEMIWB

Data memory

Figure 2.2. Block diagram of the pipelined MIPS processor

10

2.3

Closely Related Work

Two major approaches to automatic processor synthesis can be distinguished nowadays. One of them is template-based configurable processors. This methodology is mostly exploited by commercial products. The other one generates Application Specific Instruction set Processor (ASIP) based on Architecture Description Language (ADL) - a specific language developed for a processor architecture description.

2.3.1

Architecture Description Languages

Originally ADL was developed as a high level of abstraction description language for modeling processor's architectures. VHDL and Verilog languages do not completely suit for this purpose due to their orientation toward the hardware implementation. Several ADLs were created in attempt to find the best way for processor architectural exploration and evaluation. One of them is nML which has been developed at TV Berlin [20J. This language is intended for automatic generation of the software tools for an explored processor architecture. In order to obtain a complete processor design, the developer has to create the separate ADL model and HDL description of the processor. It has limited ability to handle invalid instructions and can not describe architectures with parallel instructions [21]. A lack of the hardware generation feature in nML has been recently amended in its enhanced version Sim-nML [22]. A synthesizable Verilog description can be obtained with Structural Sim-HS tool included in Sim-nML. Generation of the processor RTL description from SimnML specification has been successfully tested with specifications of the microcontroller Motorola 68HCll and microprocessor Intel 8085. Performance of the synthesized architecture has not been estimated. Similar to nML, ISDL architecture description language was developed by MIT LCS [23J. ISDL is instruction set specific language, specifically oriented toward Very Long Instruction Word (VLIW) processor architectures. However, multi-cycle and multi-word instructions are not fully supported by ISDL. GENSIM system software automatically generates Instruction Level Simulator (lSL) specific to the developed architecture. The ISL is capable to simulate cycle-accurate and bit-true execution of the program. The achieved speed-up of such simulation compared to the simulation of the VeriIog model is 34x [24]. Lately. HGEN tool

11

has been developed in order to automatically generate Verilog RTL model from ISDL description [25]. The language EXPRESSION [26] is capable to describe correctly multi-cycle and multiword architectures. A characteristic feature of EXPRESSION is the partition of the design flow into two phases. Evaluation and exploration of the chosen architecture is performed in Exploration Phase. This phase is supported by Exploration Simulator and Exploration Compiler automatically generated by the software itself. The compiler and simulator allow rapid comparative estimation and simulation of candidate processor architectures. A chosen solution is finally adjusted in Refinement Phase. The software toolkit generates an optimized Instruction Level Parallelism (ILP) compiler and a cycle-accurate simulator from EXPRESSION description. Using these tools the developer may perform detailed processor evaluation and verification of memory hierarchy (e. g. cache, TLB). The link to RTL synthesis is provided by the HDLGen tool [27][28] which generates the VHDL model from the EXPRESSION description. In order to test results, the automatically synthesized DLX processor [29] has been compared to its hand-written version. Despite 20-40% worse results in terms of speed, power consumption, and area, it is shown that the design time is an order of magnitude less. The paper, however, do not compare the development efforts for the processors with reported degraded performance designed manually and automatically. One of the most prominent and widely used ADL is Language for Instruction-Set Architectures (LISA) [30]. Due to its C-like syntax, LISA is very attractive for architect designers who are beginners in utilization of ADL for ASIP development. The structure of LISA allows a designer to specify details sufficient for automatic generation of the software tools set containing compiler, assembler, linker, and simulator. These tools are used in the stage of exploration of the developed processor architecture. During this phase a designer can tune and verify designed processor by changing the ADL description. Repetition of compilation cycles does not introduce a considerable delay due to complete automation of the development environment [31 ][32]. LISA description contains enough architectural information for generating a synthesizable HDL model. The advantage of architectural exploration using LISA description inspired founders to develop the integrated LISA Processor Design Platform (LPDP) [33]. Efficiency ofthe LPDP has been evaluated on the example of ICORE processor. This ASIP processor is oriented

12

toward FFT realization, sampling-clock synchronization for interpolation and carrier frequency offset calculation. The handwritten version of ICORE has been compared with the automatically generated version. The generated ICORE shows the same clock speed, 1% area overhead, and 15% more power consumption. Design efforts for LPDP ICORE are approximately one month and a week vs. three months for the original handwritten version. LPDP has apparent advantage of a fully developed and integrated system for ASIP design. The convenient user interface and support of different operational systems [34] distinguishes it from general research projects, where the integrated environment accelerates the exploration of various processor architectures. Performance of the LPDP generated processors can compete with commercial handwritten versions. However, the necessity of manual development of a processor data path diminishes the advantages of this system. The advantages of utilizing LISA ADL have been recognized by many researchers. LISA has been used as a base ADL for numerous research projects focused on ASIP development [35J[36][37]. High level of LISA development has stimulated its implementation in a commercial processor generation system. LISA 2.0 is used by CoWare company in CoWare Processor Designer [38]. This platform is dedicated for design and optimization of ASIP. LISA 2.0 architectural description was used to generate a full set of processor software tools and the RTL description in Verilog, VHDL, and SystemC. This commercial processor development system lately has been used in several ASIP research projects [39][40] for rapid processor architecture exploration.

2.3.2

ConfigurabJe Processors
The concept of flexible microprocessor architecture is exploited by many authors. Two

major approaches can be distinguished: configurable and reconfigurable processors [41][42]. The term configurable presumes customization before manufacturing. Whereas, the reconfigurable processor implies configurability after manufacturing. Runtime dynamic

changing of the configuration is a powerful feature of the reconfigurable architecture. This approach offers reuse of the same silicon design by mUltiple applications without additional manufacturing cost. Examples of the reconfigurable microprocessors are shown in [43][44]. These designs represent multiple computing units connected by a sophisticated reconfigurable network. Narrow reconfiguration ability is implemented in the computing units as well. Due

13

to implementation of the described processors using technology process, their flexibility is limited. Configurable processors became very popular last decade. They can be divided into soft and hard-processors. Hard processors are intended for Application-Specific Integrated Circuit (ASIC) implementation. Xtensa LX3 offered by Tensilica [45] is an example of commercial configurable processors. This is 32-bit RISC ISA processor that allows the designer to perform the configuration by choosing predefined options from the menus. The following main groups of features can be added and tuned for Xtensa LX3: · Execution Unit and ISA Options (multipliers, DSP engines, FPU, custom instructions, etc.) · · Interface Options (DMA, FIFO, GPIOs, interrupts, debug port, etc.) Memory Subsystem Options (caches, memory management unit (MMU), parity, cache organization, etc.) The chosen configuration of the processor is automatically processed by Xtensa Processor Generator software. The complete solution is represented by the RTL description and EDA scripts. The example of the configurability of Xtensa processor is demonstrated in implementation of the multi- standard video decoder [46]. Two different processor configurations are used to create the stream processor and pixel processor. Each processor is enhanced with specific video instructions. The optimized ISA architecture of the processors allows video decoding in the software only. A similar set of configurable features is proposed by the ARC for the ARC 600 Core and ARC 700 Core processor families [47][48]. ARChitect Processor Configurator [49] extends the processor design with Single Instruction MUltiple Data (SIMD) instructions, integrated coprocessor instructions, compound instructions and many others. preconfigured options can be selected by the developer. The explicit benefit of these processor systems is that their template-base synthesis does not require an extensive knowledge ofthe processor architecture. A developer can obtain fully functional ASIP from a specification with very high level of abstraction. Rapid automatic synthesis allows fast evaluation of several solutions and optimization of the final ASIP. Flexibility of the template-based processor architecture is limited by the set of the predefined options which is not always suitable for research projects. More than 20,000

14

Along with commercial configurable products numerous research projects show interesting results in this field. Advantages of the implementation of Dolby Digital (AC-3) decoder with the hard configurable processor are shown in [50]. The paper convincingly proves that utilization of the configurable processor tuned for the specific audio application increases performance of the processor and reduces the required size of the die. Very fast growth of the FPGA performance and density accompanied with sophisticated development tools has made FPGA devices very attractive for the implementation of a processor architecture. Reprogrammable nature of FPGA determines the definition of the processor implemented in FPGA as a soft processor. Therefore, it is not a surprise that the most well-known configurable soft processors are offered by major FPGA vendors Xilinx and Altera. Xilinx promotes 32-bit RISC soft-processor Microblaze [51] with configurable

peripherals. It has limited configurable abilities for the core structure. This soft processor is proposed as alternative to the hard-processor core PowerPC 440 [52] implemented in the Xilinx Vertex-5 FXT FPGA family. Table 2.3 shows the performance of the MicroBlaze processor for different FPGA families.
Table 2.3: MicroBlaze Processor v7.2 Performance Levels

Architecture

Performance

Maximum Frequency

Clock Maximum Dhrystone 2.1 Performance 280 DMIPS

5-Stage Pipeline 3-Stage Pipeline

1.19 DMIPs/MHz

235 MHz in Virtex®-5 FXT

0.95 DMIPslMHz

106 MHz in Spartan®-3A 100 DMIPS DSP

Along with high-end Microblaze processor Xilinx developed Picoblaze 8-bit Picoblaze soft processor [53] with no options for the configurability. Source code is open for evaluation and modification. The HDL model is offered on very low gate level description. Picoblaze can be implemented only on Xilinx FPGA platform. It became very popular due to its simplicity, free distribution, and availability of software tools. Popularity of Picoblaze inspired Bleyer [54] to develop Pacoblaze - a behavioral version of Picoblaze. This model incorporates maximum level of parameterization. The high level definition file represents a wizard for implementation of the possible versions of Pacoblaze. Low level definitions files comprise a hierarchical ladder, which an experienced user can employ for configuration of a

15

custom version of the Pacoblaze architecture. Using Verilog optional compilation the author has created the specific configuration configurations. Xilinx major competitor Altera offers Nios II - second generation of
Altera~s language~

which supports a variety of custom

soft

processors [55]. It is 32-bit RISC general purpose processor with 32-bit width instruction set similar to MIPS. Altera offers Nios II in three different configurations: economy (e), standard (s) and fast (t). Table 2.4 outlines specific features of each configuration. All versions allow adding up to 256 custom instructions. The choice of the required configuration is supported by SOPC Builder software. The resulting configuration is generated in a form of FPGA programming file.
Table 2.4. Nios II different version features.

Processor Version
I

Nios IIIe

Nios IIIs 0.75 120 135 1300 5 static 3-cycle

Nios/f 1.17 200 135 1800 6 dynamic I-cycle optional I-cycle

DMIPSlMHz 0.16 28 150 600 unpiped Prediction Multiplier

Performance MaxDMIPS Clock (MHz) Area Pipeline Branch LEs

ALU

Divider Shifter

serial

3-cycle

The idea of modification of the commercially successful soft processors lies in the basis of UT Nios soft processor [56]. It is an attempt to use a different approach of configurability of the Altera Nios II. In contrast to original Nios II, UT Nios has optional 16/32-bit data path width and reduced 16-bit instruction word width. Instruction set supports five custom instructions. The register file has a configurable size with 32 visible registers window. There is an option ofinteger multiplication. Benchmark evaluation shows insignificant 1% average and 56% for particular applications speed-up. UT Nios requires 31 % more FPGA resources than Altera Nois II. Another attempt to use Altera Nios II architecture for the research project is UTMT II [57]. The design exploits the multithread processor architecture using different UTMT II

16

configurations with multiprocessor core structure. Despite the poorer performance then Altera Nios II, an advantage of the 45% area saving has been reported. Four stages pipeline is used in UWindsor Nios II (UWN2) [58], another Altera Nios II compatible soft processor. The parameterization of the UWN2 is limited to 10 options. The best achieved area saving is 47%, while the clock speed is 7% worse than Nios II. The success of commercial soft processors does not discourage numerous researchers to develop other configurable soft processor architectures. The example of a very well developed and tested configurable processor is LEON3 [59]. This 32-bit processor core is designed as synthesizable VHDL model compatible with SPRC V8 architecture. The open source design offers many configurable options for the optimization. The portability of the design is verified for Altera and Xilinx FPGA platforms on multiple development boards. The LEON3 is also suitable for ASIC implementation. The best achievable clock speed is 140 MHz for FPGA platform and 650 MHz for ASIC. The hardware design is supported by a set of software development tools including simulator, compiler, linker, NewIib embedded C-library, Eclipse based IDE, etc. The general purpose traditional processor architecture is focused on the execution of different applications of the same hardware. While most of embedded processors run only one specific application. The Application Specific Instruction-set Processor (ASIP) incorporates an idea of optimization of the processor architecture according to a running task. This approach significantly improves performance and speed of the processor. Due to a high cost of implementation of ASIP in ASIC devices, the usage of FPGA for ASIP becomes very attractive. The design of video-processor [60] demonstrates the implementation of ASIP in FPGA. The targeted Altera Nios Wf processor core is augmented with the custom hardware for block manipulation. The efficient data reuse achieves three order of magnitude acceleration compared to software implementation. Instruction Set Extensions (ISE) is another approach to optimization of ASIP architecture. The design of the E·ASIP (ETRI-Application Specific Instruction Processor) for the CAVLC of H.264/AVC decoder [61] uses this technique. In order to improve the processor performance for the specific function, the instruction set is extended with additional special purpose instructions. The number of basic instructions is reduced down to the minimum set required for the functionality.

17

Exploration of the different aspects of processor configurability is performed in the SIxD application-specific soft processor [62]. The processor incorporates several configurable

options, such as length and width of the data space, custom branching and shifting instructions, ability to choose subset of instructions and the choice of SIMD mode. The design has been successfully tested with MPEG-7 Motion Activity Descriptors application. Aside from the traditional RISC ISA architecture stands CUSTARD (CUStomizable Threaded Architecture) - a customizable threaded FPGA soft processor [63]. The available configurable features include data path width, number of threads, threading type, custom instructions, custom memory blocks, forwarding, and register file parameterization. The design is supported by the custom C-compiler developed by the authors. Reported evaluation results show a significant 2.41 x average speed-up of the single-treaded CUSTARD with custom instructions compared to Xilinx Microblaze. The disadvantage of the considered processor is a twice larger area overhead. The versatility of configurable processors shows the necessity of the performance evaluation for different configurations. Such estimation has been fulfilled using Softprocessor Rapid Exploration Environment (SPREE) [64]. This system is able to generate RTL description of the soft processor from the high level architecture description. The SPREE base configurable core is similar to MIPS and Altera Nios II processors. The textual description of the processor data path and ISA are used as an input for SPREE. Multiple generated processors were benchmarked and compared with all three versions of Atera Nios II e/s/f. The best variants show the same or better performance than Nios II. For example, 80- MHz threestage pipelined processor generated by SPREE is 9% smaller and 11 % faster than Nios IUs. The study examines the influence of different processor architectural features on the performance. The impact of the following options is investigated: shifter implementation, multiplication support, pipeline depth, pipeline organization, forwarding, application-specific architecture customization, and ISA subsetting. The optimized processors achieve improvement of the performance per area 24.5% on average. Saving of the power and area is obtained 25% on average.

18

2.4

Summary

In this chapter, the main concept of RIse processor architecture is presented. The MIPS processor specification and architecture are described. The related configurable solutions in the form of soft and hard processors are studied and analyzed. The complementary software tools are outlined and examined for the reviewed processors.

19

Chapter 3
Configurable Processor Proposed Design
This chapter describes the structural components of a configurable processor design and high level design of the processor data path. It also illustrates the design of the processor's control unit. The data path design of the configurable MIPS processor is organized in the following sequence: · · · · 5-stages pipelined architecture 4-stage pipe lined architecture Multi-cycle unpipelined architecture One-cycle unpiplined architecture

The methodology of the design of configurable processor architecture in this project differs from the classical approach described in [12]. The classical approach does not presume the configurability of the described processor architecture. The evolution from the simplified form to the more complex is chosen for the educational purpose in order to facilitate understanding. Instead of this approach, here the most complicated design is taken as an initial and gradually modified to reach the simplest. The most complicated design contains the majority of the components present in other architectures, therefore it is logical to use this design for the transformation into other architectures. The 5-stage architecture is the most advanced and complicated design with maximum hardware overhead. All other architectures are derivatives from the initial 5-stage pipelined architecture. The configuration options control transformation of the initial design toward other three architectures. The major structural components are shared in all data path architectures. Components pertained only to a specific architecture included as options controlled by the configuration engine. Since the control unit design highly depends on the data path realization, the control unit design has limited configurability. The control unit is unique for each of the four types of

20

architectures. The choice of the appropriate control unit is also supported by the configuration engine.

3.1
3.1.1

Datapath Components
ALU

In order to support MIPS instruction set, ALU is designed to have the capability of performing operations with two input operands A, B. Table 3.1 shows the correspondence between ALU operations and supported MIPS instructions.
Table 3.1: Supported ALU operations

ALU Operation
Addition (result = A+B) Subtraction (result = A-B) Logical conjunction (result = A and B) Logical disjunction (result = A or B) Logical disjunction with negation (result = A nor B) Logical exclusive or (result = A xor B) Pass operand (result A)

MIPS Instructions
add, addu, addi, addiu ,lw, sw sub, subu and, andi or, od nor xor, xori jr lui sri, srlv sIl, sllv sra, srav beq, bne sIt, slti, situ, sltui

Load immediate to upper word (result = B« 16) Logical right shift Logical left shift Arithmetic right shift Compare result to 0 Set less than
J

Shift for 16-bits applies only for classic MIPS instruction set. In general, this parameter is

configurable in the design.

The symbol for ALU is shown in Figure 3.1. The list of the ALU signals and their description are shown in Table 3.2.

21

opcode

OPERAND A

ALU
OPERAND B

RESULT
Carry out Zero

Figure 3.1: Processor ALU symbol T a bI e 32 ALU siena . s

.

Signals
OPERAND A

Dir Bitwidtll
In Data path

Description
First arithmetic/logic operand. Second arithmetic/logic operand Result of arithmetic/logic opration Code of the executed operation

OPERAN~ Data path
RESULT opcode In 3 or bits. Depend on the instruction set ConfigurabJe; 5 bits by In Out Out default 1 bit 1 bit

~

shamt
I

Shift amount. The number of bits to shift the operand B Carry out of the arithmetic operations Produces "1" when result is equal 0

Carry_out Zero

The ALU module has a configurable bit-width and subset of operations. Support for shift commands and "Set Less Than" commands is optional and may be excluded from the design to reduce hardware overhead. The ALU is an asynchronous device and consists of the combinational logic only.

3.1.2

Register File

The register file design consists of 32 registers with configurable bit-width. The register with address 0 does not have memory elements. It comprises hardwired O's. The register file symbol is shown in Figure 3.2.

22

REGISTERS
Address rs Address rt Read rs

----D

elk
wren Write address Write data

-

Read

rt

Figure 3.2: Register file symbol

The register file module works simultaneously in write and read modes. It asynchronously produces data on two output ports from two registers which addresses are set on the corresponding address inputs. It also synchronously writes data from the Write data input port to the register which address is set on the Write address input. Writing is controlled by wr en signal. In order to support configurability, two writing modes are implemented: Read-First Mode and Write-First Mode. The Figure 3.3 and Figure 3.4 show the difference between these two modes. The writing mode defines the order of access in case of simultaneous read-write access to the same register. In Read-First Mode the data set on the write port immediately appears on the corresponding read output port and is written to the register later. In WriteFirst Mode data is written to the register on the first clock edge and only after that the data is set on the read output port. The writing mode is a configurable feature of the register file module. The timing diagrams demonstrating the difference of Read-First and Write-First modes are shown in Figure 3.5 and Figure 3.6.
Read-First
Register File

Write-First
Register File

Wrne Data

Read Data

Write Data

Read Data

'F
I
Register

I

Figure 3.3: Regfile Read-First block diagram

Figure 3.4: Regfile Write-First block diagram

23

elk
wren
Address r61rt

ResQ r61rt
Write Address

~------~----~~~~~~D~R~~~~--'J---7------~
~

Write Dala

______~____~~X~wo~~~~~____~______~

Figure 3.5: RegfiJe Write-First mode timing diagram
elk
wren
Address r61rt

Read r61rt
Write Address

~------~------~~~~A+~DR~3~f------~----~
~______~______~~X~W~~~J~~~____~______~

Write Data

Figure 3.6: RegfiJe Read-First mode timing diagram

3.1.3

Instruction Memory

The instruction memory module is designed as an asynchronous static memory. The size and bit-width are configurable features of this module. The instruction memory has read-only access. The symbol of the instruction memory is shown in Figure 3.7. The design of the module provides the opportunity to use it as the built-in instruction memory in the microcontroller type of applications. The module also can be used as a prototype of the Ll cache design in the advanced processor applications.
INSTRUCTION MEMORY

Address Read data

Figure 3.7: Instruction memory symbol

24

3.1.4

Data Memory

The data memory module has an asynchronous read access and synchronous write access. The writing access is enabled by Mem Write signal. The symbol of the data memory is shown in Figure 3.8. Due to MIPS load-store architecture, simultaneous read-write access to the same memory address in not possible. Table 3.3 shows the input/output signals of the data memory module. The timing diagram describing the read/write data memory access is shown in Figure 3.9. The size and bit-width are configurable features of this module. Similar to the instruction memory, the data memory module can used in microcontroller style applications and as a prototype of the L 1 cache design.
DATA MEMORY

Address MemWrite Read data

Write data

Figure 3.8: Data memory symbol
T a bl e 33 Data memory SI!na s

..

Signals
clk Address Write data MemWrite Read data

Dir Bitwidtll
In In In In Out 1bit Data path Data path Ibit Data path

Description
Processor clock Memory address Data to be written in the memory "}" enables writing to the memory Data read from the memory

25

elk

MemWrite Address

Read data

a
~--_+- _ _-+---..Ir--__ - - - + - - ~~____-+______~-JX~W_D_A_TA~~______-+______
4-!

Write Data

Figure 3.9: Data memory read/write timing diagram

3.1.5

Program Counter

The program counter shown in Figure 3.10 is a register with a write enable (wr en) input.
It holds the current instruction address. The bit-width of the program counter is configurable

and depends on the size of the instruction memory. The program counter module does not have a built-in counting capability. An external adder is required for implementing the counting function. The functionality of the program counter is illustrated by the timing diagram shown in Figure 3.11.

IN

PC

OUT

wren elk
Figure 3.10: Program counter symbol
elk

wren

IN

OUT

0

--:.------..;..;

Figure 3.11: Program counter timing diagram

26

3.1.6

Sign Extension

In order to support I·type of commands, MIPS architecture requires extension of the 16· bit immediate operand to the bit-width of the processor datapath. In most cases it means filling the extra bits with the sign bit of the immediate operand. For commands andl, ori, xori it requires filling the extra bits with as. The sign extension module has a configurable bit-width depending on the processor datapath bit-width. The extension mode is controlled by the input port signJxt. The module is asynchronous and contains only the combinational logic.

OUT

Figure 3.12: Sign Extension symbol

3.2

Control Unit Design

The control unit module contains all logic required for producing control signals for configurable architectures. The control unit design is different for all four architectures. Due to the significant variations of the processor architectures, a unified configurable design of the control unit is not feasible. Each control module comprises a unique design specific to the chosen processor architecture. The control unit is connected to the data path trough the unified interface. It consists of the same set of input and output signals. This set contains a maximum possible number of the control signals pertained to the most complicated processor configuration. Therefore instantiation of the specific control module in the chosen processor design is a call ofthe corresponding name of the module. Due to redundancy in the connection interface, not all interface signals are used in the control unit design. They are just not connected to internal parts of the control unit. This does not introduce a problem since they are ignored by the synthesis tool.

27

All control units support the same set of instructions. The way they are decoded and handled differs in control units for different architectures. The distinguishable feature of the control module for the pipelined architectures is an internal pipe lining of control signals. This internal pipe lining corresponds to the pipe lining of the data path. Detection and handling of all type of hazards native for a pipelined architecture occur in the control unit.

3.3

Pipelined Architecture Design

The design of the pipelined architecture fonows the concept described in [12]. It exploits the Instruction Level Parallelism (ILP) when an stages of the processor execute different instructions simultaneously. Configuration options for pipelined processor architecture in this project consider 1\vo architectures: five stages and four stages. The maximum number of stages can be identified as follows: · Instruction Fetch (IF) Instruction Decode(ID) Execute (EX) Memory Access (MEM) Write Back (WB)

·
·

· ·

The designed architecture implements the following features of the pipe lined MIPS processor organization: · · · · Branch delay slot Data hazards handling Control hazards handling Forwarding

In the pipe lined architecture one instruction is issued every clock cycle. Therefore in the ideal situation, the throughput of the processor is equal to the clock speed. However, hazards cause the throughput to be reduced. The implementation of the branch delay slot reduces the penalty for control hazards but requires explicit support in the compiler. The data hazards are handled by forwarding and pipeline stalling. Read After Write (RAW) is the only type of data

28

hazard possible in the proposed pipelined architecture. The Write After Read (WAR) and Write After Write (WA W) hazards are not possible in the designed processor.

3.3.1

Five Stages Pipelined Processor

The block diagram of the processor with five pipeline stages is shown in Figure 3.13. The IF stage contains program counter, instruction memory, instruction address adder and multiplexer which selects the source of the next instruction address. An issued instruction is decoded in ID stage and analyzed in the control unit. Selection of the address source of the next instruction is controlled by signals from the control unit. In case of a sequenced order of execution, the address is increased by a number of bytes in the instruction word. Though this number is a configurable option, on practice 4 bytes organization is chosen. It allows a standard instruction set and compiler to be used. In case of a taken branch or jump instruction, the next instruction address is calculated in ID stage. Since jr instruction uses a register for the jump address, it may introduce a data hazard. The forwarding from EX, MEM, and WB stages is used to reduce or avoid a stalling penalty for data hazards. The ID stage includes Register File, adder for the taken branch address calculation, sign extension module, and comparator for the branch decision. Implementation of a separate comparator rather than using the ALU on EX stage reduces the branch hazard penalty down to one cycle. That penalty is covered by the branch delay slot technique. A drawback of this approach is a hardware overhead required for the extra comparator and forwarding mUltiplexers. ID stage multiplexers support forwarding fr?m EX, MEM, and WB stages. The jump address is obtained by combining lower bits from instruction and PC higher bits. Instruction decoding is implemented by routing data and addresses contained in the instruction code to the corresponding recipients. The op-code and function code are decoded in the control unit. The EX stage comprises ALU and multiplexers. Multiplexers are used to support the instruction set. They select ALU input data according to a processed instruction. They also support forwarding from MEM and WB stages. One of the mUltiplexers is dedicated for selection of the register address to be written in case of a register command.

29

IF
PC"

,""p_" Bn

I I~ M: I ?.;! : "
~
~I
I

I

ID
jr_arc Irw

EX
I I I I I I

MEM
I 'I I I

WB

fl,

~
INSTRUCTION MEMORY ._

S
Addrtlss
Read

u;I-----.-+--+I
rs
WB_data_ore

data

addUt

addr rd

I
NaxtPCsrc

J

WB data are

- -

UNIVERSAL CONTROL UNIT

Figure 3.13: Block diagram of five stages pipelined processor

30

The MEM stage consists of data memory and forwarding multiplexer. If the propagated trough this stage instruction is not load or store, the MEM stage just pass all data through without any changes. The WB stage graphically is represented only with multiplexer. This multiplexer selects pipelined data to write back either from the data memory or ALU. The choice depends on the processed instruction. Implicitly WB stage includes the writing portion of the register fiJe. The writing to the register fiJe occurs on this stage. The control unit is shared between all stages. It gets data and generates control signals for all data path components in order to support proper functionality of the processor.

3.3.2

Four Stages Pipelined Processor

The classic five-stage pipe lined processor has a disadvantage of having separated MEM stage. This stage is active only in case of load/store command and for other commands, data just pass though the pipeline. The design of the four-stage processor addresses that underexploitation of hardware resources. This architecture combines EX and MEM stages in one EX stage. The block diagram of the described architecture is shown in Figure 3.14. In the conventional five-stage processor the address for load/store operations executed in the MEM stage is calculated in the ALU located in the EXE stage. Executing these two operations in the same stage in series would drastically reduce the throughput. In order to avoid this reduction, an additional adder is placed in the ID stage. This adder calculates the address of the memory access. Elimination of one stage excludes some scenarios of data and control hazards. The control unit has to handle lower number of forwarding and stalls. Therefore. the four-stage architecture has following advantages: · · · · Improved latency Reduced probability of data and control hazards Reduced complexity of the control unit Reduced hardware for the pipelining and forwarding

The trade-offs for implementing four-stage architecture are: · · Additional adder Possible slower clock speed 31

IF
Jump rs

jr_src_frw

10
I
data rs

EX
I I I I

WB

~:

I I I I I I I I I
Branch
Jumo

MemWrite

immediate

~~b
I
e'
~,

~

ExlwB

DATA MEMORY

rt

f-----------+l-I Address

~:~Hlf~----1_~I:~

1

~

t::

Ii
NextPCsrc

cl

16
u

<II

VVB_data_src

~
~ddLr1

addr_rt

addr rt

addr rd

addrW~f

.1\

~
NextPCsrc

31-+\1'

WB_addCsrc

I
A_src B_SfC vve_addr_src

t

Mfen ,-sri-trw cmp_rstsrc_fwd CITIP_f1..ffC_fwd
UNIVERSAL CONTROL UNIT

~

t

t

11

I MemWrile

I

VVB_data_src

i
I

Figure 3.14: Block diagram offour stages pipelined processor

32

The comparator and address adder in this architecture work in parallel. In general, an adder structure is more complex than comparator's. Therefore, the additional adder may cause a longer delay in the ID stage. The delay highly depends on an implementation platform. In case of FPGA, implementation may not necessarily lead to a longer delay in the ID stage. See Chapter 4 for implementation details.
It is clear that the four-stage architecture can be derived from the five-stage one. The

choice of a specific pipeline configuration is achieved by selecting particular compilation keys. The HDL descriptions of five-stage and four stage architectures are contained in the same module. The compilation keys control only the difference in the designs causing partial compilation of the code pertained to a specific architecture. The design of the control for four stages architecture is similar to five stages. Nevertheless due to structural differences, it is realized as a separate module. The choice of a control unit for the particular architecture is also controlled by compilation keys.

3.4

Unpipelined Architecture Design

The basic principle of the unpipelined MIPS architecture is described in [12]. Though inferior to a pipe lined architecture as per clock speed, the unpipelined architecture offers benefits of simplicity and lower hardware overhead. For the design with limited hardware resources the unpipelined architecture may be preferable.

3.4.1

One-Cycle Processor

The one-cycle processor architecture is the least efficient from speed point of view. But it requires least amount of hardware resources. The execution of any instruction takes only one clock cycle. Therefore, the execution of the longest instruction defines clock speed of the processor. For the architecture shown in Figure 3.15 the longest is a load type instruction. To transform the base five stages pipelined design to a one-cycle design, the following is performed: · · · All pipeline registers are replaced with dummy pass modules All forwarding hardware is disabled A specific for one-cycle architecture control unit is implemented

33

jumpJlI

Branch
JumD PC+4

~}EJl1
M

data rs
.2 ~ Address
~

Rood; ,.

..

~IXJ~. V

U X

PC

Read·date
WrIte

_r

ALU 4 . B sre

k
....--i-----IIO_-H...

MemWtite

!
DATA MEMORY Address WS_data_sre

IJ

Read I----i_--I>I
data

I

write . data

L::::==~....J

I "'"
addr:d
NextPCsrc

:

I "" ~ I1
lad::

Z~

~
MemWrlle

I

WS_sddr_8rc

I~

t

wrf

A_sre

t
UNIVERSAL CONTROL UNIT

B-ire ws_arr_src

t

WS_dats_sre

t
I

Figure 3.15: One-t:ycle processor architecture

34

In the architecture shown in Figure 3.15, only register file, program counter, and data
memory are synchronous. The rest of the processor is asynchronous. The control unit in this architecture the control unit's design is very simple. This is because the handling of hazards, stalls, and forwarding is removed. Basically, only instruction decoding is left in the control unit module.

3.4.2

Multi-Cycle Processor

The multi-cycle architecture is a mid-way between the pipe lined and one cycle designs. It has more hardware overhead than one-cycle architecture, but benefits from the shorter average execution time of instruction. Similar to the pipe lined architecture, it is divided into five sections where the execution of each section occurs in one clock cycle. The execution time of each instruction depends on the type of the instruction. It varies from three clock cycles for branch type instructions to five cycles for load type. Each stage is separated by a register that holds the data produced by each stage. Since each instruction is issued after completion of a previous instruction, no forwarding components are required. They are disabled by appropriate compilation keys. Also some supplement pipelining provisions are removed. Removal of the next instruction address adder also contributes to a hardware reduction. ALU is used for the calculation of the next instruction address and for instruction operation because they occur in different processor cycles. In the same way, ALU is used to calculate the branch address, sparing another adder. The block diagram of the multi-cycle architecture is shown in Figure 3.16. The control unit significantly differs from all other architectures. Since the execution of an instruction requires several clock cycles, the design of the control unit utilizes Finite State Machine (FSM).

35

jump. rs
Branch Jumo PC+4

PC+"

PC+4

NSTRUCll0N

11'/10

MEMORY

~ 11 II
addr

ump

MemWrite REGISTERS dala rs

IDIEX

:I~~;~
~

R:d

-

1
DATA MEMORY
~-'----r""""", Address ME~B

WB_dala_src

Add,s"

~:~: I--

Read dalA_rt
rt data_

pC_WT_en

LlLM

~

add, Write Read rt data immediate addr ,
add'_rt add' rd

Write data

~

L _ _ _- - '

addr rt

~~

31-+W

WB_eddr_src

1::

J
I),

NexlPCsrc pc WT en

t

-r

wrfn

A_SI"C

i
UMVERSAL CONTROL UNIT

B_tSI"C

WB_std,_arc

MemWrite

WB_dela_src

t

i

l

Figure 3.16: Multi-cycle processor architecture

36

3.5

Configuration Control

Selection of a processor architecture is controlled by a set of compilation keys. Configurability of the design exploits Verilog HDL capability of macro definitions and optional compilation. The configuration control is based on the following Verilog compiler directives:

· · ·

'define 'ifdef, 'elsif, 'else, 'endif 'ifndef

The structure of all design modules contains a base part common to all processor architectures and optional parts pertained to the chosen configuration. All configuration control definitions are contained in one file processor_conftgjlat. v. In order to change the processor configuration, it is necessary to enable or disable definitions provided in the configuration file or change a defined number in the macro in case of a numerical configuration option (e.g. bit-width). Modification of the configuration file can be achieved in two ways: manually and by software. The manual modification requires basic skills and knowledge in processor architecture. In order to facilitate a choice of a processor configuration, the specific GUI based wizard is developed. Using the wizard requires only a basic specification of the processor configuration. The style of HDL design defines all possible flexibility in the configuration file. The current state of the design explores a limited subset of the possible options defined in the configuration file. Other options are left for the further development.

3.6

Configurable Features

The configurability of the proposed processor design is not limited to the choice of four architectures. Each processor architecture has a subset of configurable features. The subset of features is common for all architectures. The combination of features and processor architectures creates a significant exploration space of possible processor designs. The design configuration space is shown in Table 3.4.

37

Table 3.4: Set of configuration features available for the processor core

Configurable features
Data path bitwidth Instruction subsetting Data memory size Instruction size 110 address space size 110 bitwidth FPGA optimization

Processor architectures
One-Cycle Multi-Cycle 4-stage Pipeline x set x 5-stage Pipeline x x

Ix
x

x x

x

x x

x x

x x

memory x

x x x

x x x

IX

x x x

Ix
x

3.6.1

Data Path Width Parameterization

The processor data-path bit-width is not limited. In theory, an arbitrary number can be chosen. For sake of practicality, the only bit-widths 16,32,64, 128, and 512 are explored. The original MIPS instruction set is designed for 32-bit processor. Therefore, the full utilization of wider data bus requires extension of the existing instruction set with additional commands. Nevertheless, the MIPS instruction set fully compatible with wide data path processors with full support ofR-type commands and limited support ofl-type commands. For all data path sizes the bit-width of an instruction remains 32-bit. This constrain insures the compatibility of the designed processor with MIPS instruction set and therefore utilization of MIPS software tools (e.g. compiler, linker, simulator).

3.6.2

Instructions Set Parameterization

The configurability of the instruction set is limited to the choice of enabling/disabling two sets of commands: Shift and Set Than Less. Selection of these sets includes a barrel shifter and comparator in the ALU module. In case of an application specific processor design, saving of hardware resources may be achieved when these instructions are not used.

38

Due to the open configurable architecture of the processor, any custom instruction can be added to the design. The support of a custom instruction may require a modification of the control unit and data path design.

3.6.3

Data Memory Parameterization

The following parameters of the data memory can be configured: · · · Memory size (address bit-width) Organization - number of bytes in one memory word Mapping window - limits in the processor address space allocated for the data memory The data bus width of the data memory is defined by the processor bit-width.

3.6.4

Instruction Memory Parameterization

Parameterization of the instruction memory supports the following options: · · Memory size (address bit-width) Organization - number of bytes in one memory word

Mapping is not required for the instruction memory due to a separated access interface for this type of memory.

3.6.5

110 Memory Parameterization

The I/O memory interface features the following configuration options: · Memory size (address bit-width) represents the allocated for input/output address space size · · Data bit-width Mapping window defines Bmits for the processor address space allocated for the input/output Data bit-width is not Bmited but should be equal or less than processor bit-width. A choice violating this rule would cause a waste of hardware resources.

39

3.6.6

FPGA Optimization

To reduce the consumed hardware resource of the target FPGA, BlockRAM (BRAM) can be utilized. In modem FPGAs built-in hardware [65J such as BRAM is made available to the designers to improve the design speed and minimize the consumed FPGA's area. By default, an FPGA compiler implements memory components in BRAM whenever it is possible. In order to facilitate BRAM implementation, the memory HDL behavioral description must contain a dedicated address register [66]. The typical BRAM organization with built-in address register is shown in Figure 3.17.

i\
Address

DI

.
r-

·

Register

;-----

Memory
Array

0

0

1
r-

o

Or-

r - - (common to

Latches

Register

1I

F-

>

both ports)

Jl Strobe Write r
WE

>

r Read Jl Strobe
Control Engine

rEnable Latch Jl

EN
Optionall Inverter

1

I

I..

I
DConfigurable Options

eLK

I

Figure 3.17: BRAM logic diagram

Implementation of the instruction memory with a separate address register requires duplication of the PC register. This register is implied as a part of BRAM by the synthesis tool. Therefore, this apparent increase in the number of structural components in HDL leads to a reduction in hardware overhead in final implementation. Utilization ofBRAM for the data memory requires duplication of the register allocated for the pipe lining of the data memory address. Modification of the five stages pipe lined architecture for BRAM optimization is shown in Figure 3.18. Dotted line shows hardware blocks implemented in BRAM.

40

jr_orc_trw

jl
~
j!!1

~

IDIEX

MEMIWB

WB_dala_ore

Wrile

~~~!
dala

Read

rill

k]

Ya'Q""

1.1
dala

Read dala

cmp_rt_SfC_lwd

immediate addr r'
6dd,-rt

----_ .....

: I I I I I

addr rd

~I
NexlPCore
MemWrite WB_data_src

UNIVERSAL CONTROL UNIT

Figure 3.18: BRAM optimization for five stages architecture

41

3.7

Input/Output Interface

Practical usage of the processor core requires a hardware provision for communication with external devices. The MIPS instruction set does not have specific input/output commands. The general approach in this case is to use a data memory address space for input/output interface mapping. Figure 3.19 shows the hardware implementation of the external memory sharing the address space with an internal memory of the processor core.

z ii:

I/)

{

..
---t;.

1/0 MEMORY
Address B

MemVllrile

Read data B Write dataB

--+

PINS

---+EN

.. ...
---I>

MemEnA Address A Read data A

MernVllrite

Vllrile data A

EN

r-+

Addr Decode

-

il
MemWrile

nEN

l
DATA MEMORY MernEn

.V
Read dala

M U

..

...

Address

Vllrile data

Figure 3.19: Block diagram of the input/output interface organization

I/O memory module shown in Figure 3.19 may encapsulate any input/output structure. It can be a set of input/output registers. multiple or single external memory blocks, or any

42

combination of them. The internal address decoder defines only two types of accesses - to internal data memory or external memory. In order to use the external memory address space" an additional hardware overhead is required, e. g. supplementary address decoder, registers, memory, etc. The example of connection of an external device to the designed processor core is described in the section 4.5.3 "Demo Platform Interface Design" of this project. The lIO memory interface is the only connection of the designed processor core to the external world. In case of a standalone implementation of the processor core, lIO memory interface is routed to pins of a chip of the chosen platform. This interface is used for connection of the testbench in this project.

3.8

Configuration GUI

Selection of the combination of architecture and features of the implemented processor core requires certain skills in a processor architecture design. Manual tuning of the configuration fi1e requires attention to a correlation of compilation keys. A wrong combination of the selected keys may leads to a non-functional processor design. In order to ensure selection of the correct set of compilation keys, GUI wizard software is developed. The appearance of the wizard software is shown in Figure 3.20. The wizard software is written using VB.NET language in Microsoft Visual Studio 2008 Integrated Development Environment (IDE). The GUI has two tabs: Configuration and Architecture. The Configuration tab contains comprehensible menu with available configuration options. Each drop list in the menu contains the commonly used numbers for practical processor configuration. If the choice is not in the list of suggested options" it can be entered manually in the textbox. The default values of the menu pertain to 32-bit five stages pipe lined processor with predefined parameters. Therefore. configuration of the default design does not need any processor architecture knowledge.

43

'1IQ.4&IiU-i;:.:;4{1.lamit.;; b1lrm3; ,&i.:; i ,CootIg\.l<!llOn IAlthilectu!e I

e
Iniliai.tatlOll

·*M'iSii:if§··ftMii' ~~~f,;*,J q'.A'YI1t C,:=¢.!i.·=:t:;:;!:~::;; . , ","",-- iJI..
11>400000
Ih7fHlHc

'.n'

·.I~-~~~'~-~foT~1
#J ", -

W","",", ___'''',",,_'',"

2!J

r
I':
I

I:
I

Althileet... '

r-Memotytd~~~="-------'

I',

It OnoH:)lCleM1PSP!ocenot (' M~IeMIPS"'_

0111.101.....1 UllP"'lirilheltl

IhBOOJooll..:J
rhlWW:lo..:J
I'

Programl:OUI1Ier
Adi;hu (heM)

::::J
:::oJ

r "'1t_~MIPSP,.....""
f'

II

5-tlaget~MIPSPr_

DuM_

l_lirilheltl

v.... (heM)

Stacl<PoOt..

DelaPalhW'dh ~ 9b , "

Ii' . l~sll..
'i"
II
InsIlucIicn

L~':.':'(heM1 1~1fujj----:!]
IIOM_ l_U"iI('-, .,.,,----.., It-D '~ P,ogram CoLrIter Wdh ,32

l,..,w'IJul;JutM .....V 110 M""""ySize 110
1024 1

3J

W",do

II. II
'l

"'' ' ' ' 1 B~"""

jj23

Su

"'' ' ' ' II "'' ' ' ' II

"
r;--'":1

'.
~
.!:J Db
BJMtI\iI",d

r-1ns!rudion Sel Opliono

"'''''----------~~--

l
Iii

f'

InoIIudion"'_Size 11024:::J Worde ,
SIructtr.

po

Stilt c.:.m..n.:b SI4JIlOI\

Geno".o (#(111 Flo

lnolludion

I'.:.J

po SotConwn.tnloS-,

i'
i"
J.

I~: loatalo1~

~u "'''''''''1 Size

j1 024 ::::J

W.. de

r

DRM!

"'' ' ' ' II Utizalion

, " j: I
i":"

Oelo SIn£Iue (S1.m.d S\iI \IItII 4)
10 Ou Path Wdh

"'' ' ' ' II

r;---:-:, 14 .!:J BJMtl\ilord

OlllaM_W'dhit""""

1.1

I'

II·
Figure 3.20: Configuration GUI wizard screenshot

44

The Architecture tab shows the block diagram of the selected processor architecture. If user changes the chosen configuration the block diagram dynamically changes. The pictures of the block diagrams are shown in Figure 3.13, Figure 3.14, Figure 3.15, and Figure 3.16. That visualizes the selected architecture and helps to make the choice of other options. The generation of the resulting configuration file occurs when Generate Conjig File button is pressed. If the file already exists the dialog window appears for confirmation.

3.9

Summary

This chapter has described the details of the design of the MIPS based configurable processor. The described processor design has a choice of four different major processor architectures. In addition to architectural configurability, the multiple structural options are presented for each processor architecture. The specific software tool is developed to facilitate and coordinate the choice of mUltiple configuration options. In order to show capability of the designed processor core, the demo design is developed for the existing FPGA development board. The demo design includes the hardware and software parts. The hardware section comprises the selected processor core and interface peripherals. The software section contains demo program and LCD driver.

45

Chapter 4
Implementation
In this chapter the implementation of the proposed configurable processor on FPGA and ASIC platforms is explored. The design and implementation flow is described in details. Various processor variants are generated and synthesized using the custom-proposed configuration tool and standard FPGAIASIC development tools. The obtained implementation results characterize the maximum clock speed and hardware resources of each processor configuration. The detailed interpretation of the implementation data is provided in chapter 6. A practical implementation of the proposed processor core is shown on the example of the demo design implemented on FPGA development board.

4.1

Hardware Components and Development Tools

Assorted software and hardware tools were used in this project. The development tools used for implementation and verification of the design are shown in Table 4.1. The Xilinx development board "Spartan-3E FPGA Starter Kit Board" was used for hardware implementation of the demo design.
Table 4.1: Implementation and development tools

Name Xilinx ISE 9.2.03i Altera Quartus II 9.0sp2

Usage Description Development and Xilinx FPGA synthesis Development and Altera FPGA synthesis

46

Mentor Graphics ModelSim SE 6.2g Synopsys Design Analyzer MipsIT 1.3.0 sreg2vlog 1.0 MIPS Processor Configuration Manager MipsSim 1.5.1 Microsoft Visual Studio 2008

Behavioral and FPGA post-route simulation

ASIC synthesis Compilation and linking of MIPS software Custom format conversion (*.srec Custom processor configuration
~

Verilog *.v)

MIPS software simulation IDE for development ofsreg2vlog 1.0 and MIPS Processor Configuration Manager GUI

4.2

Design and Implementation Flow

The design-implementation flow of the proposed configurable processor involves the usage of different tools from different vendors. The major stages of the flow are shown in Figure 4.1. Architecture Block Diagram stage is dedicated for the design of the high level architecture described in Chapter 3. At this stage one of the four proposed architectures is to be selected and the set of configuration options is to be defined for the implementation. MIPS Test Program Software is the software development stage where the test or any other specific application is designed. In general, the executed software can be designed using arbitrary development tools supporting MIPS architecture. This project uses MipsIt IDE for development and MipsSim for simulation. The IDE supports both C/C++ and Assembler languages. The linker is capable to produce multiple output formats. None of them can be implemented directly into the instruction memory module. Therefore, the Motorola S-record format [67] is selected for the conversion at the next stage. MIPS Code to Verilog Conversion stage utilizes the custom conversion tool
srec2vlog developed in this project. The tool converts Motorola S-record format to Verilog

assignment operators for ROM as shown in Figure 4.2.

47

Architecture Block Diagram

MIPS Processor Configuration Manager Test Bench

FPGA Syntesis and Post-Route Model Simulation Generation

ASIC Netlist

Gate Level Simulation

Figure 4.1: The configurable MIPS processor design flow

assign [addressO] = dataO; assign [addressl] =datal; assign [addressN] = dataN; address - instruction memory address data - instruction memory data
Figure 4.2: Format ofthe pseudo code inserted in the instruction memory module by the proposed custom conversion tool

48

Verilog HDL Design is the hardware development stage where the HOL description of
the proposed processor was developed. After the completion of the processor development this stage is intended for the processor customization beyond the options presented in this project. Also at this stage the me generated by the converter is included in the instruction memory module using the 'include directive. The software program to be executed by the processor becomes encapsulated in the ROM (Read Only Memory) instruction memory.

Processor Configuration stage is assigned for the selection of the required processor
architecture and configuration. All four possible architectures are described in a form of Verilog HOL using optional compilation keys for selection of the particular architecture. The HOL programming style congregates all configuration changes in one configuration me

processor_config. v. A specific configuration of the processor can be chosen manually by
modifying the configuration me or with the help of MIPS Processor Configuration

Manager. At the output of the stage the fully developed HDL description of the specific
processor configuration is obtained. At the Behavioral Simulation stage the fully defined processor design is combined with the corresponding testbench me. The co-design of the processor sofuvare program and testbench supports functional verification of the processor hardware. The behavioral

simulation is performed by ModelSim tool [68]. The verified processor design can be synthesized on either FPGA or ASIC.

FPGA Synthesis and Post-Route Simulation Model Generation stage produces
the bit-stream me for FPGA configuration and model for post-route simulation.

ASIC Gate Level Netlist Generation stage creates the gate level netIist for the further
fabrication on silicon and gate level simulation. At the Post-Route Simulation and Gate Level Simulation stages the synthesized modellnetlist is verified again using the same testbench module interacting with the same build-in' program in the instruction memory as the testbench and program applied on the behavioral simulation stage.

49

PROPERTVOF RYERSON UNIVERSITY UBR.~Y

4.3

FPGA Implementation

The implementation of the proposed configurable processor on the FPGA platfonn is perfonned targeting devices from two major vendors - Altera and Xilinx where various configurations of the processor are fit into different FPGA device families. In order to compare the implemented configurations, the chip that is capable of incorporating the largest number of possible configurations is chosen. The base design is developed and verified in Xilinx ISE environment. The Altera Quartus II is used as an alternative for portability verification of the base design. The implementation of the Xilinx-oriented features (i.e. FPGA optimization) of the design on the Altera platfonn leads to a significant difference in the processor area and clock speed. The obtained results may facilitate the selection of the optimal platfonn for the implementation of any application targeting ASIP with specific timing and area requirements.

4.3.1

Project Files

Figure 4.3 illustrates the hierarchical structure of the top module mips_dlx module for the five-stage pipelined processor configuration in Xilinx ISE project view window. Each design module is defined in separate file. The description of each project file is shown in Table 4.2. The structure of the design comprises two levels of hierarchy. The top level is represented by the module ritips_ dlx that contains the description of interconnects and instantiations of the data path modules. The second level of the hierarchy constitutes modules containing the HDL designs of the major data path components described in §3.1. The verification process introduces an additional level of the hierarchy. The testbench includes the mips_dlx module as a UUT (Unit Under Test). This three-level structure is used only for the purpose of verification, and it is not synthesizable.

50

e· c xc5v1x155t·1ff1136
~
!:

!

I

I . Q. . r I " t=-,""". ""~,,~~::l1JlflSt~e,,..na~;..~erst~e...,(:l~~L Inters!age_pas~.y .".. ""W ·,.,.c" '_"7C."~l!

" , controLonecycle (controLonecycle. v) H~j control"'pipe_4st [controLpipe_4st v) a-@mips_dlx_tb_v(mips_dlxjnUb.vl a-@uut·mips_dlx{mips_dl)!.v) !-@ processOI_control· cOI'luol_pipe (control_pipe. vI I--@ processorjmem' instmem [inst_mem.v) l-·@ifjdjnsueg.interstage_dat.:ueg(interstage_datcueg.v) 1-··@processOI_,egfile. regfile (reglile.v) I-@ icLexjmm_reg . interstage_data_reg [lnlerslage_data_,eg. v) I-@id_ex...pc_reg. interstage_dala_reg [lnterstage_data_,eg.v} !-@id_ex_,,_,eg. interstage_data:reg (interstage_data_reg. vI I-·@id_ex_b_,eg. interstage_data_leg (interstage_data_,eg.v) I·-@id_ex_shamueg.interstage_data_reg [lnterstage_dati.ueg.v) 1-@processOI_alu. alu_behav (processOI_alu. v) j·-@el!_mem_lesuueg. interstage_data_leg [anterstage_data_reg.v) I·-@ ex_mem_Ueg · interstage_data_leg (interstage_data_reg. v) 1"'@processOl_data_mem : data_ram (memO/.\'. v) I·-@mem_wb_dmem_reg.interstage_data_reg[lnlerstage_data_reg.v) . J.-@mem_wb_aIu_reg. intelstage_data_leg (interstage_dala_reg.vl 1·-@iCid.....PC_reg. interstage_data_reg (interstage_data_reg. v) 1··.. id_el!_rs_addr_reg· interstage_data_leg fanterstage_data_reg. vl i-"@id_el!_rt_addr_,eg.interstage_dat,veg(interst~ge_datcueg.v} id_eX_ld_addr_l~g . interst~_data_leg [Iflterstage_data_reg. vI j-·@ex_mem_,d_w_addr_,eg. interstage_data_,eg flnlerstage_data_,eQ. vl ;, l-@mem_wb_rd_w_addr_reg. interstage_dat<ueg (interstage_data_reg.v) it .

D controUncvc!e (controLmcycIe.v)

0

I. . 0

Figure 4.3: MIPS_DLX project modules hierarchy. Table 4.2: MIPS_DLX project files description

. File Name
,
,~.

.
.:.'

Description;:; '.'
' \. ! ".
~
',"

,

'
' "

,.

....

,;'

",

'.

'~.::"',
:-

.

mips_dlx.v

Main project file. Defines all interconnects between processor components, declaration of the mips_dlx module.

Processor_control. v

Comprises the module ofthe control unit for the 5-stage pipelined processor configuration, declaration of
mips_dlx module, and declaration of the controlyipe

module.

~ssorjmem.v

Comprises the processor instruction memory module

51

interstage_dataJeg. v

Comprises the parameterizable module of the pipeline inter-stage register, declaration of the
interstage_dataJeg module.

ProcessorJegfile.v Processor alu.v Memory.v Control_mcycIe. v

Comprises module of the processor register file, declaration ofthe reglUe module. Comprises the processor ALU module, declaration of the
alu behav module.

Comprises the processor data memory module, declaration ofthe data ram module. Comprises the module of the control unit for the multicycle unpipelined processor architecture, declaration of
controCmcycle module.

Control_onecycIe. v

Comprises the module of the control unit for the onecycle unpipelined processor architecture, declaration of the control_onecycle module.

Controtpipe_4st.v

Comprises module of the control unit for 4-stage pipe lined processor architecture, declaration of the
controlyipe_4st module.

Interstage.J)ass. v Processor_config. v auto_config.J)art.v utils.v Ext Imm.v mips_dlx_int_tb.v

Comprises the module of the dummy pass inter-stage register, declaration of the interstageyass module. Comprises definitions and configuration control macros The automatically generated part of the configuration file. Included in processor_config. v by 'include directive Comprises functions used in the design but not available in Verilog Comprises the function Extlmm of the immediate operand extension. Comprises the verification testbench. Not synthesizable.

52

4.3.2

Architecture

The graphical symbol of the proposed configurable processor is shO\\TI in Figure 4.4. The figure reflects the configurations with 32-bit I/O interface and 10-bit address of I/O memory space. The symbol represents all possible architectures and configurations and depends only on the configuration of I/O interface which affects the bit-width of the address and data lines. The description of the input/output signals of the configurable processor is shown in Table 4.3.

elk

io_mem_enable io_mem_write_enable

reset io_mem_addr(9:0) io_mem_data_out(31:0) io_mem_dataJn(31:0)
Figure 4.4: 32-bit MIPS processor module Table 43 . MIPS'IDterf:ace sIgna s

.

Signal Name --:'
:""
,,~

-

..

Direction - Description
~

'

'}-'

,

.

',"'

-'

,

,

>C-.,

',".

,""

.

,",,-,

- ,-

--.

elk
I

In In In

Main clock signal Global reset signal Data signals ofI/O interface. Inputs for MIPS processor, outputs for I/O memory components. This signal is used for entering data into the processor

reset io_mem_data_out

I

io_mem_enable

Out

Enable access to I/O memory interface Write enable to I/O memory interface Address signals of I/O memory Data signals of 110 interface. Outputs for MIPS processor, inputs for I/O memory components. This signal is used for processor data outputting.

io_mem_write_enable Out io_mem_addr io_mem_data_out Out Out

53

4.3.3

BRAM Optimization

The implementation of the processor with BRAM optimization is verified on the synthesis stage. In case of implementation of the instruction and data memories in BRAM the Xilinx synthesis tool reports about implementation of the instruction and data memory as aBRAM and absorption of the implied address register into BRAM. If the design is implemented without the FPGA optimization option the synthesis tool reports about implementation of instruction and data memory on LUTs due to the asynchronous read of memory. The excerpts from the synthesis reports for BRAM and LUTs implementations are shown in Appendix C.2 The synthesis report also contains information about the number ofBRAM blocks used in the design. If FPGA optimization is not used, the synthesis tool does not report any BRAM utilization. See the summary reports in Appendix C.I.

4.3.4

Timing Constraints

The only constraint applied for the processor core is the clock speed. The maximum speed of the designed processor depends on the chosen configuration. In order to estimate the maximum speed, the clock constraint is changed according to the configuration. The interactive technique is used for the optimal constraint retrieving. The initial constraint is obtained from the synthesis report which defines the possible maximum speed without actual routing. The initial constraint is changed and tried until synthesis and routing fail. If the clock constraint is set with a big slack, the synthesis tool does not generate a design with maximum possible speed. If the clock constraint is too tight, the implementation fails on the mapping stage. The constraint for which the tool generates the best achievable clock period can have negative and positive slack. Timing constraints for different configurations are shown in Table 4.4. The one-cycle processor variant does not have the EXEIMEM register holding the memory address. Consequently, there is no register to be accommodated in BRAM. Therefore, the implementation of the one-cycle variant with BRAM optimization is not performed.

54

Table 4.4: Clock period timing constraints (ns)
I

Architecture 5-stage 4-stage
no

Bit Width

Multi-Cycle
no

One-Cycle
no

Instr. Set
no

BRAM

BlUM
18 14 12 11 10 10 9 12 10

BRAM
25 21 18 14 16 14 10 11 11 11

BRAM

BRAM
15

BRAM

BRAM
25

BRAM

256

Full

25 14

20 16 14 16 14 13 10 12 10

16 14 14

15 14 14 11 10 10 9 9 9

23 20

N/A N/A N/A N/A N/A N/A N/A N/A N/A

128
Reduced Full

13

11
11
10 10 9 10

I

18 18 16 16 14 16 12

64
Reduced Full Reduced

11
10 10 9 9 9

32

16

Full Reduced

8~0

4.3.5

Xilinx Platform Implementation

For Xilinx FPGA platfonn implementation, Virtex-5 FPGA device is selected with following specifications: Device: XC5VLX50 Package: FF324 Speed grade: -1 The essential FPGA [69] characteristics that affect the maximum clock speed and occupied area of the implemented processor are: · · · 550 MHz max clock 7200 slices 28800 LUTs

Table 4.5 shows the best achievable clock speed for the set of the processor configurations implemented into Xilinx FPGA.

55

Table 4.5: Maximum clock speed (MHz) of the processor configurations implemented in Xilinx
FPGA

Architecture Bit Width 5-stage lnstr. Set
no
BRAM Full
I

4-stage
no

Multi-Cycle
DO

One-Cycle
no

BRAM

BRAI\I

BRAM

BRAM

BRAM

BRAM

BRAM

256 128

44 71 83 90 91 101 100 112 100

56 72 84 91 100 100

40 46 56 65 63 72 73 91 86 92

40 50 55 72 64 72

51 63 71 83 91 100 100 112 107 112

52 60 69 72 81 94 86 109 102

40 43

Reduced Full Reduced Full

N/A N/A N/A N/A N/A N/A N/A N/A N/A N/A

I

50 56 56 63 63 73 64 83

64
Reduced Full

32
Reduced Full

111
111 100 100

77
96 83 95

16
Reduced

113

111

The utilization of the FPGA resources used for the implementation of various processor configurations is shown in Table 4.6. The sizes of instruction and data memories are chosen equal for all configurations as shown below: · · Instruction memory size - 1024 words Data memory size 1024 words

The detailed implementation reports for the selected processor configurations are shown in Appendix C. In order to verifY the extremities, the 512-bit 5-stage pipe lined processor configuration with the full instruction set support has been implemented and verified. The implementation results are shown in Table 4.7. For this implementation the selection of the lager FPGA device is required. The chosen device is XC5VLX155 with 97280 LUTs available.

56

Table 4.6: Xilinx FPGA resources (LUTs) used for the implementation of the different processor configurations

Architecture Bit Width 5-stage Instr. Set
no
BRAM BRAM

4-stage
no
BRAM BRAM

Multi-Cycle
no
BRAM BRAM

One-Cycle
no
BRAM BRAM

256

Full
Reduced

9927 5073 4757 2732 2541 1444 1369 811 734

8858 4004 4237 2179 2260 1147 1203

9761 4960 4657 2570 2348 1359 1242 70

8720 3894 4114 2018 2048 1061 1069 601 569 364

8850 3896 4196 2008 2081 1062 1106
I 589

7845 2831 3609 1457 1821 767 935 422 466 257

6 3907 4271 2015 2099 1132 1142 648 599 419

N/A N/A N/A N/A N/A N/A N/A N/A N/A

128

Full
Reduced

64

Full
Reduced

·

32

Full
Reduced

16

Full
Reduced

64 403

4 469

570 361

I

507

Table 4.7: Implementation results of512-bit 5-stages pipelined processor configuration

Parameters Area Max clock speed Clock constraint

noBRAM 20193 LUTs 32.8 MHz 45 ns

BRAM 18106 LUTs 42.4 MHz 20 ns

4.3.6

Altera Platform Implementation

In order to compare the Altera and Xilinx implementations, the compatible Altera FPGA is chosen for the processor implementation. The Altera and Xilinx FPGAs are different by many aspects including a structure of the base elements. The match for Virtex-5 is Stratix III family fabricated with utilization of the same 65 nm silicon technology. The base element of Xilinx technology is LUT and for Altera it is the Adaptive Logic Module (ALM). A comparative ratio (Le. ratio of the LUT quantity to the quantity of ALMS required for the

57

implementation of the same design) of ALM vs. LUT is 1.8x by Altera sources [70] and 1.2x by Xilinx sources [71]. The compatibility of the families used in the project is based on -1.5x practical ratio. Therefore, the closest available Altera analog of Xilinx XC5VLX50 has the following parameters: Device: EP3SL70 Package:F780 Speed grade: 4L Capacity: 27000 ALMs Max internal clock speed: 600 MHz The set of processor configurations implemented in Altera FPGA is similar to the set of Xilinx implementations. Table 4.8 shows the maximum clock speed of the implementation in AItera FPGA.
Table 4.8: Maximum clock speed (MHz) oftbe processor implemented in Altera FPGA

Architecture

Bit
Width

Instr. Set

5-stage
no

4-stage
no

Multi-Cycle
no

One-Cycle
no

BRA!\I
Full

BRAM
49.25 49.49 68.95 73.37 85.32 94.67 96.41 98.01 104.64 104.01

BRAl\1
27.16 36.98 46.74 54.95 62.28 69.81 74.42 81.18 83.17 85.02

BRAM
27.07 38.1 46.19 56.75 60.38 69.57 73.69 76.51 81.0 87.57

BRAM
39.72 45.28 63.69 64.21 77.63 90.59 89.35 98.82 107.38 121.68

BRAM
38.56 43.57 58.09 63.38 66.22 73.06 83.52 94.66 93.39 98.92

BRAM
X X X 47.44 49.63 52.25 54.97 60.31 61.4 66.42

BRAM

51.78 48.01 72.11 74.83 85.14 86.22 96.93 100.02 102.03 119.52

256
Reduced Full

128
Reduced Full

64
Reduced Full

32
Reduced Full

16
Reduced

N/A N/A N/A N/A N/A N/A N/A N/A N/A N/A

i

The time analysis for the three top configurations ofthe one-cycle architecture is unavailable due to unsuccessful fitting of the design into the chosen FPGA device. The size of the design

58

exceeds the fitting capability (27000 ALMs) of the chip. Nevertheless, the synthesis tool produces the amount of the required hardware resources for the implementation of oversized configurations. Table 4.9 shows the FPGA hardware resources required for the implementation of the selected processor configurations. The numbers of ALMs shown in the shaded cells indicate the unsuccessful implementations.
TabJe 4.9: Alten FPGA resources (ALMs) used for tbe implementation oftbe different processor configurations
I

Architecture Instr. Set 5-stage
no
BRAM. BRAM

Bit Width

4-stage
no
BRAM BRAM

Multi-Cycle
DO

One-Cycle
no

BRAM

BRAI\I

BRAI\I
r
' "

BRAM

256

Full Reduced

6066 3127 2993 1582 1435 806 739 469 396 290
I

6066 3281 2934 1572 1385 754 745 485 425 302

6278 230 2903 1116 1665 732 702 428 219 275

6351

5511

55 2307
"
,

40017
"

128

Full Reduced Full

2915 1114 1531 641 647 455 461 -312

I

3195 1404 1453 757 672

2661 1415 1474 641 654 382 383 260

'31477
..

23417 12014 11298 6166 5809 4266 4138

64
Reduced Full

N/A N/A N/A N/A N/A N/A N/A N/A N/A

32
Reduced Full

16
Reduced

:ii
244

4.4

ASIC Implementation

In order to verify portability of the proposed design, the selected processor configurations were compiled using TSMC 0.18 /lm technology process. The synthesis of the considered processor is performed by CMC recommendations for the Digital IC Design Flow [72] [73]. The synthesis tool Synopsys Design Analyzer was used to obtain the gate level netlist. The compilation is performed under the control of the script shown in Appendix D. The synthesized set has a reduced number of implemented configurations compared to FPGA

59

implementations. Table 4.10 contains the data about maximum clock speed of the selected processor configurations implemented using the technology process. The exhaustive implementation of all possible configurations requires unreasonable amount of time. Therefore, it is not practical to implement a complete configuration set. The proof of the design portability and acquisition of the data for a comparative analysis can be achieved with a lower number of implementations.
Table 4.10: Maximum clock speed (MHz) of the processor configurations implemented using 0.18,...m technology process

Bit Width

Instr. Set 5-stage
Full

Architecture 4-stage Multi-Cycle One-Cycle

165

100

134

87

256
Reduced Full Reduced Full

128

N/A N/A N/A N/A N/A
200 200 200 200

N/A N/A ""'fA N/A N/A
158 161 186 174
I

64
Reduced Full

N/A N/A N/A N/A N/A
168 176 182 204

N/A N/A N/A N/A N/A
139

32
Reduced Full

116 148 156

16
Reduced

The same 4 ns clock timing constraint was applied for all configurations. In all cases the constraint was violated with a different negative slack. The minimum achievable clock period is calculated as the sum of the applied constraint and reported slack. The important data retrieved from the compilation report includes the total cell area occupied by the implemented design. This data is shown in Table 4.11 for the implemented processor configurations. The area units are relative and specific for the Artisan tpz973gwc cell library used for the synthesis. For Artisan library the units are 11m2. The implementation of the design using the technology process was performed successfully without any modifications to the Verilog code used for the FPGA implementations. Therefore, the portability of the proposed design is fully verified.

60

Table 4.11: Total cell area (J-lm 2) occupied by the processor configurations implemented using 0.18 J-lm technology process

Bit Width 256 Instr. Set 5-stage
Full Reduced Full

Architecture 4-stage 8241904

I Multi-Cycle
39663

One-Cycle 6732384

8309477

128
Reduced Full Reduced Full

64

N/A N/A N/A N/A N/A
1065715 1032431 .]40470 525973

N/A N/A N/A N/A N/A
,,75418 1046299 556243 539625

N/A N/A N/A N/A N/A
1044842 1022721 526176 523056

N/A N/A N/A N/A N/A
947h51 88 46002 45835

32
Reduced Full

16
Reduced

4.5

Demo Platform Design and Implementation

The purpose of the demo platform design is to show a practical utilization of the configurable processor core. Through the memory mapped 110 interface connected to the user interface the selected processor core obtains input data, processes the collected data, and shows the results on the display.

4.5.1

Hardware Platform Description

The hardware setup used to implement the processor design is Spartan-3E FPGA Starter
Kit Board [74J. This development board incorporates Xilinx Spartan-3 FPGA chip

XC3S500E and variety of peripherals. The block diagram of the implemented setup is shown in Figure 4.5. The Rotary Shaft Encoder is chosen as an input device for the demo design. A photo ofthe encoder is shown in Figure 4.6.

61

r--

----", -,/

}
'---

0

,I

rI

T-I>T-I>-

FF Ary

'---

Figure 4.5: Demo platform block diagram

1

110 MEM

Figure 4.6: Spartan-3E startup kit FPGA board

Depending on a direction, rotation increases or decreases a default number read by the processor core. The default number is 5. The input number is used to calculate Fibonacci number [75]. The input data indicates the position in the sequence of Fibonacci numbers. The calculated result is shown on the character LCD display in the following form:

62

Fib(!vJ=M,
N - order of Fibonacci number
.M - calculated Fibonacci number
Rotation of the shaft causes a change of both Nand M numbers dynamically. The numbers are represented in hexadecimal radix. The number of characters allocated for N and N are two and four respectively.

4.5.2

Processor Core Configuration

The demo design utilizes the processor core with following configuration: · · · · · · · · · · · Five stages pipelined architecture 32-bit data path Shift commands support Set Than Less commands support Instruction memory size - 1024 words Instruction memory count step - 1 word Data memory size - 1024 words Data memory count step - 4 bytes Upper limit of data memory address space - h8fffffif Lower limit of data memory address space - hI 0000000 I/O memory allocated size - 1024 words

·
· · · · ·

110 memory data bit-width - 32 bits
Upper limit ofIlO memory address space - h00400000 Lower limit ofIlO memory address space - hO Program counter bit-width - 32 bits Reset address - h80020000 Stack pointer initial data - h800bcOOO

The limits of data memory, 110 memory, initialization values for program counter and stack pointer are chosen to be compatible with MIPS simulation model in the simulator Mipslt

[76].

63

4.5.3

Demo Platform Interface Design

The signals from Rotary Shaft encoder are processed in the Decoder module. The module performs debouncing of input signals, detection of a shaft tum event and direction of a tum. The HDL design of the Decoder module is based on Xilinx reference design [77]. The direction and tum event change the initial number for Fibonacci calculation. The register that storing the number is connected to VO memory interface. The decoding in VO memory address space is supported by a dedicated decoder. In addition to Fibonacci number calculation, the processor core runs a custom driver for LCD screen. The driver software generates data and control signals according to the specification of LCD screen interface. LCD signals are written to registers mapped to the VO memory address space. The mapping of LCD signals and Fibonacci initial number are shown in Table 4.12.
Table 4.12: Mapping of the Demo design signals in 110 memory address space

Signal Name
fib_in_number

MIPS 110 Address
OxOOOOOO08

Bit range

Direction
Input

Description
Order number of Fibonacci

31:0

lcd_ output_data OxOOOOOO14 lcd drive OxOOOOOO14

7:4 3

Output Output

LCD data to be written Enable signal for whole LCD interface

lcdJs

OxOOOOOO14

2

Output

Command/Data signal

select

lcd_ rw_control lcd e

OxOOOOOO14 OxOOOOOO14

1 0

Output Output

Read/Write control signal Read/Write enable signal

4.5.4

SoftwareIHardware Co-Design

Timing and electrical specification of LCD interface requires an algorithm intensive control capability. That capability is supported in the software running by the processor core. The following functions are performed in the software: · · LCD power-on initialization LCD configuration

64

·

Writing data to LCD

Writing data to LCD in the loop sustains a dynamic refreshment of the visualized information on the screen when the shaft is rotated. All timing delays for the LCD interface are implemented in software loops. Pre-processing of the rotary shaft encoder signals is realized in hardware in a form of HDL code. The code also has a provision for the control of LEDs and reading of buttons available on the board. This provision is used for development and debugging of Demo softwarelhardware co-design. The driver software is written in C+t- language. The limitations of the implemented processor core are reflected in the programming technique. For instance, only unsigned integer variables are used in the code. The compiled code is examined in order to eliminate unsupported commands and variables. The configuration of the processor core is optimized to support the demo program. The optimization includes a choice of the supported command subset, size of instruction and data memory. The fulJ code of the demo design program is shown in Appendix A.

4.5.5

Demo Design Implementation

The choice of FPGA device for the demo design implementation is defined by the chip installed on the development board. The parameters of FPGA are shown below: Device: Xilinx Spartan-3 XC3S500E Package: FG320 Speed grade: -5 Capacity: 9312 LUTs The time constraint is determined by 50 MHz clock available on the development board and connected to the FPGA input. All other constraints are related to the pin assignments. The full set of the demo design constraints is shown in Appendix E. The synthesis of the demo design was successfully performed with the following results: Number of used LUTs: 4888 Number of used I/O blocks: 30 Minimum period: 19.971 ns (Maximum frequency: 50.073MHz) Device utilization: 52%

65

Since the FPGA optimization option is not used, the synthesis report does not have the information about BRAM utilization. The full implementation report is shown in Appendix E.

4.6

Sumntary

This chapter showed the successful implementation of the proposed configurable MIPS· like processor on the two competitive FPGA platforms and ASIC implementation using 0.181lm TSMC technology process. The applied design flow and tools used on every design stage were described in details. The justification of the selected implementation platforms was based on the project requirements and FPGA devices compatibility. As a result of implementation using standard FPGNASIC toots, the data about hardware resources utilization and maximum possible clock speed was obtained for the selected configurations. The demo design was successfully implemented in the selected development platform meeting all design constraints.

66

Chapter 5
Design Verification
This chapter discusses the verification scheme of the proposed microprocessor architecture. The process is achieved in two stages. The scheme is conducted at two stages of the design flow. The first stage is at the HDL development level of the design where a testbench is built to veritY the design's HDL code. The second is at post- implementation level, where the implemented design on the target platform is tested. At the HDL level, the design's code is tuned until the correct behavior ofthe design is reached. The postimplementation verification depends on the target platform. For example, in case of FPGA, the main objective of this verification is the post-place & pout simulation model. However, in case of ASIC implementation, the objective is the gate level netlist. The design of a testbench must cover as much as possible functionality of the simulated processor. The large number of the verified processor configurations and implementation platforms appeals to the stringent requirements for the testbench. In order to be able to veritY numerous variants, the testbench output shall simply state whether the tested design failed or passed. The functional verification of the design is performed for the selected processor configurations. When all bugs are eliminated, the set of selected configurations is verified with post-route simulation. Table 5.1 shows the subset of the processor configurations which were simulated where the simulated configurations are referred to by x sign. The shown selection was driven by the following reasons: · BRAM optimization is independent of the instruction set and bit-width. It may be verified once per chosen architecture

67

·

Different from the standard 32-bit processor configuration may be verified only at extremities. In the considered case, extremities are 16-bit and 256-bit

·

Reduced instruction set is independent of bit-width, It may be verified once per chosen architecture

, : V en ' Iior th e processor con fi T a hi e 51 'fi Ica f Jon rna trlx Igura t' Jons se t

Architecture
Bit

e Instr. Set
no

4-stage
no

Multi-Cycle
no

One-Cycle
· I

Width

no

BlUM

BlUM
X

BlUM
X

BlUM
X

BlUM
X

BlUM
X

BlUM
X

BlUM.
I

256

Full Reduced

X

128

Full Reduced

·

I

64

Full Reduced

X

X

X

X

32

Full Reduced

X X X

X

X X

X

X X X

X

X X
X

16

Full Reduced

X

5.1

Testbench Design

The testbench is created to verify the functionality of the developed processor. The recursive algorithm of calculation of the Fibonacci numbers is widely used as an evaluation example of the functionality of the MIPS processor [78J [79J, The Fibonacci calculation algorithm can be implemented into a compact program due to its recursive nature. Translated into machine codes it utilizes most of the proposed instruction set including the complicated instructions (e, g. function calls; branches, jumps etc,). Moreover, the translated program contains all RAW hazard scenarios possible in the proposed pipelined architecture. The

68

external data required for the computation is minimal. The described set of properties of the Fibonacci algorithm makes it very practical for validation of the proposed processor.

5.1.1

Fibonacci Number Test Program

The Fibonacci number sequence was introduced by the medieval mathematician Fibonacci (Leonardo Pisano) as a solution to the logical puzzle. Later it was found that the sequence reflects many processes in nature [75]. The Fibonacci numbers comprise the following sequence:

1, 1,2,3,5,8, 13,21,34,55,89, 144,233,377,610,987, 1597,2584,4181,6765 ...
The C-style description of the recursive function for the calculation of the Fibonacci numbers is shown below.
int fib(int n) if (n==O) if (n==I) {

{return Ii} {return I;}

return (fib(n-I) + fib(n-2»i

The assembler code obtained after translation is augmented manually for communication with the high level Verilog testbench. The assembler code of the test program is shown below.
Iw $29, 4($0) Iw $4, 8($0) addi $29, $29, -12 ; fib: sw $31, 8($29) sw $16, 4($29) addi $2, $0, 1 ; beq $4, $0, 52 addi $8, $0, 1 i beq $4, $8, 40 nop addi $4, $4, -1 ; sw $4, 0 ($29) ; jal Ox00400008 [fib]; lw $4, 0 ($29) i addi $ 4 , $ 4 , -1 i add $16, $2, $0 jal Ox00400008 [fib]; add $2, $2, $16 Iw Ssp, 4($zero) //Ioad from I/O mem Iw SaO, 8($zero) //Ioad from I/O mem addi Ssp, Ssp, -12 sw $ra, 8($sp) sw $sO, 4($sp) addi $vO, $zero, 1 beq SaO, $zero, fin addi $tO, $zero, 1 beg SaO, $tO, fin nop (delay slot) addi SaO, SaO, -1 sw SaO, O($sp) jal fib lw SaO, O($sp) addi SaO, SaO, -1 add $sO, $vO, $zero jal fib add $vO, $vO, $sO

69

sw $2, 12 ($0) lw $16, 4 ($29) fin: lw $31, 8($29) addi $29, $29, 12 sw $29, 16 (SO) jr $31 nop

sw $vO,12($zero)//store to I/O mem lw $sO, 4($sp) lw $ra, 8($sp) addi Ssp, Ssp, 12 sw $sp,16($zero)//store to I/O mem jr $ra nop

; ;

The additional instructions have been inserted at the beginning of the program to retrieve the initial stack value and the order of calculated Fibonacci number. The program performs calculation starting from the value in r4 and places the calculated result in r2. Moreover, the program frequently sends values of the stack and r4 to I/O interface. This method allows monitoring of the values by an external testbench. The translated machine codes are contained in a separated file which is stored in the instruction ROM. Appendix F shows two variants of the developed test program. The variation reflects the differences of the processor architectures. The applicability of the variants is shown below: · · Delay slot with reordering - pipelined architecture No delay slot - unpipelined architecture

If reordering is not used for the pipe lined architecture. the additional nap instructions have to be placed instead ofreordeiing. This option can be chosen in the compiler. A recursive nature of the test program allows testing of all possible data and control hazards for the implemented instruction set.

5.1.2

Verilog Testbench

The organization of the testbench and test program allows them to be applicable at the behavioral and post-rout levels. The testbench does not interact directly with the internal processor registers. Though acceptable for the behavioural simulation, the direct access is not applicable on the post-route leve1. The testbench mips_d/x_tb.v comprises the instance of the tested processor configuration and memory accessible by the testbench. The memory is connected to the processor as I/O memory and mapped to the processor memory address

70

space. The mapping of the VO memory is shown in Table 5.2. The testbench also contains the pre-calculated array of Fibonacci numbers.
Table 5.2: Mapping ortestbench in I/O memory address space

I 110 Memory Address Direction ( processor scope)

Description
i

·1
2 3
4

Input Input Output Output

Initial stack value Order of Fibonacci number Calculated Fibonacci number Current stack value

The test program loads r4 with the order of the calculated Fibonacci number and r29 (stack pointer) with the initial value. The program performs calculation continuously updating
VO memory with current values of the stack and Fibonacci number. The simulation finishes

when the stack pointer returns back to its initial value. The block diagram of the developed Fibonacci number testbench is shown in Figure 5.1.
Test Bench Processor Core UUT
r2 1I0MEM

Test stop

2
r4

3
4

r29 (stack)

Figure 5.1: Block diagram of the Fibonacci number testbench

The testbench program compares the result contained in VO memory with the true preca1culated Fibonacci number and reports whether the test is successfully completed. The examples of the successful and unsuccessful simulation reports are shown in Appendix G. The waveform of the simple case Fib(3) =3 is also shown in Appendix G. Due to the recursive nature of the algorithm, the calculation of Fibonacci numbers of the higher order requires substantially longer time. For instance, the calculation of Fib (16)
=

1597 requires

52447 machine cycles of the processor with one-cycle architecture. In order to reduce the

71

verification time, the Fibonacci number calculation case Fib (5)

=

8 is chosen for testing of

all implemented configurations. The higher order of calculation does not increase the confidence in verification results but only the execution time and size of the data placed in the stack.

5.2

Pipelined Architecture Verification

The five-stage architecture was simulated and the following message was obtained for all tested configurations of this architecture:
# Fibonacci number test SUCCESSFULLY completed, Fib (5)

8

# Test finished after

28£ machine cycles

The same test is performed four-stage architecture and the following message was obtained:
# Fibonacci number test SUCCESSFULLY completed, Fib ( 5) =

8

# Test finished after

278 machine cycles

The important part of the pipelined architecture testing is verification of the hazards handling. The following sequence of the instructions creates a data hazard:
0: 1: 2: lw $29,4($0) lw $4, 8($0) addi $29, $29, -12

IIWB stage
I/MEM stage

IIEX stage

r29 value used on the EX stage by instruction 2 is fetched from the regfile before it is written to the regfile by instruction O. Therefore r29 value must be forwarded from the WB stage to EX stage. The waveform in Figure 5.2 shows how the instruction addi (address 2) fetched in the IF stage from the instruction memory triggers the change of the forwarding multiplexer in the EX stage selecting ALU operands A and B from the WB stage (multiplexer address 2). Another case of hazards created by an instruction sequence:
I lIst hazard 1/2 nd hazard
2:

addi $29, $29, -12 sw $31, 8 ($29) sw $16, 4($29)

I/MEM stage /IWB stage

3:
4:

IIEX stage
//ID stage

//MEM stage /IEX stage

72

Instruction Mem - - - - - - - - - - - - - - + - - - - - 1

w+

.. Imips_dbUb_v/uuVprocessoUmem/clk Imips_dlx_tb_v/uuVpro:essorjmem/e.ddr Instruction Reg .. /mips_dlx_tb_v/uuViUcjnsUegfwrite_ene.ble

0 0 0000000

r-l---,

I

L
3
=-":,*3bd

1
B91,::

Ii)+ Imips_dlx_tb_v/uuV ro:essorjmem/de.le._oul

Be~40008

~--- -'4 6
1

OBOO~Od

-"7

---;

_20920001'

_~_ ~OOBOOP
120~20001 '
OOBOOO

8

J
00000000 8 ... Be 4000B

I.B+ Imips_dlx_tb_v/uut/iUdjnsUeg/de.te.jn
Universal Control Unit

l±J+ /mips_dlx_tb_v/uuViUdjnsUeg/dBtB_out
W+ Imips_dlx_tb_v/uuVpro:essor_controVe.lu_6_srcj·....d ij;;+ /mips_dlx_tb_v/uuVpro:essor_controValu_b_srcjwd W+ /mips_dlx_tb_v/uuVpro:essor_controVjr_src_frw W+ /mips_dlx_tb_v/uuV ro:essor_controVcmp_rs_slC_fwd

0000000
0 0 0 SIO StO 0 0 0

:Scl j 004

o

ii)

+ /mips_dlx_tb_v/uuVpro:essor_controVcmp_rCsrc_fwd
RegFile

Figure 5.2: Forwarding WB~EX and

MEM~

EX in the pipe lined architecture (ModelSim waveform)

Instruction Mem

l!l+ Imips_dlx_tb_v/uUVprocessorjmemiaddr

. . /mips_dhUb_v/uuVprocessorjmemtclk

o

.1

I

.. l
;,:,7

l!.l+ /mips_dlx_lb v/uuViUdjnsUeg/dah_out
Universal Control Unit

W+ /mips dlx_tb_v/uUVprocessorjmemidata_out Inslruction Reg + /mips dlx tb v/uuViUdjnsUegfwnl,,_enable W+ /mips_dlx tb v/uuVif id inst reg/dahjn

0 4 6 ____ OOOOOOOC 1OBOOOOd _____

___ ~~ __,9 __ ~_ ~I
OOBO

~".~tJ'L'"'i,,~~ II
p-r..
-- --

,-- I

'20 20001

;,1 OBE 000e.

10 " WOOOOO

,'I
_

.

~ 20E 411ff -_

J~-J 1_
11 _ __
I

St lIing
-

1 OOOOOOO( 10BOOOOd- --20 20001 OOOOOOO( afbOOb04 - ;lOBO OOd'
--

_._ ... -

OOBOO 1-

12] 20001

,~ OOOaOOBOO
~--.-

m-.....

I '" 21111lo00 A10860000-------

\
-

I
-~

--

----

20E 411ff

-I

,ooooe 000

~

;20 .

\£1+ /mips_dlx_lb_v/uuVprocessor_controValu31 src fwd l!.l+ /mips_dlx_lb_v/uuVprocessor_conlroValu b src fwd W+ /mips_dlx_lb_v/uuVprocessor_control/jr_src frw W+ /mips_dlx_lb_v/uuVprocessor_controVcmp rs src_fwd

0 0 0 SIO SIO

11
0 1

_T2
,0 I

~.-~.-

---:0

1----- ------

-~----

"-

~

_:0
I

W+ /mips_dlx_lb_v/uuVprocessor_control/cmp. rt src fwd
....
RegFile

1""1

rwar tting

\

2
'--

'-0

I

..

.....

..

.
in the pipelined architecture (ModelSim waveform)

Figure 5.3: Stalling and forwarding

MEM~ID

73

The shown hazards are similar to the previously described hazard, where r29 value is used on the EX stage before it becomes available from the regfile. The first hazard is handled by forwarding from the MEM stage and the second hazard is handled by forwarding from WB stage. This forwarding is also shown in Figure 5.2. The instruction sw (address 3) triggers the forwarding of the ALU operand A from the MEM stage (multiplexer address 1). In the same way the next instruction sw causes the forwarding of the operand A from the WB stage (multiplexer address 2). Since not all hazards can be handled by forwarding, the verification of stalling is to be verified as well. The following instruction sequence creates the hazard to be handled by stalling and forwarding:
7: 8: addi $8, $0, 1 beq $4, $8, 40

IIEX stage IIID stage

The instruction beq (address 8) uses r8 value on the ID stage when the previous instruction addi (address 7) that changed r8 did not yet write it in the regfile. Moreover, the result of addi instruction is not available yet from the EX stage. Therefore, the immediate forwarding cannot help. The stalling for one clock cycle and forwarding from the MEM stage allows handling that type of hazards. Figure 5.3 shows the detailed waveform of the described hazard handling in the simulation of the five-stage architecture with BRAM optimization. The shown examples of forwarding and stalling do not cover the whole set of RAW hazard handling that are implemented in the proposed processor design. The complete set of verified hazard scenarios handled in the pipelined configurations is as shown in Table 5.3
. rme d arc h' T a hi e 53 . : Data b azard s h an dl ed h )y f.orwar mg an d staIr mg . In t h e pipe Itectures

Pipeline Length

Fibonacci Test

Hazards Handled by Forwarding 2 4

Hazards Handled by Stalling 2

4 stages 5 stages

Fib(5)=8 Fib(5)=8

5

The Fibonacci number testbench contains all described hazard scenarios. The correct handling of these hazards was simulated and verified. The post-route simulation was successfully performed for the configurations shown in Table 5.1. The only type of hazard possible in the proposed pipelined architecture is the RA W hazard, therefore handling of WAR and WA W hazards is not required.

74

5.3

Multi-Cycle Design Verification

Due to the significant difference in the control units between multi-cycle and pipeJined architectures, the verification of the control unit functionality for the multi-cycle architecture is crucial. The simpler control unit design contains no hazard handling to be verified, though FSM functionality is to be validated. Figure 5.4 shows the se1ected waveforms of the 32-bit multi-cycle processor running Fib(3) =3 program. The highlighted waveforms ofFSM states (i. e. state & nexlstate) represent a typical example ofFSM operation.

zOOt0001 .

. ~ ·~iOOO~:_~~t
. --~ . 7 -~ ~---

--

0 -.-

Figure 5.4: Wneform ofthe multi-cycle architecture simulation

The shown waveforms reflect the following instruction sequence:
2: 3: addi $29, $29, -12 sw $31, 8 ($29)

III-type instruction
IIMEM-type instruction

There is the following correspondence between FSM states shown and actions performed by the control unit: State Action 071767870717477 FETCH7DECODE7EXECUTE_IMM_TYPE7WR_BACK7 7FETCH7DECODE7EXECUTE.:...MEM_TYPE 7MEM_ACCESS
. t' T a bl e 54 · : FSM actIOn d escrlp·.on

FSMAction FETCH

Description An instruction is fetched from the program memory and stored in the instruction register. The program counter is updated with the next instruction address. ALU increments the next instruction address

DECODE

The instruction is decoded. The operands are retrieved from the regfile and stored in IDIEX register. ALU calculates the next instruction address for a possible branch instruction.

75

EXECUTE- IMM- TYPE

ALU performs an arithmetic/logic operation with the immediate operand

EXECUTE_MEM_TYPE ALU performs adds a memory address offset calculating a memory access address MEM_ACCESS WR_BACK Memory load/store operation Writing the result of load operation or ALU calculation in the regfile

Table 5.4 describes major processor actions performed under control of the FSM incorporated in the control unit. The post-route simulation the testbench Fib(5) =8 was performed for the multi-cyc1e architecture configurations shown in Table 5.1 and the following message was reported for all configurations:
# Fibonacci number test SUCCESSFULLY completed, Fib (5) # Test finished after 964 machine LV'-'-'-~'''''

8

5.4

One-Cycle Design Verification

The simplest by data path and control organization one-cyc1e architecture was verified for the functionality of the processor design by successful completion of the testbench. The example of the post-route simulation waveforms of the one-cyc1e processor simulation is shown in Appendix G. The adduced waveforms validate the correct operation of this processor architecture. The post-route simulation the testbench Fib(5) =8 was performed for the one-cyc1e architecture configurations shown in Table 5.1 and the following message was reported for all configurations:
# Fibonacci number test SUCCESSFULLY completed, Fi~ # Test finished after 243 machine cycles

5)

8

5.5

Demo Platform Design Verification

The verification of the demo platform design is more complicated than the verification of the processor core itself due to the increased design complexity. The demo design is verified

76

at behavioral and post-route stages by checking waveforms on the LCD interface lines by means of the software simulator. The timing diagram and data send through the interface complies with LCD screen interface specification. The correctness of the displayed information is checked by comparing waveforms of the data sent to the LCD screen with the expected values. The final validation is performed by loading the design bit-stream into the target FPGA on the development board and comparing the values displayed on the screen with pre-calculated Fibonacci values. The pictures of the development board running the demo design are shown in Appendix H. All numbers are displayed in the hexadecimal format. The change of the order of Fibonacci number is performed by turning of the rotary shaft. The maximum obtained correct number Fib(Ox17) =OxB520 is limited by the four character positions allocated for the resulting Fibonacci number. The Fibonacci numbers shown on the LCD screen coincide with the pre-calculated values.

5.6

Summary

This chapter outlined the verification process applied for validating the proposed configurable processor. The design of the testbench was described in details. Also, the results of the testbench execution were presented. The verification of the critical design features was outlined and shown in examples presented in this chapter. The practical implementation of the proposed processor was verified on the development board. The obtained testing results concurred with expected values. The proposed design was verified successfully.

77

Chapter 6
Result Analysis
This chapter analyzes the implementation and verification results obtained in the chapters 4 & 5. The difference between implemented architectures, as it was outlined in chapters four and five, is based on the structural features of a particular design. In this chapter the stated assumptions are supported by the actual data. The comparative analysis of the considered processor configurations illustrates the advantages and disadvantages of the proposed architectures. The conducted analysis may facilitate the selection of the considered processor configuration for the specific application.

6.1

Xilinx FPGA Implementation Evaluation

The performance evaluation of the proposed processor is conducted for corresponding configurations of the different architectures. Figure 6.1 shows the maximum clock speed and occupied hardware resources of the architecture variants of the 32-bit processor implemented in Xilinx FPGA. The chart also compares implementations with full/reduced instruction sets and BRAMIno BRAM optimization options. The five-stage pipelined architecture shows the highest clock speed. The trade-off for this advantage is the largest number of the FPGA resources required for the implementation. The multi-cycle architecture offers very close clock speed with saving 19% of hardware resources. But simple comparison of the clock speed of the considered architectures would be misleading. However, the throughput can be used as a parameter that reflects more precisely the performance of the architecture. The fivestage architecture has throughput of one instruction-per-cycle while multi-cycle architecture has a variable throughput of 3-5 cycles per instruction. The Fibonacci testbench executed on

78

the fi ve-stage processor requ ires 3.4x times less cl ock cycles than executed on the multi-cycle processor regardless of the bit-width and chosen confi guration. T herefore. the multi -cycle architecture is. in fact, the slowest of all co n idered imp lementations. The benefit of multicyc le architecture is the r duced util ization of the hardware resources.
1600 120 00

1400 100,00 1200 8000 1000
en ::>
...J

Hml Area , no BRAM, full Area, no BRAM , reduced Ci:iJArea. BRAM . full c:=J Area , BRAM . reduced - . - Speed. no BRAM. full Speed. no BRAM , reduced ____ Speed, BRAM, full

I-

800

60.00

~
~

600 40,00 400 2000 200

Speed, BRAM. reduced

0 5-stages 4·stages Multi-Cycle One-Cycle Architecture

Figure 6.]: ["aluation chart of the architecture variants of 32-bit processor implemented in Xilinx FPGA

The comparative analysis of two pipelined architectures shows that the four-stage architecture consumes 9% less area at the expense of 26% reduction in the clock speed. Though the theoretical throughput is one-instruction-per-cycle for t>oth architectures. the reduced number of hazards handled by stalling causes 3% faster testbench execution measured in clock cycles for the four-stage architecture. Despite the fact that the execution of another testbench may result in better clock cycle performance. the combined speed performance of the four-stage architecture is worse than the five-stage architecture. The clock speed of the one-cycle architecture is lowe t ofal!. This result is xpected and can be explained by the longest asynchronous path of the one-cycle architecture. The difference of 37% between one-cycle and multi-cycle architectures in the clock speed is

79

considerably less than stated in [12]. This difference can be related to the dissimilarity in the control units where the control unit of the multi-cycle architecture introduces more deJay. The control unit of the multi-cycle architecture contributes to the resulting delay significantly more than the control unit of the one-cycle architecture. Having 3% hardware overhead, the one-cycle architecture offers an advantage of 4x times faster execution of the testbench measured in clock cycles. Hence, the one-cycle architecture of the proposed processor becomes very attractive for the applications where the resource saving is critical. The reduced instruction set implementation demonstrates improvement of the clock speed in the range from 12% to 24% and reduction of the hardware overhead 42-49% for all considered architectures. This effect is due to removal of the barrel shifter from the ALU. The barrel shifter significantly contributes to the resulting data path delay and consumption of the hardware resources. For an application without shift operations removing of this feature offers a considerable advantage. The implementation of the BRAM optimization option improves the clock speed for the pipelined architectures. The five-stage architecture gains 12% of the clock frequency and four-stage architecture gains 5%. In contrast to that gain, the multi-cycle architecture shows a reduction of the clock speed. The speed drops occurs because the major contributor to the deJay is the control unit not the data path. The BRAM optimization option affects the data path only leaving the control unit intact. The additional delay for multi-cycle architecture is caused by the memory control signals which have a longer delay for BRAM. The distinguishable feature of the BRAM optimization option is saving of general hardware resources (i. e. LUTs) by implementing parts of the design into specialized FPGA blocks (i.e. BRAM). This saving reaches 12-15% for all architectures with the full instruction set and 21-28% for architectures with the reduced instruction set. The results of the architecture comparative analysis conduced for 32-bit implementations can be extended for the implementations of other bit-widths.

6.2

Altera FPGA Implementation Evaluation

The implementation of the proposed processor variants on the competitive Altera FPGA platform demonstrates results different from the Xilinx implementation. These results are illustrated on Figure 6.2 showing the quantitative relation of the implementation variants of

80

the 32-bit processor. The FPGA resources for the one-cycle architecture ar om itted for better vi sibil ity of the graph because the hardwar recourses occupi ed by this type of architectu re exceed the closest val ue by eight times.
800 120

700 100 600 80 500 EEl3 A rea, no BRAM, full ,EE!J Area, no BRAM , reduced crJJ A rea, BRAM. full c::=J A rea, BRA M, reduced - . - Speed, no BRAM , fu ll
~ Speed, no BRAM, reduced ___ Speed , BRAM, full

:E 400 ...J
<C

III

300 40 200 20 100

Speed , BRAM, reduced

0 5-stages 4-stages Multi-Cy cle One-Cycle Architectu re

Figure 6.2: Evaluation chart of the architecture variants of 32-bit processor implemented in Altera FPGA

The comparative analysis of the clock speed between the architectures shows the results close to Xilinx implementation. The five-stage architecture is 23% faster than the four-stage architecture. The multi-cycle architecture demonstrates the similar to five-stage clock speed while showing the worse testbench execution time measured in clock cycles. The one-cycle architecture is 43% slower than the pipelined five-stage architecture. The distribution of the hardware resources between the architectures for the Altera implementation is similar to the Xilinx implementation in case of the pipelined and l11ulticycle architectures. The difference in resources between five and four stages pipelined

architectures is 5%. Consequently. the multi-cycle architecture requires 9% less resources than the five-stage architecture. The major difference in implementations on the e two FPGA platforms is the hardware resources required by the one-cycle architecture. Implemented on

81

the AItera platfonn the one-cycle processor occupies 734% resources more than the five-stage architecture. This phenomenon can be explained by the difference in FPGA organization and compilation tools for Xilinx and Altera. Altera Quartus II compiler [80] recognizes inferred memory blocks in the proposed design even without BRAM optimization option. By default, the compiler is allowed to use hardware memory blocks for the inferred memory implementation. This feature causes only minor differences in the implementations with or without BRAM optimization. In fact, all architectures except the one-cycle are implemented with the utilization of hardware memory blocks. The one-cycle architecture does not contain inferred synchronous memory blocks. Therefore it is implemented purely in ALMs resulting in ajump of utilized FPGA resources. Due to high level behavioral description of the proposed processor, there is no direct control of the utilization of memory blocks on the Altera platfonn. The analysis of the synthesis report shows that the data memory and regfile are implemented in hardware memory blocks every time when the automatic recognition of memory blocks is enabled. The excerpts from the compilation reports are shown in Appendix I. In several processor configurations the BRAM optimization option causes the implementation of the instruction memory into a memory block. But this effect is inconsistent through the explored set of implementations resulting in variations of the utilized hardware resources. Another source of variation is the utilization of Memory Logic Array Blocks (MLAB) or Memory 9-Kbit blocks (M9K) [81] for the regfile implementation. The compiler uses either option justifying the choice by the optimization strategy. In order to have a full control of the design implementation, it is necessary to use specific to Altera FPGA hardware resources (i.e. memory blocks, megafunctions) in the HDL code of the design. This approach would negate the portability concept critical to the proposed design. The variation in the implementation results on the Altera platfonn is a trade-off for the design portability. The predictable and consistent reduction or the utilized hardware resources is achieved by implementation or the reduced ISA support. The removal of the barrel shifter and extra ALU operations benefits in 5% hardware saving for 32-bit one-cycle architecture and 30-42% for other architectures. The removed hardware is the constant number of ALMs for all architectures while the remaining occupied resources vary in different architectures. That

82

explains the significant difference in the ratio of occupied resources for the considered architectures. Based on the data shown in Table 4.8 and Table 4.9 it may be deduced that the conducted evaluation of the 32·bit processor variants implemented in the different processor architectures can be applied to the implementations with other bit-widths. Though quantitative values may significantly differ, the general trends are common for all bit-widths.

6.3

ASIC Implementation Evaluation

The results of the implementation of the proposed processor using 0.18 !lm technology process show the similar to FPGA implementation tendency. As shown in Figure 6.3 the clock speed ratio between two pipe lined architectures is 21 % in favor of the five-stage architecture. In the same way as the FPGA implementation, the multi-cycle architecture demonstrates higher clock speed than four-stage and one-cycle architectures. Nevertheless, the higher clock speed does not compensate the longer instruction execution time, due to the worse throughput of the multi-cycle architecture The one-cycle architecture offers the advantage of the smallest die area and the clock speed just 30% less then the fastest five-stage pipelined architecture. The distinguishable feature of the ASIC implementation is a minor variability of the occupied area for five-stage. four-stage and multi-cycle architectures. The difference does not exceed 3%. That effect can be explained by the strategy used for the design compilation. The compilation tool breaks the hierarchy of the design and optimizes it. The actual difference in hardware resources (i. e. registers. combinational logic, and memory) between these three architectures corresponds to the obtained values. The reduction of the die area for the onecycle architecture is caused by absence of the inter-stage registers in this architecture. The most attractive choice for the speed oriented application using the technology process is the five-stage pipelined architecture. This architecture features the fastest execution speed and 9% more die area than the most resource efficient one-cycle architecture. In case of a tight die area constraint the best choice is the one-cycle architecture which occupies the smallest of all architectures area and offers the execution speed (testbench adjusted) 22% less than the fastest five-stage pipelined architecture. 83

1200000

250

E!:
1000000

!:::

800000

II !
t::

~ r-. .......

~,

;.. f-.--:

I
~

~
':

200

~
~

oct

'" E

500000

I
"-

"'" ~

,.
150
EHttI Area , full
~

c=::J Area , reduced

400000

200000

I
~
5-stages 4-stages

i
E;

~ ~

==
100
,.

---.- S peed, full
--.- Speed, reduced

:. :.

':

o

I I
Multi-Cycle

50

~
One-Cy cle

o

Arcnitecture

Figure 6.3: Eval uation chart of the architecture \'ariants of 32-bit processor implemented using
0.18 /lm technology process

The imp lementation of the reduced instruction set does not significantly affect the occupied die area. The maximum area sav ing is 6%. That can be explained by the more efficient implementation of the barrel shifter using the technology process compared to FPGA platfonll.

6.4

Evaluation Against Existing Solutions

The comparison of the proposed processor against the existing processors with similar architectures and implementation platforms is complicated by the differences in details of a particular design. The closest processor solutions were selected for the comparative evaluation. Table 6.1 outlines the major features of two configurations of the proposed 32-bit processor implemented on the A ltera Stratix-III FPGA platform vs. similar Altera Nios Ills (small) and Nios IIle (economic) soft processors.

84

Table 6.1: Configurable MIPS processor variants vs. Altera Nios HIsle

Feature
Con fig. MIPS
I Bit-width

Processor Core
Nios Ills 32 bits CODfig. MIPS 32 bits 89 MHz 672 ALMs No 5 max No I-cycle barrel Nios IIle 32 bits 200 MHz 350 ALMs No 6 max No I cycle-per-bit 32 bits 96 MHz 739 ALMs 5 stages I No I-cycle barrel

Fmax Area Pipeline Cycles/Instruction Hardware Multiply Shifter

165 MHz
700 ALMs 5 stages
1

3-cycle 3-cycle shift

The five-stage pipelined architecture yields to Nios Ills by the speed and occupied area due to the optimization of Nios II for the Altera FPGA architecture. Also the proposed configurable MIPS processor design uses more advanced barrel shifter which requires an additional area and contributes to the delay of the EXE stage. The same causes are responsible for the superiority of NIOS We over the multi-cycle architecture of the proposed processor implemented on the Altera platform. The close contemporary solutions implemented on the Xilinx Virtex-5 FPGA platform are represented by Xilinx Microblaze v7.0 [82] and Leon3 [83] soft processors. Table 6.2 compares the critical specification details of these competitive processors with the proposed five-stage processor. Due to the optimization of the Microblaze organization and instruction set for the specific structure of Xilinx FPGA, the Micoblaze speed performance greatly exceeds the configurable MIPS. By the same reason, Microblaze occupies 28% less hardware resources. On the other hand, Leon3, a portable research solution not optimized for a specific FPGA also demonstrates the inferior speed performance compared to Microblaze. The reduced clock speed is a trade-off for portability common for Leon3 and proposed configurable MIPS processors. As a result, the Leon3 is just 25% faster than the configurable MIPS. This advantage is stipulated by the longer pipeline which, in general, requires hardware overhead for data path and control elements.

85

T a hi e 62 I IDX M' Icro hI aze an d L eon 3 . : C on ti19ura hi e MIPS processor vs. XT

Feature
Con fig. MIPS Bit-width Fmax Area Pipeline Cyc1es/Instruction 32 bits 100 MHz 1369 LUTs 5 stages

Processor Core
Microblaze 32 bits 220 MHz 980 LUTs Leon3 32 bits 125 MHz 3500 LUTs 7 stages
1

5 stages
1 Optional I-cycle barrel Xilinx FPGA only

1
I-cycle barrel AlteraIXilinx
i

Hardware Multiply No
i

Optional 3-cyc1e shift AlteraIXilinxiActellLattice FPGA, ASIC

Shifter Portability

FPGA, ASIC

Despite the fact that the proposed processor shows the performance worse than the commercial solutions. it has an advantage of an open design available for customization and tuning. It also offers the high portability which is not available for the considered commercial products. A distinguishable benefit of the proposed processor is the configurable data path bitwidth. Such level of configurability is not offered by any processor selected for the comparative evaluation.

6.5

Summary

This chapter analyzed the results of implementation of the proposed processor on different hardware platforms. The detailed analysis was performed for the 32-bit processor configuration implemented using various options for the four considered architectures. The conducted analysis defined a correlation between a chosen processor configuration and technical parameters obtained after the implementation. The specific to a hardware platform implementation features were identified and explained using the obtained results. The selected processor configurations were compared with similar contemporary processor solutions. The advantages and disadvantages of the evaluated designs were described in details.

86

Chapter 7
Conclusion and Future Work
7.1 Conclusion

In this project the configurable processor with MIPS compatible instruction set was developed. The configurability of the design offers a choice of four possible processor architectures: · · · · Five-stage pipelined Four-stages pipelined Multi-cycle unpipelined One-cycle unpipelined

Within each architecture the configurabJe options include data path bit-width, organization and size of the data and instruction memories, instruction subsetting. 110 space size and bitwidth. The configuration tool was developed in order to facilitate configuration of the processor for the chosen specification. The processor design flow was established starting from a specification stage and finishing with the processor implementation in hardware and running an application program. The design flow invokes tools from different vendors and augmented with the custom tool connecting design stages. Following the design flow the selected processor configurations were implemented on Xilinx and Altera FPGA platforms. The full portability of the design was verified using 0.18 11m TSMC technology process for implementation. In order to maximize verification coverage, the specific testbench was developed and used for the design validation. The simulation of the design was performed on the behavioral and post-route levels for the selected configurations. In order to increase

87

verification confidence, one selected processor configuration was implemented in the hardware development board. The additional VO hardware interfaces were developed connecting the selected processor core with LCD screen and inputting device. In addition to the testbench, the specific software driver was developed for communication with the development board

va devices. As a result the demo design was successfully verified.

The implementation of the proposed processor variants on the different hardware platforms created the exploration space. This space was analyzed in order to determine the dependencies between implemented configuration options and technical parameters of the resulted processor. Major trends and rules for utilization of the specific configuration options were derived. The wide spectrum of the possible processor configurations provides an opportunity to optimize the selection of a processor for the specific application. Comparison to the existing commercial and research solutions revealed advantages and disadvantages of the designed processor. The advantages include high portability, unique configuration options, and wide range of the processor variants.

7.2

Future Work

The processor design presented in this project explored only a limited number of the configuration options. The potential for the further improvement includes many advanced features inherent in modem processors. The list of the processor enhancements that can increase the performance of the presented processor includes but not limited by the following: · · · · · · · · · Multiplier Divider Multilevel instruction and data caches Floating Point Unit (FPU) Memory Management Unit (MMU) Translation Look-aside Buffer (TLB) Dynamic branch prediction Superscalar architecture Unaligned data memory access

88

The proposed processor pipeIined architecture considers only five and four stages variants. The future work may explore the architectures with shorter or longer pipelines and define benefits and trade-offs of these designs. The presented processor design is based on the existing MIPS instruction set which is oriented toward the standard 32-bit data path. Therefore, the expansion of the instruction set with specific commands capable of the efficient handling of wider data words would increase the performance of processor configurations with wide data paths. The standard MIPS software development tools cannot support all possible improvements. Hence the development of the advanced software tools is required in order to use efficiently all described processor enhancements. The developed Configuration Manager tool may include the additional feature providing the speed and hardware resources for the selected processor configuration. This feature would facilitate a choice of the processor configuration optimized for the specific application. Moreover, the configuration process may be completely automatic driven by the application parameters entered by a user. The portability of the presented design has been verified only on three different hardware platforms. The future work may extend the implementation hardware with other FPGA families such as Actel, Latice, Atmel, Achronix, etc. The performance of the proposed processor configurations may be estimated with better accuracy by execution of the standard benchmarks such as Dhrystone, SPEC, Whetstone, etc. Evolution of the presented configurable processor introduces an opportunity for development of a processor solution far beyond the explored in this project.

89

Appendix A
Demo Design Program Code
II 1/0 ports mapped to drnem addresses #define FIB_OUT «volatile int*) Ox00000010l #define LCD_aUT_PORT «volatile int*) Ox00000014) II 5 :LCD_OUT_PORT {led output data, led drive, led rs, led rw control, led e} #define FIB=IN_NUM «volatile int*)-Ox00000008) -II 2 :Input for Fibonacci number calculation II Delays definitions #define DELAY40ns 0 #define DELAY230ns 1 #define DELAY15ms 75000 #define DELAY4 Ims 20500 #define DELAYIOOus 500 #define DELAY40us 200 #define DELAYlus 5
int fib () i void Wait15ms (); void Wait4_1ms ()i void WaitlOOus (); void Wait40us (l; void Wait40ns (); void Wait230ns (li void Wai tlus (); void Write4bitsLCD (); void Write8bitsLCD {li void Displaylnit {)i void DisplayConfig (); void SetAddr(}; void WriteData(); void DrawFib(); void DrawEqu(}; void DrawFib_N(); void DrawHexNum{);II"Draw 4 hex digits number unsigned int Hex2LcdChar(); int start () { int N; Ilint result; II*FIB OUT = fib(N); *LCD OUT PORT = Oxfffffffe; DisplayInit()i DisplayConfig(); for (; ; ) II Display in loop
{

II Display "Fib(" N "1-" fib(N)
N - *FIB_IN_NUM;

90

SetAddr{O); DrawFib(l; DrawFib N(N); DrawEqu() i DrawHexNum{fib(N»);

int fib(int nl { if (n==O) {return Ii} if (n==I) {return I;} return (fib(n-l) + fib(n-2»;
}

void Waitl5ms ()
{

unsigned int i; for (i = 0; i < DELAYI5ms; i++); void Wait4 Ims ()
{

unsigned int i; for (i 0; i < DELAY4_1ms; i++);

void Waitl00us ()
{

unsigned int i: for (i = 0; i < DELAYI00us; i++);

void Wait40us (l
{

unsigned int i; for (i = 0; i < DELAY40us; i++l; void Wait40ns ()
{

unsigned int i; for (i = 0; i < DELAY40ns; i++); void Wait230ns ()
{

unsigned int i; for (i = 0; i < DELAY230ns; i++); void Waitlus {l
{

unsigned int i; for (i = 0; i < DELAYlusi i++);

91

void Write4bitsLCD (unsigned int lcddata, unsigned int lcd_rs)
{

unsigned int datasend datasend datasend data send data send lcddata;

Oxffffffff;

datasend«l: datasend I Ox1: Illcd_drive =1 datasend«l:

II lcd rs =1

datasend data send I lcd rs: II 1 ->data I 0 -> command datasend datasend«2: II-led rw control = 0, led e = 0 *LCD OUT PORT = datasend: II send-to port Wait40ns(): datasend = datasend I Ox1: Illcd_e 1 *LCD OUT PORT = datasend: II send to port Wait230ns (); datasend = datasend & Oxfffffffe: Illcd_e *LCD_OUT_PORT = datasend: II send to port datasend datasend I OxOa: lied rw control *LCD OUT PORT = datasend: II send to port 0 1

void Write8bitsLCD (unsigned int leddata, unsigned int
{

lcd~rs)

unsigned int upper_nibble: upper nibble = lcddata»4: Write4bitsLCD (upper_nibble, lcd_rsJ: II write upper nibble Waitlus(): Write4bitsLCD (lcddata, lcd_rs); Wait40us{J: void Displaylnit
{ ()

II write low nibble

*LCD OUT PORT Wait 15ms () :

Oxfffffffe; Iiset lcd e low

Write4bitsLCD (Ox03,O); Wait4 1ms();

-

Write4bitsLCD (Ox03,O): WaitlOOus(); Write4bitsLCD (Ox03,O); Wait40us();

92

Write4bitsLCD (Ox02,O): Wait40us(); void DisplayConfig ()
{

WriteSbitsLCD WriteSbitsLCD WriteSbitsLCD Write8bitsLCD Wait4_lms();

(Ox2S,O); IIFunction Set (Ox06,O); IIEntry Mode Set (OxOe,O); IIDisplay On/Off (OxOl,O); IIClear Display

void SetAddr(unsigned int addr) unsigned int addr_send = addr I OxSO; WriteSbitsLCD (addr_send,O); void WriteData(unsigned int data)
{

IISet DD RAM Address

Write8bitsLCD (data,l); IIWrite Data to CG RAM or DD RAM void DrawFib()
{

II"Draw "Fib{" II II II II
draw draw draw draw F i b (

WriteData{Ox46); WriteData{Ox69)i WriteData{Ox62); WriteData(Ox28);

void DrawFib_N(unsigned int fib_num)II"Draw N
{

unsigned int send_nibble; send nibble = fib num » 4; WriteData{ Hex2LcdChar(send_nibble) ); send nibble = fib num; WriteData{ Hex2LcdChar{send_nibble) )i void DrawEqu{)
{

II draw lower nibble

II"Draw ")=" II draw II draw

WriteData(Ox29); WriteData(Ox3d)i

void DrawHexNum(unsigned int hex_num)II"Draw 4 hex digits number
{

unsigned int send_nibble: send nibble = hex num » 12; WriteData{ Hex2LcdChar{send_nibble) ); send nibble

II draw 4th nibble

= hex

num »

8;

93

WriteData( Hex2LedChar(send_nibble) ); II draw 3rd nibble send nibble hex nUID » 4; WriteData( Hex2LedChar(send_nibble) );
II draw 2nd nibble

send nibble = hex num ; WriteData( Hex2LCdChar(send_nibble) )i II draw lower nibble unsigned int Hex2LcdChar(unsigned int hex_nib)IIConvert hex nibble to LCD char
{

unsigned int lcd_nibble; led nibble = hex nib & OxOOOOOOOf; if (lcd_nibble >9)
{

led nibble (lcd_nibble & Ox07) -1; II 0111, convert to A-F led nibble 1= Ox40; else led nibble return Ox30;

led nibble;

94

AppendixB
Processor Configuration File
B.1 Base Configuration File Template
'ifdef _PROCESSOR_CONFIG_FLAT_V_ 'else 'define _PROCESSOR_CONFIG_FLAT_V_ IIProcessor architecture definitions

11---------------------------------------------------------------------11--------------------------------------------------------------------'define MIPS PROCESSOR

'define processor inst width 32 Iinot reconfigurable(reserved) II Instruction format 'define inst opcode width 6 'define inst-funct ;idth 6 'define inst-shamt-width 5 lIThe branch-bug handling in the PCSpim compiler 'define PCSpim compiler 'ifdef PCSpim-compiler 'define Branch=jump PC_next<=PC+immediate; 'else 'define Branch_jump PC_next<-PC+'imem_step+immediate; 'endif II debug provision 'define BREAK ADDRO 'hlc/4 'define BREAK-ADDRl 'h274/4 'define BREAK-ADDR2 'h390/4 'h3lc/4 'define BREAK=ADDR3 I/'include "auto_configyart.v"
11**************************************************** ******************

II Automatically Generated Section of Configuration File
11**************************************************** ****************** //**********************************************************************

II Global processor definitons
//**********************************************************************

11---------=----------------------------------------------------------'define processor_data_width 32
II Instruction Memory definitions
'define 'define 'define 'define imem size 1024 imem-step 1 imem-addr width imem=shift 0 10

'define SHIFT_COMMANDS 'define SET CO~.ANDS

95

// Data Memory definitions 'define dmem size 1024 'define dmem-step 4 'define dmem-addr width 10 1/ Data Memory Mapping 'define dmem_up_limit 'hBfffffff 'define dmem down limit 'hlOOOOOOO II I/O Memory definitions 'define io mem size 1024 'define io-mem-width 32 'define io-addr width 10 1/ 1/0 memory mapping 'define io mem down limit 'hO 'define io-mem-up limit 'h400000 II PC width - 'define PC width 32 I/PC start-address 'define reset addr 'hB0020000 /1 SP start address 'define SP_INIT 'h800bcOOO

//=-~~~~--------~~~---------------------------- IIEnd of global processor definitons
1/**************************************************** ******************

//.~~~~~~~~~~~~~~~~~~~~~~~~~~77
//**********************************************************************

I/Register file definitons 'define REGISTER FILE regfile /Iregfile module name 'define regfile addr width 5 111< Register file address width 'define regfile-size-(l«'regfile addr width) 11/< Register file size 'define regfile-width 'processor data ;idth ///< Register file width 'define link addr 31 I/Address of link register (return address - raj IIEnd of register file definitons
11**************************************************** ******************

I/-----------------Architecture Configuration--------------------------/I*****************************************~********** ******************

//Pipeline Interstage Register

//---------------------------------------------------------------------// interstage-9ass --> dummy reg pass
1/ interstage data reg --> reg
// Control Unit configuration

definitons

//-----------~----~-----------------------------------------------------

//---------------------------------------------------------------------'ifdef MIPS_MULTI CYCLE
'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define IF_ID_INST_REG ID_EX_IMM_REG ID_EX_PC_REG ID_EX_A_REG ID EX B REG IO=EX=SHAMT_REG EX MEM RESUT REG EX=MEM=T_REGMEM_WB_DMEM_REG MEM_WB_ALU_REG IF IO PC REG ID=EX=RS=ADDR_REG ID_EX_RT_ADDR_REG ID_EX_RO_AOOR_REG EX_MEM_RD_W_ADDR_REG MEM_WB_RD_W_AODR_REG interstage_data_reg interstage-9ass interstage-9ass interstage_data_reg interstage_data_reg interstage-Fass interstage data reg interstageyassinterstage_data_reg interstage-Fass interstage-9ass interstage-9ass interstage-9ass interstage-Fass interstage-Fass interstage-9ass

//--------~------------------------------------------------------------//--------~-----=------------------------------------------------------'define NO DELAY SLOT 'define CONTROL UNIT ONECYCLE

//---------------------------------------------------------------------'define NO FORWARDING
control mcycle//control unit module name

//-------------=------------------------------------=------------------'elsif

96

11--------------------------------------------------------------------'define NO FORWARDING 11--------=-----------------------------------------------------------'define NO DELAY SLOT 11--------=-----=-----------------------------------------------------'define CONTROL_UNIT control_onecyclellcontrol unit 11---------------------------------------------------- -----------------'elsif 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define FOURSTAGES IF_ID_INST_REG ID_EX_IMM_REG ID_EX_PC_REG IO_EX_A_REG ID_EX_B_REG ID_EX_SHAMT_REG EX_MEM_RESUT_REG EX_MEM_T_REG MEM_WB_DMEM_REG MEM_WB_ALU_REG IF_IO_PC_REG ID EX RS ADOR REG ID:EX:RT:ADOR:REG ID_EX_RO_ADDR_REG EX_MEM_RO_W_ADOR_REG MEM WB RO W ADOR REG interstage data reg interstage-data-reg interstage data reg interstage-data-reg interstage data reg -Interstage data reg interstage-pass -interstage-pass interstage data reg int-erstage data reg interstage_data_reg interstage data reg interstage-data-reg - interstage data reg interstage-pass -interstage data reg

'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define

IF 10 INST REG IO-EX-IMM REG IO-EX-PC REG IO:EX:A_REG IO_EX_B_REG 10 EX S~~T REG EX-MEM RESUT REG EX:MEM:T_REGMEM_WB_DMEM_REG MEM_WB_ALU_REG IF_IO_PC_REG ID_EX_RS_ADOR_REG ID_EX_RT_ADOR_REG ID_EX_RO_ADDR_REG EX_MEM_RO_W_ADDR_REG MEM_WB_RD_W_ADDR_REG

interstage-pass interstage-pass interstage-pass interstage-pass interstage-pass interstage-pass interstage-pass interstage-pass interstage-pass interstage-pass interstage-pass interstage pass interstage-pass - interstage-pass interstage_pass interstage-pass

module name

11---------=--=--=-=----=------------------=----=---------------------'define FORWARDING 4 STAGES 11----------------=-=-------------------------------------------------'define CONTROL UNIT control-pipe 4st Ilcontrol 11-------------=-----------------------------------------=-------------'else II 5-stages pipeline
'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define IF_IO_INST_REG 10 EX IMM REG ID:EX:PC_REG ID EX A REG IO-EX-B-REG ID-EX-SHAMT REG EX:MEM_RESUT_REG EX MEM T REG MEM WB-DMEM REG MEM:WB:ALU_REG IF 10 PC REG IO-EX-RS-ADDR REG IO-EX-RT-AODR-REG ID-EX-RD-ADDR-REG EX:MEM_RD_W_ADDR_REG MEM WB RO W ADDR REG interstage data reg interstage-data-reg int-erstage data reg interstage:data:reg interstage data reg Interstage data reg interstage data reg -interstage-data-reg interstage-data-reg intersta-ge_data_reg interstage_data_reg interstage_data_reg interstage data reg - interstage_data_reg interstage data reg interstage:data:reg

unit module name

II---------=--=--=-~----=-----------------------------------------------

11----------------=-=-------------------------------------------------'define CONTROL UNIT control-pipe Ilcontrol unit
/I-------------~--------------------------------------------------------

'define FORWARDING 5 STAGES

module name

97

'endif IIEnd of Configurable Architecture definitons 11 ________________________________________________________ __
//**********************************************************************

IIALO definitons
11**************************************************** ******************

'define ALO alu behav II alu module name 'define alu_operand_width 'processor_data_width 111< ALO operand bit width

IIALO opcodes
'define 'define 'define 'define 'define 'define 'define 'define 'define 'hO alu add alu-subb 'hl alu-and 'h2 alu-or 'h3 alu-nor 'h4 'h5 alu:=xor alu_up 'h6 'h7 alu a alu:=opcode_width 3 1/1< ALO opcode bit width

'ifdef SHIFT COMMANDS 'define alu sll 'hB 'define alu:=srl 'h9 'define alu sra 'ha 'define alu-sllv 'hb 'define alu:=srlv 'he 'define alu srav 'hd 11 ......... :-........................ ................ . 'define alu_opcode_width 4 111< ALO opcode bit width 'endif 'ifdef SET COMMANDS 'define alii slt 'he 'define alu-sltu 'hf 'define alu:=opcode_width 4 111< ALO opcode bit width 'endif 'define alu_opcodes_number (l«'alu_opcode_width) /11< Number of ALO opcodes

//1/11/1111111111111111 /IEnd of ALO definitons
11**************************************************** ******************

11.77~~~~~~~~~~77~~~~~~~~~~~~~~~
IIData memory definitons
//**********************************************************************

'define DATA MEMORY data ram /Idata memory module name 'define dmem-width 'processor data width IIData memory bit width IIEnd of data memory definitons II~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~* ~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*7*

II

IIInput/OUtput memory map definitons
11**************************************************** ******************

'define io_mem_step 4 III/O memory step (how sw addresses it) IIEnd of data memory definitons
//**********************************************************************

/IInstruction register definitons
1/**************************************************** ******************

'define INST REG inst reg I/instruction register module name 'define inst-reg width 'processor inst width //Data memory bit width IIEnd of instruction register definitons
1/**************************************************** ******************

11.~~~~~~~~~~~77~~~~~~~~~~~~~~77
'define INST MEMORY inst mem //instruction memory module name 'define imem-width 'processor inst width /IBit width of the instruction memory I/End of instruction memory definitons

IIInstruction memory definitons
1/**************************************************** ******************

98

//.77~77~~~------------------------------------------- /I~*************************************************** ******************
/IControl module definitons
11**************************************************** ******************

/I----------FSM states------------------------------------------------'define FETCH o 'define DECODE I 'define EXECUTE R TYPE 2 'define EXECUTE-BRANCH 3 'define EXECUTE-MEM TYPE 4 'define EXECOTE-J TYPE 5 'define EXECUTE-IMM TYPE 6 'define MEM_ACCESS 7 'define WR_BACK B 'define LAST STATE 9
11**************************************************** ******************

/IControl commands definitions
1/**************************************************** ******************

// Nex PC source controls

/1-------------------------------------------------------------------'define next_instruction 0
'define imm jump 'define branch 'define rs_jump II'define stall~c 'define nextPCsrc_width I 2 3 4 2 Illog2('rs_jump) ->width of nextPCsrc

II Write Back Register destination controls

/1---------------------------------------------------- ----------------/1-------------------------------------------------------------------'define ra_reg 0
'define rt reg 1 'define rd=reg 2 'define wb_addr_src_width 2 Illog2('rd_reg) ->width of wb_addr_src

/1-------------------------------------------------------------------II ALO forwarding controls 11-------------------------------------------------------------------'define reg ex 0 1/ regile data from ID/EX stage

/1---------=---=---=-------------------=-------------- ----=-=---=------ - - //--------------------------------------------------------------------II'define reg ex 0 /1 regile data from ID/EX stage
// ALO operand source controls

'define fwd-mem I II forwarding from EX/MEM stage 'define fwd=wb 2 II forwarding from MEM/wB stage 'define alu src fwd width 2 Illog2('fwd wb) ->width of alu a src frw/alu b src frw

//---------=-=---=---------------------=--------------------=-=-------II Write Back data source controls 11-------------------------------------------------------------------'define alu wb 0 II ALO data
'define dmem_wb I 'define wb data src width
/1 Data MEM input data source controls

1/ Operand A 'define pc ex I II PC from ID/EX stage 'define alu a src width I l/log2('pc_ex) ->width of alu_a_src /1 Operand B 'define imm ex I // Immediate from ID/EX stage 'define plus_step 2 II + imem step (support of jal command R[31]=PC+B;PC=JumpAddr) 'define shift step 3 // multicycle verson bqe/bne support 'define alu b-src width 2 l/log2('shift step) ->width of alu b src

II Data Mem data I /llog2('dmem wb) ->width of wb data src

/1--------=----=---=------------------------=--------- --------=----=--//--------------------------------------------------------------------'define dmem data 0 II DMEM regular data input 1/----------=----=---=----------------------=-------------------=----= I/Rs jump source controls 11-------------------------------------------------------------------'define j rs id 0 /1 rs data from ID stage
'define fwd mem 1 /1 forwarding from MEM stage 'define fwd-wb 2 II forwarding from WB stage 'define jr_src_frw_width 2 Illog2('fwd_wb) ->width of jr_src_frw 'define dmem=fwd 'define dmem data erc width I II DMEM forwarded data input from WB stage 1 l/log2('dmem fwd) ->width of dmem data src

99

11-------------------------------------------------------------------II Comparator forwarding controls 11-------------------------------------------------------------------'define cmp_reg 0 II regile data from IDIEX stage
IIParse instruction definitons

'define cmp fwd 1 II forwarding from EX/MEM 'define cmp=src_fwd_width 1 Illog2('cmp_fwd) ->width of cmp_rs_src_fwd/cmp_rt_src_fwd

11**************************************************** ******************

II--~~--~~~~~--~~~~~~~~--------~~~~~~~

1/**************************************************** ******************

IIProcessor opcode up limit 'define opcode up 'processor inst width-l IIProcessor opcode down limit 'define opcode_down 'processor_inst_width-'inst_opcode_width IIProcessor immediate up limit 'define immediate up 'processor inst width -'inst opcode width-('regfile addr width*2)-1 IIProcessor shift-amount up limit 'define shamt_up 'processor_inst_width -'inst_opcode_width-C'regfile_addr_width*3)-l IIProcessor shift amount down limit 'define shamt down 'shamt up - 'inst shamt width +1 IIProcessor jump address up limit 'define jump addr up 'processor inst width -'inst opcode width-1 IIProcessor sign extension width -'define sign ext width 'processor data width-('immediate up+1) IIProcessor sign-extension width 'define zero_ext_width 'processor_data_width-('immediate_up) II Register Rs 'define rs addr up 'inst reg width-'inst opcode width-l 'define rs - addr-down addr up-' regfile addr width+1 II Register Rt -'define rt addr up 'rs addr down - 1 'define rt-addr-down 'rt addr up - 'regfile_addr_width + 1 II Register Rd -'define rd addr up 'rt addr down-1 'define rd-addr-down 'rd addr up-'regfile addr width+1 IIEnd of parse Instruction definitons -

'rs

II~-----------------------------------------------------//**********************************************************************

IIMIPS instruction Set definitions
//**********************************************************************

fiR type instructon functions
'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define ADD ADDU SUB SUBU AND OR XOR NOR SLT SLTU SLL SRL SRA SLLV SRLV SRAV
JR

JARL MOVZ MOVN SYSCALL BREAK SYNC MFHI MTHI MFLO MTLO

'h20 'h21 'h22 'h23 'h24 'h25 'h26 'h2? 'h2a 'h2b 'hO 'h2 'h3 'h4 'h6 'h? 'he 'h9 'ha 'hb 'hc 'hd 'hf 'hlO 'hll 'h12 'h13

100

'define 'define 'define 'define 'define , define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define 'define

MULT MULU DIV DIVU TGE TGEU TLTT TLTU TEQ TNE R TYPE JJAL BEQ BNE BLEZ BGTZ ADDI ADDIO SLT1 SLTIU ANDI OR1 XORI LUI LB
La

'hI8 'hI9 'hla 'hIb 'h30 'h31 'h32 'h33 'h34 'h36 'hO 'h2 'h3 'h4 'h5 'h6 'h'7 'he 'h9 'ha
'hb

1/ Instruction opcodes

LWL LW LBU LHU LWR

~

sa
SH SWL SW SWR CACHE LL LWCI LWC2 PREF LDCI LDC2 SC swCI swC2 SDCl SDC2

'hc 'hd 'he 'hf 'h20 'h21 'h22 'h23 'h24 'h25 'h26 'h28 'h29 'h2a 'h2b 'h2e 'h2f th30 th31 'h32 'h33 'h35 'h36 'h38 th39 th3a 'h3d 'h3e

11111111111111/11111111

IIEnd of MIPS instruction Set definitions 'ifdef DLX_PROCESSOR
11**************************************************** ******************

IIDLX instruction Set definitions
11**************************************************** ******************

//R type instructon functions 'define ADD 'h20 'define sua 'h22 'define AND 'h24 'define OR 'h25 'define XOR 'h26 'define SEQ 'define SLT 'define SLE 'h28 'h2a 'h2c

101

'define SNE 'define SLL 'define SRL 'define SM

'h29 'h4 'h6
'h7

II Instruction opeodes 'define R TYPE 'hO 'define J'h2 'define JAL 'h3 'define BEQZ 'h4 'define BNEZ 'h5 'define ADDI 'hB 'define SOBI 'ha 'define ANDI 'he 'define ORI 'hd 'define XORI 'he 'define LHI 'hf 'define JR 'hIZ 'define JARL 'h13 'define SLLI 'h14 'define SRLI 'h16 'define SEQ I 'hIB 'define SMI 'h17 'define SNEI 'h19 'define SLTI 'hla 'define SLEI 'hIe 'define LW 'hZ3 'define SW 'hZb

111111I1II1III111I11111 II
fiEnd of DLX instruction Set definitions
'e-n~d~i~f-'/~/~D~L~X~-------------------------------------------------------

'endif II _PROCESSOR_CONFIG FLAT V

B.2 Automatically Generated Part of Configuration File
The example is shown for the 5-stages architecture with the full support of the instruction set and BRAM optimizaiton.

//**********************************************************************

// Automatically Generated Section of Configuration File
//********************************************************************** //**********************************************************************

// Global processor definitons
//**********************************************************************

'define SHIFT COMMANDS 'define SET COMMANDS 'define processor data width 256 // Instruction Memory definitions 'define imem_size 1024 'define imem_step 1 'define imem addr width 10 'define imem-shift 0 // Data Memory definitions 'define dmem size 1024

102

'define 'define II Data 'define 'define

drnem step 4 drnem-addr width 10 Memory Mapping drnem up limit 'h80000000 drnem-down limit 'hlOOOOOOO II Ilo Memory definitions 'define io mem size 1024 'define io-mem-width 32 'define io-addr width 10 II IIO memory mapping 'define io mem down limit 'hO 'define io-mem-up limit 'h400000 II PC width - 'define PC width 32 IIPC start-address 'define reset addr 'h400000 II SP start address 'define SP INIT 'h7ffffffc II Padding-of PC bitwidth natural('processor_data_width-'PC_width) 'define PC_padding 224 'define FPGA BRAM

103

Appendix C
Implementation Reports
C.l Xilinx Summary Reports
Implementation report for the following processor configuration: · · · ·
.
~

4-stage architecture 256-bit data path BRAM optimization Full instruction set support
~

'>"

,..

",

-~

,

.

'Project File: :Module , iName : iTarget ,Device: ,Product ,Version:

mips dlx.ise mips_dlx xc5vlx50Iff324 ISE 9.2.04i

MIPS D~~ Project Status Current State: · Errors:

-,,~

.

Placed and Routed No Errors 318 Warnings Tue Feb 2 19:18:582010
""

· Warnings:

·

Updated:

I

MIPS_DLX Parti!i~~~Suinmary ;No partition information was found. ~ Device Utilization Summa.lJ' ... Used Available ,Slice Logic Utilization 1,635 28,800 iNumber of Slice Registers Number used as Flip Flops 1,634 Number used as Latch-thrus 1 8,720 28,800 iNumber of Slice LUTs 8,203 Number used as logic 28,800 Number using 06 output 8,063 ,only Number using 05 and 06 140 516 Number used as Memory 7,680 Number used as Dual 516 ,Port RAM Number using 06 4 ,output only

.. _.

_~.~,_ ' ... " .· ~' .... " .....

-

.. I:

i
.~---

.. -

Utilization 5%

Note{s)

30% 28%

,
i

6%

104

Number using 05 ioutput only Number using 05 and 106 I I, Number used as exclusive Iroute-thru iNumber of route-thrus I Number using 05 and 06 ,Slice Logic Distribution INumber of occupied Slices Number of LUT Flip Flop pairs used I Number with an unused ,Flip Flop I, Number with an unused ,LUT I, Number of fully used LUTIFF pairs Number of unique control sets I lID Utilization Number of bonded lOBs jSpecific Feature Utilization ]Number of BlockRAMIFIFO

I.

4 508 1

1
1

57,600

1%

11
2,879 10,330 8,695 1,610 25 9 10,330 10,330 10,330 84% 15% 1% 7,200 39%

I!

78
1

220

35%
i

481
9

0

I

I.
I,

Number using B10ckRAM pnly iTotal primitives used

Number of36k BlockRAM used

7 3
i

\, Number of 18k BlockRAM used , ITotal Memory used (KB) Number of :BUFGIBUFGCTRLS I Number used as BUFGs ITotal equivalent gate count ,for design IAdditional JTAG gate count [for lOBs

306 1
1

1,728 32

17% 3%

1,321,378 3,744
_.. ··_. " " "'r." ·

t

-,

"

"
~,
,"
'

I

,
".-.~

' . , """,,;,

,~---

..

.'

Performall~~~~!l~Il1f!1a,ry~

,
· '"., "j.I.' ',' ."

105

Final Timing iScore: Routing :Results: ITiming ,Constraints:
I

0 All Signals Completely Routed All Constraints Met

Pinout Data: Clock Data:

Pinout Report Clock Report

t . ""._

'

"~

-

,Report Name Status iSynthesis IReport l!ranslation IReport Current

Current

IMap Report
lPlace and I IRoute Report

Current

Current

:Static Timing Current IReport ,Bitgen Report

Detailed ~eports Generated Errors Tue Feb 2 18:39:14 0 2010 Tue Feb 2 0 18:40:14 2010 Tue Feb 2 18:56:39 0 2010 TueFeb 2 19:17:29 0 2010 Tue Feb 2 0 19:18:57 2010

Warnings lnfos 140 71nfos Warnings 0 0

177 61nfos Warnings 1 Warning 1 Info

0

21nfos

106

Implementation report for the following processor configuration: · · · · 5-stages architecture 128-bit data path No BRAM optimization Full instruction set support

,Project File: iModule iNa me: l:rarget ,Device: ;Product IVersion:

.". " mips_dlx.ise
~ ~

"'-"-"'"

mips_dlx xc5vlx501ff324 ISE 9.2.04i
t; , - " .... "r'~ ' ··

"'. MI}>S_DJ.lX proje(!t Status !Current State: Placed and Routed · Errors: No Errors
.

.·.

· ·

Warnings: Updated:

218 Warnings Sun Jan 1723:41 :032010
I

. ~)\1WS_DLXParti~io!!.~u!D_ID!ry .. -.-. INo partition information was found. Device Utilization Summ~ry .. ... Utilization Used Available ISHee Logic Utilization 3% 1,006 28,800 iNumber of Slice Registers Number used as Flip Flops 1,005 1 Number used as Latch-thrus 16% 4,757 28,800 ;Number of Slice LUTs 13% 28,800 3,988 Number used as logic
"-'.
~.
,y

~

".
I

Note(s)

i
·

Number using 06 output ,only Number using 05 and 06 Number used as Memory I Number used as Dual Port RAM Number using 05 and 106

3,887 101 768 256 256 512 512

I

7,680

10%

I

I

I, Number used as Single ,Port RAM Number using 06 :output only I, Number used as exclusive route-thru ;Number ofroute-thrus Number using 05 and 06 ;Slice Logic Distribution
·

1 1 1
57,600 1%
I

107

iNumber of occupied Slices Number ofLUT Flip Flop pairs [used 1 Number with an unused Flip :Flop I Number with an unused LUT I Number of fully used LUTFF pairs I, Number of unique control ,sets 10 Utilization IN umber of bonded JOBs $pecific Feature Utilization INumberof ,BUFGIBUFGCTRLs Number used as BUFGs ITotal equivalent gate count lor design !Additional JTAG gate count for ,lOBs
.......,..... -"
~

1,841 5,739 4,733 982 24 7

7,200

25%

I

I
I

5,739 5,739 5,739

82% 17% 1%

I
I

78

220

35%

1

32

3%

1
169,476 3,744
"
" .. " ' "
-~-

,

J

'"

" \-.-

,Final Timing IScore: IRouting Results: I jTiming ;Constraints:

·J:>er!<?!!Dance Sum!Dary . Pinout 0 Pinout Re;Qort Data: All Signals Com;Qletel,Y ICIOCk Clock Re;Qort Routed Data:
"

--

,,-,j

All Constraints Met
,.

,,.,:., '. ]Report Name
","..

,,".,

Status Current Current Current Current Current

Synthesis Re;Qort ITranslation Re;Qort
I

IMa;Q Re;Qort iPlace and Route Re;Qort
i

IStatic Timing Re;Qort :Bitgen Report

" .Detailed Reports,. Generated Errors Sun Jan 17 0 15:01:282010 Sun Jan 17 0 23:32:072010 Sun Jan 17 0 23:39:342010 Sun Jan 17 0 23:40:382010 Sun Jan 17 0 23:41 :022010

,

..... ,

'"

'~"

<,.",d

".

~

~

"

Warnings InCos 124 7 Infos Warnings 1 Warning 0 92 Warnings 6 Infos

1 Warning 1 Info
0 2 Infos

108

Implementation report for the following processor configuration: · · · · One-cycle architecture 16-bit data path No BRAM optimization Reduced instruction set
,

;Project File: :Module ;Name:

mips dlx.ise mips_dlx xc5vlx50lff324 ISE 9.2.04i
'

MIPS DLX Project Status Placed and Routed !Current State: · Errors: No Errors

I

I!ar~et

· ·

Warnings: Updated:

pevlce:

130 Warnings Thu Feb 11 19:14:572010

;Product IVersion:

, MIPS DLX Partition Summary. iNo partition information was found. Device Utilization Summary .. Used Available Utilization ~Slice Logic Utilization 28,800 INumber of Slice Registers 10 Number used as Flip Flops 10 28,800 ;Number of Slice LUTs 419 28,800 Number used as logic 323 Number using 06 output 323 lonly I Number used as Memory 1 7,6801 961 I Number used as Dual Port RAM Number using 05 and I 32 .06 i Number used as Single 64 Port RAM I Number using 06 64 ,output only 57,600 1 ,Number of route-thrus Number using 05 output 1 ;only ;Slice Logic Distribution 7,200 135 ]Number of occupied Slices
.. ,'
~_A'

r

"

"

Note(s) 1% 1% 1%

I

I

j

1%

1%

Number ofLUT Flip Flop pairs ~used

419

109

I. Number with an unused Flip

I

,Flop Number with an unused ,LUT 1 Number of fully used LUTiFF pairs I. Number of unique control sets :10 Utilization jNumber of bonded lOBs ISpecific Feature Utilization INumberof iBUFGIBUFGCTRLs 1 Number used as BUFGs [Total equivalent gate count ,for design lAdditional JTAG gate count lor lOBs

409 0 10 3 62
1 1

419 419 419

97% 0% 2%

220 32

28% 3%

18,941 2,976
, ,

I '

,-

-_.

jFinal Timing jScore: (ROUting Results: ITiming ,Constraints:

Performan~e ~lImltlary Pinout Pinout Report 0 Data: All Signals Completely Clock Clock Report Routed Data:
"

....

All Constraints Met
.'""", .

t ___

.. _,c ..

,,:',',',,''.

,Report Name :SynthesiS Report ITranslation Report I. IMap Report

Status Current Current Current Current Current

I

IPlace and Route Report

jStatic Timing Report ,Bitgen Report

_ Det~!I~d. ~eports ,,,.". Errors iGenerated ThuFeb 11 0 19:09:192010 Thu Feb 11 0 19:13:032010 ThuFeb 11 0 19:14:142010 Thu Feb 11 0 19:14:432010 Thu Feb 11 0 ]9:14:572010
' ,

- --."

,,-

.

' '"j', ,,"

"",~

"'.

Warnings Infos 100 3lnfos Warnings 5 Warnings 0 24 Warnings 61nfos

i

1 Warning 1 Info 0 21nfos

110

C.2 BRAM Utilization Reports
Excerpt from the synthesis report in case of the successful BRAM utilization:
INFO:Xst:2694 - Unit <inst mem> : The ROM <Mrom_data_out_asynch> will be implemented as a read-only BLOCK RAM, absorbing the register: <data out>. INFO:Xst:2690 - Unit <data ram> : The BLOCK RAM
RF~

<Mram ram> will be implemented as

Excerpt from the synthesis report ifBRAM optimization is not used:
HDL ADVISOR - Unit <data_ram> : The RAM <Mram_ram> will be implemented on LUTs either because you have described an asynchronous read or because of currently unsupported block RAM features. If you have described an asynchronous read, making it synchronous would allow you to take advantage of available block RAM resources, for optimized device usage and improved timings. Please refer to your documentation for coding guidelines.

111

AppendixD
TSMC 0.18 11m Process Implementation
Synopsys Design Analyzer script for compilation of the five-stage pipeUned architecture
sh rm -Rf Work sh mkdir Work define_design_lib Work -path "./Work" analyze analyze analyze analyze analyze analyze analyze analyze -format -format -format -format -format -format -format -format verilog verilog verilog verilog verilog verilog verilog verilog -lib -lib -lib -lib -lib -lib -lib -lib WORK WORK WORK WORK WORK WORK WORK WORK {"control_pipe. v"} {"mips_dlx.v"} {"memory. v"} {"processor_alu.v"} {"interstage_pass.v"} {"interstage_data_reg.v"} {"regfile.v"} {"inst_mem.v"}

elaborate mips_dlx -arch "verilog" -lib DEFAULT -update set load set-load set load set load
20 20 20 20

"io mem write enable" "io-mem-enable" "io-mem-addr*" "io mem data in*" "clk" }

create_clock -name "clk" -period 4 -waveform "0" "2" } { set_dont_touch_network find( clock, "clk") set clock skew -propagated clk set_clock_skew -plus_uncertainty 0.1 "clk" set clock skew -minus uncertainty 0.1 "clk" set-fix multiple port-nets -all write -format db--hierarchy -output "mips_constrained. db" {ttmips_dlx.db:mips_dlx"} remove_design find(design n*,,) read -format db {"mips constrained.db"} current design "mips constrained.db:mips dlx" compile--ungroup_allcurrent design "mips constrained.db:mips dlx" write -format db -hierarchy -output ttmips compilel.db" {"mips_constrained.db:mips_dlx"} -

112

report_area report_constraints report timing -path full check_design

max -max-paths 1 -nworst 1

remove design find(design u*") read -format db {"mips compile1.db"} current design "mips compile1.db:mips dlx" compile--map_effort high -incremental=map write -format db -hierarchy -output "mips_compile2.db" {"mips_compilel.db:mips_dlx"} report area report=constraints report_timing full -delay max -max_paths 1 -nworst 1

check design change names -hier -rule verilog write =format verilog -hierarchy -output "mips_gate.v" { .db:mips_dlx"}

113

AppendixE
Demo Design Constraints and Report
NET "clk" TNM NET TIMESPEC "TS_clk" "clk"; PERIOD "clk" 20.0ns HIGH 50 %;

NET "clk" USELOWSKEWLINES;
#

# soldered 50MHz Clock. # "C9" I IOSTANDARD NET "elk" LOe
/I

LVTTL;

#
/I Simple LEDs

# Require only 3.5rnA.
#

NET "led<O>" LOC = "F12" NET "led<l>" LOC NET "led<2>" LOe NET "led<3>" LOC NET "led<4>" Loe NET "led<5>" LOC NET "led<6>" LOC NET "led<7>" LOC
#

IOSTANDARD

LVTTL

SLEW SLEW SLEW SLEW SLEW SLEW SLEW SLEW

SLOW SLOW SLOW SLOW SLOW SLOW SLOW

DRIVE DRIVE DRIVE DRIVE DRIVE DRIVE DRIVE DRIVE

4;
4; 4;

"E12" "Ell" "Fll" "ell" "Dl1" nEg" "F9"

IOSTANDARD = LVTTL IOSTANDARD = LVTTL IOSTANDARD IOSTANDARD IOSTANDARD IOSTANDARD

= LVTTL
LVTTL LVTTL

4; 4;

IOSTANDARD = LVTTL

=

4; 4; 4;

= LVTTL

= SLOW

#

# LCD display
# Very slow so can use lowest drive strength. #

NET "lcd rs" NET "led rw" NET "led_e"

LOe LOC LOC

"LIS" "L17" "M18"

IOSTANDARD IOSTANDARD

= LVTTL = LVTTL
114

SLEW SLEW

SLOW SLOW

DRIVE DRIVE DRIVE

2;
2; 2;

IOSTANDARD = LVTTL

SLEW = SLOW

NET "lcd_d<4>" LOC NET "lcd_d<S>" LOC NET "lcd d<6>" Loe

"RIS" "RI6" "PI7" "MIS"

IOSTANDARD IOSTAN DARD
IOSTANDA.~D

LVTTL LVTTL
=

SLEW SLEW SLEW SLEW

SLOW SLOW SLOW SLOW

DRIVE DRIVE DRIVE DRIVE

2; 2; 2;

LVTTL

NET "led d<7>" LOC
it

IOSTANDARD = LVTTL

2:

# Strata Flash (need to disable to use LCD display)

it

NET "strataflash oe" LOC NET "strataflash ce" LOC NET "strataflash we" LOe
#
it

"CIS" "D16" "D17"

IOSTANDARD IOSTANDARD IOSTANDARD

LVTTL LVTTL LVTTL

SLEW SLEW SLEW

SLOW SLOW SLOW

DRIVE DRIVE DRIVE

2; 2: 2;

it Simple switches it it

Pull UP resistors used to stop floating condition during switching. "L13" "L14" "HIS" "NI7" IOSTANDARD IOSTANDARD IOSTANDARD IOSTANDARD LVTTL PULLUP; PULLUP: PULLUP; PULLUPi

NET "switch<O>" LOe NET "switch<l>" LOC NET "switch<2>" LaC NET "switch<3>" LOC
it

= LVTTL
LVTTL LVTTL

#

it Press buttons Must have pull DOWN resistors to provide Low when not pressed. it
if

NET "btn_north" LOC NET "btn east" NET "btn west"
it
it Rotary encoder. it

"V4" "H13" "KI7" "DIS"

IOSTANDARD IOSTANDARD IOSTANDARD IOSTANDARD

LVTTL LVTTL LVTTL LVTTL

PULLDOWN; PULLDOWN; PULLDOWN; PULLDOWN;

LOC LOC

NET "btn south" LOe

Rotation contacts require pull UP resistors to provide High level. Press contact requires pull DOWN resistor to provide Low when not pressed .· LOC LOC "KIS" "GIS" "VI6" IOSTANDARD IOSTANDARD IOSTANDARD LVTTL LVTTL LVTTL PULLUP; PULLUP; PULLDOWN;

#

# NET "rotary_a"
NET "rotary_b"
if

NET "rotaryyress" LOC

# # End of File
it

115

MIPS_DLX_DEMO Project Status Programming File Generated Project File: mips dlx demo.ise Current State: ,Module · Errors: No Errors demo_led_fib :Name: Target · Warnings: 148 Warnings xc3s500e-5fg320 ,DeYice: · Updated: ,Product Thu Dec 31 20:46:33 2009 ISE 9.2.04i IVersion: MIPS DLX_DEMO Partition Summary iNo partition information was found. .. '" -"-,"" Device UtilizatIon Summ'ary [ " Utilization Note(s) Available ;Logic Utilization Used 1,399 9,312 15% !Number of Slice Flip Flops 46% 9,312 4,355 INumber of 4 input LUTs :Logic Distribution 72% 3,369 4,656 jNumber of occupied Slices I Number of Slices containing 100% 3,369 3,369 only related logic I Number of Slices containing 0% 3,369 0 ,unrelated logic 4,888 9,312 52% iTotal Number of 4 iuput LUTs iNumber used as logic 4,355 ;Number used as a route-thru 19 Number used for 32xl RAMs 512 Number used as Shift registers 2 Number of bonded lOBs 30 232 12% 15 I lOB Flip Flops ,Number of GCLKs 1 24 4% !Total equivaleut gate count for 106,751 de~gn '

~

.

"

t

""

< ···· ,--

,',

'

"

"

,

Additional JTAG gate count for I ,lOBs

1,440
~ ~

t

.---~

.- .
..

.,

--'--~.'-~-~'->----

.·.

~-,

.".~

",.!'~rforl!1~nc~, ~umIltary", _,_,

.0$

.'

"

'

.,

,Final 0 ITiming iScore: Routing I All Signals Completely Routed Results: ITiming All Constraints Met Constraints:

Pinout Data: ICIOCk Data:

Pinout Report Clock Report

116

!
I

Detailed Reports Status Generated Errors 'Varnings Infos

Report Name

,Synthesis

,Report ITranslation Report

Current Current

iMapReport Current IPlace and IRoute ,Report IStatic ITiming ;Report IBitgen ,Report Current

Wed Dec 9 22:39:46 2009 Wed Dec 9 22:40:08 2009 Wed Dec 922:40:37 2009 Wed Dec 9 22:44:01 2009 Wed Dec 9 22:44:18 2009 Wed Dec 9 22:46:13 2009

0 0 0 0

141 16 IWarnings I Infos
1 0 Warning 3 3 Infos Warnings

3 0 Warnings

Current iCurrent

0 0

0 0

2 Infos 0

117

Appendix F
Fibonacci Test Program
The assembler and machine code of Fibonacci number calculation program is shown below. The values are presented in hexadecimal format. This code is a part of the instruction memory module. Each row contains Verilog assignment for ROM address and comments showing a corresponding assembler code.

F.1 Program With Delay Slot And Reordering
'ifdef _FIB_PROGRAM_V_ 'else 'define _FIB_PROGRAM_V_ assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign ram[ 0]='h8cld0004;//lw $29, 4($0) ;40 0000: lw Ssp, 4 ($zero) //load from I/O mem ram[ 1]='h8c040008;//lw $4, 8($0) ;40-0004: lw SaO, B($zero) //load from I/O mem ram[ 2] 'h23bdfff4;//addi $29, $29, -12 40 0008: addi Ssp, Ssp, -12 <-- fib 40-000c: sw $ra, 8($sp) ram! 3)='hafbf0008;//sw $31, 8($29) 40-0010: sw $sO, 4($sp) ram[ 4]='hafb00004;//sw $16, 4($29) ram[ 6]='h20020001;//addi $2, $0, 1 40-0018: addi $vO, $zero, 1 ram[ 5J-'hlOBOOOOd;//beq $4, $0, 52 40=0014: beq SaO, $zero, fin ram[ 7]='h20080001;//addi $8, $0, 1 40 OOlc: addi $tO, $zero, 1 40-0020: beq SaO, $tO, fin ram[ B]='hl088000a;//beq $4, $8, 40 40-0024: nop (delay slot) ram[ 9]='hOOOOOOOO;//nop ram[10]='h2084ffff;//addi $4, $4, -1 40-0028: addi SaO, SaO, -i ram[121='hafa40000;//sw $4, 0($29) ; 40-0030: sw SaO, O($sP) ram[11]='hOcl00002;//jal Ox00400008 [fib]; 40-002c: jal fib ram[13)='h8fa40000;//lw $4, 0($29) 40-0034: 1w SaO, O($sp) ram[14]='h2084ffff;//addi $4, $4, -1 40-0038: addi $aO, SaO, -1 ram[16]='h00408020;//add $16, $2, $0 ; 40-0040: add $50, $vO, $zero ram[15]-'hOcl00002;//ja1 Ox0040000B [fib]; 40=003c: jal fib ram[17]='h00501020;//add $2, $2, $16 40 0044: add $vO, $vO, $50 ram[1B]='hac02000c;//sw $2, 12($0) 40-0048: sw $vO,12($zero)//store to I/O mem ram[19]='h8fb00004;//1w $16, 4($29) 40-004c: lw $sO, 4($sp) <-- fin ram[20]='h8fbf0008;//1w $31, 8($29) 40-0050: lw $ra, 8($sp) ram[21]='h23bdOOOc;//addi $29, $29, 12 40-0054: addi Ssp, Ssp, 12 ram[22]='hacld0010;//sw $29, 16($0) 40-0058: sw $sp,16($zero)/lstore to I/O mem 40-005c: jr $ra ram[23]='h03e00008;//jr $31 ram[24]='hOOOOOOOO;//nop 40-0060: nop ram[25]='hOOOOOOOc;//sysca11 40=0064: sysca11 ram[26]='hOOOOOOOc;// ram[27]='hOOOOOOOO;//// ram[28]='hOOOOOOOO;//// ram[29]='hOOOOOOOO;////

Note. The reordering is shown in bold font.

118

F.2 Program Without Delay Slot And Reordering
'ifdef _FIB_PROGRAM_V_ 'else 'define _FIB_PROGRAM_V_ assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign assign ram[ 0]a'h8cld0004;1/ ram[ 1j3'h8c040008;1/ ram[ 2]='h23bdfff4;/1 ram[ 3]='hafbfOOOB;// ram[ 4]='hafb00004:// ram[ 5j='h20020001;// ram[ 6]='h10BOOOOd;// ram[ 7]='h20080001;// ram[ 8j='h1088000a;// ram[ 9]='hOOOOOOOO;// ram[10]='h2084ffff;// ram[11j='hafa4000D;// ram!12]='hOcl00002;// ram[13]='h8fa40000;// ram[14]='h2084ffff;// ram[15]='h00408020;// ram[16]-'hOcl00002;// ram[17J='h00501020;// ram[lB]='hac02000c;// ram[19]='hBfb00004;/1 ram[20]='h8fbf0008;11 ram[2l]='h23bdOOOc;// ram[22J='hacldOOlOi// ram!23]='h03e00008;// 1w $29, 4($0) ; 40 0000: 1w Ssp, 4($zero) //1oad from I/O mem 1w $4, 8($0) ; 40-0004: lw SaO, 8($zero) //load from I/O mem addi $29, $29, -12 - 40_0008: addi $sp, Ssp, -12 <-- fib sw $31, 8($29) 40 OOOc: sw $ra, 8($sp) sw $16, 4($29) 40-0010: SW $50, 4($sp) addi $2, $0, 1 40-0014: addi $vO, $zero, 1 beq $4, $0, 52 40-0018: beq SaO, $zero, fin addi $8, $0, 1 40-001c: addi $tO, $zero, 1 beq $4, $8, 40 40-0020: beq SaO, $tO, fin nop 40-0024: nop addi $4, $4, -1 40-0028: addi SaO, SaO, -1 SW $4, 0($29) 40-002c: sw $aO, O($sp} jal Ox00400008 [fib]; 40-0030: ja1 fib lw $4, 0($29} 40-0034: lw $aO, O($sp) addi $4, $4, -1 40-0038: addi $aO, SaO, -1 add $16, $2, $0 40-003c: add $sO, $vO, $zero jal Ox00400008 [fib); 40-0040: jal fib add $2, $2, $16 ; 40-0044: add $vO, $vO, $50 ; 40 0048: sw $vO,12($zero)//store to I/O mem sw $2, 12($0) 1w $16, 4($29) ; 40 004c: 1w $50, 4($sp) <-- fin 1w $31, 8($29) ; 40-0050: 1w $ra, 8($sp) addi $29, $29, 12 ; 40-0054: addi Ssp, Ssp, 12 sw $29, 16($0) ; 40 0058: 5W $sp,16($zero)//store to IIO mem jr $31 40_005c: jr $ra nop sysca11

ram[24]='hOOOOOOOO:11
ram[25j='hOOOOOOOc:l/ ram[26j='hOOOOOOOc:l/

ram[27j='hOOOOOOOO;/II/
ram[28]='hOOOOOOOO;/I//

ram[29]='hOOOOOOOO;II//

119

Appendix G
Configurable Processor Verification
G.l Verification Reports
Typical successful completion report:

* Fibonacci
* Test

number test SUCCESSFULLY completed, Fib finished after 242 machine cycles

5)

8

Typical unsuccessful completion report with calculation errors:
# Test completed with ERRORS: Expected Fib( 5)= 8, obtained Fib( 5)= x Test finished after 242 machine cycles

*

Typical unsuccessful completion report due to a timeout:
# Test test finished UNSUCCESSFULLY due to the timeout # Test finished after 50001 machine cycles

G.2 Simulation Waveforms

120

Figure G.t: Post-route simulation waveforms of the 32-bit configuration of multi-cycle architecture

121

10

ZUJ!lIO

I :2
;0

~

5

10
8

5

0
'0

0 0 0

~

5
:5

29 P l2H7~e"'lo ; 6

1.--

0
0

,

0 [5

H
JJ4

~
I

,I

14

;5
~'o

:5
;1
'I

:1

:0 0

is
'-1
0

t5
11

:::I,
1
0

.4

;;;0

;ZH1~.JI3
;1
.'1

r::ZI47~1"'13

31

2; I iU 31 "t~21414". 11 b 3 I..

~ '21474.j <;13

'""''' .'·,t,-, r' '"
29

~t6

2

10

4 0 0

t

;16 :2 2H74.._:_:2147~B... _2 4HB.. , ~ I

0

,14

Ii 4 {I i~ 21474._;-;2147~ .. 21 7483,.. }:1
i}12

f "

4
10
l~

II

Figure G.2: Post-route simulation waveforms of the 32-bit configuration of one-cycle architecture

122

o o

Figure G.3: Post-route simulation waveforms of the 32-bit configuration of four-stage architecture

123

Figure G.4: Post-route simulation waveforms of the 32-bit configuration of five-stage architecture

124

AppendixH
Images of Demo Design Example
All numbers have a hexadecimal radix.

125

:.....

,

126

127

128

129

Appendix I
Altera FPGA Implemention
Excerpt from the Altera Ouartus II fitter report for the processor with following configuration: · · · · 5-stages pipe lined 12S-bit width Full ISA support BRAM optimization

130

."
+-----~------------------------------------------------------------------------~---------------------------- --------------------

+----------------------------------------------------------------------------------------------------+------+------------------+
+----------------------------------------------------------------------------------------------------+------+------------------+
data ram:processor data memlaltsyncram:ram rtl 21altsyncram fljl:auto generatedlALTSYNCRAM
inst=mem:processor=imemlaltsyncram:Mux31_rtl_3IaltsynCram_3~71:auto_generatedIALTSYNCRAM

; fitter RAM Summary ; Name

; Type ; Mode AUTO AUTO MLAB MLAB

regfile:processor regfilelaltsyncram:data register rtl Olaltsyncram ptil:auto generatedlALTSYNCRAM
regfile:processor=regfilelaltsyncram:data=register=rtl=1Ialtsyncram~ti1:auto=generatedIALTSYNCRAM

+----------------------------------------------------------------------------------------------------+------+------------------+ --------------+--------------+--------------+--------------+--------------+------------------------+-------------------------+ Clock Mode ; Port A Depth; Port A Width; Port B Depth ; Port B Width ; Port A Input Registers ; Port A Output Registers ; --------------+--------------+--------------+--------------+--------------+------------------------+-------------------------+
Dual Clocks 256 Single Clock ; 1024
32

Simple Dual Port ROM Simple Dual Port Simple Dual Port

128

256

128

21

--------------+--------------+--------------+--------------+--------------+------------------------+-------------------------+
--------------~---------+-------------------------+-------+--------------------~--------+------------------- ----------+-----------------------------+

32

128 128

32 32

128 128

yes yes yes yes

no no no no

------------------------+-------------------------+-------+-----------------------------+-----------------------------+-----------------------------+
yes no yes yes no no 32768 21504 4096 .: 4096
256

Port B Input Registers ; Port B Output Registers ; Size

; Implementation Port A Depth ; Implementation Port A Width ; Implementation Port B Depth ; 1024 32 32 128 21 128 128 256 32 32

---------~--------------+------~------------------+-------+-----------------------------+------------------~ ----------+-----------------------------+

-----------------------------+---------------------+------------+--------------+------------+----------------------------+ Implementation Port B Width ; Implementation Bits ; M9K blocks ; M144K blocks ; MLAB cells ; MIF -----------------------------+---------------------+------------+--------------+------------+----------------------------+
128

-----------------------------+---------------------+------------+--------------+------------+----------------------------+

128 128

32768 21504 4096 4096

4 3 0 0

0 0 0 0

0 0 256 256

None mips cfg.mips dlxO.rtl.mif None None

131

Excerpt from the Altera Ouartus II fitter report for the processor with following configuration: · · · · 5-stages pipe lined 128-bit width Full ISA support No BRAM optimization

+------------------------------------------------------------------------------------------------------------------------------I Fitter RAM Summary
+----------------------------------------------------- ------------------------------~---------------~+------ +------------------+ I Name I Type I Mode

+----------------------------------------------------------------------------------------------------+------+------------------+

+----------------------------------------------------------------------------------------------------+------+------------------+
-------------+--------------+--------------+--------------+--------------+------------------------+-------------------------+ Clock Mode ; Port A Depth ; Port A Width ; Port B Depth ; Port B Width ; Port A Input Registers ; Port A Output Registers ; -------------+--------------+--------------+--------------+--------------+------------------------+-------------------------+
Dual Clocks

data ram:processor data memlaltsyncram:ram rtl 21altsyncram fljl:auto generatedlALTSYNCRAM AUTO Simple Dual Port ; regfIle:processor_regfilelaltsyncram:data_register_rtl~Olaltsyncram-ptil:auto~generatedIALTSYNCRAM I MLAB ; Simple Dual Port; ; regfile:processor_regfilelaltsyncram:data_register~rtl~llaltsyncram-ptil:auto~generatedIALTSYNCRAM ; MLAB I Simple Dual Port;

-------------+--------------+--------------+--------------+--------------+------------------------+-------------------------+
------------------------+-------------------------+-------+-----------------------------+-----------------------------+-----------------------------+
Port B Input Registers ; Port B Output Registers ; Size
no ; no ; no

256 ; 32 ; 32

128 ; 128 ; 128

256 ; 32 ; 32

128 ; 128 ; 128

yes

; yes ; yes

no ; no ; no

; Implementation Port A Depth ; Implementation Port A Width ; Implementation Port B Depth ;
256

------------------------+-------------------------+-------+--------~--------------------+--~---------------- ----------+-----------------------------+

------------------------+-------------------------+-------+-----------------------------+-----------------------------+-----------------------------+ -----------------------------+---------------------+------------+--------------+------------+------+ Implementation Port B Width ; Implementation Bits ; M9K blocks ; M144K blocks ; MLAB cells ; MIF -----------------------------+---------------------+------------+--------------+------------+------+
128 32768 4 0 0

yes yes yes

32768

128
; 128 I 128

256

; 4096 ; 4096

; 32 ; 32

; 32 ; 32

None

128 128

; 4096 ; 4096

; 0 ; 0

; 0 ; 0

; 256 ; 256

; None ;

; None ;

-----------------------------+---------------------+-- ----------+---------~----+------------+------+

132

Bibliography
[1] P. Yiannacouras, JG Steffan, J Rose, "Soft vector processors vs FPGA custom
hardware: measuring and reducing the gap", in Proceeding of the ACMISIGDA international symposium on Field programmable gate arrays, Monterey, California, USA, pp. 277-277, 2009 [2] I. Kuon, R. Tessier, 1. Rose, "FPGA Architecture: Survey and Challenges", Foundations and Trends® in Electronic Design Automation,Vol. 2, no. 2, pp. 135-253, Feb. 2008 [3] J. Nurmi, "Processor Design: System-On-Chip Computing for ASICs and FPGAs", Springer, 2007 [4] "HardCopy IV Device Handbook", Ahera, Jul. 2009 [5] "IEEE Standard Hardware Description Language Based on the Veri log Hardware Description Language (1364-2001)", IEEE Inc., 3 Park Avenue, New York, NY 100165997, USA, 2001 [6] J. L. Hennessy, N. P. Jouppi, J. Gill, F. Baskett, A. Strong, T. R. Gross, C. Rowen, J. Leonard, "The MIPS machine", in Proceedin.gs of24th IEEE Computer Society International Conforence, IEEE Com peon, San Francisco, Feb. 1982, pp. 2-7. [7] J. L. Hennessy, D. A. Patterson, "Computer Architecture: A Quantitative Approach", 4th edition, Morgan Kaufmann, 2007 [8] N. Pinckney, T. Barr, M. Dayringer, M. McKnett, N. Jiang; C. Nygaard, D. Money Harris, J. Stanley, B. Phillips, "A MIPS R2000 implementation", in Proceedings ofthe 45th annual Design Automation Conforence, Anaheim, California, pp. 102-107, 2008 [9] "MIPS32® Architecture For Programmers Vol. I: Introduction to the MIPS32® Architecture", MIPS Technologies, Rev 2.60, June 25,2008 [10] D. Sweetman, "See MIPS Run Linux", Morgan Kaufinann, 2nd ed., 2007

133

[11] H. Tago, K. Hashimoto, N. Ikumi, M. Nagamatsu, M. Suzuoki, Y. Yamamoto, "CPU for PlayStation(R)2", in Proceedings ofDesign, Automation and Test in Europe, 2001.

Conference and Exhibition 2001. p. 696, 13-16 March 2001
[12] J. L. Hennessy, D. A. Patterson, "Computer Organization and Design: The Hardware/Software Interface", 4th edition, Morgan Kaufmann, 2008 [13] W. Stallings, "Computer Organization and Architecture: Designing for Performance", 8th edition, Pearson Education Inc, 2009 [14] Y. Liu, Z. Chen, Y. Chen, "How to Optimize the Cryptographic Symmetric Primitives on Loongson-2E Microprocessor", in Proceedings ofthe 22nd International Conference

on Advanced Information Networking and Applications - Workshops, pp. 608-614, 2008
[15] W. Hu, J. Wang, X. Gao, Y. Chen. "Microarchitecture ofGodson-3 Multi-Core Processor", in Proceedings of the 20th Hot Chips, 2008. [16] N. Seki, Lei Zhao, J. Kei, D. Ikebuchi, Yu. Kojima, Hasegawa Yohei, H. Amano, T. Kashima, S. Takeda, T. Shirai, M. Nakata, K. Usami, T. Sunata, J Kanai, M. Namiki, M. Kondo, H. Nakamura, "A fine-grain dynamic sleep control scheme in MIPS R3000",

IEEE International Conference on Computer Design, pp. 612 - 617, Oct. 2008
[17] HG Kim, HC Oh, "A DSP-Enhanced 32-Bit Embedded Microprocessor", Journal of

Embedded Computing, Springer, 2009
[18] J. Larus, "SPIM S20: A MIPS R2000 Simulator", University of Wisconsin-Madison, Tech. Rep., 2004 [19] R. Stallman and the GCC Developer Community, "Using the GNU Compiler Collection: For gee version 4.4.2", GNU Press a division of the Free Software Foundation, 2008 [20] A. Fauth, J. Van Praet, and M. Freericks, "Describing instruction set processors using nML", in Proceedings European Design and Test Conference, Paris, France, pp. 503507, Mar. 1995 [21] P. Mishra, N. Dutt , " Processor Description Languages", Morgan Kaufinann, 2008 [22] S. Basu, R.Moona, "High level synthesis from Sim-nML processor models", in

Proceedings ofthe 16th International Conference on VLSI Design, pp. 255 - 260, Jan.
2003

134

[23] G. Hadjiyiannis, S. Hanono, S. Devadas, "ISDL: An Instruction Set Description Language for Retargetability", in Proceedings of the 34th Design Automation Conference, pp 299-302, June 1997 [24] G. Hadjiyiannis, P. Russo, S. Devadas, "Automatic architecture evaluation for hardware/software codesign", in Proceedings a/the 6th IEEE International Conference on
Electronics, Circuits and Systems, Vol. 1, pp. 47 - 53, Sept. 1999

[25] G. Hadjiyiannis, P. Russo, S. Devadas, "A methodology for accurate performance evaluation in architecture exploration", in Proceedings ofthe 36th Design Automation
Conference, pp. 927 - 932, June 1999

[26] A. Halambi, "EXPRESSION: A language for architecture exploration through compiler/simulator retargetability", in Proceedings on the Design, Automation and Test in
Europe,pp.
100-104,~ar.

1999

[27] A. Kejariwal et al. "HDLGen: Architecture Description Language driven HDL Generation for Pipelined Processors", CECS TR 03-04, University of Cali fomi a, Irvine, 2003. [2S] P. ~ishra, N. Dutt, "Specification-driven directed test generation for validation of pipelined processors", AC\.f Transactions on Design Automation ofElectronic Systems, VoL 13, no. 3, July 200S, [29] J. L. Hennessy, D, A. Patterson, "Computer Architecture: A Quantitative Approach",
~organ

Kaufinann, 1997

[30] S. Pees, A. Hoffmann, V. Zivojnovic, H. ~eyr, "LISA-machine description language for cycle-accurate models of programmable DSP architectures", in Proceedings ofthe36th
Design Automation Conference, pp. 933 - 938, June 1999

[31] O. Schliebusch, H. ~eyr, R. Leupers, "Optimized ASIP Synthesis from Architecture Description Language ~odels", Springer, 2007 [32] ~. Hohenauer. R. Leupers , "C Compilers for ASIPs: Automatic Compiler Generation with LISA", Springer, 2009 [33] A. Hoffmann, T. Kogel, A. Nohl, G. Braun, O. Schliebusch, O. Wahlen, A. Wieferink, H. ~eyr, "A novel methodology for the design of application-specific instruction-set processors (ASIPs) using a machine description language", Computer-Aided Design of

135

Integrated Circuits and Systems, IEEE Transactions, Vol. 20, no. 11, pp. 1338 - 1354, Nov. 2001 [34] H. Scharwaechter, D. Kammler, A. Wieferink, M. Hohenauer, K. Karuri, J. Ceng, R. Leupers, G. Ascheid, H. Meyr, "ASIP Architecture Exploration for Efficient IPSec Encryption: A Case Study", in Proceedings ofthe Workshop on Software and Compilers for Embedded Systems, Vol. 6, no. 2, May 2007 [35] A.R. Jafri, A. Baghdadi, M. Jezequel, "Rapid Prototyping of ASIP-based Flexible MMSE-IC Linear Equalizer", IEEEIIFIP International Symposium on Rapid System Prototyping, pp.130-133, 2009 [36] A. Chattopadhyay, A. Sinha, D. Zhang, R. Leupers, G. Ascheid, H. Meyr, "Integrated Verification Approach during ADL-Driven Processor Design", Microelectronics Journal, no. 40, pp. 1111- 1123,2009 [37] U. Meyer-Base, A. Vera, S. Rao, K. Lenk, M. Pattichis, "FPGA wavelet processor design using language for instruction-set architectures (LISA)", in Proceedings SPIE, Vol. 6576, Apr. 2007 [38] "CoWare® Processor Designer, Programmable Accelerators for Platform-Driven ESL Design", CoWare, 2006 [39] B. Sander, J. Schnerr, O. Bringmann, "ESL power analysis of embedded processors for temperature and reliability estimations", in Proceedings o/the 7th IEEEIACM international conference on Hardware/software codesign and system synthesis, Grenoble, France, pp. 239-248, 2009 [40] S. Yang, Y. Qian, Z. Tie-Jun, S. Rui, H. Chao-Huan, "A new HW/SW co-design methodology to generate a system level platform based on LISA", in Proceedings ofthe 6th International Conforence On ASIC, Vol. 1, pp. 163 - 167, Oct. 2005 [41] A. Jain, "FPGA versus configurable processors: selecting the right device for your application", lET Seminar on the Latest Technologies and Tools in Electronics Design, Bangalore, India, p.3, Sept. 2008, [42] M. Pumaprajna, M. Porrmann, U. Rueckert, "Run-time reconfigurability in embedded multiprocessors", ACM SIGARCH Computer Architecture News, Vol. 37, no. 2, pp. 3037, May 2009

136

[43] Y. Saito, T.Shirai, T. Nakamura, T. Nishimura, Y. Hasegawa, S. Tsutsumi, T. Kashima, M. Nakata, S. Takeda, K. Usami, "Leakage Power Reduction For Coarse Grained Dynamically Reconfigurable Processor Arrays With Fine Grained Power Gating Technique", Field-Programmable Technology, International Conference, pp. 329 - 332, Dec. 2008, (44] H.P. Huynh, T. Mitra, "Runtime Adaptive Extensible Embedded Processors-A Survey", in Proceedings of the 9th International Workshop on Embedded Computer Systems; Architectures, Modeling, and Simulation, Samos, Greece, pp.: 215 - 225,2009 [45] T. Halfhill, "Tensilica Tweaks Xtensa: Xtensa LX3 and Xtensa 8 Cores Boost Performance, Cut Power", Microprocessor Report, Tensilica, 2009 [46] T. Tohara, G. Ezer, "Multi-Standard Video Decoder Using Configurable Microprocessor Technology", Consumer Electronics, Digest of Technical Papers. International Conference, pp. 1 - 2, Jan. 2008 [47] "ARC® 700 Core Family", ARC International, Online, http://www.arc.com/configurablecoresiarc700/. Retrieved on Jan. 2010 [48] "ARC® 600 Configurable Core Family", Product brief, ARC International, 2007 (49] "ARChitect Processor Configuratior", Product brief, ARC International, 2007 [50] G. Brown, "Configurable Microprocessor Implementation of Low Bit Rate Audio Decoding", Audio Engineering Society, Convention Paper, Presented at the 113th Convention, Los Angeles, USA, Oct. 2005 [51] "MicroBlaze Processor Reference Guide", Xilinx, UG081 (v 10.3), 2009 [52] "Virtex-5 FPGA Embedded Processor Block with PowerPC 440 Processor", Product Specification, DS621, Xilinx, 2009 [53] "PicoBlaze 8-bit Embedded Microcontroller User Guide, Spartan-6, Spartan-3, Virtex-6, and Virtex-5 FPGA Devices", UG129 (v 1.2), Xilinx, November 11,2009 , [54] P. Bleyer, "Pacoblaze - a synthesizable behavioral verilog picoblaze clone," Online, January 2010, <http://bleyer.orglpacoblaze/> [55] "Nios II Processor Reference Handbook, ver 9.1 ", Altera Corporation, Nov. 2009

137

[56] F. Plavec, B. Fort, Z.G. Vranesic, S.D. Brown, "Experiences with Soft-Core Processor Design", in Proceedings ofthe 19th IEEE International Parallel and Distributed Processing Symposium (IPDPS'05j - Workshop 3, Washington, DC, USA, pp.167b-167b, Apr. 2005 [57] B. Fort, D. Capalija, Z. G. Vranesic, S. D. Brown, "A Multithreaded Soft Processor for SoPC Area Reduction", in Proceedings ofthe 14th Annual1EEE Symposium on FieldProgrammable Custom Computing Machines (FCCM'06), pp. 131-142,2006 [58] O. Rayahi, M. Khalid, "UWindsor Nios II: A soft-core processor for design space exploration", in Proceedings ofIEEE International Conference on Electro/Information Technology, pp. 451-457, June 2009 [59] J. Gaisler, S. Habinc, E. Catovic, "GRUB IP Library User's Manual", Gaisler Research, 2009 [60] M.-A. Daigneault, J.M.P Langlois, J.P. David, "Application Specific Instruction Set Processor Specialized for Block Motion Estimation", in Proceedings ofIEEE International Conference on Computer Design, pp. 266-271, Oct. 2008 [61] J. Lee, J. Lee, M. Jeong, N. Eum. S. Park, "A 100MHz ASIP (application specific instruction processor) for CAVLC ofH.264/A VC decoder", in Proceedings of IEEE International Symposium on Circuit and Systems, ISCAS 2008, Seattle, WA, pp. 34623465, May 2008 [62] N. Sonmez. A. Yurdakul, "SIxD:A Configurable Application-Specific SISD/SIMD Microprocessor Soft-Core", in Proceedings ofInternational Symposium on System-onChip, Tampere, pp. 1-4, Nov. 2006 [63] R. Dimond, O. Mencer, W. Luk, "Application-specific customisation of multi-threaded soft processors", lEE Proceedings Computers & Digital Techniques, Vol. 153, no. 3, pp.173 - 180, May 2006 [64] P. Yiannacouras, J. G, Steffan, J. Rose, "Exploration and Customization of FPGA-Based Soft Processors", IEEE Transactions on Computer-Aided Design ofIntegrated Circuits and Systems, Vol. 26, no. 2, pp. 266-277, Feb. 2007 [65] "BlockRAM (BRAM), Block(vl.OOa)", Product Specification DS444, Xilinx, Dec. 2009 [66] "XST User Guide 9.2i", Xilinx, 2007

138

[67] "ColdFire® Family Programmer's Reference Manual", Freescale Semiconductor, Rev. 3, Mar. 2005 [68] "ModeISim® SE User's Manual: Software Version 6.2g", Mentor Graphics, 2007 [69] "Virtex-5 Family Overview: Product Specification", DSI00 (v5.0), Xininx, Feb. 2009 [70] "Stratix III FPGAs vs. Xilinx Virtex-5 Devices: Architecture and Performance Comparison", White paper, ver. 2.1, Altera Corporation, Oct. 2007 [71] A. Percey, "Advantages of the Virtex-5 FPGA 6-Input LUT Architecture", White Paper, WP284 (vI.O), Xilinx, Dec. 2007 [72] "Digital IC Design Flow: A Tutorial on RMC's Digital Design Flow (based on CMOSP18 Artisan), ver. 5.0", RMC Microelectronic Lab, Jan. 2008 [73] "Digital IC Design Flow: Tutorial. Document ICI-134", CMC, July 2004 [74] "Spartan-3E FPGA Starter Kit Board, User Guide", Xilinx, UG230 (vl.l) June 20, 2008 [75] A. Posamentier, I. Lehmann "The (Fabulous) FIBONACCI Numbers", Prometheus Books,pp.305,2007 [76] M. Brorsson, "Mipslt: A simulation and development environment using animation for computer architecture education", in Proceedings ofthe 2002 workshop on Computer architecture education, Anchorage, AK, pp. 65-72, May 2002. [77] K.Chapman, "Rotary Encoder Interface for Spartan-3E Starter Kit," Xilinx, Feb. 20, 2006 [78] A. Ziebinski, S. Swierc, "The VHDL Implementation of Reconfigurable MIPS Processor", Book Chapter, "Man-Machine Interactions", Springer BerJinlHeidelberg, 2009 [79] R. Kastner, "Computer Organization", ECE 15B - Spring 2006, Lecture 8, April 27, 2006, http://W\\w .ece.ucsb.edU/-kastner/ece 15b/slidesllecture08.pdf [80] "Quartus II Handbook Version 9.1 Vol. 1: Design and Synthesis", Altera Corporation, November 2009 [81] "Stratix III Device Handbook, Vol. 1: TriMatrix Embedded Memory Blocks in Stratix III Devices", Altera Corporation, May 2009 [82] T. R. Halfhill, "MicroBlaze v7 Gets an MMU: Memory Manager Brings Full-Fledged Linux to Xilinx Processor Core", Xedl Journal, 2008

139

[83] "SPARC V8 32-bit Processor LEON3 / LEON3-FT: CompanionCore Data Sheet, Version 1.0.3", Aeroflex Gaisler AB, December 2008

/-/

140

