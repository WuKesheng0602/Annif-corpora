5 I `f 'b 'S ~ ^ 7 0 S r

Advanced DSP Control of Induction Motors using Kalman Filter

by

Shiping Zhu

A project presented to Ryerson University in partial fulfillment of the requirement for the degree of M aster of Engineering in the Program of Electrical and Computer Engineering Toronto, Ontario, Canada, 2003 ©Shiping Zhu, 2003

UMI Number: EC53454

INFORMATION TO USERS

The quality of this reproduction is dependent upon the quality of the copy submitted. Broken or indistinct print, colored or poor quality illustrations and photographs, print bleed-through, substandard margins, and improper alignment can adversely affect reproduction. In the unlikely event that the author did not send a complete manuscript and there are missing pages, these will be noted. Also, if unauthorized copyright material had to be removed, a note will indicate the deletion.

UMI*
UMI Microform EC53454 Copyright2009by ProQuest LLC All rights reserved. This microform edition is protected against unauthorized copying under Title 17, United States Code.

ProQuest LLC 789 East Eisenhower Parkway P.O. Box 1346 Ann Arbor, Ml 48106-1346

Author's Declaration
I hereby declare that I am the sole author of this research paper. I authorize Ryerson University to lend this research paper to other institutions or individuals for the purpose of scholarly research.

I

r

I further authorize Ryerson University to reproduce this research paper by photocopying or by other means, in total or in part, at the request of other institutions or individuals for the purpose of scholarly research.

Instructions on Borrowers
Ryerson University requires the signatures of all persons using or photocopying this research paper. Please sign below, and give address and date.

Advanced DSP Control of Induction Motors using Kalman Filter
Abstract

This research paper presents a novel method for the speed control of induction motors without using a speed sensor. The rotor speed can be accurately computed using an optimal control observer named the Kalman filter designed in this research paper. This replaces a speed sensor and eliminates the difficulty of the sensor installation in many applications. This research paper presents an advanced field oriented control of induction motors, based on a specific d-q coordinate model with the d-coordinate chosen to be in line with the rotor flux and the q-coordinate chosen to be 90° lagging. The position of the rotor flux can be accurately computed using the Kalman filter. This eliminates the position sensors required to monitor the flux. This research paper shows that as a result of this specific d-q transformation, the motor torque is proportional to the product of the rotor flux and the q-coordinate stator current. This significantly simplifies the induction motor control, such that the rotor flux is simply controlled by regulating the flux-related d-coordinate stator current and the motor torque is controlled just by regulating the q-coordinate stator current. This research paper presents a computational efficient recursive algorithm for Kalman filter which is specifically designed for the induction motor control. The Kalman filter provides the minimum variance state estimation and tolerates induction motor modeling and measurement errors. The Kalman filter can process all available measurements regardless of their precision (only two input current measurements required for the motor control), and provides a quick and optimal estimate of the variables of interest (the rotor speed and flux selected as outputs), as well as achieves a fast convergence. This research paper presents the digital signal processor (DSP) implementation of the field oriented control of induction motors using Kalman filter. The hardware requirements and all software modules are detailed. The experimental verification of the control method designed in this research paper is provided. Typical measurements are given to demonstrate the efficiency of the novel control presented in this research paper.

Key words:

field oriented control, Kalman filter, DSP control, PID regulator

Acknowledgments
I would like to express my sincere gratitude and appreciation to my supervisor Professor Richard Cheung for his guidance in my study and project. I cordially thank Professor Bin Wu for his advice and help in my study period. At the same time I would like to thank my classmates or friends in the laboratory of power electronics at Ryerson University for their help or assistance in my project. Specially thanks to my wife and son for their full support.

Contents
1 Introduction................................................................................................................... 1 1.1 DSP Control of Induction Motors..................................................................... 2 1.2 Speed Sensorless Control of Induction Motors.................................................3 1.3 Novel Control Method for Induction Motors.................................................... 4 1.4 Outline of the Research Paper........................................................................... 6 2 Advanced Field Oriented Control of Induction Motors.............................................. 8 2.1 3-phase to 2-phase Transformation................................................................... 9 2.2 Space Vector PWM Control of Motor Drive Inverter.....................................11 2.3 Field Oriented Control..................................................................................... 15 2.4 Adaptive PID Regulator................................................................................... 17 3 Kalman Filter for Speed Sensorless Control of Induction Motors............................ 20 3.1 Basics of Kalman Filter................................................................................... 20 3.2 Induction Motor Model for Implementation of Kalman Filter.......................23 4 Digital Signal Processor Implementation of Speed Sensorless Field Oriented Control..................................................................................................................... 28 4.1 Overview of DSP FOC Operations................................................................. 28 4.2 Hardware Implementation of Field Oriented Control.................................... 29 4.3 DSP Software Implementation of Field Oriented Control.............................. 31 4.4 Debugging of Software and Hardware............................................. 33 5 Experimental Verification of Field Oriented Motor Control using Kalman Filter ...36 5.1 Internal States of Closed-Loop Control...........................................................36 5.2 Dynamic Response.......................................................................................... 44 5.3 Speed Control Accuracy..................................................................................46 6 Conclusions.................... 47 Bibliography..................................................................................................................50 Appendix A Summary of Notations............................................................................52 Appendix B Induction Motor Parameters................................................................... 53 Appendix C Characteristics of PID Control...............................................................54 Appendix D Assembly Code for TMS320LF2407.................................................... 55

List of Figures
Figure 1: Methods of Sensorless Speed Control............................................................. 4 Figure 2: The Control Structure of FOC with Kalman Filter......................................... 5 Figure 3; a-P Transformation..........................................................................................10 Figure 4: Park Transformation........................................................................................11 Figure 5: Three-phase Voltage Source Inverter................................... 12 Figure 6 : Configuration of Space Vector PWM.............................................................13 Figure 7: Example of Space Vector PWM pattern.........................................................15 Figure 8 : Field Oriented Control of Induction Motors.................................................. 16 Figure 9: Relationship between Current, Voltage and Rotor Flux................................16 Figure 10: Sensorless Controller for Induction M otors................................................ 17 Figure 11: The Adaptive PID Control............................................................................18 Figure 12: Principle of Kalman Filter...................................................... 21 Figure 13: Extended Kalman Filter Algorithm................................... 23 Figure 14. Experiment Setup for Sensorless Control System....................................... 29 Figure 15: Block Diagram of eZdspTM LF2407.............................................................30 Figure 16: Software Flowchart...................................................................................... 31 Figure 17: EKF Software Structure for an Induction M otor........................................ 32 Figure 18: Overview of Phase 2 Software Flow ..............................................34 Figure 19: Overview of Phase 2 Workspace..................................................................35 Figure 20: ia, ib Currents from AD C.............................................................................37 Figure 21: Currents from Clarke Transformation......................................................... 37 Figure 22: Currents Estimated by Kalman Filter.......................................................... 38 Figure 23: Flux Circle Estimated by Kalman filter....................................................... 38 Figure 24: Currents from Park Transformation.............................................................39 Figure 25: Speed Control................................................................................................ 39 Figure 26: iq Control...................................................................................................... 40 Figure 27: id Control...................................................................................................... 40 Figure 28: Voltage Outputs from id, iq Regulators....................................................... 41 Figure 29: Ualfa, Ubeta from Inverse Park Transformation......................................... 41 Figure 30: Duty Ratios of PWMl, PWM3 and PWM5 in Carrier Period....................42 Figure 31: PWM Outputs of IGBT Power Module....................................................... 43 Figure 32: Line to Line Voltages of the Induction M otor............................................ 43 Figure 33: Speed Step Response.................................................................................... 44 Figure 34: Speed Transient from 0 to lOOOrpm.............................................................45 Figure 35: Speed Reversion............................................................................................45 Figure 36: The Model of an Induction Motor................................................................53

List of Tables
Table 1: Steady State Performance of Speed Sensorless Control.......................46 Table 2: Summary of Notations Used in this Research Paper...........................52

Chapter 1 Introduction
Induction motors are popular in the industry because they are reliable, rugged, low cost, and virtually maintenance free. Market analysis shows that most of industrial motor applications use induction motors. However, the use of induction motors may have several difficulties, which include control disadvantages due to complex motor model and nonlinear motor parameters caused by saturation and variations with temperature. In order to overcome these difficulties, many methods have been proposed for the control of induction motors [1-5]. The field-oriented control (FOC) is the most popular one. This control requires the instantaneous measurements of the motor speed, voltages and currents. The speed of the motor is usually measured using a speed/position sensor. The installation of the sensor not only increases the motor drive cost and the sensor maintenance cost, but also the installation could be very difficult or impractical for some applications such as the pumps used in oilrigs. This research paper presents a novel method for controlling the speed of induction motors without the need of a speed or position sensor. The information of the motor speed is obtained by processing the stator voltages and currents which are simply measured at the motor terminals or at the supply terminals. Induction motor drives without speed or position sensors will increase the drives reliability and reduce their costs. This research paper has developed an efficient control for induction motors using a closed-loop optimal control observer named the Kalman filter to compute the motor speed and position, as well as using an adaptive feedback regulator to provide a reliable and accurate speed control. The following lists the key work carried out in this research paper. a. Full investigation o f Kalman filter fo r the control o f induction motors. This research paper provides a full investigation of the practical application of Kalman filter for the control of induction motors. There has been very limited information about the use of Kalman filter for induction motor drives, possibly because of the difficulty of understanding the theory of the Kalman filter. This research paper research provides a detailed study of the control theory of the Kalman filter and its suitability for the control of induction motors. This research provides a concrete finding that Kalman filter is well suitable for induction motor control. Detailed formulations o f the specific field oriented control with Kalman filter fo r real-time control o f induction motors.

b.

This research paper develops all formulations required for the specific field oriented control of induction motors using Kalman filter. In particular, a recursive algorithm of the Kalman filter is given in the research paper. The algorithm and its corresponding formulations has provided an accurate computation of the rotor speed, the flux linkage, and the flux angle which are the essential components for the specific field oriented control of induction motors. c. DSP implementation o f the specific field oriented induction motor control. This research paper develops the software required for the implementation of the specific field oriented motor control in DSP TMS320LF2407. The software is developed in modules which can be easily modified for different induction motor drive applications. Real-time verification o f the specific field oriented control using Kalman field. A prototype of the induction motor drive is built to verify the specific field oriented control using Kalman filter. Typical measurements are given to demonstrate the efficiency of the novel control designed in this research paper.

d.

This chapter provides an introduction of the control method developed in this research paper. The following outlines the sections in this chapter. Section 1.1 Section 1.2 Section 1.3 Section 1.4 discusses the digital signal processor (DSP) control of induction motors. assesses the research in speed sensorless control of induction motors. introduces the novel control method designed in this research paper. control combines the field oriented control and the Kalman filter. shows the structure of this research paper.

This

1.1

DSP Control of Induction Motors

Induction motor controls were traditionally designed and implemented with analog components. There are several drawbacks with analog controllers including component aging and drifts. Analog controllers are usually hard-wired circuits that make modifications or upgrades fairly difficult. Also the implementation of advanced control algorithms using analog circuits requires an excessive number of components. On the other hand, digital control offers improvements over the analog control. The effect on the control due to analog component characteristic variations can be eliminated in the digital control. Upgrades in the digital control can fairly easily conducted in software, and the number of control circuit components required is significantly reduced since the digital controller can handle many control functions in a single chip. Digital signal processor (DSP) can provide high speed and high accuracy control signals. Fixed-point DSPs are preferable in the cost-effective induction motor control, because

fixed-point DSPs cost much less than the floating-point ones and for most applications, the dynamic range of 16 bits is sufficient. If needed for certain small portions in the control computation, the dynamic range can be increased in the fixed-point processor by carrying out floating-point calculations. The performance of an induction motor strongly depends on the characteristics of its control. DSPs can be used to enhance the real-time control of induction motors without the use of any electromechanical speed sensors. The DSP controller can reduce the number of control circuit components and can optimize the drive performance. The DSP for motor drive applications can perform the following. 1) Handle complex control schemes such as implementation of sensorless motor control algorithms to eliminate the need of a speed or position sensor. 2) Implement communication functions for fault and status information. 3) Re-program control schemes for different applications. 4) Generate high-resolution PWM signals for efficient control of the power electronic inverter and reduction of harmonics. 5) Provide a single chip drive control system and reduce the drive system cost.

1.2

Speed Sensorless Control of Induction Motors

The world market of induction motor drives is over ten thousand million US dollars annually with a rapid growth. Current researches on motor drives have focused on the elimination of the speed sensor at the motor shaft without deteriorating the dynamic performance of the drives [6 , 7]. The speed estimation is of particular interest with the induction motor drives where the mechanical speed of the rotor is generally different from the speed of the revolving magnetic field. The advantages of speed-sensorless induction motor drives include reduction of hardware complexity and cost, increase of control-circuit noise immunity and drive reliability, and reduction of maintenance requirements. Operations in the hostile environments mostly require motor drives without speed/position sensors. Figure 1 shows the block diagram of the speed-sensorless induction motor control. Basically there are two commonly-used control methods; the voltage-to-frequency (V/f) control and the field oriented control (FOC). Both methods for the speed sensorless control require a speed estimation algorithm. In the V/f control, the ratio of the stator voltage to stator frequency is kept constant using a feed forward control to maintain the magnetic flux in the motor at a desired level. This control is simple but it only can satisfy moderate motor dynamic requirements. On the other hand, high motor dynamic performance can be achieved using the FOC control which is also called the vector control. The stator currents are injected at a well-defined phase angle with respect to the spatial orientation of the rotating magnetic field, thus overcoming the complex dynamic properties of the induction motor. The spatial location of the magnetic field, that is the field angle, is difficult to measure.

There are several models and algorithms that can be used for the estimation of the field angle, for example the open-loop estimator such as model reference adaptive system (MRAS), or the close-loop observer such as the Kalman filter. The induction motor control using the field orientation usually refers to the rotor field. This research paper presents a novel rotor field oriented control.

Speed estimation

Field angle estimation

v/f control

Vector control

^r
Rotor model Stator model Kalman filter or observers

Rotor field orientation

Stator field orientation

Figure 1: Methods of Sensorless Speed Control

1.3

Novel Control Method for Induction Motors

This research paper investigates the real-time field oriented control (FOC) of induction motors using a Kalman filter and an adaptive feedback controller. This FOC control has been successfully implemented in the Power Electronic Laboratory at Ryerson University. Figure 2 shows the basic control structure. The main contribution of this research paper consists of achieving accurate sensorless control using a Kalman fiter implemented in a DSP processor.

1.3.1

Field Oriented Control

An efficient vector control scheme for induction motors has been implemented in this research paper based on the following three major points; 1) Transform the motor's three-phase ever-changing rotor-position dependent model of control and computation disadvantages into a two-coordinate motor-speed model for efficient computation and control. 2) Formulate the current and voltage space vectors for high performance motor speed and torque control.

3) Generate the pulse-width-modulation (PWM) signals to accurately control the power electronic inverter that drives the induction motor. Separately-excited dc motor drives are simple in control, because they independently control of the motor's flux and torque through two separate controls of the field current and the armature current. The vector control would like to make the induction motor drive similar to the dc motor drive with two separate controls of the motor flux and the torque. Furthermore, the vector control method can achieve an accurate steady state and transient control that leads to high dynamic performance of the induction motor in a fast response to the changes of its load.
Vsa
'ref 'sqref

PWMl-6

O"

PID

PID INVERSE PARK PID SVPWM VSI

`sdref

j

Vsp

PARK

EKF

CLARKE

s in 0 / COS 0

FLUX POSITION

Figure 2: The Control Structure of FOC with Kalman Filter

1.3.2

Kalman Filter

The conventional induction motor drive uses electromechanical sensors to measure the position and speed of the rotor. However in many applications such as the pumps used in oil rigs working under the sea, it would not practical to use sensors for the speed or position measurement as it is either technically impossible or extremely expensive. Recently, there have been several proposals addressing this problem and showing that the motor speed can be calculated from the current and voltage inputs to the motor. For a better motor performance, this research paper has designed an observer named the Kalman filter for an efficient control of induction motors. This filter is a statistically optimal observer, which has a good dynamic performance, disturbance rejection, and capability of working in a standstill position. In general, the implementation of a Kalman filter in the motor control is fairly involved.

because it requires an accurate model of the induction motor to be calculated in real time. The filter equation to be evaluated involves matrix computations. Digital signal processor (DSP) is especially suitable for this kind of numerical computations. An economical fixed-point DSP TMS320LF2407 from the Texas Instrument is selected for the implementation in this research paper. The design of the Kalman filter of induction motor control is detailed in Chapters.

1.3.3 Adaptive PID Controller
An adaptive controller can accommodate unpredictable changes, whether these changes arise within the system or external to it, such as design and measurement errors or uncertainties. This research paper has designed an adaptive proportional-integral-derivative (PID) control to overcome the control uncertainties and to enhance the quality of the induction motor control. The design of adaptive PID controllers for the induction motor speed and torque control is detailed in Chapter 2.

1.3.4 Modular Software fo r Induction Motor Controls
The benefits of structured modulator software are well known especially for large control systems with many sub-blocks. In examination of various motor control systems, it becomes clear that a large degree of commonality exists between the control software modules. Therefore, if each module is implemented according to well-defined guidelines, then compatibility can be assured across all modules. Since the modularity approach allows efficient software re-uses, efforts have been put on expanding the module library base for greater functionality and features in this research paper. As a form of modularity strategy, the Kalman filter module designed in this research paper can be easily transferred to different induction motor control applications.

1.4

Outline of the Research paper

The outline of the following chapters is given below. Chapter 2 presents an advanced field-oriented control for induction motors. This chapter examines the key components of the field oriented control including the 3-phase to 2-phase transformation, the space vector PWM technique, and the separate induction motor flux and torque control. develops the Kalman filter for induction motor control. This chapter details all the formulations required to accurately compute the flux angle for the speed sensorless control of an induction motor.

Chapter 3

Chapter 4

discusses the hardware and software implementation of the novel control scheme designed in this research paper using the DSP TMS320LF2407. This chapter details all key hardware components / circuits and software modules. presents the experimental results to demonstrate the accuracy and efficiency of the FOC control designed in this research paper. provides a conclusion of this research paper research and recommendations for future work.

Chapters

Chapter 6

Appendix A summarizes the notations used in this research paper. Appendix B provides the parameter values of the induction motor used in the experiment. Appendix C shows the characteristics of the FID controllers. Appendix D gives all software modules for speed sensorless control of the induction motor.

Chapter 2 Advanced Field Oriented Control of Induction Motors

This chapter presents an advanced field-oriented control (FOC) of induction motors, based on mathematical transformations of the standard three-phase motor model into a specific two-phase d-q coordinate model. The three-phase induction motor model is a complex matrix equation with sinusoidal functions of the rotor angle. This model has inherent control and computation disadvantages due to the ever-changing rotor angle. This can be greatly improved with a simple transformation of the three-phase model into a d-q model with the two coordinates rotate with respeet to the rotor flux at the synchronous speed. This chapter shows the transformation which, as an extension of the well-known Park's Transformation, provides the induction motor control and computation efficiency. The three-phase instantaneous stator currents of the induction motor may be modeled as a complex space vector which can be transformed into two currents: the stator d-coordinate current and the stator q-coordinate current, with the d-coordinate chosen to be in line with the rotor flux and the q-coordinate chosen to be 90° lagging. This chapter shows that as a result of the specific d-q transformation, the motor torque is proportional to the product of the rotor flux and the q-coordinate stator current. The rotor flux of the induction motor can be controlled through the regulation of the flux-related d-coordinate stator current. By maintaining the rotor flux to a desired value, there exists a linear relationship between the motor torque and the q-coordinate stator current. The motor torque can be controlled by regulating the q-coordinate stator current. Therefore, this transformation leads to a simple control structure similar to that of a separately-excited dc motor drive where the flux and the torque of the dc motor can be controlled separately. This transformation also provides significant computational advantage in the field-oriented control of induction motors. The following outlines the sections in this chapter. Section 2.1 presents the three-phase to two-phase transformation. This transformation is implemented in two steps. First, transform the three-phase system into the two orthogonal coordinate system. This transformation is known as a-P transformation or Clarke's transformation. Seeond, transform the a-P coordinates into the d-q coordinates, with the d-coordinate chosen to be in line with the rotor flux and the q-coordinate chosen to be 90° lagging. This transformation can be regarded as an extension of the Park's transformation. Section 2.2 presents a space-vector pulse-width-modulation (PWM) technique for the control of a three-phase yoltage-source inverter (VSI) that drives the induction

motor. The space-vector PWM technique is used to generate the desired instantaneous reference voltages for the VSI from the corresponding basic space vectors according to the switching states. Section 2.3 presents the field oriented control which provides an efficient real-time control of the torque of the induction motor which in terms controls the motor mechanical speed. Section 2.4 presents the design of FID regulator used to regulate the motor torque and flux to the desired values.

2.1

3-phase to 2-phase Transformation

The three-phase voltages, currents and fluxes of an induction motor can be modeled in terms of complex space vectors. The space vector for the stator currents of the motor is defined as follows. Assuming that ia, h, k are the three instantaneous currents in the stator, the complex stator current vector/s is defined by: is = ia +e 3 +e 3 ( 1)

This current space vector can be transformed into two currents: the d-coordinate current and the q-coordinate current by the following two steps: Step 1: Transform the three-phase system into two orthogonal coordinate system. This transformation is known as a-p transformation or Clarke's transformation. Step 2: Transform the a-P coordinates into the d-q coordinates, with the d-coordinate chosen to be in line with the rotor flux and q-coordinates chosen to be 90° lagging. This transformation can be regarded as an extension of the Park's transformation.

2.1.1

a-p Transformation (Clarke's Transformation)

The current space vector can be transformed into two orthogonal axes named a and P . The a-coordinate is chosen in line with the phase "a", and the P-coordinate is 90° lagging. Then the a-P coordinate currents and the three phase instantaneous currents are related as follows:
ha = h

(2)

where ia+h+ic-O is assumed. To further illustrate the above relationship, assume the three phase currents are balanced as given below: /^ = /s in ( 6») if, = / sin(nw + 2n 13) ig = /sin(ûW -2;r/3) Then the a-P coordinate current becomes:
i s a = I sin(ûX)
~ I sin(£Of " t"7T/ 2 )

(3)

(4)

o

Figure 3: a-p Transformation

2.1.2

d-q Transformation (Park's Transformation)

The core transformation in the field oriented control (FOC) is the d-q transformation, which can be regarded as an extension of the Park's transformation. The a*P coordinates are transformed into the d-q coordinates, with the d-coordinate chosen to be in line with the rotor flux 'P r and the q-coordinate chosen to be 90° lagging. Figure 4 shows the relationship between the current vectors in the two reference frames.

10

` Sa 

Figure 4: Park Transformation
In Figure 4, 6 is the rotor flux angle. the following equations: The d and q current components are determined by

hd = js,,cos0 + i^psin0

=-*sa sin 0 +

cos 0

(5)

The d-q coordinate system has the following characteristics: · · · It is a two-coordinate time-invariant system; both w and hq are dc quantities. The current w is a flux related component and the current isq is a torque related component. The torque of the motor can be easily controlled using these dc current data.

2.2

Space Vector PWM Control of Motor Drive Inverter

Space-vector pulse-width-modulation (PWM) technique has become a popular PWM technique for the control of three-phase voltage-source inverters (VSI) for applications such as induction motor drives. In comparison to the direct sinusoidal PWM technique, the space-vector PWM technique generates less harmonic distortion in the output voltages and currents and provides more efficient use of the dc supply voltage to the inverter [3]. Figure 5 shows a basic three-phase power inverter circuit, where Vd, Vb, Vc are the voltages applied to the induction motor, and where Vdc is the inverter dc input voltage.

1 1

03

05

Va

Vb
Vc

02

04

06

Figure 5: Three-phase Voltage Source Inverter
The six switches Q 1 to Q 6 are insulated-gate-bipolar-transistors (IGBT). sequence of these switches follows the conditions below: · · The ON-OFF

Three of the switches must be always ON and three are always OFF. The upper and the lower switches of the same leg are driven with two complementary pulsed signals with dead band between the two signals to avoid short-circuit.

The induction motor is supplied with the required three phase voltages for the designed operating conditions using the PWM technique. In this research paper, the space-vector PWM method is used to generate the gating signals for the switches in the VSI inverter that drives the induction motor with high performance in terms of fast response to changes of loads and speed commands. The relationship between the switching variable vector [a b c]^ and the line-to-line output voltage vector [Vab Vbc Vcaf and the phase voltage vector [Va % V ^ is given by the following equations. 1 0 -1
2



-1 1 0
-1

o' a -1 b 1
1
--

(6)

c

= - V dc V,

--

1

2

1

(7)

--

1 -- 1 2

where Vab=Va-Vb, Vbc=Vb-Vc, Vca=Vc-Va. three-phase voltages are:

The stator a-P voltages corresponding to the

12

(8 )

The above equation can also be expressed in matrix form by using the equation Va+Vb+Vc=0.
1

2
0

_JL 'y 2

2 . There are eight (2 ) possible combinations for the switch commands. These eight switch combinations determine the eight phase voltage vectors, of which the results are six non-zero vectors (yi-Ve) and two zero vectors (Vb, V7) as shown in Figure 6 .
The objective of space vector PWM technique is to generate the desired instantaneous reference voltages from the corresponding basic space vectors based on the switching states. Figure 6 shows that the basic space vectors divide the plan into six sectors. Depending on the sector that the reference voltage is in, two adjacent basic vectors are chosen. The two vectors are time weighted in a sample period T (PWM period) to produce the desired output voltage.

^2

(9)

VfiOlO)

V3 (011)

V7 (111 ) \ / Vo (000)

V4 (100)

Vl(OOl)

Figure 6: Confîguration of Space Vector PWM
Assuming that the reference vector Voui is in the sector 3 as shown in Figure 7a, the application time of two adjacent vectors is given by: T = T ,+ T ,+ T , ( 10)

where T4 and Te are the durations of the basic vectors V4 and Ve to be applied respectively. To is the duration for the zero vectors (Vbor Vj). Once the reference voltage Vout and the PWM period T are known, T4, Te and To can be determined according to the above equation [3].
13

T .=

2K dc

(3V,, S V s s )

( 11)

r , = V 3 -- y, sp V, dc T ,= T-(T,+ T ,)

( 12)

(13)

Where Vsfi are a-P components of Voui- The voltage Vout is an approximation of the desired output voltage based on the assumption that the change of output voltage is negligible within a PWM period T. Therefore it is critical that the PWM period is small with respect to the change of Vout- In practice, the approximation is very good because the calculation is performed in every PWM period (200ps). Figure 7b shows the pattern of space vector PWM in Sector 3. The space vector PWM is implemented in the DSP TMS320LF2407 in Ryerson Power Electronic Laboratory, where taon, tbon and tcon are the ON durations of switches Ql, Q3 and Q5 respectively. CMPRl, CMPR2 and CMPR3 are internal compare registers of DSP used to implement symmetrical PWM waveforms. Similarly, the patterns of the space vector PWM in other sectors can be formulated.

out

60°

VJlOO)

(a) Reference Voltage and Its Projections

14

CMPR3 CMPR2 CMPRl

tcon tbon taon t

PWMl

PWM3

-
t

PWM5

V4

T4/2

V4

V2 hV.

T 4/2

V4 1 ^ -- # V n

r

(b) PWM Pattern in Sector 3

Figure 7: Example of Space Vector PWM Pattern

2.3

Field Oriented Control

The field oriented control (FOC) designed in this research paper provides an efficient real-time control of the torque of the induction motor, which in terms controls the motor mechanical speed. The FOC also regulates the phase currents to avoid any current surges during the motor transient operation. The following describes the FOC method.

2.3.1 The Basic FOC Scheme
Figure 8 shows the basic scheme for induction motors using the FOC method. In this control scheme, two motor input currents ia, h are measured. These measurements are fed into the a-p transformation module. The outputs of this module are the two a-P currents: w and isp. They are inputs to the d-q transformation module. This module computes the two currents w and isq in the d-q rotating reference frame. Then w and isq ( they are virtually dc quantities) are compared to the flux reference isdref and the torque reference isqref- The torque reference is the output of the speed regulator in the speed feedback control module. The outputs of the two PID regulators are Vsd and Vsq. They become the inputs to the inverse d-q transformation module. The outputs of this module are Vsa and Vsp, which are the stator vector voltages in the a-P orthogonal reference frame. They are the inputs to the space vector PWM control module. The outputs of this module are the switching signals that operate the voltage source inverter (VSI) for driving the induction motor. Note that both d-q transformation and its inverse transformation require the value of the rotor flux
15

position for their computation. Therefore the rotor flux position needs to be determined prior to the transformation calculations.

DC

isqref PID

Vsq Inverse Park (d,q)-- >((x,p)

Vsa
Space Vector PWM

PWM Voltage Source Inverter

isdref

O

PID

Vsp
Vsd
sinO /cosO isa

isd

Clarke (3-phase to 2-phase)

Induction Motor

\ I

Figure 8: Field Oriented Control of Induction Motors

2.3.2

Rotor Flux Position

The information of the rotor flux position is crucial to the FOC control. Figure 9 shows the three reference frames, and the rotor flux position, the stator current space vector and the voltage space vector which rotate with respect to the d-q reference at the synchronous speed.

0

a = a

Figure 9: Relationship between Current, Voltage and Rotor Flux
In the induction motor, the speed of rotor is less than the speed of the rotor flux because of the slip due to friction and the mechanical load. For the FOC control, a specific method is needed to calculated. The basic method is the use of the current model that needs two equations of the motor model in d-q reference frame and a speed sensor [ 1]. Another method is to use a statistically optimal observer named the Kalman filter, to estimate the speed for achieving a sensorless control of induction motors. The details of this method is
16

presented in Chapter 3. Figure 10 shows the block diagram of the sensorless control. research paper is focused on the development of this control method.

This

RELD-ORIEMTED CONTROL

VOLTAGE SOURCE INVERTER

KALMAN FILTER

Figure 10: Sensorless Controller for Induction Motors

2.4

Adaptive PID Regulator

A motor drive based on the field-oriented control needs two inputs; the torque component reference isqr^ and the flux component reference isdref- The classical proportional and integral (PI) regulator is often used to regulate the motor torque and flux to the desired values. This regulator which is implemented in this research paper, is capable of reaching constant references by correctly setting both the P term (Kp) and the I term (Ki). The P term and I term respectively regulate the error sensibility and the steady state error. The regulation can be improved with the adaptive proportional-integral-derivative (PID) regulator [14]. To design a digital PID controller for the motor control, it may first consider the transfer function of an analog PID regulator: D ( s ) = K p - \ - K i --+ Kj)S (14) s where Kp is the proportional gain, Ki is the integral gain, and K d is the derivative gain. Similar to the Laplace Transform in continuous time domain, the integrator and differentiator can be represented by pulse transfer function in discrete domain. T (z + l) Integrator= (15) 2( z - l ) z-1 Differentiator= (16) Tz where T is the sampling period. Thus the transfer function of a digital non-adaptive PID controller is D ( z ) = K p + K , ^ ^ ^ ^ ^ + Kr Tz 2( z - l )

_ Og + a^z *+ ^ 2^
"
1 ^
17

( 17)

where

K ,T

2K^

( 18)

Figure 11 shows the block diagram of an adaptive control system. In this figure, r is the input or set point, c is the output feedback, y is the output and D(z) is the adaptive PID controller. The adaptive control scheme consists of two parts. First, the regulator uses initial (or updated) FID parameters and feedback input samples to determine the regulation. Second, the regulator updates the FID parameters until the error signal 62 is approaching zero.

Adaptive PID D(Z)

Figure 11: Adaptive PID Control
A quadratic objective function is used to minimize 62 with respect to the regulator parameters.

(19) r( z ) -1

The first order partial derivatives with respect to the regulator parameter «0 , 0 , , are given below: ^ "da, "I
1- z 2 1- z

+Û 2Z
-1

18

^ ,1 - z ^ 9^2
V

+fl,z `
1- z " '

^

-I

" 1

, ^ Z~'^
1 -z -

\
s,+

/

Oq+a , z" ' + 0 2 ^ 1
1- z
-1

z
1- z
-1

(20) /

where ao, ai and % can be solved according to the steepest decent method of the gradient techniques, so that the following equations can be obtained. a,,(k + \ ) = a,,(k) + P n=0,l,2; k = 0 ,l,2 "`

3a,,

(21)

where P is the parameter along the search direction. When combining equations (20) and (21) and r=e2 +y=e2 +D(z)ej, the following equations can be obtained.

r 1
9«o 9ai 9«2 '[l-z-' " [l-z -'
(22)

If ignoring the second order parts in df I Ba,,, the negative gradient is basically the product of error signal gg and error signal ey when using the first order approximation. Therefore, a modified gradient method is used as the search direction in updating the PID parameters. This also agrees with the general adaptive mechanism mentioned in [15]: new parameter = old parameter + (bounded step size) x(function of input) x (function of error). More specifically equation (21) can be written into: On{k + l)=an+P e 2 ik)ei(k --n) n=0,l,2; k=0,l,2' (23)

19

Chapter 3 Kalman Filter for Speed Senforless Control of Induction Motors
This chapter presents the design of a control observer named the Kalman filter for efficient induction motor control which does not require any speed / position sensors. The Kalman filter is an optimal recursive algorithm, which provides the minimum variance state estimation for a time-varying linear system. It can tolerate system modeling and measurement errors, which are considered as noise processes in the state estimation. The Kalman filter processes all available measurements regardless of their precision, and provides a quick and optimal estimate of the variables of interest, as well as achieves a fast convergence. Its extension to applications for non-linear systems is called the Extended Kalman Filter (EKF). This chapter describes the Kalman filter and its application to induction motor drives. Section 3.1 presents the basics for Kalman filter. First, the basic formulation of the Kalman filter control for the linear systems is provided. Second, the Kahnan filter is extended for the nonlinear systems, in particular for the induction motor control systems. Third, an efficient recursive algorithm for the DSP implementation of the Kalman filter is provided. presents the specific formulation of induction motors for the implementation of Kalman filter in the speed sensorless field-oriented control. First, the d-q model of the induction motor is re-formulated such that the rotor flux linkage and speed can be computed efficiently. Second, the per unit formulation is provided for the implementation in the fixed-point DSPs.

Section 3.2

3.1

Basics of Kalman Filter

Assume a linear system with the following equations. State Equation: Output Equation: x = Ax+ B u + w y = Cx+v (24) (25)

where x is the state variable vector, y is the output vector, « is the input vector, and A, B, C are the system matrices, w and v are the system and the measurement noises respectively. Assuming that w and v are stationary, white, uncorrelated and Gauss noises, their

20

expectations are zero, their covariance matrices are Q and R cov(iv) = cov(v) = £{vv^}= R where E{. } denotes the expected value, that is: E (w ) = P w f( w )dw where yfwj is the probability of w. Q

respectively. (26)

(27)

Briefly speaking, Kalman filter has the same structure as an observer shown in Figure 12 . The system equation of the Kalman filter is as follows. x = Ax + Bu + K ( y - C x ) = ( A - K C ) x + Bu + Ky (28)

where x is the estimate of state x. Kalman gain matrix K is a solution based on the well-known Riccati equation, which is developed to minimize the following quadratic objective function [6]. Minimize: J =^ E ^ f] , /= 1 K = PC'^R~^ AP + PA` --PC ^R ^CP + < 2= 0 e=x -x (29)

Kalman gain: Riccati equation:

(30) (31)

The error covariance matrix P is the solution of Riccati equation, which is used to determine the feedback matrix K of the Kalman filter. The matrix K, which is called Kalman gain, determines how the estimate of the state vector x is modified after the output of Kalman filter is compared with the real output of the system.

X=Ax+Bu
F e al s y s te m ___

I

x=Ax+Bu +r

^ K a l m a n filter

Figure 12: Principle of Kalman Filter

21

The extended Kalman filter (EKF) is developed to deal with the non-linearity of the induction motor. Assume g and h are the functions of the state equation and the output equation for a nonlinear system. x = g ( x ,u ,t) y = h(x) (32) The discrete time model of the nonlinear system can be represented in the following equations. x (k + l ) = x ( k ) + Tg( x (k ),u (k ),k ) = 0 ( x ( k ),u( k ),k ) y ( k ) = h (x (k )) (33) Where T is the sample period. The linearizing model of equation (33) is as follows. (34) (35)

x(k -hi) = A(k)x(k) + B(k)U(k) + w(k) y(k) = C(k)x(k) + v(k) where A ( k ) = ^ |,.,^ , B(k) = -^|,,=,,^ , C(k)=|^|,.,^

The v(k) and w(k) are considered as noises, with their covariance matrices R and Q. input Uk is perfectly known, then the prediction of state Xk is as follows: x(k + l) = A(k)x(k) + B(k)U(k)

If the

(36)

The state prediction error is found by subtracting equations (36) from equation (34) as given below. x(k +1) - jc(k -t-1) = A(k)[jc(k) - x(k)] - w(k) For simplicity, equation (37) can be written as: ^*+1 =A (38) is: (39) (37)

^ k ^ i= \^ k ~ ^ k ^ k =Xk - Xk Hence, the covariance matrix Pk of state prediction error P ,,,= A ,P ,A ,^ + Q The objective function for estimating zt+y is set as follows. = argmjn[(xt - x f P^~^ (x^ - jc) + (y^ - Q x)^ i?"' (y^ - C^x)] The minimum is found by putting the partial derivative with respect to x equal to zero. yield: Xk*i=Xk+Kt(yk~CkXk) P k .i= P k -K ,C ,P , 22 ,

(40) This

(41) (42)

T\-l K ,= P ,C ,i R + C ,P ,C ,` )

(43)

The extended Kalman filter (EKF) can be implemented in a DSP using a recursive algorithm given below. The implementation requires the following five steps: 1) State vector prediction at instant k+1. Xk^M k =^(.Xk/k,u^,k) 2) Prediction error covariance matrix computation. ^k+i/k " Q

(44)

(45)

3) Kalman gain computation at instant k+L ^k+\~ ^k+\jk^k ^k^k+\/k^k 4) State vector estimation at instant
·^fc+v^+i -- ^k-^xjk "

(46)

^(^k+yk ) )

(47)

5) Filter error covariance matrix computation at instant k+L
^k+]/k+l " ^k+]/k "" ^k+l^k^k+lfk

(48)

Equation (47) is crucial to the EKF algorithm, because it provides the state estimation. Figure 13 shows the EKF algorithm used in induction motor control.
W (K) Param eter Noise U(K) M easurem ent Noise

X 2_ N5-

V(K)

Ind uction M otor

Y(K)

>

P R E D IC T IO N

C O R R E C T IO N

E x te n d e d K a lm a n F ilte r

xfk ;

. Figure 13: Extended Kalman Filter Algorithm

3.2

Induction Motor Model for Implementation of Kalman Filter

As shown in previous section, an appropriate model of induction motor is required to
23

implement the Kalman filter [16]. The following presents the formulation of induction motors for the implementation of the Kalman filter. The stator and rotor flux in the stator reference frame are defined as
= L s is a ^sp = h h p ^R ha ^H ^R a ^H ^ R P

(49)

^R a -

^R P ~ ^ R h p

The a-P stator voltages in the stator reference frame are: ^Sa - ^ s h a (50) =^shp The a-P rotor voltages in the stator reference frame are:

(51)
Van R bÎd * 'R p -- dt
RP

For squirrel-cage induction motor, the rotor voltages are zero that is Vr,,=0, Vrp=0. Since the digital computation period for the speed control loop is very short as compared to the induction motor speed, the speed can be considered constant to have no change during one sampling period, that is doe/dt=0. If the required rotor flux %a, ¥ rp, stator current isa, isp and speed co are selected as state variables, the state equation and output equation of the induction motor can be written as: 1) State equation is
Tr ^ L fj O TrK l Tr Rr

0 Ki

r

0 0 0 0 0

-- --
ha hp T'Ra ^RP
C O

^Sa hp É. dt Ra %Rp 0)
0 Kl 0 Tr 0 0

LfjCù L r K i^ 1 Tr

1 0
0 1

-CO 1 Tr 0

K,

h t
Tr 0

C O
0

" Sa 0 0 }*sp 0 0 0 0

(52)

2) Output equation is

24

*Sa

0 0 0 0 10 0 0

hp
Ra

(53)

·P. Û )

where K r=Rs+(Lh/L r) R r, K l=(tL s. The per unit model is useful for the digital implementation as it converts various quantity ranges into one single range. This allows to choose one accurate numerical representation for the complete system. With the implementation in the fixed-point DSP TMS320LF2407, the Q15 format is used in this research paper for its greatest precision. In per unit model, all quantities are scaled with respect to their base values.
U/ -- U /n iT / ^ Ra ^ Ra^ b

ha ~ ^Sah hp ~ h p h

^Sa =^SaUb ^sp ~^sp^b

X T /

^RP -^R P ^b

--il/niT/

(0 = (0(0^

(54)

(55) where Ip, Vp are the base values of the phase current and voltage, cop is the nominal speed, % is the base flux, Zp is the base impedance, fsa, i'sp, ^Ra, P"Rp u"sa, u"sp, o)" are normalized currents, fluxes, voltages and speed respectively. By using normalized values of state variables, equations (52) and (53) can be written as the Per Unit Model o f Induction Motors below. 1) State equation is
T r Z), co Tr K , T r R r Zj, Tr R p % -0)i,(0"

Kr
'tl

0

T r ^ r Zp % T r Z/jC o"

0

Kl

Sa

0
Kp % Tr Z ,

d dt % IX / n ^RP co ""

Lr K p

0
Tr % Tr Zf,

1
Tr <o^(o"

0 0

1
Tr

^Sa % 1 1 /n ^Ra 0 11/ n ^RP 0 £0"
0 0

1 0 Z. 0 0 0

o' 1 0 *Sa (56) 0 rspj 0

0

0

0

2) Output equation is

25

^Sa

Jsp_

1 0 0 0 o ' 11/n ^Ra 0 1 0 0 0 11/ n Û)"

(57)

Using the linearizing form of the induction motor model, the matrices and vectors that are needed for the EKF recursive algorithm [equations (44)-(48)] can be calculated.

^Sa a - T ^ V 's ,
0=

+

LuRo r ^ -

R p (58)

T, Z , a h = Cx = ^Sa ''SP_

R P

(59)

0 K, 0 A= 3<P dx Lu cO i, 0 0 1 -t E ^ 0 Lfj 0

j-

Zfc L lK , C O , Lr K l T 1 --- T, oe"

T

L rK , Y ^H^R ^R^L % -TCOf^CO'' 1 -Z _ Tr 0

T

Û)"

T " ^H^b \i/n L ^Z , Lr K , (60) -T(0,^,"p ,,

T(0,(o" 0

1

dx

1 0 0 0 0 0 10 0 0

(61)

First, the matrices and vectors for the induction motor model are calculated. Second, the recursive algorithm for the extended Kalman filter is executed. Third, the rotor flux and the rotor speed are computed.

26

The recursive Kalman filter algorithm can accurately determine the speed of the induction motor and the rotor flux position or angle. This allows an accurate control of the motor speed without the need of a speed or position sensor. However, the implementation of the Kalman filter is a fairly involved process. The model of the induction motor must be calculated in real time, which involves many matrix multiplications. The DSP with high computation capability is most suitable for this type of control process. Appendix B lists all the internal parameters of the induction motor used in this research paper, which are needed for the calculations of equations (44) to (48).

27

Chapter 4 Digital Signal Processor Implementation of Speed Sensorless Field Oriented Control
This chapter presents the digital signal processor (DSP) implementation of the field oriented control (FOC) of induction motors without any speed or position sensors. The hardware and the software implementation of the speed sensorless FOC system is detailed in this chapter. The following outlines the sections in this chapter. Section 4.1 presents an overview of the DSP FOC operation. This section describes the key operations which include determination of the rotor speed and flux angle using Kalman filter, d-q transformation with respect to the rotor flux, speed and torque regulation, and generation of PWM control signals. Section 4.2 presents thehardware implementation of the FOC system for induction motors. This section describes the power electronic inverter circuit, the DSP control circuit, and their interface used for the implementation. presents the software implementation of the FOC operation. This section describes the software modules used to implement the sensorless speed control of induction motors. presents the debugging of hardware and software. This section describes the six phases used in debugging the FOC software and hardware.

Section 4.3

Section 4.4

4.1

Overview of DSP FOC Operations

The fixed-point DSP TMS320LF2407 is the core of the control system designed in this research paper. The following provides an overview of the DSP FOC operations. 1) The DSP operates its analog-to-digital converter (ADC) to collect the instantaneous induction motor input currents measured by a current transducer at the motor terminal. The DSP executes the recursive algorithm of the extended Kalman filter, using the measured motor currents, to compute the a and P currents, the rotor speed and flux angle.
28

2)

3)

The DSP carries out a specific d-q transformation with the d-coordinate chosen to be in line with the rotor flux, using the a-P currents and the flux angle, to compute the d-coordinate and q-coordinate currents. The DSP executes three feedback regulators for the motor speed, the rotor torque, and the rotor flux, to determine the d-coordinate and the q-coordinate stator reference voltages. The DSP carries out an inverse d-q transformation, using the d-q reference voltages, to compute the stator a and P reference voltages. The DSP executes the space vector pulse-width-modulation (PWM) module, using the a-p reference voltages, to compute the PWM control signals. The DSP finally outputs the PWM control signals to the gating circuits of the power electronic inverter that drives the induction motor.

4)

5)

6)

7)

4.2

Hardware Implementation of Field Oriented Control

Figure 14 shows the block diagram of the hardware required to implement a sensorless speed control system for an induction motor. The DSP control system designed in this research paper consists of the following major hardware components: 1) 2) 3) 4) DSP controller: Current sensors: Power inverter: Induction motor: Texas Instruments, eZdspTMS320LF2407 development kit. Two LEM, lOA current transducers. Semikron-SkiiP2, IGBT module. Teco-Westinghouse, 3-Phase, 60Hz induction motor.

-

Power Supply

DSP Isolator T ra n sfo rm e r

V oltage Am plifier

IGBT P ow er M odule

W atch W indow

C u rre n t S e n so rs

Induction Motor

Figure 14. Experiment Setup for Sensorless Control System

29

The power hardware used to implement and test the control scheme developed in this research paper is based on the six-power IGBT module (SkiiP2 from SEMIKRON). This module is controlled by a DSP (TMS320LF2407 from Texas Instruments) via a voltage-level shifter (MC14504). This shifter amplifies the PWM output voltages from 3.3V to 15V for gating the IGBT switches. The current sensing is performed via two current-to-voltage transducers (LEM type) supplied with ±12V. Their maximum input current is +10A, which is converted into a 3.3V output voltage to match the requirement of inputs to DSP. The induction motor is a 3-Phase, 60Hz motor (EPACT from TECO-WESTINGHOUSE), of which the rated power is 5 horsepower. DSP is the key control element in this research paper design of the FOC of induction motors. The settings of the DSP TMS320LF2407 are given as follows. Development/Emulation: Code Composer 4.1 supports real-time debugging. CPU Clock: 30MHz. PWM frequency: 5 kHz. PWM mode: Symmetrical with dead band 1.8|is. Interrupts: 2 (Tl Underflow - System time base). System time base/PWM period: 200pS. Peripheral Usage: Timer 1, PWM 1-6, ADC (2 channels). Current loop sampling frequency: 5 kHz. Two ADC input pins (Pin 4, 6 in port PI) are used to sense the two stator currents ia, hPWM 1-PWM6 output pins (Pin 9-14 in port P2) are used to drive the IGBT power inverter.

SRAM PROG RAM / DATA

DATA ADC AD DR ESS CD CD

u
TM S320 LF2407

PA RA LLEL/ JTA G

JT A G

PW M

JTA G P 1 0

PO W ER P3

Figure 15:

Block Diagram of eZdspTM LF2407

The eZdsp LF2407 platform is used to develop and run software for the DSP TMS320LF2407. With 64K words of onboard program/data RAM, this platform allows a full speed verification of software code. To simplify code development and shorten
30

debugging time, a C2000 Tools Code Composer driver is provided, which could run the software in real time. Figure 15 shows the block diagram of this platform.

4.3

DSP Software Implementation of Field Oriented Control

DSP control software developed in this research paper is based on two modules: the initialization and the run module. The initialization module is performed only once at the beginning of the software execution. The run module is based on a user interface loop interrupted by the PWM underflow. When this interrupt flag is set, the corresponding Interrupt Service Routine (ISR) is acknowledged and served. The complete extended Kalman filter (EKF) and the FOC algorithms are computed within a PWM interrupt at the same period as the chopping frequency 5 KHz. The overview of the software is given in Figure 16.

^ _c_intO ^

Initialize S o ftw a r e M o d u le s

S a v e C o n te x ts a n d C le a r Interrupt F la g s

Initialize T im er T1 a n d R e a l-tim e M onitor

E x e c u te th e S e le c te d I n c r em e n ta l Build

E n a b le T1 U n d erflo w Interrupt a n d C o r e Interrupt INT2

E x e c u t e D A T A .L O G M o d u le

Initialize S y s t e m P a r a m e te r s a n d In c r em e n ta l Build O p tio n s

R e s t o r e C o n te x ts

Return ^

Figure 16:

Software Flowchart

The DSP Controller Full Compare Units are designed to generate symmetrical complementary PWM signals to the power inverter at a frequency of 5KHz. TIMER 1 is used as the time base with a sampling period T= 200 ps. The benefits of structured modulator software are well known. This is especially true for large complex systems, such as the FOC motor control, with many sub-blocks. It reduces the developing time, and could be reused in the future project. Therefore, a typical
31

incremental build process is used in this research paper. ****************************************************************** Phase commissioning options
******************************************************************

phase_commissioningl phase_commissioning2 phase_commissioning3 phase_commissioning4 phase_commissioning5 phase_commissioning6

.set .set .set .set .set .set

1 0 0 0 0 0

; hardware checkup ; open loop start up ; current measurement chain checking ; current regulation implementation ; Kalman filter estimation ; closed current and speed loop

spd_re^ pid_reg_spd 015/015 s p d jd b

spd_out/ iq_ref Iq_fdb p id .re g jq 015/015

uq_out/ park.O LPARK 015/ 015

lpark_q/ Ubeta SVGEN.DO 015/015

"PWI^ -- 
lpark_d AJalfa M1unc_p PWM6 la_out/ clark_d ILEG2DRV CLARKE 015/015 Q15 A D 0 H W ADCIN Tc PC PWM DRV QO/HW EV HW PWM3 PWM4 PWM5 3-Phase Inverter

PWM1

ud_out/ ipark.D pid_reg_ld 015/015

ld_Mb

sin 0 /cos 0
park_D Theta_est 015/015 p sin b e.e sti^ A psiRa! n_est park_0 PARK 015/ 015 park_d EKF 015/ 015 clark.q

ADCINy

park.q

clark.c

Figure 17: EKF Software Structure for an Induction Motor
The Figure 17 shows the block diagram of the software developed in this research paper. The system implemented here uses the following assembly software modules, which meet the requirements of reusability, compatibility, predictability and expandability. Appendix D gives all of the software modules used in this research paper. CLARKE: Clarke transformation module converts the three-phase stator currents into two-phase quadrature currents. Extended Kalman filter computes the rotor flux and speed. Store the real-time values of two selected variables for graphical display. Inverse Park transformation converts rotating reference frame into stationary frame.
32

EKF: DATA_LOG:

I_PARK:

ILEG2DRV-ADC: Convert two current inputs ia, ib into digital representations. PARK: Park transformation converts two-phase a-p stationary frame into d-q rotating reference frame.

PID_REG_ID/IQ: Control module for regulatinge currents id, iqPID_REG_SPD: Control module for speed control loop. FC_PWM_DRV: Generate PWM outputs. THETAJEST: Calculate the sine value and cosine value of rotor flux angle (sin 6 / cos 0) for Park transformation and inverse Park transformation. Generate 60 Hz saw-tooth waveform to emulate the rotor flux angle in debugging. Look-up table for sine value from 0° to 360°. Square-root table from 0 to 1.22. Use space vector PWM technique PWM1-PWM6. Initialize the software. to calculate duty ratios for

RAMPJGEN:

SINTB360: SQRTJTAB: SVGEN_DQ:

SYS_IN1T:

4.3

Debugging of Software and Hardware

After the hardware work and software programming have been completed, the software needs to be carefully debugged. The Incremental Build Process plays a key role in debugging, which decomposes the whole control task into several small tasks. There are totally six phases in debugging of the control system: Phase 1: Phase 2: Phase 3: Phase 4: Phase 5: Phase 6: Confirm operation of hardware connection and the code framework. Check the forward control path and PWM driver. Use the 60 Hz open-loop start to check the current sensing and feedback path. Check the correct operation of the current regulators. Examine the correct operation of extended Kalman filter estimation and insert it in the control system. Implement close loop control of current and speed.
33

For simplicity, Phase 2 is explained as an example. The other phase debugging procedure can be found in the software of main program foc2.asm (Appendix D).

a)

Goal of the Phase 2

The objective of this phase is to check the PWM driver and PWM outputs with a simple RC filter. Following this verification, the induction motor will be connected to the power inverter board and started to run smoothly

b) Building blocks interconnection
Figure 18 shows all software modules to be used in Phase 2. The output of the inverse Park module "I_PARK" is used as the stator voltage reference. The amplitude and phase of this voltage vector are translated into commutation durations by the SVGEN_DQ module, which uses the space vector PWM technique. The FC_PWM_DRV module uses the timing information to generate the PWM outputs to control inverter for driving the induction motor. The DATA_LOG module provides a dual memory buffer to display two graphical waveforms in real time, which could be used to show any interested variable such as Ta, Tb, Tc or PWM outputs. The RAMP_GEN module is used to generate a 60-Hz saw-tooth waveform to emulate the rotor flux angle in debugging.

rmp_offset rm p.treq rm p.g ain R M P .G E N 0 1 5 /0 1 5 t h e t a jp l r 1) Check the waveforms of T a j b j c 2) Check PWM waveforms

PWM1 lpark_qi Ubeta S V G E N _D O 0 1 5 /0 1 5

C o s ta n t c u rre n t inputs

Ipark.O   .  LPARK 015/ 015 PC PWM PW M3 3-Phase nverter OO/HW M func.p PW M5

Ipark.D

ipark_d /U alfa RAM Buffi

dlogJptrO D A TA .LO G 015 /H W

d lo g jp t n

RAM Buff2

RC filter SCOPE

Figure 18: Overview of Phase 2 Software Flow c) Hardware and software debugging in Phase 2

34

1. Select the build option phase_commissioning2 .set 1 (the others stay tq zero) in the main program foc2.asm, then build the project and load the program^c2.o«r and the corresponding workspace (see Figure 19). 2. Connect a RC filter to one PWM output. 3. Verify that the filtered waveform. 4. The values of resistor and capacitor in the RC low-pass filter can be changed to have different cutoff frequencies, which must be well below the PWM carrier frequency. 5. Connect the PWM outputs to the power inverter. 6. Increase the input voltage gradually until the motor starts running. 7. Change the value of tmp_freq (one of inputs in RAMP_GEN module) in a real-time watch window to vary the motor speed.

h-OlL#

case s ;& 4sru e; 0 0 6 0A A C 6 S srsr DQ62'. ... êVk^i:j!zxrjsi D Q & s A c & s snue o o e *R o sy
0065 WE3KLRE3RT1 K565 8BIÏS

«366 criK ? itrr

4

w e» 6 9 0 $ »
·H a t
· H at

eaom

·Hat

«B

Figure 19: Overview of Phase 2 Workspace
It should be pointed out that the real time watch window is very helpful in the debugging period, since it can be used to watch each internal variable defined in the software and can be updated continuously.

35

Chapter 5 Experimental Verification of Field Oriented Motor Control using Kalman Filter

This chapter presents the experimental verification of the field oriented control of induction motor using Kalman filter. Typical measurements are given to demonstrate the efficiency of the novel control designed in this research paper. The following outlines the sections in this chapter. Section 5.1 presents all the waveforms of the internal states in the close-loop speed control to demonstrate the efficiency of the control process designed in this research paper. Section 5.2 demonstrates the dynamic response of the speed sensorless control scheme, and results of the speed-step response are given. Section 5.3 shows the quality of the speed sensorless control, and results of the relative speed errors are given.

5.1

Internal States of Closed-Loop Control

This section presents all the waveforms of the internal states in the close-loop speed control to demonstrate the efficiency of the control process designed in this research paper. The control scheme was shown in Figure 17 (Chapter 4). In the following demonstration, the reference speed spd_refwas set to 1758 rpm 1) Phase currents (4, /*) are measured by current transducers, then the outputs of the transducers are converted into digital signals (Ia_out, Ib_ouf) by two analog-to-digital (ADC) channels in the DSP analog interface. Figure 20 shows the phase currents.

36

JQ

0

1

2

3

4
t(us)

5

6

7

8

x10

Figure 20:

4, h Currents from ADC

2) The digital signals of the two phase currents are transformed into a-p currents {clarkji, clark_q) using Clarke transformation. Figure 21 shows the a-P currents.

clark-d clark-q

Y 

<

I
-3 -

t{us)

x10

4

Figure 21:

Currents from Clarke Transformation
37

3)

Kalman filter module has four inputs (two currents clark_d, clark_q and two voltages Ubeta,Ualfa) and five estimate outputs (two currents iSal_est, iSbe_est, two rotor fluxes psiRal_est, psiRbe_est and one speed estimation n_est). Figure 22 and Figure 23 show the estimated outputs from the Kalman filter module.
4 park-d 3 park-q

2 1

I §.

0
1

I

·2
·3 -4

0

1

2

3

4 t(us)

5

6

7 x io

8

Figure 22; Current Estimated by Kalman Filter
0.2
0.15 0.1 0.05

-0.05 0.1

-

-0.15 0.2
-

-

0.2

-0.15

-

0.1

-0.05 0.05 psiRal-est(Wb)

0.1

0.15

0.2

Figure 23: Flux Circle Estimated by Kalman Filter

4) a-p currents (park_d, park_q) computed by Kalman filter module are transformed into two quadrature currents (park_D, parkjQ) with reference to the rotor flux using extended Park transformation. Figure 24 shows the quadrature currents.

38

3.5

2.5

park-D

s. 1.5 Û i 1
0.5 park-Q

I

-0.5 t(us)
X

10

4

Figure 24:
5)

Currents from Park Transformation

Speed regulator has two inputs. One is reference speed (spd_ref), and the other is speed feedback (spdjdb) estimated by Kalman filter. The output of the regulator is used as the reference iq current (iq_ref). Figure 25 shows the speed control.
1800 1600 1400 reference speed speed estimation

1200

|.

1000

600 400

200
speed error

0

4 t(us)

X

10

Figure 25:

Speed Control

39

6) There are two regulators for ij and iq. The id regulator has two inputs: one is reference id (id_ref), which is dependent on the flux requirement; the other is feedback id (id_fdb), which is obtained from the Park transformation. Similarly, the ig regulator has two inputs: one is reference iq(iq_ref), which is dependent on the speed requirement; the other is feedback iq {iq_fdb), which is obtained from the Park transformation. Figure 26 shows the torque control and Figure 27 shows the flux control. Figure 28 shows the outputs from the two regulators.
0.3

0.2

iq-error

0.1

-

0.2

-0.3 -0.4 iq-ref -0.5 ((us) x10
4

iq-fdb

Figure 26: iq (torque component) Control

3.5 id-ref

2.5

id-fdb

2
1.5
1

0.5 0 -0.5

Id-error

0

1

2

3

4 t(us)

5

6

7

8 x io

Figure 27:

id (flux component) Control

40

100
uq-out 80

60

>

I

§ F

40

20 ud-out

-20
t(us)

x10 4

Figure 28:

Voltage Outputs from id, iq Regulators

7) Inverse Park transformation is used to convert the outputs of the two current regulators (ud_out, uq_out) into a-P voltages (Ualfa, Ubeta). Figure 29 shows the a*P voltages.
100
U alfa U b eta

40

â I

i
-20 -40 -60 -80 -100
t(u s)
4

Xio

Figure 29:

Ualfa, Ubeta from Inverse Park Transformation

8) Flux angle estimation (theta_est) is used to calculate the sine and cosine values of flux angle, which are crucial to Park and inverse-Park transformations, based on the estimated flux inputs from Kalman filter. 9) Given the required a-P voltages (Ualfa, Ubeta), space vector PWM module is used to generate corresponding ON durations: Ta, Tb and Tc in a sample period T. Figure 30
41

shows the durations.

Ta

Tb

0.8
0.6 0.4

in

i
Q.

0-2 0
-0.2

I
^

.8
O

^ -0.4 >»
-0 .6

-

0.8
0
1

w
2
3 4 t(us) 5

6

7

8

x10

Figure 30:

Duty Ratios of PWMl, PWM3 and PWM5 in Carrier Period

10) Three full compare units in the DSP are used to produce the PWM1-PWM6 based on the Ta, Tb, Tc and sample period T. 11) The PWMs from the DSP are fed to the voltage source inverter (VSI). The outputs of the VSI are three-phase voltages used to control the induction motor. Figure 31 shows the PWM outputs from the IGBT module and Figure 32 shows the line-to-line voltages fed to the induction motor. From above figures, the following results can be obtained. 1) ia leads 4 120 degrees. 2) After Clark transformation, clark_d leads clark_q by 90 degrees. 3) Currents (park_d, park_q), estimated by Kalman filter, are almost the same as the clark_d and clark_q. 4) After Park transformation, id, iq currents (ParkJD, Park_Q) are close to dc currents. 5) The performances of the speed control, id regulation and iq regulation are very good. 6) Ualfa leads Ubeta by 90 degrees. 7) Flux is constant in the control process. 8) Ta leads Tb 120 degrees, Tb leads Tc 120 degrees. 9) Phase voltages are 120 degrees shift from each other.

42

Tek Run: S.OOkS/s


sample
ra -

»!

o n C h3

1.00 V 50.0 V

jg lB

1 .0 0 V

M l 0.0ms

Chi >

4omV

Figure 31;

PWM Outputs of IGBT Power Module

Tek aEHB lo .o k s/s

3 Acqs

Chi ' sddmv 20.0 V

Ch2 ' 'sdo'mv

MS.boms Chi

j

40mV

Figure 32:

Line to Line Voltages of the Induction Motor

43

5.2

Dynamic Response

This section demonstrates the dynamic response of the speed sensorless control scheme. Figure 33 shows speed-step response from SOOrpm to ISOOrpm. The scope Channel #1 is the speed reference, Channel #2 is the measured speed, Channel #3 is the flux component id , and Channel #4 is the torque component iq.

Clvl Zoom:'

W.OX Vert

6.2X Horz

^

cli3

étii ' itidrnV
soomv

IK D

Clii ' SBomi/ ' ' Wibbms àii J * ' ' i.Vo ^
i.o o v

(a) without load
CÜ4 zoom: l.o x v é ït d.3XHbtz :

r

Ch3

soomv

mv I.OOV

fODO nS

(b) with load
Figure 33: Speed Step Response (from SOOrpm to ISOOrpm)
The Figure 33a shows the speed control without load. Figure 33b shows the speed control with load (another EPACT motor is used as a load). The response time varies between
44

500ms and 800ms.

Figure 34 shows the stator currents starting from 0 to lOOOipm.

·+ + + + ··

sdoniv

O Î2 Ch4

do v a M20.0ms Ch3 j 00 Vfl

2.66 v

Figure 34; Speed Transient from 0 to lOOOrpm Chi; n: mechanical speed; Ch2: Ib stator phase current; Ch4: la stator phase current
The following scope picture shows a speed reversion test from -lOOOrpm to lOOOrpm with load.
Cll3 Zoo IX Horz

a
tAf'-itddm V........ CIÎ2 ` 'Sddmti' ` Miftbm t `Clia
«Ê 2.00 V ch4 1.00 V

` ` `i.W tr

Figure 35: Speed Reversion (from -lOOOrpm to lOOOrpm)

45

5.3

Speed Control Accuracy

For testing the quality of the speed sensorless control performance, the relative error in speed is defined as follows: n --n,,f e(%) = ------ Î^100% ^ref (35)

Table 1 shows the relative speed error at different speeds. The measurements run from 500 rpm up to 1800 rpm (the nominal speed of the induction motor used in the test).

TABLE 1 Steady State Performance of Speed Sensorless Control
Reference speed (rpm) 549.3 824.0 1098.6 1373.3 1648.0 1702.9 1757.9 1785.3. Measured speed (rpm) 550.5 818.9 1095.0 1376.0 1650.0 1702.0 1758.0 1789.0 Estimated speed (rpm) 550.8 819.6 1096.5 1377.6 1651.5 1702.5 1759.5 1790.7 Speed control error (100%) 0.22% -0.62% -0.33% 0.20% 0.12% -0.05% 0.005% 0.21%

46

Chapter 6 Conclusions
This research paper has presented a novel method for the speed control of induction motors without using a speed sensor. The rotor speed is accurately computed using the Kalman filter software module designed in this research paper. The computation, which has been implemented in the DSP TMS320LF2407, simply uses the two current measurements at the motor terminal. This replaces a speed sensor and eliminates the difficulty of the sensor installation in many applications. This research paper has presented an advanced field oriented control of induction motors based on a specific d-q coordinate model, with the d-coordinate chosen to be in line with the rotor flux and the q-coordinate chosen to be 90° lagging. The position of the rotor flux is accurately computed using the Kalman filter module. This eliminates the position sensors required to monitor the flux. This research paper has shown that as a result of the specific d-q transformation, the motor torque is proportional to the product of the rotor flux and the q-coordinate stator current. This significantly simplifies the induction motor control, such that the rotor flux is controlled simply by regulating the flux-related d-coordinate stator current and the motor torque is controlled just by regulating the q-coordinate stator current. This research paper has presented the Kalman filter which is an optimal control observer and its recursive algorithm and formulations which are specifically designed for the induction motor control. The Kalman filter provides the minimum variance state estimation and tolerates system modeling and measurement errors, which are considered as noise processes in the state estimation. The filter processes all available measurements regardless of their precision, and provides a quick and optimal estimate of the variables of interest, as well as achieves a fast convergence. This research paper has presented the implementation of the field oriented control of induction motors using Kalman filter. The hardware requirements and all software modules are detailed. The experimental verification of the control method designed in this research paper has been provided. Typical measurements are given to demonstrate the efficiency of the novel control designed in this research paper.

Key Contributions of this Research Paper
The following lists the key contributions in this research paper. -1. Full investigation of Kalman filter for the control of induction motors.

47

This research paper has provided a full investigation of the practical application of Kalman filter for the control of induction motors. There has been very limited information about the use of Kalman filter for induction motor drives, possibly because of the difficulty of understanding the theory of the Kalman filter. This research paper research has carried out a detailed study of the control theory of the Kalman filter and its suitability for the control of induction motors. This research has provided a concrete finding that Kalman filter is well suitable for induction motor control. 2. Detailed formulations of the specific field oriented control with Kalman filter for real-time control of induction motors. This research paper has developed all formulations required for the specific field oriented control of induction motors using Kalman filter. In particular, a recursive algorithm of the Kalman filter is given in the research paper. The algorithm and its corresponding formulations has provided an accurate computation of the rotor speed, the flux linkage, and the flux angle which are the essential components for the specific field oriented control of induction motors. 3. DSP implementation of the specific field oriented induction motor control. This research paper has developed the software required for the implementation of the specific field oriented motor control in DSP TMS320LF2407. The software is developed in modules which can be easily modified for different induction motor drive applications. 4. Real-time verification of the specific field oriented control using Kalman field. This research paper has built a prototype of the induction motor drive to verify the specific field oriented control using Kalman filter. Typical measurements are given to demonstrate the efficiency of the novel control designed in this research paper.

Future Work in Field Oriented Control using Kalman Filter
This research paper has provided a concrete proof that Kalman filter can be used to accurately compute the motor speed and flux which are crucial for the specific field oriented control of induction motors. The efficiency of the novel control designed in this research paper has been demonstrated. Key future researches in the area of the induction motor control are proposed in the following. 1. Tune the Q and R matrices in the Kalman filter to get better performance.

48

Q and R are the covariance matrices of the state and measurement noises in the Kalman filter formulation. To date, there has been no exceptional good method to determine the matrices of Q and R. 2. Find lower order of the state equation for the Kalman filter computation. If a lower order state equation, instead of the 5-order equation presented in this research paper, can be found and can represent accurately the rotor speed and flux, the computation can be significantly reduced. The reduction of computation time is very important for the real-time control of induction motors. 3. Compare the motor drive with or without a speed sensor. Usually the sensorless control has good performance in the normal motor speed. However, the performance may deteriorate in very low motor speed. In fact, low speed sensorless control for induction motors is a hot topic in recent research on sensorless control.

49

Bibliography
[1] R. Di Gabriele, F. Parasiliti, M. Tursini, "Digital Field Oriented Control for induction motors: implementation and experimental results". Universities Power Engineering Conference (UPEC97) Texas Instruments, "Implementation of a Speed Field Orientated Control of Three phase AC Induction Motor using TMS320F240", Literature number: BPRA076, January 1998 Texas Instruments, "Field Orientated Control of Three phase AC-motors", Literature number: BPRA073, December 1997 R. Di Gabriele, F. Parasiliti, M. Tursini, "Digital Field Oriented Control for induction motors: implementation and experimental results". Universities Power Engineering Conference (UPEC'97) L. Loron, G. H. L. Peterson, "Application of an Extended Kalman Filter to the estimation of the parameters of a solid rotor asynchronous drive with two degrees of freedom", EPE 1991, Firenze Texas Instruments, "Sensorless Control with Kalman Filter on TMS320 Fixed-Point DSP", Literature number: BPRA057, July 1997 A. Germano, F. Parasiliti, M.Tursini, "Sensorless Speed Control of a PM Synchronous Motor drive by Kalman Filter", International Conference on Electrical Machine (ICEM '94) C. Manes, F. Parasiliti, M.Tursini, "A Comparative Study of Rotor Flux Estimation in Induction Motors with a Nonlinear Observer and the Extended Kalman Filter", IEEE International Conference on Power Electronics, Control and Instrumentation (lECON '94) Werner Leonard, "Control of Electrical Drives", 2nd Completely Revised and Enlarged Edition, Springer, ISBN 3-540-59380-2 D. W. Novotny and T. A. Lipo, "Vector Control and Dynamics of AC Drives", Oxford Science Publications, ISBN 0-19-856439-2 K. Astrom, B. Wittenmark, Adaptive Control, Addison Wesley, 1995. C. Phillips, H. Nagle, Digital Control Systems Analysis and Design, Prentice Hall, 1995.
50

[2]

[3]

[4]

[5]

[6]

[7]

[8]

[9]

[10]

[11] [12]

[13]

Y. Dote, Servo Motor and Motion Control Using Digital Signal Processors, Prentice Hall, 1990.

[14] J. Tang, R. Chassaing, "PID Controller Using the TMS320C31 D SKfor Real-Time DC Motor Control," Free, of the 1999 Texas Instruments DSPS Pest, Houston, Texas, August, 1999. [15] B. Widrow, S. Steams, Adaptive Signal Processing, Prentice Hall, 1985 [16] R. Krishnan, Electrical Motor Drives: Modeling, Analysis, and Control, Prentice Hall, 2001.

51

Appendix A
Summary of Notations
M eaning Electrical and Mechanical Torque Flux Flux A ngle Flux Speed ^mR Inertia Leakage Factor <7 = N otation

TcTl y

e
J 1

M agnetic Pole Number M agnetizing Current

P w

Phase Currents

Rotor, Stator and Main Inductances L r ,L s ,L h Rotor and Stator R esistances

R r >Rs
Rotor and Stator Time constants ^R '^S . Rotor Angle Rotor Currents Scalar Components ^Ra'^RP R otor Speed Stator and Rotor Currents iR .is Stator Currents in Field Coordinates ^sd'h q Stator Currents Scalar Components h a 'h p Voltage u £

a>

Table 2: Summary of Notations Used In this Research Paper

52

Appendix B Induction Motor Parameters
The induction motor used in this research paper is a single cage, three-phase, 60Hz, Y-connected induction motor. The rated values and the parameters of this motor are as follows:

Rated power Rated voltage Rated current Rated speed Pole pairs Slip Stator resistance (Rs) Rotor resistance (R r) Magnetizing inductance (L h) Stator leakage inductance (Las) Stator inductance (Ls=Las+LH) Rotor leakage inductance (L or) Rotor inductance (L r= L or+ L h) Leakage coefficient (o=1-l_H/LRLs) Rotor inertia

P=5HP V=133V rms (phase) 1=12A rms ISOOrpm 2 0.0278 0 .3 7 5 a 0 .4 0 5 a 77mH 2.63mH 79.63mH 2.63mH 79.63mH 0.065 19.36*10'^kgm^

These values are used in the electromagnetic equation of the induction motor as well as the mechanical equation and the control algorithm.

AAAr
Las V Lar

r(1-s}/s

Figure 36:

The Model of an Induction Motor
53

Appendix C Characteristics of PID Control
The proportional controller (Kp) will have the effect on reducing the rise time a step response and will reduce, but not eliminate, the steady-state error. An integral control (Ki) will have the effect of eliminating the steady-state error, but it may make the transient response worse. A derivative control (Kd) will have the effect of increasing the stability of the system, reducing the overshoot, and improving the transient response. Effects of each of controllers Kp, Kd, and Ki on a closed-loop system are summarized in the table shown below.
C L R E SPO N SE R ISE T IM E O V E R SH O O T SE T T L IN G T IM E S-S E R R O R Kp Ki Kd D ecrease D ecrease Small Change Increase Increase D ecrease Small Change Increase Decrease Decrease Eliminate Small Change

Note that the correlations shown in the table may not be exactly accurate, because Kp, Ki, and Kd are dependent of each other. In fact, changing one of these variables can change the effect of the other two. For this reason, the table should only be used as a reference for determining the values of Ki, Kp and Kd.

54

Appendix D Assembly Code for TMS320LF2407
1) Main program- foc2.asm FOG foc2.asm

System Name: File Name:

Description: 3-phase Field Oriented control with Kalman filter Originator: Shiping Zhu - Ryerson University

Target dependency: LF2407 To Select the target device see x24x_app.h file.

Date: 3-9-2003
********************************************************************

SYSTEM OPTIONS
********************************************************************

real-time

.set

1

; 1 for real time mode, otherwise set 0

* Phase commissioning options phase_commissioning 1 phase_commissioning2 phase_commissioning3 phase_commissioning4 phase_commissioning5 phase_commissioning6 .set .set .set .set .set .set 0 1 0 0 0 0 ; Ramp and sine_wave signal generation ; openJ o o p start up ; current measurement chain checking ; current regulation implementation ; Kalman filter estimation ; final regulation:closed current and speed loop ; in FOG control ; PWM period in uS (5KHz) ;*1000nS/(2*33nS)

PWM_PERIOD .set 200 T1PER_ .set PWM__PERI0D*15

*********************************************************************

.if (phase_commissioning3) current_observation .set 1 .endif * Internal phase commissioning options .if (phase_commissioning4) constant__current .set 1 park_sign .set 0 .endif .if (phase_commissioning5) theta_est_mod .set 1 .endif

; check o f Ia_out/Ib_out, clark_d/clark_q

; Theta/Thetajp switch (0 or rmp_out). ; check o f park_D/park_Q sign

; l-rmp__out / 0 - theta_est

External references

55

.include

"x24x_app.h"

.global MON_RT_CNFG .ref SYS_INIT .ref RAMP_GEN, RAMP_GEN_INIT ;function call .ref rmp__gain, rmp_offset, rmp__freq ;Inputs .ref step_angle_max ;Input .ref rmp_out ;Outputs .ref LPARK, I_PARK__INIT .ref ipark_D, ipark_Q, thetajp .ref isin_theta,icos_theta .ref ipark_d, ipark_q .ref DATA_LOG, DATA^LOG^INIT .ref dlog_iptrl, dlog_iptr2 .ref trig_value ;function call ;Inputs ;Inputs ;Outputs ;functlon call ;Inputs ;Inputs

.ref SVGEN_DQ,SVGEN_DQ_INIT ;function call .ref Ualfa,Ubeta ;Inputs .ref Ta,Tb,Tc ;Outputs .ref FC_PWM_DRV,FC_PWM_DRV_INIT ;function calls .ref Mfunc_c 1,Mfunc_c2,Mfunc_c3,Mflinc_p ;Inputs .ref n_period ;Input .ref ILEG2DRV, ILEG2DRV_INIT .ref Ia_gain,Ib_gain,Ia_offset,Ib_offset .ref layout, Ib_out .ref CLARKE, CLARKE_INrT .ref clark_a, clark_b .ref clark_d, clark_q .ref PARK, PARK_INIT .ref park_d, park__q, theta_p .ref psin_theta,pcos_theta .ref park_D, park__Q .ref D_sign, Q_sign .ref .ref .ref .ref ;function call ;Inputs ;Outputs ;function call ;Inputs ;Outputs ;function call ;Inputs ;Inputs ;Outputs

pid_reg_id,pid_reg_id_init ; function call id_fdb,id__ref,Kp__d,Ki_d,Kc_d ; Inputs u d jn t ; Input ud_out ; Outputs

.ref pid_reg_iq,pid_reg_iq_init ; function call .ref iq_fdb,iq_ref,Kp_q,Ki_q,Kc_q ; Inputs .ref uq_int ; Input .ref uq_out ; Outputs .ref EKF,EKF_INIT ; function call .ref _u_al,_u_be, ; Inputs .ref _i_be,_i_al ; Inputs .ref iSal_est,iSbe_est,psiRal__est,psiRbe_est,n_est ; Outputs .ref theta_est,theta__est__init ; function call .ref psiRal,psiRbe ; Inputs .ref sinTeta_est,cosTeta_est ; Outputs .ref pid_reg_spd,pid_reg_spd_init ; function call .ref spd_fdb,spd_ref ; Inputs .ref spd_out ; Outputs

56

Variable Declarations
.def GPRO ;General purpose registers, .bss GPR0,1 ;General purpose register .bss my_iq_ref,l .bss my_id_ref,l .bss speed_reference,l

VECTOR

TABLE

( including RT monitor traps ) ; Include conditional assembly options.

.include "c200mnrt.i" .sect "vectors" .def _c_intO .def c int4 RESET INTI INT2 INT3 INT4 INT5 INT6 B B B B B B B .include

; int4-EV group C dispatcher/service ;0 0 ;0 2 ;0 4 ;0 6 ;0 8 ;0 A ;0C

_ c jn t0 PHANTOM T1_PERI0D_ISR PHANTOM PHANTOM PHANTOM PHANTOM "rtvecs.h"

; Note : The above include line must be AFTER the user configurable ; vectors. Do not change the place where this line is included.

MAIN

CODE .text

- starts here

_c_intO: SYS__INrr FC_PWM_DRV__INIT ; Here is defined the Timer ;frequency (5KHz), it is thus mandatory ;to include this initialisation since the beginning CALL DATA_LOG_INIT .if (phase_commissioningl) CALL CALL

CALL CALL

RAMP_GEN_INIT I_PARK_INrr

; DATA_LOG display LDP#dlog_iptrl; SPLK #ipark_d, dlog_iptrl; * SPLK #ipark__q, dlog_iptr2 SPLK #rmp_out, dlog__iptr2 .endif .if (phase_commissioning2) CALL RAMP_GEN_INIT CALL I_PARK_INIT CALL SVGEN_DQ_INIT ; DATA_LOG display LDP#dlog_iptrl; SPLK #ipark_d, dlog_iptrl; SPLK #ipark_q, dlog_iptr2

57

SPLK #rmp_out, dIog_iptr2 SPLK #Ta, dlog_iptr2 .endif .if (phase_commissioning3) CALL RAMP__GEN_INÏT CALL I_PARK__INIT CALL SVGEN DQ_INrr CALL ILEG2DRV INIT CALL CLARKE INIT CALL PARK INIT ; DATA_LOG display LDP #dlog_iptrl; SPLK #Ia_out, dlog_iptrl ; SPLK #Ib_out, dlog__iptr2 SPLK #clark_d, dlog_iptrl SPLK #clark_q, dlog_iptr2 SPLK #park_D, dlog_iptrl SPLK #park_Q, dlog__iptr2 .endif .if (phase__coniniissioning4) RAMP_GEN__INIT CALL I_PARK_INIT CALL SVGEN_DQ_INIT CALL ILEG2DRV_INIT CALL CLARKE__INIT CALL PARK_INIT CALL CALL QEP THETA_DRV_INIT SPEED__FRQ__INIT CALL pid_reg_id_init CALL pid_reg__iq_init CALL ; DATA_LOG display LDP #dlog_iptrl; this is inserted by Shiping SPLK #rmp_out, dlog_iptrl; splk #Ia_out, dlog_iptr2 .endif .if (phase_comniissioning5) RAMP__GEN_INIT CALL CALL I PARK_INrr SVGEN DQ INIT CALL ILEG2DRV_INIT CALL CLARKE_INIT CALL CALL PARK INIT EKF_INIT CALL CALL pid_reg_idjnit CALL pid_reg_iq_init CALL theta_estjnit ; DATA_LOG display .endif .if (phase_commissioning6) CALL I_PARK_INrr CALL SVGEN_DQ_INrr CALL nJEG2DRV_INIT CALL CLARKE_INrr

* * * *

58

CALL CALL CALL CALL CALL CALL

PARK INIT EKF__INrr pid_reg_idjnit pid__reg_iq_init theta_est_init pid_reg_spd_init

; DATÀ_LOG display .endif ;--Real Time option---------------.if (real_time) CALL MON_RT_CNFG .endif Variables initialization LDP #n_period SPLK #TlPER__,n_period; initialize the PWM period to 5kHz LDP SPLK LDP SPLK LDP SPLK LDP SPLK #rmp_freq #64AAh,rmp_freq; 60Hz frequency for RAMPGEN(5kHz)/=25770d #my_iq_ref #OOOOh,my_iq_ref #my_id_ref #OOOOh,my_id_ref #speed_reference #OOOOh,speed__reference

;For Real-Time

.if (phase_commissioning6) POINT_BO SPLK #0500h,m yjd_ref .endif

System Interrupt Init. ;Event Manager POINT_EV SPLK #00000010000000005,IMRA ;Enable T1 Underflow Int (i.e. Period) SPLK #00000000000000005,IMRC ; SPLK #OFFFFh,IFRA ; Clear all Group A interrupt flags SPLK #OFFFFh,IFRB ; Clear all Group B interrupt flags SPLK #OFFFFh,IFRC ; Clear all Group C interrupt flags ;C2xx Core POINT_PGO ;-- Real Time option-------------------------------------.if (real_time) SPLK #0000000001000010b,IMR ;5432109876543210 .endif

;En Int Ivl 3,7 (T2ISR)

*

.if (real_time != 1) SPLK #0000000000001010b,IMR

;En Int Ivl 4 (CAP3/QEP ISR)

II!!!!
;5432109876543210 SPLK #0000000000000010b,IMR .endif ;Disable Int Ivl 4 (CAP3/QEP ISR)

59

SPLK #OFFFFh, IFR EINT POINT BO

;Clear any pending Ints ;Enable global Ints

MAIN:

;Main system background loop

M_1

NOP NOP NOP CLRCXF B MAIN

Routine Name: T1__PERI0D_ISR Description:

Routine Type: ISR

Originator: Shiping Zhu - Ryerson University ; Last Update: 20-Apr 03

T1__PERI0D_ISR: ;Context save regs MAR *,AR1 MAR *+ S S T # 1 ,* + SST #0, *+ SACH *+ SACL *

;AR1 is stack pointer ;skip one position ;saveSTl ;save STO ;save acc high ;save acc low to clear Int flags & not SPLK! ; Clear all Group A interrupt flags (T1 ISR) ; set sign extension mode ; clear overflow mode

;NOTE: should use "read-modify-write" POINT_EV SPLK #OFFFFh,IFRA SETC XF SETC SXM CLRC OVM

;Start main section of ISR .if (phase_commissioning 1) ; Ramp_Generation module CALL RAMP_GEN ; Inverse Park Module LDP #theta_ip BLDD #rmp__out,theta_ip CALL LPARK ; PWM driver CALL FC_PWM_DRV; called just to set the PWM period to 5kHz .endif .if (phase_commissioning2)

60

; Ramp generation module CALL RAMP_GEN ; Inverse-Park module LDP #thetajp BLDD #rmp_out,thetaJp CALL LPARK ; Space-Vector DQ module LDP #Ualfa BLDD #ipark_d,Ualfa BLDD #ipark_q,Ubeta CALL SVGEN_DQ ; PWM driver LDP #Mfunc_cl BLDD #Ta,Mfunc_cl BLDD #Tb,Mfunc_c2 BLDD #Tc,Mfunc_c3 FC__PWM_DRV CALL .endif .if (phase_commissioning3) ; Current leg measurement, Ileg2drv module CALL ILEG2DRV ; Clarke module LDP #clark_a BLDD #Ia_out,clark__a BLDD #Ib out,clark_b CLARKE CALL ; PARK module LDP #park_d #clark_d,park_d BLDD BLDD #clark_q,park_q BLDD #rmp out,theta p CALL PARK ; Ramp generation module RAMP_GEN CALL ; Inverse-Park module #theta__ip LDP #rmp_out,thetaJp BLDD LPARK CALL ; Space-Vector DQ module #Ualfa LDP #ipark_d,Ualfa BLDD #ipark_q,Ubeta BLDD SVGEN.DQ CALL ; PWM driver #Mfunc_cl LDP #Ta,Mfunc_cl BLDD #Tb,Mfunc_c2 BLDD #Tc,Mfunc_c3 BLDD FC_PWM_DRV CALL .endif .if (phase__commissioning4) ; Current leg measurement, Heg2drv module CALL ILEG2DRV ; Clarke module LDP #clark__a BLDD #Ia_out,clark_a

61

BLDD #Ib_out,clark__b CLARKE CALL ; PARK module LDP #park_d BLDD #clark_d,park_d BLDD #clark_q,park_q .if constant_current ; here we SPLK #0000h,theta_p; .else BLDD #rmp_out,theta_p .endif CALL PARK ; D-axis current regulator LDP #id_ref BLDD #my_id_ref,id_ref ; BLDD #park_D,id_fdb CALL pid_reg__id ; Q-axis current regulator LDP #iq_ref .if constant_current ; here we apply 0 or my_iq_ref (user) SPLK #0000h,iq_ref ; check the internal phase_commissioning option .else BLDD #my_iq_ref,iq_ref .endif BLDD %ark_Q,iq_fdb CALL pid_reg_iq ; Ramp generation module CALL RAMP_GEN ; Inverse-Park module LDP #ipark_D . BLDD &id__out,ipark__D BLDD #uq_out,ipark_Q ; here we apply 0 or rmp_out .if constant_current ; check the internal phase_commissioning option SPLK #0000h,thetajp .else BLDD #rmp_out,thetajp .endif CALL LPARK ; Space-Vector DQ module LDP #Ualfa BLDD #ipark_d,Ualfa BLDD #ipark_q,Ubeta CALL SVGEN_DQ ; PWM driver LDP #Mfunc_cl BLDD #Ta,Mfunc_cl BLDD #Tb,Mfunc_c2 BLDD #Tc,Mfunc_c3 CALL FC_PWM_DRV .endif
******************************************

.if (phase_commissioning5) ; Current leg measurement, Ileg2drv module CALL ILEG2DRV ; Clarke module LDP #clark_a BLDD #Ia__out,clark__a BLDD #Ib_out,clark_b CALL CLARKE

62

; EKF module
LDP BLDD BLDD BLDD BLDD CALL #_u_al #ipark_d,_u_al #ipark_q,_u_be #clark_d,J_al #clark_q,J_be EKF

; PARK module LDP #park_d BLDD ÂSal_est,park_d BLDD #iSbe_est,park_q .if theta__est_mod ; he BLDD #rmp_out,theta__p ; .else #sinTeta_est,psinJheta BLDD BLDD #cosTeta_est,pcos_theta .endif PARK CALL ; theta_est LDP BLDD BLDD CALL

#psiRal #psiRal_est,psiRal #psiRbe_est,psiRbe theta_est

; D-axis current regulator LDP #id_ref BLDD #my_id_ref,id_ref ; lEB8h gives a current o f 2.5A peak BLDD #park_D,id_fdb CALL pid_reg_id ; Q-axis current regulator LDP #iq_ref BLDD #my_iq_ref,iq__ref BLDD #park_Q,iq_fdb CALL pid_reg_iq ; Ramp generation module CALL RAMP_GEN ; Inverse-Park module LDP #ipark_D BLDD #ud__out,ipark_D BLDD #uq_out,ipark_Q ; here we connect rmp_out or theta_est__mod .if theta_est_mod ; check the internal phase_commissioning option #rmp_out,thetajp BLDD .else #sinTeta_est,isin_theta BLDD #cosTeta_est,icosJheta BLDD .endif CALL ; Space-Vector DQ LDP BLDD BLDD CALL ; PWM driver LDP BLDD BLDD BLDD CALL .endif LPARK module #Ualfa #ipark_d,Ualfa #ipark_q,Ubeta SVGEN_DQ #Mfunc_cl #Ta,Mfunc__cl #Tb,Mfunc_c2 #Tc,Mfunc_c3 PC PWM.DRV

63

******************************************
.if (phase__commissioning6) ; Current leg measurement, Heg2drv module CALL ILEG2DRV ; Clarke module #clark_a LDP #Ia_out,clark__a BLDD BLDD #Ib out,clark_b CLARKE CALL ; SPEED REGULATION #spd_ref LDP #speed_reference,spd_ref bldd #n__est,spd_fdb bldd pid_reg_spd CALL ; EKF module #_u_al LDP #ipark_d,_u_al BLDD #ipark_q,_u__be BLDD #clark_d,_i_al BLDD #clark_q,_i_be BLDD EKF CALL ; PARK module #park_d LDP #iSal_est,park_d BLDD #iSbe_est,park_q BLDD #sinTeta_est,psin_theta BLDD #cosTeta_est,pcos_theta BLDD PARK CALL ; theta est LDP #psiRal #psiRal_est,psiRal BLDD #psiRbe__est,psiRbe BLDD theta_est CALL ; D-axis current regulator #id ref LDP #lEB8h,id_ref ; lEB8h ;SPLK #m yjd_ref,id_ref BLDD #park_D,id_fdb BLDD pid_reg_id CALL ; Q-axis current regulator LDP #iq_ref #spd_out,iq_ref BLDD #park_Q,iq_fdb BLDD pid_reg_iq CALL ; Inverse-Park module #ipark_D LDP #ud__out,ipark_D BLDD #uq_out,ipark_Q BLDD #sinTeta_est,isin_theta BLDD #cosTeta est,icos__theta BLDD LPARK CALL ; Space-Vector DQ module LDP #Ualfa #ipark_d,Ualfa BLDD #ipark__q,Ubeta BLDD SVGEN_DQ CALL ; PWM driver #Mfunc_cl LDP #Ta,Mfunc_cl BLDD #Tb,Mfunc_c2 BLDD

64

BLDD CALL

#Tc,Mfunc__c3 FC_PWM__DRV

.endif ;Allow variable viewing via DAC o/ps CALL DATA_LOG * CALL DAC_VIEW DRV

End main section of ISR Context restore regs EN D JSR : POINT PGO MAR LACL ADDH LST #0, LST EINT RET *, A R l ;make stack pointer active *;Restore Acc low *;Restore Acc high *;load STO # 1 ,* ;loadSTl

*******************************************************

IS R

-

PHANTOM

Description: Dummy ISR, used to trap spurious interrupts. Modifies: Last Update: 11-03-03 PHANTOM B PHANTOM

65

*************************************************************
File name: iv2drv.asm IV2DRV Module Name:

Initialization Routine: ILEG2DRV_INIT Description: Configures and starts ADC for converting two analog inputs with programmable gains and offsets.

I__ch_sel Ia_gain Ib_gain Ia__offset Ib offset

ooooo-

Q13 Q13 Q15 Q15

ILEG2DRV Q15| >o layout Q15|---- >0 Ib_out I I

Target:

X2407

History: 3-11-2003 Notes on Configuration 1. Ix__gain has range o f -3.999999 --> +3.99999 (i.e. Q13) 2. Ix_offset has range -0.999999 - > +0.99999 (i.e. Q15) 3. Ix_out has range -0.999999 - > +0.99999 (i.e. Q15) with: 1.0 X (VrefHi - VrefLo) = +0.999999 (7FFFh)_____ 0.5 X (VrefHi - VrefLo) = 0 (0000/FFFFh) 0.0 X (VrefHi - VrefLo) = -0.999999 (8000h) I_ch_sel HEX values vs Channels selected: I
X

I

X

I Ib select | la select |

For x2407 la select: 0,1,2...F Ib select: 0,1,2...F

-> ->

Ch0,l,2,...15 Ch0,l,2,...15

Reference/Prototypes .ref ILEG2DRV, ILEG2DRV_INIT .ref Ia__gain,Ib_gain,Ia_offset,Ib_offset ;Inputs .ref Ia_out, Ib_out ;function call ;Outputs

Global Definitions .def ILEG2DRV, ILEG2DRV_INIT .def Ia__gain,Ib_gain,Ia_offset,Ib_offset ;Inputs .def Ia_out, Ib_out
******************************************************

;function call ;Outputs

* Define Peripherals
******************************************************

.include

"x24x_app.h"

66

******************************************************
* Variables
******************************************************

I_ch_sel .usect "ileg2drv",l Ia_gain .usect "ileg2drv",l Ib__gain .usect "ileg2drv", 1 Ia__offset .usect "ileg2drv",l Ib_offset .usect "ileg2drv",l Ia_out .usect "ileg2drv",l Ib_out .usect "ileg2drv",l I_temp .usect "ileg2drv",l
******************************************************

* Configuration Parameters
******************************************************

; .ifx2407 I_ch__sel_ .set 0032h ; .endif

;'2407 EVM ; Select Ch3(Phase B),2(Phase A)

; .ifx2407 ACQ__PS_ .set 0001b CON_PS_ .set 0 CAL_ .set 0 ; .endif Ia__offset_.set Ib__offset_.set Ia_gain_ .set Ib_gain_ .set 32 32 Ifffh Ifffh

; Acquisition clk p/s=l/2*(conv p/s) > Acuisition win=4*clk ; Conversion clk p/s= 1/1 ; Calibration register = 0

Offset introduced by XOR gain=I.O (Q13) gain=1.0 (Q13)

ILEG2DRV_INIT LDP #I_ch_sel ; SPLK #I_ch_sel_,I_ch_sel ; Set channel select SPLK #Ia_gain_,Ia_gain ; Set gains SPLK #Ib_gain_,Ib_gain ; SPLK #Ia_offset_,Ia_offset; Set offsets SPLK #Ib_offset_,Ib_offset ; Idp # G P T C 0 N » 7 ; Set TIUF as ADC trigger splk#0000h, GPTCON lace GPTCON and # 0 F E 7 F h ;llll,1 1 1 0 ,0 1 1 1 ,llll or # 0 1 b « 7 ;0000 0000 1000 0000 sacl GPTCON .ifx2407 LDP #C A LIBR A TI0N»7 ; Configure CALIBRATION SPLK #CAL_,CALIBRATION ; Set Calibration register SPLK #4000h,ADCL_CNTLI ; Reset entire Module SPLK #0010000I0I010000b,ADCL_CNTLl ;Acq = 4 x Clks,Cascaded mode ; continuous run SPLK #(03000h+A C Q _PS_«8+C O N _PS_«7),A D C L_C N TLl ; ADCL CNTLl ;OOIIOOOIOOOOOOOO SPLK #0302h,ADCL_CNTL2 ; Allow EVA to start conversion

Config

;000000I100000010
SPLK #1 ,MAXCONV ; 2 conversions bldd #I_ch__sel,CHSELSEQ 1 ; Configure channel select .endif SPLK #0010Ô0000000Ô000b,ADCL_CNTL2 ; Start the conversions ret

67

ILEG2DRV: .ifx2407 Idp #A D CL_CN TL2»7 Wait bit ADCL^CNTL2,Brri2 bcndWait,TC ;

; Check SEQ__BSY bit

;

LACC ADC_RESULTO ; Read 1st converted value XOR #8000h ; Convert to Q15 Idp #Ia_out SACL layout LT Ia_gain ; Ia__gain in Q13 MPY layout ; Q13 x Q15 = Q28 PAC ADD Ia_offset, 13 ; add offset in Q28 neg ; positive => going into motor SACH Ia__out,3 ; Convert final result to Q15 LDP #ADC__RESULT1»7 ; Read 2nd converted value LACC ADC.RESULTl XOR #8000h ; Convert to Q15 Idp #Ib_out SACL Ib_out LT Ib_gain ; Ib_gain in Q13 MPY Ib_out ; Q13 x Q15 = Q28 PAC ADD Ib_offset, 13 ; add offset in Q28 neg ; positive => going into motor SACH Ib_out,3 ; Convert final result to Q15 bldd I_ch_sel,#CHSELSEQl .endif RET ; Reconfigure channel select

File Name:

park.asm PARK

Module Name:

Description: This transformation converts vectors in balanced 2-phase orthogonal stationary system into orthogonal rotating reference frame. id = ialfa * cos__teta + ibeta * sin_teta iq = -ialfa *sin_teta + ibeta * cos_teta

I park_d o----- > park_q o----- > PARK I ----- >0 theta_p o >1 I or psin_theta___________|______________ | pcos_theta Note: 0 < theta_p < 7FFFh

>o

park_D

park__Q

(i.e. equivalent to

0 < theta_p < 360 deg

)

68

Target dependency: C2xx core only

History: 3-11-2003 (To use this Module, copy this section to main system file) .ref PARK, PARKJNTT ;function call .ref park_d, park_q, theta_p ;Inputs .ref psin_theta,pcos_theta ;Inputs .ref park_D, park_Q ;Outputs Module definitions for external reference. .def PARK, PARK_INIT .def parked, park_q, theta_p .def psin_theta,pcos_theta .def park_D, park__Q .def D_sign, Q_sign Options High_precision.set 0 theta_est_mod .set negtive__sign .set ;Set to 1 for High prec / Set to 0 for low prec 1 ;1-- rmp_out / 0--theta_est 0

;function call ;Inputs ;Inputs ;0utputs ;D,Q sign

.ref SINTAB_360 .ref theta_est_mod

;1-- rmp_out / 0--theta_est

park__d .usect "park",l park_q .usect "park", 1 theta_p .usect "park",l park_D .usect "park",l park_Q .usect "park",l t_ptr .usect "park",l ip_val .usect "park",l cos_theta .usect "park",l sin_theta .usect "park", 1 nxt_entry .usect "park",l delta_angle .usect "park",l GPRO_park .usect "park",l psin__theta .usect "park",l pcos__theta .usect "park", I Design .usect "park",l Q_sign .usect "park", I

PARK_INIT: RET

PARK: Idp #theta__est_mod theta_est_mod

.if

69

;CalcuIate Cos(theta_p) ;-- High_precision option------.if (High_precision) ;see park for its definition ;Higher precision using look-up + interpolation method Idp #theta_p LACC theta_p ADD #8192 ;add 90 deg, i.e. COS(A)=SIN(A+90) AND #07FFFh ;Force positive wrap-around SACL GPRO_park ;here 90 deg = 7FFFh/4=8192d LACC GPR0_park,9 SACH t_ptr ;TabIe pointer SFR ;Convert Interpolation value(ip_val) to Q15 AND #07FFHi f o r c e ip_val to a positive number SACL ip_val LACC #SINTAB_360 ADD t_ptr TBLR cos_theta ;cos__theta = Cos(theta) in Q15 ADD # lh ;Inc Table pointer TBLR nxt_entry ;Get next entry i.e. (Entry + 1 ) LACC nxt_entry SUB cos_theta ;Hnd Delta o f 2 points SACL delta_angle LT delta_angle ;ip_val = interpolation value MPY ip_val PAC SACH ip_val,l ip__val LACC ADD cos_theta cos__theta ;cos__theta = Final interpolated value SACL .endif

;-- Normal precision option------.if (Hi^_precision != 1) ;Normal precision with simple 256 word look-up Idp #theta__p LACC theta_p ADD #8192 ;add 90 deg, i.e. COS(A)=SIN(A+90) AND #07FFFh fo r c e positive wrap-around SACL GPRO_park ;here 90 deg = 7FFFh/4 LACC GPR0_park,9 SACH t_ptr LACC #SINTAB_360 ADD t_ptr TBLR cos_theta ;cos_theta = Cos(theta_p) in Q15 .endif

;Calculate Sin(theta_p) ;-- High_precision option------.if (High_precision) ;Higher precision using look-up + interpolation method LACC SACH SFR AND SACL LACC ADD theta_p,9 t_ptr ;Table pointer ;Convert Interpolation value(ip_val) to Q15 #07FFFh f o r c e ip__val to a positive number ip_val #SINTAB_360 t_ptr

70

TBLR sin_theta ;sin_theta = Sin(theta) in Q15 ADD # lh ;Inc Table pointer TBLR nxt__entiy ;Get next entry i.e. (Entry + 1 ) LACC nxt_entry SUB sin_theta ;Fînd Delta o f 2 points SACL delta_angle LT delta_angle MPY ip_val ;ip_val = interpolation value PAC SACH ip_val,l LACC ip_val ADD sin_theta SACL sin_theta ;sin_theta = Final interpolated value .endif

;-- Normal precision option------.if (High_precision != 1) ;Lower precision simple 256 word look-up LACC theta_p,9 SACH t_ptr LACC #SINTAB_360 ADD t^ptr TBLR sin_theta ;sin_theta = Sin(theta_p) in Q15 .endif .else Idp #theta__p splk #psin_theta, sin_theta splk #pcos_theta, cos_theta .endif ;Calculate the Park transform SPM 1 ; SPM set for Q15 multiplication ZAC ; Reset accumulator LT park_q ; TREG = ibeta MPY sin_theta ; PREG = ibeta * sin_teta LIA park_d ; ACC = ibeta * sin_teta and TREG = ialfa MPY cos_theta ; PREG = ialfa * cos_teta MPYA sin_theta ; ACC = ibeta*sin_teta + ialfa*cos__teta and PREG=ialfa*sin_teta SACH park_D ; id = ialfa * cos_teta + ibeta * sin_teta LACC #0 ; Clear ACC LT park_q ; TREG = ibeta MPYS cos_theta ; ACC = -ialfa*sin_teta and PREG = ibeta*cos_teta APAC ; ACC = -ialfa *sin_teta + ibeta * cos_teta SACH park__Q ; iq = -ialfa *sin_teta + ibeta * cos_teta SPMO RET ; SPM reset

71

File Name:

clarke.asm CLARKE

Module Name:

Initialization Routine: CLARKE JNIT

Description: Converts balanced three phase quantities into balanced two phase quadrature quantities. (a,b,c) > (d,q) Transformation clark_d = clark_a clark_q = (2 * clark_b + clark_a) / sqrt(3)

clark_a clark_b clark_c*

o----- > o----- > o >|

->o CLARKE I
>0

clark_d

clark_q

L
*Note: Not needed (for completeness only)

Target dependency: C2xx core only

History: 3-Ü -2003 (To use this Moduie, copy this section to main system file) ;function call .ref CLARKE, CLARKE_INIT .ref clark_a, clark_b ;Inputs .ref clark_d, clark_q ;Outputs Vlodule definitions for external reference. .def CLARKE, CLARKE.INIT .def clark_a, clark_b .def clark_d, clark_q .include "x24x_app.h" ; Variables clark_a .usect "clarke", 1 clark_b .usect "clarke", 1 clark_d .usect "clarke", 1 clark_q .usect "clarke",! sqrtSinv .usect "clarke",! c!k__temp .usect "clarke",!

;function call ;Inputs ;Outputs

; !/sqrt(3)

CLARKE_INIT: ; sqrt3inv = (!/sqrt(3))=0.577350269 Idp #sqrt3inv SPLK #0!8830,sqrt3inv RET

; !/sqrt(3) (Q !5)

CLARKE:

SPM!

; Set SPM for Q !5 math 72

SETC

SXM

; Sign extension mode on

;clark_d = clark_a Idp #clark_a LACC clark_a SACL clark_d ;clark_q = (2 * clark_b + clark_a) / SFR ADD clark_b SACL clk_temp LT clk_temp MPY sqitSinv PAC SFL SACH clark_q SPMO RET

; ACC = clark_a ; clark__d = clark__a sqrt(3) ; ACC = cIark__a/2 ; ACC = cIark_a/2 + clark_b ; clk_temp = cIark_a/2 + clark_b ; TREG = clark__a/2 + clark_b ; PREG = (cIark__a/2 + clark_b)*(l/sqrt(3)) ;A C C = (clark_a/2 + clark_b)*(l/sqrt(3)) ; ACC = (clark_a + clark_b*2)*(l/sqrt(3)) ; clark_q = (clark_a + clark_b*2)*(l/sqrt(3)) ; SPM reset

Filename: I_PARK.asm Routine Name: I_PARK Routine Type: SR Description: id = ialfa * cos_teta - ibeta * sin_teta iq = ialfa *sin_teta + ibeta * cos_teta 1 ---------------------------1 ipark_D o-- >| |- -- >0 ipark_Q o-- >| f_PARK | th etajp 0-- >1 |- -- >0 orisin theta | | icos_theta Note: 0<theta_ip<7FFFh # Cycles (including call/ret): Target dependency: C2xx core only Last Update: 3-11-2003 (To use this Module, copy this section to main system file) .ref I_PARK,I_PARK_INrr ; function call .ref ipark_D,ipark_Q,thetajp ; Inputs .ref isin_theta,icos_theta ;Inputs .ref ipark_d,ipark_q ; Outputs Vlodule definitions for external reference. .def LPARK,LPARK_INIT ; function call .def ipark_D,ipark_Q,theta_ip ; Inputs .def isin_theta,icos_theta ; inputs .def ipark_d,ipark_q ; Outputs

ipark__d ipark_q

(i.e. equivalent to 0<theta_ip<360 deg

)

;Options High_precision .set 0 theta__est_mod .set ; Set to 1 for High prec / Set to 0 for low prec 1 ;l-rm p_out / 0 - theta_est

73

.ref SINTAB_360 ; Sine table .ref theta__est_mod

ipark_d .usect "I_park'\l ipark_q .usect "I_park",l thetajp .usect "I__park",l ipark_D .usect "I_park",l ipark_Q .usect "I_park",l isin_theta .usect "I_park",l icosJ h eta .usect "I__park", 1 t_ptr .usect "I_park",l ip_val .usect "I__park", 1 cos__theta .usect "I_park",l sin_theta .usect "I_park",l nxt_entry .usect "I_park",l delta_angle .usect "I__park",l GPROJpark .usect "I_park",l L pARK.INIT: Idp #ipark__D SPLK #3FFFh, ipark_D SPLK #3FFFh, ipark_Q SPLK #0000h, thetajp; this is added by Shiping RET

I PARK: Idp #theta__est_mod .if theta_est_mod ;Calculate Cos(theta_p) ;-- High__precision option------.if (High_precision) ;Higher precision using look-up + interpolation method Idp #thetajp LACC thetajp ADD #8192 ;add 90 deg, i.e. COS(A)=SIN(A+90) AND #07FFFh ;Force positive wrap-around SACL GPROJpark ;here 90 deg = 7FFFh/4=8192d LACC GPROJpark,9 SACH t_ptr ;Table pointer SFR ;Convert Interpolation value(ip_val) to Q15 AND #07FFFh ;Force ip_val to a positive number SACL ip_val LACC #SINTAB__360 ADD t_ptr TBLR cos__theta ;cosJheta = Cos(theta) in Q15 ADD # lh ;Inc Table pointer TBLR nxt__entiy ;Get next entry i.e. (Entiy + 1 ) LACC nxt_entry SUB cos_theta ;Find Delta o f 2 points SACL delta_angle LT delta_angle MPY ip_val ;ip_val = interpolation value PAC SACH ip_val,l LACC ip_val ADD cos_theta SACL cos_theta ;cosJheta = Final interpolated value .endif *

74

;-- Normal precision option------.if (High_precision != 1) ;Normal precision with simple 256 word look-up Idp #thetajp LACC theta_ip ADD #8192 ;add 90 deg, i.e. COS(A)=S1N(A+90) AND #07FFFh ;Force positive wrap-around SACL GPROJpark ;here 90 deg = 7FFFh/4 LACC GPR0Jpark,9 SACH t_ptr LACC #SINTAB_360 ADD t_ptr TBLR cos_theta ;cos_theta = Cos(theta_p) in Q15 .endif

;Calculate Sin(theta_p) ;-- High_precision option------.if (High__precision) ;Higher precision using look-up + interpolation method LACC thetajp,9 SACH t_ptr ;Table pointer SFR ;Convert Interpolation value(ip__val) to Q15 AND #07FFFh ;Force ip_val to a positive number SACL ip_val LACC #SINTAB_360 ADD t_ptr TBLR sinJheta ;sinJheta = Sin(theta) in Q15 ADD # lh ;Inc Table pointer TBLR nxt_entry ;Get next entry i.e. (Entry + 1) LACC nxt_entry SUB sinJh eta ;Find Delta of 2 points SACL delta_angle LT delta_angle MPY ip__val ;ip_val = interpolation value PAC SACH ip_val,l LACC ip_val ADD sinjheta SACL sin__theta ;sinJheta = Final interpolated value .endif

;-- Normal precision option------.if (High_precision != 1) ;Lower precision simple 256 word look-up LACC thetaJp,9 SACH t_ptr LACC #SINTAB_360 ADD t_ptr TBLR sin jheta ;sinJheta = Sin(theta_p) in Q15 .endif .else

Idp #thetajp splk #isinJheta, sinjheta splk #icos_theta, cosJheta .endif
;Calculate the Inverse Park transform

75

SETC SPM 1

SXM

; Sign extension mode ; SPM set for Q15 multiplication

;park_q = ipark_Q * cos_theta + ipark_D * sin__theta LACC #0 ; Clear ACC LT ipark_D ; TREG = Udref MPY sin__theta ; PREG = Udref * sin_theta LTA ipark_Q ; ACC = Udref*sin_theta and TREG=Uqref MPY cos_theta ; PREG = Uqref * cos_teta MPYA sin_theta ; ACC = Uqref*cos_theta + Udref*sin_theta TREG=Uqref*sin_theta SACH ipark_q ; Ubeta = Uqref*cos_theta + Udref*sin_theta ;park_d = ipark_D * cos_theta - ipark_Q * sin_theta LACC #0 ; Clear ACC LT ipark.D ; TREG = Udref MPYS cos_theta ; ACC = -Uqref*sin_theta and PREG = Udref*cos__theta APAC ; ACC = -Uqref*sin_theta + Udref*cos_theta SACH ipark_d ; Ualfa = -Uqref*sin_theta + Udref*cos_theta SPMO RET ; SPM reset

and

File Name:

EKF.asm Kalman filter

Module Name:

Initialization Routine: EKF INIT

Description: Kalman filter for field oriented control o f an AC induction machine

_u_al _u_be _i_al _i_be

->| ->l, ->l ->l

I ->iSal_est TER I ->iSbe_est I->psiRal_est I->psiRbe_est I->n_est

Target:

x2407

History:

76

3 - 17-2003
Reference/Prototype ref EKF,EKF_INIT ; function call .ref _u_al,_u_be, ; Inputs ref _Lbe,_i_al ; Inputs .ref iSal_est,iSbe_est,pslRal_est,psiRbe_est,n_est ; Outputs .include "matcal.inc" .copy "matcal.inc" .mlib "mac.lib" ;EKF macros file .copy "matGC24.inc" ;EKF macros file .copy "maddG.asm" .copy "madiG.asm" .copy "mmsclG.asm" .copy "nuntfraG.asm" .copy "msubG.asm" .copy "detG.asm" .copy "mmfraG.asm" .copy "mdsclG.asm" .copy "madjG.asm" Global Definitions .def EKF,EKF_INrr ; function call .def _u_al,_u_be, ; Inputs .def J_be,_i_al ; Inputs .def iSaLest,iSbe_est,psiRal_est,psiRbe_est,n_est ; Outputs

; Variable Definitions ;public variables ;_u__al .usect "ekf',1 .usect "ekf',1 ;_u_be ;J_b e .usect "ekf',1 .usect "ekf',1 ;J_ai iSal_est .usect "ekf',1 .usect "ekf',1 iSbe_est psiRal__est .usect "ekf',1 psiRbe_est .usect "ekf',1 .usect "ekf',1 n_est ;private variables *psiR_est *psiRal_estl *psiRbe_estl *psiR_estl *run *est .usect "ekf ,1 .usect "ekf',1 .usect "ekf',1 .usect "ekf',1 .usect "ekf',1 .usect "ekf',1 ;rotor flux amplitude ;1.15 format (alfa-axis estimated rotor fliix), x(3) ;1.15 format (beta-axis estimated rotor flux), x(4) ;1.15 format rotor flux amplitude initialization flag ;estimation flag:Oh=initialization, 1000h=sensorless

;alfa-axis estimated current, x (l) ;beta-axis estimated current, x(2) ;alfa-axis estimated rotor flux, x(3) ;beta-axis estimated rotor flux, x(4) ;estimated electrical speed, x(5)

Default parameters

***********************************************************
* Variables and constants initializations
***********************************************************

.data

77

*** data page EKF algorithm*** kal_fll ;BKF algorithm data page pointer ;Input vector ;ua ;ub ;Output vector ;ia ;ib ;LAFERT__TI, with T=300us

_u_al u be

.word .word

0 0 0 0

_Lal _i_be diff_f

.word .word

.word 29591,0, 7 4 7 ,0 , 0 .word 0, 29591, 0, 74 7 ,0 .word 696, 0, 32442, 0 ,0 .word 0, 696, 0, 32442, 0 .word 0, 0, 0, 0, 32767 .word 0, 0, 0, 0, 0

_ _ X
Cx 1 _x__l C4 C9 C5 C8 CIO C

;state vector x(k,k) ;Cx_l= [x (l)x (2 )]' predicted state vector x(k+l,k) ;[1,4] & [1,5] coeff o f diff_f ;[3,4] & [3,5] coeff of diff^f ;wbase*T/xsig coeff ;[4,3] & [4,5] coeff of diffLf ;[2,3] & [2,5] coeff o f diff^f ;C matrix

.word .word .word .word .word .word .word .word

0, 0, 0, 0, 0 14164 -6177 15400 6177 -14164

32767, 0, 0, 0, 0 0, 32767, 0, 0, 0

P

.word .word .word .word .word .word .word .word .word .word .word .word

3 2 0 ,0 ,0 ,0 , 0 0, 320, 0, 0, 0 0 ,0 , 320, 0 ,0 0, 0, 0, 320, 0 0, 0, 0, 0, 320 0, 0 ,0 ,0 , 0 0, 0, 0, 0, 0 0, 0 ,0 , 0, 0 0, 0, 0, 0, 0 0, 0 ,0 , 0 ,0

prediction err cov mat P(k+l,k)

P_1

;Filter err cov mat P (k+l,k+l)

Q R RSLT _K

1000,1000,300, 300,500 ;state noise cov matrix 20000, 20000 ;Measure Noise Cov Matrix ;Result mat, not bigger than 5*5

.space 25*16 .word .word .word .word .word 0 ,0 0 ,0 0 ,0 0 ,0 0 ,0 .set

Pole_pairs_number

Initialization

78

.text EKF INIT Idp #n_est splk #OOOOh,iSal_est splk #OOOOh,iSbe__est splk #0000h,n_est splk #OOOOh,psiRal_est splk #OOOOh,psiRbe_est ret

EKF
***********************************************************

*** e x t e n d e d KALMAN FILTER *** estimated variables (iSal_est,iSbe_est) *** (psiRal_est,psiRbe_est) *** (n_est)

*** *** *** ***

***********************************************************

;diff_f matrix update d iff.f= [l-T/Ts2,0,(xH*T)/(xsig*xR*TR),((xH*wBase*T)/(xsig*xR))*x(5),((xH*wBase*T)/(xsig*xR))*x(4); 0,l-T/Ts2,-((xH*wBase*T)/(xsig*xR))*x(5),(xH*T)/(xsig*xR*TR),-((xH*wBase*T)/(xsig*xR))*x(3); (xH*T)/TR, 0, l-T/TR,-wBase*T*x(5),-wBase*T*x(4) ; 0, (xH*T)/TR, wBase*T*x(5),l-T/TR, wBase*T*x(3);

0, 0, 0, 0, 1];
Idp lar lar lar mar It mpy pac sach neg adrk sach mpy pac adrk sach neg adrk sach It mpy pac sbrk sach mpy pac sbrk sach It lar mar mpy pac adrk sach #kal_fil AR2,#_x+4 ;load in AR4 the address of _x+4=x(5) AR3,#diff__f+3 ;load in AR3 the address o f A(k)[l,4] AR6,#C4 ;load in AR6 the address o f C4 *,AR2 ;ARP=2 *-,AR6 ;Treg=x(5), AR2->x(4), ARP=6 *+,AR3 ;Preg=C4*x(5), AR6->C9, ARP=3 ;Acc=Preg *,1 ;A(k)[l,4]=C4*x(5) in Q15 format ;Acc= -Preg 4 ;add 4 to the address loaded in AR3 <-> AR3->A(k)[2,3] *,1,AR6 ; A(k)[2,3]=-C4*x(5) in Q15 format, ARP=6 (N.B. AR6->C9) *,AR3 ;Preg=C9*x(5)=-C8*x(5), ARP=3 ;Acc=Preg 6 ;add 6 to the address loaded in AR3 <-> AR3->A(k)[3,4] *,1 ;A(k)[3,4]=C9*x(5)=-C8*x(5) in Q15 format ;Acc=-Preg 4 ;add 4 to the address loaded in AR3 <-> AR3->A(k)[4,3] *,1,AR2 ;A(k)[4,3]=C8*x(5) in Q15 format, ARP=2 *-,AR6 ;Treg=x(4), AR2->x(3), ARP=6 *-,AR3 ;Preg=C9*x(4)=-C8*x(4), AR6->C4, ARP=3 ;Acc=Preg 3 ;sub 3 to the address loaded in AR3 <-> AR3->A(k)[3,5] *,1,AR6 ;A(k)[3,5]=-C8*x(4) in Q15 format, ARP=6 *,AR3 ;Preg=x(4)*C4, ARP=3 ;Acc=Preg 10 ;sub 10 to the address loaded in AR3 <-> AR3->A(k)[l,5] *,1,AR2 ;A(k)[l,5]=C4*x(4) in Q15 format, ARP=2 * ;Treg=x(3) AR6,#C10 ;Load in AR6 the address o f CIO *,AR6 ;ARP=6 *-,AR3 ;Preg=x(3)*C10=-C4*x(3), AR6->C8, ARP=3 ;Acc=Preg 5 ;add 5 to the address loaded in AR3 < > AR3->A(k)[2,5] *,1,AR6 ;A(k)[2,5]=C10*x(3)=-C4*x(3) in Q15 format, ARP=6

79

mpy pac adrk sach

*,AR3 ;Preg=x(3)*C8, ARP=3 ;Acc=Preg 10 ;add 10 to the address loaded in AR3 o AR3->A(k)[4,5] *,1 ; A(k)[4,5]=C8*x(3) in Q15 format.

;diff_f matrix is now updated x _ l= state vector prediction = x(k/k-l) x_l= [d iff_f(l,l)*x(l)+ diff_f(l,3)*x(3)+d iff.f(l,4)*x(4); diff^f(2,2)*x(2)+diff_f(2,3)*x(3)+diff_f(2,4)*x(4); diff^f(3,l)*x(l)+diff_f(3,3)*x(3)+diffj(3,4)*x(4); diff_f(4,2)*x(2)+diff^f(4,3)*x(3)+diff_f(4,4)*x(4); diff_f(5,5)*x(5)]... +[((wBase*T)/xsig)*u(l);((wBase*T)/xsig)*u(2); 0; 0; 0]; spm setc lar lar lar lar mar It mar mpy mar Itp mpy Ita mpy lar Ita mpy apac sach lar lar It mpy Itp mpy Ita mpy lar Ita mpy apac sach lar lar mar It mar mpy mar Itp mpy Ita mpy apac 1 ;set default left shift on Preg for Q15 calculations ovm AR4,#__x__1 ;load in AR4 the address o f x _ l (=x(k/k-l)) AR2,#_x ;load in AR2 the address o f x (=x(k-l/k-l)) AR3,#diff_f ;Ioad in AR3 the address o f diff_f AR6,#C5 ;load in AR6 the address o f C5 *,AR2 ;ARP=2 *+ ;Treg=x(l), AR2->x(2) *+,AR3 ;AR2->x(3), ARP=3 *+ ;Preg=x(l)*A (k)[l,l], AR3-> A(k)[l,2] *+,AR2 ;A R 3->A (k)[l,3],A R P=2 *+,AR3 ;Acc=Preg, Treg=x(3), AR2->x(4), ARP=3 *+,AR2 ;Preg=x(3)*A(k)[l,3], AR3-> A (k)[l,4], ARP=2 *+,AR3 ;Acc=Acc+Preg, Treg=x(4), AR2->x(5), ARP=3 *+,AR2 ;Preg=x(4)* A (k)[l,4], AR3-> A (k)[l,5], ARP=2 AR2,#u ;load in AR2 the address o f u (l) *,AR6 ;Acc=Acc+Preg, Treg=u(l), ARP=6 *,AR4 ;Preg=C5*u(l), ARP=4 ;Acc=Acc+Preg ;store in x _ l( l) , AR4->x__l(2), ARP=2 *+,AR2 AR2,#__x+l ;load in AR2 the address o f x(2) AR3,#diff_f+6 ;load in AR3 the address o f A(k)[2,2] *+,AR3 ;Treg=x(2), AR2->x(3), ARP=3 *+,AR2 ;Preg=x(2)*A(k)[2,2], AR3->A(k)[2,3], ARP=2 *+,AR3 ;Acc=Preg, Treg=x(3), AR2->x(4), ARP=3 *+,AR2 ;Preg=x(3)*A(k)[2,3], AR3->A(k)[2,4], ARP=2 *+,AR3 ;Acc=Acc+Preg, Treg=x(4), AR2->x(5), ARP=3 *+,AR2 ;Preg=x(4)*A(k)[2,4], AR3->A(k)[2,5], ARP=2 AR2,#u+l ;Ioad in AR2 the address o f u(2) *,AR6 ;Acc=Acc+Preg, Treg=u(2), ARP=6 *,AR4 ;Preg=C5*u(2), ARP=4 ;Acc=Acc+Preg *+,AR2 ;store in x _ l(2 ), AR 4->x_l(3), ARP=2 AR2,#_x ;load in AR2 the address o f x (l) ' AR3,#diff_f+10 ;load in AR3 the address o f A (k)[3,l] *,AR2 ;ARP=2 *+ ;Treg=x(l), AR2->x(2), ARP=3 *+,AR3 ;AR2->x(3), ARP=3 *+ ;Preg=x(l)*A(k)[3,l], AR3-> A(k)[3,2] *+,AR2 ;AR3->A(k)[3,3], ARP=2 *+,AR3 ;Acc=Preg, Treg=x(3), AR2->x(4), ARP=3 *+,AR2 ;Preg=x(3)*A(k)[3,3], AR3->A(k)[3,4], ARP=2 *+,AR3 ;Acc=Acc+Preg, Treg=x(4), AR2->x(5), ARP=3 *+,AR4 ;Preg=x(4)*A(k)[3,4], AR3->A(k)[3,5], ARP=4 ;Acc=Acc+Preg

-

80

sach lar lar It mpy Itp mpy Ita mpy apac sach lar lar It mpy pac sach spm clrc

*+,AR2

;store in x_l(3), AR4->x_l(4), ARP=2

AR2,#__x+l ;load in AR2 the address o f x(2) AR3,#diff_f+16 ;load in AR3 the address of A(k)[4,2] *+,AR3 ;Treg=x(2), AR2->x(3), ARP=3 *+,AR2 ;Preg=x(2)*A(k)[4,2], AR3-> A(k)[4,3], ARP=2 *+,AR3 ;Acc=Preg, Treg=x(3), AR2->x(4), ARP=3

*+,AR2
*+,AR3 *+,AR4 *+,AR2

;Preg=x(3)*A(k)[4,3], AR3->A(k)[4,4], ARP=2
;Acc=Acc+Preg, Treg=x(4), AR2->x(5), ARP=3 ;Preg=x(4)*A(k)[4,4], AR3->A(k)[4,5], ARP=4 ;Acc=Acc+Preg ;store in x _ l (4), AR4->x_l (5), ARP=2

AR2,#_x+4 ;load in AR2 the address of x(5) AR3,#diff_f+24 ;load in AR3 the address of A(k)[5,5] *,AR3 ;Treg=x(5), ARP=3 *,AR4 ;Preg=x(5)*A(k)[5,5] ;Acc=Preg *,AR2 ;store in A(k)[5,5]

0
ovm

;P_1= prediction error covariance matrix = P(k/k-l) ;P = filter error covariance matrix = P (k-l/k-l) ;P_l=diff_f*P*diff_f +Q mmtfraG P, diff_f, RSLT, 5,5,5 ;RSLT=P*diff_f mmfraG diff_f, RSLT, P _l, 5,5,5 ;P_l=diff^f*P*diff_f madiG P_1,Q,5 ;P_1= diff_f*P*diff_f+Q ;Kalman gain matrix calculation ;K= P_1 * C * inv(C*P_l*C' +R); mmtfraG P _l, C, RSLT, 5,5,2 ;RSLT=P_1 *C mmfraG C, RSLT, _K, 2,5,2 ;_K is a temp matrix, __K=C*P_1 *C madiG _K, R, 2 ;_K=_K+R madjG _K, P ;P is a temp matrix, P=adjCK) mmfraG RSLT, P, _K, 5, 2, 2 ;_K=RSLT*P=P_1 *C*adj(C*P__l *C'+R) detG P, RSLT ;RSLT=det(P) mdsclG _K, RSLT, _K, 5, 2,RSLT+1 ;_K=l/det(P)* P_1 *C*adj(C*P_l *C'+R) ;state vector estimation ;x_l= state vector prediction = x(k/k-l) ;x = state vector estimation ;x = x _ l + K*(y-C*x_l) msubG y, C x_l,P, 2,1 mmfraG _K, P, RSLT, 5,2,1 maddG _ x _ l, RSLT, _x, 5,1 f ilt e r error covariance matrix ;P=P_1-K*C*P_1; mmfraG __K, C, RSLT, 5, 2, 5 mmfraG RSLT, P _l, P , 5, 5, 5 msubG P_1,P,P,5,5 Idp lacc Idp sfr sfr sacl Idp lacc #kal_fil _x #iSal est

;P is a temp matrix, P= y-C*x_l ;RSLT=_K*P=_K*(y-C*x_l) ;_x= x _ l + K*(y-C*x_l)

;RSLT=_K*C ;P=_K*C*P_1 ;P=P_1-P

;notice that _x (estimated state) is in 1.15 format

iSal_est,l #kal_fil x+1

;iSalfa estimated *2

81

* *

Idp sfr sfr sacl

#iSbe_est

iSbe_est,l

;iSbeta estimated*2

* * * *

Idp lacc Idp sacl sfr sfr sfr sacl Idp lacc Idp sacl sfr sfr sfr sacl

#kal_fil _x+2 #psiRal_est psiRal_est

;__x+2 is the rotor flux alpha comp address ;f 1.15, used for the 1.15 division

psiRal_est #kal_fil _x+3 #psiRbe_est psiRbe_est

;psiRalfa estimated, 4.12 format

;__x+3 is the rotor flux beta comp address

* * * *

psiRbe_est

;psiRbeta estimated, 4.12 format

Idp #kal_fil _x+4 lacc ;_x+4 is the rotor speed variable address Idp #n_est * sfr * sfr ;n_est estimated*2 sacl n_est,l ret *** END Extended Kalman Filter **************

Filename:

pid.asm pid_reg_id, pid_reg__iq

Module names:

Initialization routines: pid_reg_idjnit, pid_reg_iq J n it

Description: PI current regulator with integral correction for d and q axes

Lfdb i_ref u jn t Kp Ki Kc

o--- ->l 0-- - > | 0-- -> l 0--- - >

1
pid_reg |-- ->o u_out

I

1 1

Target dependency: 'c2xx core only History: 3-11-2003

82

*************************************************************
* D-Axis PI Current Regulator
*************************************************************

Reference/Prototype .ref ref .ref .ref pid_reg_id,pid_reg_idJ n it ; function call id_fdb,id_ref,Kp_d,Ki_d,Kc_d ; Inputs u d jn t ; Input ud_out ; Outputs

Global Definitions .def .def .def .def pid_reg_id,pid_reg_id__init ; function call id_fdb,id_ref,Kp_d,Ki_d,Kc_d; Inputs udJnt ; Input ud_out ; Outputs

Variable Definitions id_fdb id_ref ud_out u d jn t uintlo_d Kp__d Ki_d Kc_d .usect "pid",l .usect "pid",l .usect "pid",l .usect "pid'% 1 .usect "pid",l .usect "pid",l .usect "pid",l .usect "pid",l ; current feedback ; current reference ; control voltage output ; error integral

; proportional gain ; integral gain ; integral correction gain ; current error ; control voltage prio saturation ; saturation error ; temp scrach

id_error .usect "pid",l uprsat_d .usect "pid",l saterr_d .usect "pid",l tmp_d .usect "pid",l

Default parameters Parameter spreadsheet: pid.xls Kp_d_ Ki_d_ Kc_d__ .set 783; 388 ; Q 11, proportional gain 0.189d .set 5133; 2542; 1271 ; Q25, integral gain 0.37878*0.0002d .set 32767 ; Q14, saturation correction gain 2d ; maximum U(0.875PU) ; minimum U(-0.875PU)

Umax_d_ .set 07000h Umin_d_ .set 08FFFh

Initialization pid_reg_idjnit #Kp_d Idp SPLK #Kp_d__,Kp_d SPLK #Ki_d_,Ki_d SPLK #Kc_d_,Kc_d SPLK #0,u d jn t SPLK #0,uintlo__d RET

; zero integral term

; Routine

83

pid_reg_id setc SXM setc OVM Idp #id_ref LACC id__ref,16 SUB id_fdb,16 SACH id_error lad uintlo_d ; add u d jn t, 16 spm 2 LT id_error mpy Kp_d apac SACH uprsat_d sacl tmp_d adds tmp__d add uprsat_d,16 sach tmp_d lacc tmp__d sub #Umin_d_ bend U_gmind,GEQ lacc #Umin_d_ B Nextd U_gmind lacc tmp__d sub #Umax_d_ BCND UJmaxd,LEQ lacc #Umax_d_ b Nextd UJm axd lacc tmp_d Nextd sacl ud_out Int_termd lacc ud_out,15 SUB uprsat_d,16 sach saterr_d It mpy pac sach lacc id_error Ki_d tmp_d tmp_d

; Allow sign extension ; Set overflow protection mode

; Use ACCH for GY protection ; Q15 id_ref - id_fdb

32-bit Q30 ; product 1/s 4 for accumulation ;Q 1 5 * Q ll-> 32-bit Q26 32-bit Q30 uint + id_error*Kp_d ; save as Q14 uprsat_d

; Q30 -> Q31 with GY protection ; save to tmp_d as Q15

; Continue if tmp_d>=U_min ; otherwise, saturate

; Continue if tmp_d<=U__max ; otherwise, saturate

; Use ACCH for GY protection ; save as Q14 saterr__d = ud_out-uprsat_d

; Q15*Q25 -> Q40 ; Q40 -> Q44 Q44 > Q28 (r/s 16 bits)

LT saterr_d MPYKc_d APAC norm norm ADDS ADD SACH SACL RET uintlo_d u d jn t, 16 u d jn t uintlo d

Q14*Q14 -> Q28 saterr_d * Kc_d Q28 Ki_d*id_error + Kc_d*saterr_d

; Q28 -> Q30 (with GY protection)

; uint + saterr_d*Kc_d + id_error*Ki__d ; save as 32-bit Q30

84

***END D-Axis PI Current Regulator

*************************************************************

*************************************************************
Reference/Prototype .ref .ref .ref .ref pid_reg_iq,pid_reg_iq J n it ; function call iq_fdb,iq_ref,Kp_q,Ki__q,Kc__q ; Inputs u q jn t ; Input uq_out ; Outputs

* Q-Axis PI Current Regulator

Global Definitions .def .def .def .def pid_reg_iq,pid_reg_iq J n it ; function call iq_fdb jq_ref,Kp_q,Ki_q,Kc__q ; Inputs uqJnt ; Input uq_out ; Outputs

Variable Definitions iq_fdb iq__ref uq_out .usect "pid",l .usect "pid'',l .usect "pid",l ; current feedback ; current reference ; control voltage output ; error integral

u q jn t .usect "pid",l uintlo_q .usect "pid",l Kp_q Ki_q Kc_q

.usect "pid",l ; proportional gain .usect "pid",I ; integral gain .usect "pid",l ; integral correction gain ; current error ; control voltage prio saturation ; saturation error ; temp scrach

iq_error .usect "pid",l uprsat_q .usect "pid",l saterr_q .usect "pid",l tmp_q .usect "pid",I

Default parameters Parameter spreadsheet: pid.xls Kp_q_ Ki_q_ Kc_q_ .set 1566; .set 7700; .set 24576 776 3814 ; Q l l , proportional gain 0.3789d ;1907 ; Q25, integral gain 0.56833*0.00026 ; Q14, saturation correction gain 1.5d

Umax_q_ .set 07000h Umin_q_ .set OSFFFh

; maximum U ; minimum U

Initialization pid_reg_iq_init Idp #Kp_q #Kp_q_,Kp_q SPLK SPLK #Ki_q_,Ki_q SPLK #Kc_q_,Kc_q #0,u q jn t SPLK #0,uintlo_q SPLK

; zero integral term

85

RET

Routine pid_reg_iq setc SXM setc OVM Idp #iq_ref LACC iq_ref,16 SUB iq_fdb,16 SACH iq_error lad uintlo__q add u q jn t, 16 spm 2 LT iq_error mpy Kp_q apac SACH uprsat_q sacl tmp_q adds tmp_q add uprsat_q,16 sach tmp__q lacc tmp_q sub #Umin__q_ bend U__gminq,GEQ lacc #Umin__q_ B Nextq U_gminq lacc tmp_q sub #Umax_q_ BCND UJmaxq,LEQ lacc #Umax_q_ b Nextq U Jm axq lacc tmp_q Nextq sacl uq_out Intjerm q lacc uq_out,15 SUB uprsat__q,16 sach saterr__q It mpy pac sach lacc iq__error Ki_q tmp_q tmp__q

; Allow sign extension ; Set overflow protection mode

; Use ACCH for GY protection ; Q15 iq_ref - iq_fdb

; 32-bit Q30 ; product 1/s 4 before accumulation ;Q 1 5 * Q ll-> 32-bit Q26 ; 32-bit Q30 uint + iq_error*Kp_q ; save as Q14 uprsat__q

; Q30 -> Q31 with GY protection ; save to tmp_q as Q15

; Continue if tmp_q>=U_min ; otherwise, saturate

; Continue if tmp_q<=U_max ; otherwise, saturate

Use ACCH for GY protection save as Q14 saterr_q = uq__out-uprsat__q

; Q15*Q26 -> Q40 ; Q40 -> Q44 ; Q44 > Q28 (r/s 16 bits)

LT saterr_q MPYKc_q APAC norm norm ADDS ADD uintlo__q u q jn t, 16

Q14*Q14 > Q28 saterr_q * Kc_q Q28 Ki__q*iq_error + Kc__q*saterr__q

; Q28 -> Q30 (with GY protection)

; uint + saterr_q*Kc_q + iq__error*Ki_q

86

SACH SACL RET

uq_int uintlo_q

; save as 32-bit Q30

***END Q-Axis PI Current Regulator

Filename: History: 3-11-2003

pid_spd.asm

*************************************************************
* Speed PI Regulator
*************************************************************

.ref pid_reg_spd,pid__reg_spd_init ; function call .ref spd_fdb,spd_ref ; Inputs .ref spd_out ; Outputs Global Definitions .def pid_reg_spd,pid_reg_spdjnit ; function call .def spd_fdb,spd_ref ; Inputs .def spd__out ; Outputs Variable Definitions

spd_ref spd_fdb spd_out

.usect "pid_spd",l .usect "pid_spd",l .usect "pid_spd'\l

;other variables : * PI regulators variable upi .usect "pid_spd",l ;PI regulators (current and speed) elpi .usect "pid_spd",l ;PI regulators (current and speed) Kcom .usect "pid__spd",l Ki .usect "pid_spd", 1 Kcor .usect "pid_spd",l Kpin .usect "pid_spd",l Kin .usect "pid_spd",l Kpi .usect "pid_spd",l epin .usect "pid_spd",l ;speed error (used in speed xin .usect "pid_spd",l ;speed regulator integral epiq .usect "pid_spd",l ;q-axis current regulator error epid .usect "pid_spd", 1 ;d-axis current regulator error xiq .usect "pid_spd", 1 ;q-axis current regulator integral xid .usect "pid_spd", 1 ;d-axis current regulator integral *** vSqref and YdSr limitations Vmin .set OecOOh ;4.12 format=-1.25 pu

;output limitation error

;regulator) ;component

;component ;component

87

Vmax

.set 1400h

;4.12 format=1.25 pu

*** iSqref limitations Isqrefmin .set -1310 ;4.12 format=-0.8 pu, I_nom=10A Isqrefmax .set 1310;4.12 format=0.8 pu, I_nom=10A vSqref .usect "pid_spd",l iSqref .usect "pid_spd", 1 iSd .usect "pid_spd",l iSq .usect "pid__spd",l n .usect "pid_spd",l n_ref .usect "pid_spd", 1 vSdref .usect "pid_spd", 1 iSdref .usect "pid_spd", 1

pid__reg_spd_init zac Idp #spd__ref sacl xin sacl upi sacl elpi sacl spd_out sacl upi sacl elpi sacl epin sacl epiq sacl epid sacl xiq sacl xid sacl vSqref sacl iSqref sacl iSd sacl iSq sacl n sacl n__ref sacl vSdref sacl iSdref *** PI speed regulators parameters splk #35h,Kin ; 0.012939 Q12? splk #482bh,Kpin; 4.5105 splk #Obh,Kcom ; 0.0026855 ret pid_reg__spd ;Interface avec les nouvelles variables Idp #spd_fdb lacc spd_fdb ;Q15, 6000rpm as pu sfr Idp #n sacl n ;Q12,1500rpm aspu Idp #spd_ref ;Q15 ref with Ipu =1500rpm lacc spd_ref sfr sacl n__ref ;Q12 with 1500rpm as pu
*****************************************************

* Speed regulator with integral component correction
*****************************************************

Idp #n_ref lacc n_ref sub n sacl epin ;epin=n_ref-n, 4.12 format

88

lacc xin, 12 It epin mpy Kpin apac sach upi,4;upi=xin+epin*Kpin, 4.12 format ;here we start to saturate bit upi,0 bend upimagzeros,NTC ;If value >0 we branch lacc #Isqrefmin ;negative saturation sub upi bend neg_sat,GT ;if upi<ISqrefmin then branch to ;saturate lacc upi ;value o f upi is valid b limiters neg_sat lacc #Isqrefmin ;set acc to -ve saturated value b limiters upimagzeros ;Value is positive lacc #Isqrefmax ;positive saturation sub upi bcndpos_sat,LT ;if upi>ISqrefmax then branch to lacc upi ;value of upi valid b limiters pos_sat lacc #Isqrefmax ;set acc to +ve saturated value limiters sacl iSqref ;Store the acc as reference value ;Interface avec la nouvelle variable de sortie setc OVM sfl sfl sfl Idp #spd_out sacl spd_out sub #7fffh clrc OVM Idp #iSqref lacc iSqref sub upi sacl elpi ;elpi=iSqref-upi, 4.12 format It elpi ;if there is no saturation elpi=0 mpy Kcom pac It epin mpy Kin apac add xin, 12 sach xin,4;xin=xin+epin*Kin+elpi*Kcom, 4.12

;saturate

***********************************************************
* END Speed regulator with integral component correction
***********************************************************

;format

ret

Filename:

pwm_drv.asm FC_PWM_DRV

Module Name:

89

Initialization Routine: FC_PWM_DRV_INIT Description: This module uses the duty ratio information and calculates the compare values for generating PWM outputs. The compare values are used in the full compare unit in 24x/24xx event manager(EV). This also allows PWM period modulation.

Mfunc_cl o------> I---- >o CMPRl (EV register) Mfunc_c2 o------> FC_PWM_DRV I------ >0 CMPR2 (EV register) Mfunc c3 o------> I ---- >0 CMPR3 (EV register) Mfunc_po >1-------------------------- I----- >0 T 1PER (EV register) n_period o >|_________________ | Target: Other: x2407 Event Manager Timer! & F Compares Dependent on PWM period selection

History: 3-11-2003

Reference/Prototype .ref FC__PWM_DRV,FC__PWM_,DRV_INrr ;function calls .ref Mfunc_cl ,Mfunc_c2,Mfunc_c3,Mfunc_p ;Inputs .ref n_period ;Input

Define Related Peripherals .include "x24x_app.h"

Default PWM Period *PWM_PERIOD PWM_PERIOD Global Definitions .def FC_PWM_DRV,FC_PWM_DRV_INIT ;function calls .def Mfunc_cl,Mfunc_c2,Mfunc_c3,Mfunc__p ;Inputs .def n_period ;Input .set 50 .set 200 ; PWM period in uS (20KHz) ,different from foci.asm? ; PWM period in uS (5Khz)

Variables Mfunc_cl .usect "pwm_drv",l ; Phase 1 mod function Q15 Mfunc_c2.usect "pwm_drv",l ; Phase 2 mod function Q15 Mfunc_c3 .usect "pwm__drv",l ; Phase 3 mod function Q15 Mfunc_p .usect "pwm_drv",l ; Period mod function Q15 n_period .usect "pwm_drv",l ; Norminal period/compare value m_period .usect "pwm__drv",l ; Modulated period

Configuration parameters

.ifx2407 T1PER_ .set PWM_PERI0D*15 ;*1000nS/(2*33nS)

90

T1C0N__ .set 1000100001000000b ; Symmetric PWM DBTCON_ .set 09E8h ; D/B = 1.18uS @ 33nS clk ACTR_ .set 011001100110b ;1/3/5 Active Hi, 2/4/6 Active Lo COMCON__ .set 1000001000000000b ; Compare Cntl .endif Initialization FC_PWM_DRV__INIT L D P #T 1P E R »7 SPLK #T1PER_,T1PER SPLK #T1C0N_,T1C0N SPLK #DBTCON_,DBTCON SPLK #ACTR_,ACTR SPLK #COMCON_,COMCON .ifx2407 Idp # 0 C R A » 7 ; Configure 6-pwm pins LACC OCRA OR #000011 111 1000000b SACL OCRA .endif Idp #n_period SPLK #TlPER_,n__period SPLK #7FFFh,Mftinc_p RET

Driver Routine FC_PWM_DRV: Idp #Mfunc_p; modulate period LT Mfunc_p MPY n_period ; Mfunc_p*n_period/2 PAC add n_period,15 ; offset by n_period/2 SACH m_period ; save for later reference Idp #T 1P E R »7 ; sach TIPER ; save Idp #Mfunc_cl ; Modulate channel one LT Mfunc_cl MPY m_period ; Mfunc_cl x m_period/2 PAC ; add m_period,15 ; offset by m__period/2 Idp #C M P R 1»7 SACH CMPRl ; save Idp #Mfunc_c2 ; Modulate channel two LT Mfunc_c2 MPY m_period ; Mfunc__c2 x m_period/2 PAC ; add m_period,15 ; offset by m_period/2 Idp #C M P R 2»7 SACH CMPR2 ; save Idp #Mfunc_c3 ; modulate channel three LT Mfunc_c3 MPY m_period ; Mfunc__c3 x m_period/2 PAC ; add m_period,15 ; offset by m_period/2 Idp #C M P R 3»7 SACH CMPR3 ; save RET

91

File Name:

rampgen.asm RAMP__GEN

Module Name:

Initialization Routine: RAMP__GEN_INIT

Description: This module generates ramp output of adjustable gain, frequency and dc offset.

I ------------------ 1
RAMP_GEN |

rmp_gain o----- >| rmp_offset o >| rmp_freq o----- >|

| >o |

rmp_out

______________ I I
Target dependency: c2xx core only History: 3-11-2003 (To use this Module, copy this section to main system file) .ref RAMP__GEN, RAMP_GEN_1N1T ;function call .ref rmp__gain, rmp_offset, rmp_freq ;lnputs .ref step_angle_max ;lnput .ref rmp_out ;Outputs def .def .def .def RAMP__GEN, RAMP_GEN_1N1T ;function call rmp_gain, rmp__offset, rmp__freq ;lnputs step_angle_max ;lnput rmp_out ;Output

STEP_ANGLE_RG_MAX .set 1000;Corresponds to 305.2Hz for fs=20kHz ; or 152.6Hz for fs=10fflz, or 76.3Hz for fs=5KHz ;See related doc for details alpha_rg .usect "rampgen",! step_angle_rg .usect "rampgen",! step_angle_max .usect "rampgen",! rmp__gain .usect "rampgen",! rmp_offset .usect "rampgen",! rmp_freq .usect "rampgen",! rmp_out .usect "rampgen",! rmp_out_abs .usect "rampgen",!

RAMP_GEN_!N!T: LDP #alpha_rg SPLK #0,alpha_rg SPLK #STEP__ANGLE_RG_MAX, step_angle_max SPLK SPLK SPLK RET #3FFFh, rmp__gain #3FFFh, rmp__offset #3FFFh, rmp__freq

RAMP__GEN: SPM 0 LDP #rmp_freq LT rmp__freq

;Normalized frequency rmp_freq

92

MPY PAC SACH LACC ADD SACL

;is in Q15 step_angle__max ;Q15 x QO ;Q 0xQ 15 = Q15(32bit) step_angle_rg,l ;Q0 alpha_rg ;Q0 step_angle__rg ;QO+QO alpha_rg ;Q0

;scale the output with gain(user specified) LT alpha_rg ;Q0 MPY rmp__gain ;Q0 x Q15 PAC ;P = rmp__gain * alpha_rg SACH rmp_out_abs,l ;Q0 T.A Pn rmn oiif nhc *00 LACC rmp_out_abs Q O SACL rmp_out Q15** ;In the last two instructions the variables rmp_out_abs and rmp__out contain ;the same value which is the result o f the preceeding multiply operation. ;Although they have the same value, by representing rmp__out with a ;different Q format(Q15) than rmp_out_abs(QO), we have essentially performed ;an implicit normalization(division) operation. The normalized ramp output, ;rmp_out(in Q15), and the absolute ramp output, rmp_out_abs (in QO), are ;related by, ;rmp_out = rmp_out_abs/7FFFh. ;The output of this module(rmp_out) is normalized (expressed in Q15) since ;in many other s/w modules, where this is used as input, require the input ;be provided in Q15 format.

;add offset value LACC rmp_out ADD rmp__offset SACL rmp_out RET

Q15 Q15+Q15 Q15

93

File: SINTB360.asm Name: SINTAB_360 Type: Table Description: This is a program space lookup table for Sin/Cos functions.

Target:

C2xx core

Last Update: 03-11-2003 (To use this Module, copy this section to the calling file) .ref SINTAB_.360 Module definitions for external reference. .def SINTAB__360

Sine look-up table No. Entries: 256 Angle Range: 360 deg Number format: Q15 with range -1 < N < +1 ;SINVAL SINTAB_360 .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word ,word .word 0 804 1608 2410 3212 4011 4808 5602 6393 7179 7962 8739 9512 10278 11039 11793 12539 13279 14010 14732 15446 . 16151 16846 17530 18204 18868 19519 20159 20787 21403 22005 22594 23170 23731 . 24279 24811 25329 25832 94 Index 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 Angle Sin(Angle) 0 0.0000 1.41 0.0245 0.0491 2.81 0.0736 4.22 0.0980 5.63 0.1224 7.03 0.1467 8.44 0.1710 9.84 0.1951 11.25 0.2191 12.66 0.2430 14.06 0.2667 15.47 0.2903 16.88 0.3137 18.28 0.3369 19.69 0.3599 21.09 0.3827 22.50 0.4052 23.91 0.4276 25.31 0.4496 26.72 0.4714 28.13 0.4929 29.53 0.5141 30.94 0.5350 32.34 33.75 0.5556 0.5758 35.16 0.5957 36.56 0.6152 37.97 0.6344 39.38 40.78 0.6532 0.6716 42.19 43.59 0.6895 45.00 0.7071 46.41 0.7242 47.81 0.7410 49.22 0.7572 50.63 0.7730 52.03 0.7883

.word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word

26319 26790 27245 27683 28105 28510 28898 29268 29621 29956 30273 30571 30852 31113 31356 31580 31785 31971 32137 32285 32412 32521 32609 32678 32728 32757 32767 32757 32728 32678 32609 32521 32412 32285 32137 31971 31785 31580 31356 31113 30852 30571 30273 29956 29621 29268 28898 28510 28105 27683 27245 26790 26319 25832 25329 24811 24279 23731 23170 22594 22005 21403 20787

38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100

53.44 54.84 56.25 57.66 59.06 60.47 61.88 63.28 64.69 66.09 67.50 68.91 70.31 71.72 73.13 74.53 75.94 77.34 78.75 80.16 81.56 82.97 84.38 85.78 87.19 88.59 90.00 91.41 92.81 94.22 95.63 97.03 98.44 99.84 101.25 102.66 104.06 105.47 106.88 108.28 109.69 111.09 112.50 113.91 115.31 116.72 118.13 119.53 120.94 122.34 123.75 125.16 126.56 127.97 129.38 130.78 132.19 133.59 135.00 136.41 137.81 139.22 140.63

0.8032 0.8176 0.8315 0.8449 0.8577 0.8701 0.8819 0.8932 0.9040 0.9142 0.9239 0.9330 0.9415 0.9495 0.9569 0.9638 0.9700 0.9757 0.9808 0.9853 0.9892 0.9925 0.9952 0.9973 0.9988 0.9997 1.0000 0.9997 0.9988 0.9973 0.9952 0.9925 0.9892 0.9853 0.9808 0.9757 0.9700 0.9638 0.9569 0.9495 0.9415 0.9330 0.9239 0.9142 0.9040 0.8932 0.8819 0.8701 0.8577 0.8449 0.8315 0.8176 0.8032 0.7883 0.7730 0.7572 0.7410 0.7242 0.7071 0.6895 0.6716 0.6532 0.6344

95

.word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word

20159 19519 18868 18204 17530 16846 16151 15446 14732 14010 13279 12539 11793 11039 10278 9512 8739 7962 7179 6393 5602 4808 4011 3212 2410 1608 804 0 64731 63927 63125 62323 61524 60727 59933 59142 58356 57573 56796 56023 55257 54496 53742 52996 52256 51525 50803 50089 49384 48689 48005 47331 46667 46016 45376 44748 44132 43530 42941 42365 41804 41256 40724

101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163

142.03 143.44 144.84 146.25 147.66 149.06 150.47 151.88 153.28 154.69 156.09 157.50 158.91 160.31 161.72 163.13 164.53 165.94 167.34 168.75 170.16 171.56 172.97 174.38 175.78 177.19 178.59 180.00 181.41 182.81 184.22 185.63 187.03 188.44 189.84 191.25 192.66 194.06 195.47 196.88 198.28 199.69 201.09 202.50 203.91 205.31 206.72 208.13 209.53 210.94 212.34 213.75 215.16 216.56 217.97 219.38 220.78 222.19 223.59 225.00 226.41 227.81 229.22

0.6152 0.5957 0.5758 0.5556 0.5350 0.5141 0.4929 0.4714 0.4496 0.4276 0.4052 0.3827 0.3599 0.3369 0.3137 0.2903 0.2667 0.2430 0.2191 0.1951 0.1710 0.1467 0.1224 0.0980 0.0736 0.0491 0.0245 0.0000 -0.0245 -0.0491 -0.0736 -0.0980 -0.1224 -0.1467 -0.1710 -0.1951 -0.2191 -0.2430 -0.2667 -0.2903 -0.3137 -0.3369 -0.3599 -0.3827 -0.4052 -0.4276 -0.4496 -0.4714 -0.4929 -0.5141 -0.5350 -0.5556 -0.5758 -0.5957 -0.6152 -0.6344 -0.6532 -0.6716 -0.6895 -0.7071 -0.7242 -0.7410 -0.7572

96

.word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word

40206 39703 39216 38745 38290 37852 37430 37025 36637 36267 35914 35579 35262 34964 34683 34422 34179 33955 33750 33564 33398 33250 33123 33014 32926 32857 32807 32778 32768 32778 32807 32857 32926 33014 33123 33250 33398 33564 33750 33955 34179 34422 34683 34964 35262 35579 35914 36267 36637 37025 37430 37852 38290 38745 39216 39703 40206 40724 41256 41804 42365 42941 43530

164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226

230.63 232.03 233.44 234.84 236.25 237.66 239.06 240.47 241.88 243.28 244.69 246.09 247.50 248.91 250.31 251.72 253.13 254.53 255.94 257.34 258.75 260.16 261.56 262.97 264.38 265.78 267.19 268.59 270.00 271.41 272.81 274.22 275.63 277.03 278.44 279.84 281.25 282.66 284.06 285.47 286.88 288.28 289.69 291.09 292.50 293.91 295.31 296.72 298.13 299.53 300.94 302.34 303.75 305.16 306.56 307.97 309.38 310.78 312.19 313.59 315.00 316.41 317.81

-0.7730 -0.7883 -0.8032 -0.8176 -0.8315 -0.8449 -0.8577 -0.8701 -0.8819 -0.8932 -0.9040 -0.9142 -0.9239 -0.9330 -0.9415 -0.9495 -0.9569 -0.9638 -0.9700 -0.9757 -0.9808 -0.9853 -0.9892 -0.9925 -0.9952 -0.9973 -0.9988 -0.9997 -1.0000 -0.9997 -0.9988 -0.9973 -0.9952 -0.9925 -0.9892 -0.9853 -0.9808 -0.9757 -0.9700 -0.9638 -0.9569 -0.9495 -0.9415 -0.9330 -0.9239 -0.9142 -0.9040 -0.8932 -0.8819 -0.8701 -0.8577 -0.8449 -0.8315 -0.8176 -0.8032 -0.7883 -0.7730 -0.7572 -0.7410 -0.7242 -0.7071 -0.6895 -0.6716

97

.word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word .word

44132 44748 45376 46016 46667 47331 48005 48689 49384 50089 50803 51525 52256 52996 53742 54496 55257 56023 56796 57573 58356 59142 59933 60727 61524 62323 63125 63927 64731 65535

227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256

319.22 320.63 322.03 323.44 324.84 326.25 327.66 329.06 330.47 331.88 333.28 334.69 336.09 337.50 338.91 340.31 341.72 343.13 344.53 345.94 347.34 348.75 350.16 351.56 352.97 354.38 355.78 357.19 358.59 360.00

-0.6532 -0.6344 -0.6152 -0.5957 -0.5758 -0.5556 -0.5350 -0.5141 -0.4929 -0.4714 -0.4496 -0.4276 -0.4052 -0.3827 -0.3599 -0.3369 -0.3137 -0.2903 -0.2667 -0.2430 -0.2191 -0.1951 -0.1710 -0.1467 -0.1224 -0.0980 -0.0736 -0.0491 -0.0245 0.0000

Filename:

svgen_dq.asm SVGEN_DQ

Module Name:

Initialization Routine: SVGEN_DQ_INIT

Description: This module calculates the appropriate duty ratios needed to generate a given stator reference voltage using space vector PWM technique. The stator reference voltage is described by it's (a,b) components, Ualfa and Ubeta.

Ualfa Ubeta

o-- >1

I->0 I SVGEN^DQ o-- >|------------------------ |-->o

Ta I Tc >0 Tb

I ____________ I
History:

98

3- 11-2003

Reference/Prototype .ref SVGEN_DQ,SVGEN_DQ^INIT .ref Ualfa,Ubeta ;Inputs .ref Ta,Tb,Tc ;Outputs ;function call

Select Processor and Define Related Peripherals .include "x24x_app.h"

Global Definitions .def SVGEN_DQ,SVGEN_DQ_INIT .def Ualfa,Ubeta ;Inputs .def Ta,Tb,Tc ;Outputs out_of_phase_ Variables Ualfa .usect "svgen_dq",l Ubeta .usect "svgen_dq",l Va .usect "svgen__dq",l Vb .usect "svgen_dq",l Vc .usect "svgen_dq",l Ta .usect "svgen_dq",l Tb .usect "svgen_dq",l Tc .usect "svgen_dq",l sector .usect "svgen_dq",l ;SVPWM sector tl .usect "svgen_dq", 1 ;SVPWM T1 t2 .usect "svgen_dq",l ;SVPWM T2 half_sqrt3 .usect "svgen_dq",l ;SQRT(3) * 0.5 ;Alias Variable declaration (to conserve .bss locations) X .set Va Y .set Vb Z .set Vc SR_ADDR .set sector .set 0 ;function call

SVGEN_DQ_INIT: Idp #half_sqrt3 SPLK #28378,half_sqrt3 ; Set constant sqrt(3)*0.5 in Q15 format RET

SVGEN_DQ: ;INV__CLARKE: SPM 1 SETC ;Va = Ubeta ; SPM set for Q15 multiplication ; Sign extension mode on

SXM

99

Idp #Ubeta LACC Ubeta SACL Va

; ACC = Ubeta ; Va = Ubeta

;Vb = (-Ubeta + sqrt(3) * Ualfa) / 2 LT Ualfa ;TREG = Ualfa MPY half_sqrt3 ; PREG = Ualfa * half_sqrt3 PAC ; ACC high = Ualfa *half_sqrt3 SUB Ubeta, 15 ; ACC high = Ualfa * half_sqrt3 +Ubeta/2 SACH Vb ; Vb = Ualfa * half_sqrt3 +Ubeta/2 ;Vc = (-Ubeta - sqrt(3) * Ualfa) / 2 PAC ; ACC high = Ualfa * half_sqrt3 NEG ; ACC high = - Ualfa * half_sqrt3 SUBUbeta,15 ; ACC high = - Ualfa * half_sqrt3 -Ubeta/2 SACH Vc ; Vc = - Ualfa * half_sqrt3 -Ubeta/2

60 degrees sector determination sector = rl + 2*r2 + 4*r3 r l= l if Va>0 r2=l if Vb>0 r3=l if V o O SPLK LACC BCND LACC OR #1 SACL vrefl_neg LACC BCND LACC OR #2 SACL vref2_neg LACC BCND LACC OR #4 SACL vref3_neg Vc vref3_neg,LEQ sector sector Vb vref2_neg,LEQ sector sector ; ;If Vc<0 do not set bit 3 of sector #0,sector Va vrefl_neg,LEQ sector sector ; ;If VtxO do not set bit 2 of sector

;If Va<0 do not set bit 1 of sector

X,Y,Z calculation: XYZ_CALC: ;X = Ubeta LACC SACL

Ubeta X

;Y = (0.5 * Ubeta) + (sqrt(3) * 0.5 * Ualfa) LT Ualfa ; TREG = Ualfa ; PREG = Ualfa * half_sqrt3 MPY half_sqrt3 PAC ; ACC high = Ualfa * half_sqrt3 ; ACC high = Ualfa * half_sqrt3 + Ubeta/2 ADD Ubeta, 15 SACH Y ; Y = Ualfa * half_sqrt3 + Ubeta/2 ;Z = (0.5 * Ubeta) - (sqrt(3) * 0.5 * Ualfa) PAC ; ACC high = Ualfa * half_sqrt3 NEG ; ACC high = - Ualfa * half_sqrt3 ADD Ubeta, 15 ; ACC high = - Ualfa * half_sqrt3 + Ubeta/2

100

SACH

; Z = - Ualfa * half_sqrt3 + Ubeta/2

Sector calculations ("case statement") LACC ADD TBLR LACC BACC SECTOR^SRl: ;sector 1: tl=Z and t2=Y, (abc -- > Tb, Ta, Tc) lacc Z sad tl lacc Y sad t2 lacc #7FFFh sub tl sub t2 sfr sad Tb add tl sad Ta add t2 sad Tc B SV_END _SR2: tor 2: tl= Y and t2= -X, (abc lacc Y sad tl lacc X neg sad t2 lacc #7FFFh sub tl t2 sub sfr sad Ta add tl sad Tc add t2 sad Tb B SV END SECT0R_SR3: ;sector 3: tl=-Z and t2=X, (abc lacc Z neg sad tl lacc X sad t2 lacc sub sub sfr #7FFFh tl t2 > Ta, Tb, Tc) > Ta, Tc, Tb) ;Load 1 (Q15) ;taon=(l-tl-t2)/2 #SECTOR_TBL sector SR.ADDR SR.ADDR

;tbon=taon+tl ;tcon=tbon+t2

;Load 1 (Q15) ;taon=(l-tl-t2)/2

;tbon=taon+tl ;tcon=tbon+t2

;Load 1 (Q15) ;taon=(l-tl-t2)/2

101

sad Ta add tl sad Tb add t2 sad Tc B SV_END SECTOR SR4: ;sector 4: tl= -X and t2=Z, (abc lacc X neg sad tl lacc Z sad t2 lacc sub sub sfr sad add sad add sad B SECT0R_SR5: #7FFFh tl t2 Tc tl Tb t2 Ta SV^END

;tbon=taon+tl ;tcon=tbon+t2

> Tc, Tb, Ta)

;Load 1 (Q15) ;taon=(l-tl-t2)/2

;tbon=taon+tl ;tcon=tbon+t2

;sector 5: tl= X and t2=-Y, (abc -- > Tb, Tc, Ta) lacc X sad tl lacc Y neg sad t2 lacc sub sub sfr sad add sad add sad B _SR6: tor 6: tl=-Y and t2= -Z, (abc - > Tb, Tc, Ta) lacc Y neg sad tl lacc Z neg sad t2 lacc #7FFFh sub tl t2 sub sfr sad Tc add tl ;Load 1 (Q15) ;taon=(l-tl-t2)/2 #7FFFh tl t2 Tb tl Tc t2 Ta SV_END ;Load 1 (Q15) ;taon=(l-tl-t2)/2

;tbon=taon+tl ;tcon=tbon+t2

;tbon=taon+tl

102

sad add sad

Ta t2 Tb

;tcon=tbon+t2

SV_END: ;Multiply Ta by 2 & offset by 1/2 LACC Ta SUB#3FFFh SACL Ta, 1 ;mpy by 2 ;MuItiply Tb by 2 & offset by 1/2 LACC Tb SUB#3FFFh SACL Tb,l ;mpy by 2 ;Multiply Tc by 2 & offset by 1/2 LACC Tc SUB#3FFFh SACL Tc, 1 ;mpy by 2 .if (out_of_phase_) LACC Ta NEG SACL Ta LACC Tb NEG SACL Tb Tc LACC NEG SACL Tc .endif DUMMY RET SPMO ; SPM reset

SVPWM Sector routine jump table - used with BACC inst. SECTOR.TBL: SROO .word DUMMY SRO .word SECTOR.SRl SRI .word SECT0R_SR2 SR2 .word SECT0R_SR3 SR3 .word SECT0R_SR4 SR4 .word SECT0R_SR5 SR5 .word SECT0R_SR6

103

Module Name: S Y S _ I N I T File Name: Description: Sys_init.asm Initializes F24x/xx devices

A R l is used as stack pointer Last Update: 3-11-2003 .include x24x__app.h .def SY SJN IT .ref GPRO

stack_size.set 20h stack_start .usect SYSJNIT:

"stack",stack__size

;-- target dependancy---------------.if(x2407) POINT__PGO SETC INTM SPLK #0h, IMR SPLK #OFFh, IFR

;Disable interrupts ;Mask all Ints ;Clear all Int Flags

;Init PDP interrupt flag after reset L D P#PIR Q R 0»7 LACC PIRQRO ; Clear pending PDP flag AND #OFFFEh SACL PIRQRO LACC PIRQR2 ; Clear pending PDP flag AND #OFFFEh SACL PIRQR2 POINT__EV LACC EVAIFRA ; Clear PDPINTA flag OR #0001h SACL EVAIFRA LD P#EV B IFR A »7 LACC EVBIFRA ; Clear PDPINTB flag OR #0001h SACL EVBIFRA POINT_PGO CLRC SXM CLRC OVM CLRC CNF SPMO LARARI, #stack_start MÀR *,AR1

;Clear Sign Extension Mode ;Reset Overflow Mode ;Config Block BO to Data mem. ;Init s/w stack pointer

POINT_BO SPLK #OOCOh, GPRO ;Set 3 wait states for I/O space OUTGPRO, WSGR P0INT_PF1 .if(x4_PLL) SPLK #0085h, SCSRl .endif

; x4 PLL, ADC en, EVl en, clr 111 Addr fig

104

.if(x2__PLL) SPLK #0285h, SCSRl .endif ;Comment out if WD is to be active SPLK #006Fh, WD_CNTL KICK__DOG RET .endif

; x2 PLL, ADC en, EVl en, clr 111 Addr fig

;DisableW DifVCCP=5V

File Name:

theta_est.asm theta_estimation_model

Module Name:

Initialization Routine: theta_est_init

Description: Current model for field oriented control of an AC induction machine

IpsiRal ->| I theta_est psiRbe ->|I, I I-->cosTeta_est model I-->sinTeta_est

I _______
Target: x2407

History: 3-18-2003 ; Reference/Prototype

.ref theta_est,theta__est_init .ref psiRal,psiRbe .ref sinTeta_est,cosTeta_est

; function call ; Inputs ; Outputs ;

Global Definitions

.def theta_est,theta__est_init ; function call .def psiRal,psiRbe ; Inputs .def sinTeta_est,cosTeta__est ; Outputs ; .ref sqrt_tab ; square root table

105

Variable Definitions
public variables psiRal .usect "theta__es",l psiRbe .usect "theta_es",l sinTeta_est .usect "theta_es",l cosTeta_est .usect "theta_es",l

;private variables tmp .usect "theta_es",l tmpl .usect "theta_es",l Index .usect "theta_es",l psiR__est .usect "theta_es",l psiR_estl .usect "theta_es",l psiRal_estl .usect "theta_es",l psiRbe__estl .usect "theta_es",l Default parameters Ksqrt .set 2751 Pole_pairs_number .set 2

Initialization theta_est__init CURRENT__MODEL_INrr Idp #psiRal splk #OOQOh,sinTeta_est splk #7FFFh,cosTeta_est ret

***********************************************

* Rotor flux amplitude calculation * psiR_est
***********************************************

theta_est Idp bldd bldd lacc sfr sfr sfr sacl lacc sfr sfr sfr sacl mar spm mpy zac sqra pac #psiRal #psiRal,psiRal_estl #psiRbe,psiRbe_estl psiRal__estl ;change to 4.12 format psiRal psiRbe_estl

psiRbe *,AR5 2 #0

;ARP->AR5 ;automatic « 2 for 4.12 multiplications ;Preg is cleared to zero ;Acc is cleared to zero psiRal ;Preg=(psiRal_est)2 ;Acc=(psiRal_est)2 in 4.12 format (spm=2)

106

sach tmp ;tmp=(psiRal_est)2 sqra psiRbe ;Preg=(psiRbe_est)2 pac ;Acc=(psiRbe_est)2 in 4.12 format (spm=2) sach tmpl ;tmp 1=(psiRbe_est)2 lacc tmpl add tmp sacl tmp ;tmp=(psiRal_est)2 + (psiRbe__est)2 still in 4.12f spm 0 ;no automatic shift anymore It tmp ;Treg=tmp mpy #Ksqrt ;Preg=tmp*Ksqrt pac ;Acc=Preg, the two index digits are located in the high Acc sach Index ;store the two interesting digits into Index (->8.81) lacc Index ;Acc=Index add #sqrt_tab ;Acc=Index+sqrt table address sacl tmp ;tmp= Index+sqrt table address lar AR5,tnip ;load in AR5 the content of tmp lacc * ;Acc= sqrt(psiRal_est2+psiRbe_est2) in 8.8 format sacl psiR_est,4 ;psiR_est=sqrt(psiRal_est2+psiRbe_est2) 4 left shift > 4.12f sacl psiR_estI,7 ;psiR_estl=sqrt(psiRal_est2+psiRbe__est2) 7 left shift > 1.15f

***********************************************
* divisions psiRal_estl/psiR_estl * psiRbe_est l/psiR_est 1 * input in f 1.15 * output (cosTeta_est, sinTeta_est) in f 4.12
***********************************************

lacc bend lacc sad b modnotzero lacc abs sad lacc rpt subc * sfr * sfr * sfr sad lacc bend lacc neg modzero sad cospos lacc bend lacc sad b modnotzero 1 lacc abs sad lacc rpt subc * sfr * sfr

psiR_est ;Acc=psiR_est modnotzero,NEQ #0 tmp modzero ;If rotor flux module o 0 psiRal_estl ;Acc=psiRal_estl a comp of the rotor flux in 1.15 format ;Acc=abs(siRal_estl), unsigned numbers division tmp ;tmp=abs(psiRal__est 1) tmp, 15 ;store abs(psiRal_estl) in high side of Acc #15 psiR_estl ;AccL=psiRal__estl/psiR__estl, res in 1.15 format

cosTeta_est psiRal_estl cospos,GT cosTeta_est

;three right shifts > division result in 4.12 format ;store 1.15 res (=psiRaLestl/psiR_estl) in cosTeta_est

;If psiRal_estl<0 then cosTeta__est<0

cosTeta_est psiR_est ;cosTeta_est=psiRal_est 1/psiR_est 1, 4.12 format modnotzero 1,NEQ #0 tmp modzerol ;If rotor flux module o 0 psiRbe_estl ;Acc=psiRbe_est 1 b comp of the rotor flux in 1.15 format ;Acc=abs(psiRbe_est 1), unsigned numbers division tmp ;tmp=abs(psiRbe_est 1) tmp,15 ;store abs(psiRbe_estl) in high side o f Acc #15 psiR_estl ;AccL=psiRbe_est 1/psiR_est 1, res in 1.15 format

107

sfr sacl lacc bend lacc neg modzerol sad sinpos

*

sinTeta__est psiRbe__estl sinpos,GT sinTeta est

;three right shifts > division result in 4.12 format ;store 1.15 res (=psiRbe_estl/psiR_estl) in sinTeta_est

;If psiRbe_estl<0 then sinTeta_est<0

sinTeta_est

;sinTeta_est=psiRbe_estl/psiR_estl, 4.12 format

*******************************

* END divisions ret

*

*******************************

r-

108

