Ryerson University

Digital Commons @ Ryerson
Theses and dissertations

1-1-2011

RFID security protocols simulation and prototyping
Xiaohui Yu
Ryerson University

Follow this and additional works at: http://digitalcommons.ryerson.ca/dissertations Part of the Computer Engineering Commons Recommended Citation
Yu, Xiaohui, "RFID security protocols simulation and prototyping" (2011). Theses and dissertations. Paper 675.

This Thesis is brought to you for free and open access by Digital Commons @ Ryerson. It has been accepted for inclusion in Theses and dissertations by an authorized administrator of Digital Commons @ Ryerson. For more information, please contact bcameron@ryerson.ca.

RFID SECURITY PROTOCOLS SIMULATION AND PROTOTYPING
by

Xiaohui Yu
B. Eng, South China University of Technology, China, 1993

A thesis presented to Ryerson University in partial fulfillment of the requirements for the degree of Master of Applied Science in the Program of Electrical and Computer Engineering

Toronto, Ontario, Canada, 2011 © Xiaohui Yu, 2011

Author's Declaration
I hereby declare that I am the sole author of this thesis or dissertation.

I authorize Ryerson University to lend this thesis or dissertation to other institutions or individuals for the purpose of scholarly research.

I further authorize Ryerson University to reproduce this thesis or dissertation by photocopying or by other means, in total or in part, at the request of other institutions or individuals for the purpose of scholarly research.

ii

Abstract
RFID Security Protocols Simulation and Prototyping
©Xiaohui Yu, 2011 Master of Applied Science Electrical and Computer Engineering Ryerson University

As Radio Frequency Identification (RFID) technology achieves commercial success, its privacy and security issues are becoming a barrier to limit its potential for future state of the art applications. In this report, we present an investigation of the past and current research related to RFID security algorithms and protocols for product authentication. We also present a novel RFID security protocol based on eXtended Tiny Encryption Algorithm (XTEA). Analysis of the security and privacy level of our proposed protocol is performed using SystemC based modeling and different attack models are simulated to show that the protocol is robust and safe against major attacks. Furthermore, to evaluate the functionality and workability of the protocol in real application, prototypes of these attack models are implemented on FPGA platform. We also compare our proposed protocol technique with similar protocols presented in the near past that also use symmetric key algorithms to verify and demostrate main advantages of our protocol in terms of security and performance.

iii

Acknowledgements
First and foremost I want to greatly thank my supervisor Dr. Gul N. Khan for his supervision and guidance throughout my research. His inspiration and resource has made this work exciting and fruitaful. His direction allowed me to consentrate on the goal without straying away from it. I highly appreciate his contributions of time, ideas and invaluable feedbacks. Without his patience and enthusiasm, I definately could not have made such a progress.

I would also like to express my innermost gratitude to my superisor Dr. Fei Yuan for his heartfelt support ever since the beginning of my graduate study. I am deeply grateful to him for allowing me to achieve further goals in this program. His considerate help and advice strongly encouraged me at critical moments in this work and his spirit of integrity and commitment greatly motivated me throughout my graduate study.

My time in the Microsystems Research lab was made enjoyable due to a group of labmates that has become a part of my life. My knowledge definately was enriched by the warm discussion and information sharing among group members. I want to sincerely thank all of them for their help when I encountered difficulty and needed their support.

My special thanks go to all my family members. Without their love and understanding, this work could never have been completed. I feel proud to have their strong support beside me whenever I need strength to move forward. Their happiness and joy is the best reward to me.

iv

Table of Contents
1. Introduction
1.1 Background 1.2 The RFID Security 1.3 Security and Authentication Approaches 1.4 Motivation 1.5 Objective 1 1 5 6 7 8 9 10 10 11 12 15 16 17 18 22 24 26

1.6 Contribution of This Work

2.

RFID Security and Encryption Techniques
2.1 RFID Security Attacks 2.2 Cryptographic Algorithms 2.2.1 Unkeyed Algorithms 2.2.2 Symmetric Key Algorithms 2.2.3 Asymmetric Key Algorithms 2.3 Symmetric Key Encryption and Decryption Algorithms 2.3.1 Advanced Encryption Standard 2.3.2 Tiny Encryption Algorithm 2.3.3 Extended Tiny Encryption Algorithm 2.4 Related Works of RFID Security Protocols

v

3.

Novel RFID Authentication Key Management Protocol
3.1 System Assumptions 3.2 Robust RFID Authentication Key Management Protocol Design 3.3 Security Analysis

37 37 38 41 44 44 47 49 52 54 55 58 58 59 61 64 67 70 73 73 78 78 82

4.

Modeling and Simulation
4.1 Simulation of Protocol Using SystemC 4.2 Cloning Attack Model 4.3 Replay Attack Model 4.4 Man-in-the-Middle Attack Model 4.5 4.6 Denial-of-Service Attack Model Active Scanning Attack Model

5.

Protocol Analysis by Prototyping
5.1 RFID Security Protocol Experimental Analysis System 5.2 The Active Scanning Attack Model 5.3 The Cloning Attack Model 5.4 The Replay Attack Model 5.5 The Denial-of-Service Attack Model 5.6 The Man-in-the-Middle Attack Model

6.

Performance and Security Analysis
6.1 Security Level Analysis 6.2 Performance Analysis 6.2.1 Code Size 6.2.2 Communication Cost

vi

6.2.3 Number of Clock Cycles 6.2.4 Cipher 6.2.5 Scalability

83 91 93 95 98

7. Reference

Conclusion and Future Works

vii

List of Tables
2.1 2.2 5.1 5.2 5.3 5.4 5.5 6.1 6.2 6.3 6.4 6.5 6.6 6.7 6.8 6.9 Notation used in Toiruul and Lee's Protocol Notation used in Kim et al.'s Protocol Active Scanning Attack Messages Exchanged Cloning Attack Messages Exchanged Replay Attack Messages Exchanged Denial-of-Service Attack Messages Exchanged Man-in-the-Middle Attack Messages Exchanged Security Level Comparison Code Size Comparison Communication Cost Comparison Timestamp Difference Measured in Our Protocol Timestamp Difference Measured in Toiruul and Lee's Protocol Timestamp Difference Measured in Kim et al.'s Protocol Number of Clock Cycles Comparison Cipher Usage Comparison Scalability Analysis 31 34 61 63 66 69 72 77 81 82 85 87 89 90 91 94

viii

List of Figures
1.1 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 2.10 2.11 2.12 2.13 2.14 2.15 3.1 3.2 3.3 4.1 Basic Components of a RFID System Symmetric Key Algorithm Asymmetric Key Algorithm AES Encryption AddRoundKey Operation S-Box Operation ShiftRows Operation AES Decryption One Cycle of Tiny Encryption Algorithm One Cycle of eXtended Tiny Encryption Algorithm Hash-Locking Protocol Randomized Hash-Locking Protocol Hash-chain Protocol Improved Security Solution Toiruul and Lee's Protocol Kim et al.'s Protocol Novel XTEA Based RFID Security Protocol Key Update Message Format Key Update Acknowledgement Format SystemC Model of Proposed Protocol 2 15 17 19 20 20 21 22 24 26 27 27 28 29 32 35 38 39 40 45

ix

4.2 4.3 4.4 4.5 4.6 4.7 4.8 4.9 4.10 4.11 4.12 4.13 4.14 5.1 5.2 5.3 5.4 5.5 5.6 5.7 5.8 5.9 5.10

State Diagram of the Reader State Diagram of the Tag SystemC Modeling and Simulation of the Proposed Protocol Cloning Attack Model Cloning Attack Model Simulation Replay Attack Model Replay Attack Model Simulation Man-in-the-Middle Attack Model Man-in-the-Middle Attack Model Simulation Denial-of-Service Attack Model Denial-of-Service Attack Model Simulation Active Scanning Attack Model Active Scanning Attack Model Simulation Active Scanning Attack Model Implementation using Nios-II System Active Scanning Attacker Module Cloning Attack Model Implementation using Nios-II System Reader Module for the Cloning Attack Model Replay Attack Model Implementation using Nios-II System Attacker Module for the Replay Attack Model Denial-of-Service Attack Model Implementation using Nios-II System Attacker Module for the Denial-of-Service Attack Model Man-in-the-Middle Attack Model Implementation using Nios-II System Attacker Module for the Man-in-the-Middle Attack Model

45 46 47 48 49 50 51 52 53 54 55 56 56 59 60 62 63 64 65 67 68 70 71

x

6.1 6.2 6.3 6.4 6.5 6.6 6.7 6.8 6.9 6.10 6.11 6.12 6.13

Toiruul and Lee's protocol Simulation Simulation of Denial-of-Service Attack in Toiruul and Lee's Protocol Simulation of Denial-of-Service Attack in Kim et al.'s Protocol Nios-II System with Reader and Tag CPUs Compilation of the Reader Code Compilation of the Tag Code Reader System with Timestamp Timer Timestamp Difference Measured in our Protocol Timestamp Difference in Our Protocol Timestamp Difference Measured in Toiruul and Lee's Protocol Timestamp Difference in Toiruul and Lee's Protocol Timestamp Difference Measured in Kim et al.'s Protocol Timestamp Difference in Kim et al.'s Protocol

74 75 76 79 80 81 83 84 86 87 88 89 90

xi

Chapter 1
Introduction
1.1 Background
The "identification friend-or-foe" (IFF) cryptographic system for military aircraft command and control used during the second world war II is commonly regarded as the first Radio Frequency Identification (RFID) application [1]. However, the first patent of modern RFID transponder was submitted by Cardullo and Parks and published in 1973 [2]. The initial device was passive, powered by the interrogating signal and with a memory of 16 bits.

The popularity of this technology has been grown tremendously during recent years and nowadays, RFID is widely used and can be found almost everywhere. RFID systems are deployed widely in many applications including automation, manufacturing, logistics control and asset tracking. The fundamental trend of ubiquitous computing is to embed tiny advanced electronic device into the environment and make data processing automatic. As compared with other automatic data identification techniques, RFID enjoys numerous advantages such as longer reading range, larger storage capacity, higher data throughput, more rewritable capability and less human intervention [3]. Its support of multiple reading and non-line-of-sight data capture makes it useful in many applications. Even when working in adverse and harsh environments, tags are less sensitive to ambient conditions and produce robust and reliable performance.

1

A typical RFID system is shown in the Figure 1.1.

Figure 1.1 Basic Components of a RFID System (Courtesy www.rfid-handbook.de )

Every RFID application contains three basic components: tag (transponder), reader, and backend database application or server. Because RFID systems radiate electromagnetic waves, other radio services might be disrupted or impaired by their operation if the frequency and power are not controlled properly. Therefore, it is only possible to use special frequency ranges that are reserved for industrial, scientific or medical applications or for short range devices. They are classified worldwide as Industrial-Scientific-Medical (ISM) frequency ranges and they can also be utilized in RFID applications [4]. Tags can be classified into two categories: the active and the passive [5]. Active tags must be connected to a powered infrastructure or use energy stored in an integrated battery, while the passive ones obtain power from readers. In terms of passive tag design, there are two fundamentally different methods to transfer power from the reader to the tag: magnetic induction and electromagnetic wave capture. Generally, active tags are more expensive due to the requirement of extra power source.

2

Each tag has a unique number that is often called the tag identification (TID). When the reader queries the tag, the tag responds with its identification number to the reader and then the reader forwards it to the back-end server. If the TID is verified, the back-end server processes the data and notifies the reader if the reading process succeeds or fails.

As RFID technology starts to achieve more commercial success, its security and privacy issues are becoming major concerns to the public and might become a great obstacle for its future development if these risks are not addressed properly. After all, readers have to communicate with tags through an unsecured radio channel, which is vulnerable to different kinds of attacks. A strong attacker is capable of intercepting, recording, analyzing, blocking and modifying the signals over the air. The wide deployment of RFID tags also implies that using this technology might bring unintended risks, because unauthorized data collection may happen.

Currently, a number of standards for RFID systems coexist. Most important standards include ISO 11784-5 for animal identification, ISO 15693 for vicinity card and ISO14443 for high-end RFID tags used as contact-less smartcards. EPC Global is a joint venture between European Article Number (EAN) international in Europe and Uniform Commercial Code (UCC) in USA, and currently it is responsible for the standardization of present barcode systems. The organization proposed electronic product code (EPC) Class-1 Generation-2 (C1G2) standard tags to replace or complement the existing barcode technology [6]. Normally, RFID tags have to be low-cost and highly efficient. It is estimated that the total cost per tag should not be more than five cents [7]. However, very limited security features can be deployed on a C1G2 tag because it only supports functions used in passive tags such as anti-collision, 16-bit cyclic redundancy code (CRC) checksum, 10-bit pseudo-random number generator (PRNG), and a simple kill command

3

to ensure user privacy [8]. If a reader wishes to permanently disable a tag, it must send a kill command to the tag and prove its legitimacy via a 32-bit PIN number. Although this simple approach solves the privacy issue so that the user is not prone to be tracked anymore, the benefit of using RFID to update and analyze data is lost.

To find better solutions, numerous RFID security authentication proposals have been put forwarded and hundreds of papers have been published during recent years, but designing a good protocol to meet the requirements of a secure RFID system still remains challenging. An essential factor that causes the difficulty is the dynamic range of technologies RFID combines with, while the other reason is the wide area of its application. Juels's work has provided an indepth and valuable analysis of this reality [7].

Active tags have more power source and storage memory than passive ones and therefore additional privacy features can be easily implemented on them to achieve strong security level. Unfortunately, due to the requirements of lower cost and less maintenance effort, most RFID tags are still passive nowadays and come with extremely limited computational resource and memory space. As a result, to achieve the desired level of security, any practical design of RFID protocol has to take into account the constraints and balance between the level of security, cost and performance.

4

1.2 The RFID Security
There are a number of security concerns in communication systems. Manfred and others summarize that a secure communication system should achieve following objectives [9]:

i) Confidentiality: Information is unreadable for adversaries. Only authorized party is able to interpret the information. ii) Authentication: A party is able to be sure that the information received is from the source it is claimed to be. iii) Integrity: It is assured that the message is not modified after being transmitted. iv) Non-Repudiation: It can prove that the sender has actually sent out the message and the receiver has actually received the message. v) Access Control: It refers to the capability to restrict a system and control the access to it. vi) Availability: It means that whenever it is needed, the system is available. The system is guarded from loss of service and reduction in availability.

Since there is a lack of categorization of security level, Schechter proposed the concept of Cost To Break (CTB) as the measurement of security level [10]. He suggests a cryptographer should estimate the cost for an adversary to break a system by purchasing the latest and the cheapest tools and using the best known techniques. As an example, a system that takes an adversary not less than $1000 to break is secure enough to protect an item of $100 in value. In addition, another matrix of security level in a system is what punishment an attacker will get if it is caught by the security mechanism, and how likely hacking activities can be detected [11]. Apparently, more stringent punishment makes intruders more hesitant to launch attacks.

5

In order to define the concept of secure and privacy, A. Juels suggests that a formal security model that characterizes the capabilities of potential adversaries should be constructed [7]. As an example to compare with, in a security model for the Internet an adversary can have access to a server at any time, because the server have to respond to the queries coming from around the world all the time. On the other hand, around-the-clock access by attackers to RFID tags is an assumption that is too strong. An attacker has to come to a tag's proximity to transmit and receive messages and thus it is only a sporadic event. In another work, a "minimalist" security model is proposed such that an adversary comes into scanning range of a tag on a limited rate basis [12]. In the model, there is a cap on the number of times that an attacker may scan a real tag and impersonate a valid reader. Once the limit is reached, the tag should continue to interact with a legitimate reader.

1.3 Security and Authentication Approaches
RFID technology is very helpful in authenticating genuine products. Lehtonen et al. define authentication as "Product authentication = Identification + Verification of the Claimed Identity" [13]. There are many different ways to achieve authentication using RFID technology. In another work, Lehtonen et al. classify in details the approaches to authenticate RFID-based product [14]. Product authentication can be based on the authentication factors of what the product is (objectspecific features-based authentication), what the product has (tag authentication) and where the product is (location-based authentication).

The object-specific features based authentication approach was proposed by Nochta et al. and their proposal is to make products hard to be cloned [15]. In this approach, the information about physical or chemical features which are unique to a particular product (such as weight, electric

6

resistance, geometrics, and a serial number printed on the product itself) are stored on its tag. However, the cost of checking each product is generally very high.

Tag authentication approach takes advantages of tag security features that are hard to be cloned. General method is that a reader, through a challenge-response protocol, checks if its tag knows a secret shared by the authentication database in the back-end server. Normally, the secret should not be revealed in plain messages so that attackers may not be able to learn the secret.

The third approach to authenticate products is based on their locations. In such a system, the product carries only an identifier, whereas the back-end server registers all the information about the locations of genuine products. If the track and trace records show that a genuine product is at one place and in another place another product with the same identifier is found, it can be concluded that the second product is a fake one. Such an approach put the complexity of the system into the back-end server.

So far, the second approach appears to be the most economic way to enforce security in RFID systems. How to use robust authentication protocols to protect critical messages has drawn attention from researchers. As technologies are evolving and both the security systems and the potential adversaries are becoming more sophisticated, designing and implementing strong RFID authentication schemes will continue to be dynamic and challenging.

1.4 Motivation
Although, numerous RFID security authentication proposals have been put forward recently, very few of them address the security issues successfully and provide strong security level. A basic assumption made in the past works is that strong encryption algorithms such as symmetric

7

key ciphers are beyond considerations for passive tags. For example, in Juels' early work, it is concluded that a basic passive tag cannot contain Advanced Encryption Standard (AES) algorithm, which is a symmetric key cipher [7]. However, a number of recent works have already presented efficient implementation of AES on the latest Complementary Metal Oxide Semiconductor (CMOS) technology [36, 51 and 52]. As CMOS technology continues to improve, symmetric key ciphers will become more and more common in robust RFID security solutions. However, how the security keys should be managed and handled safely and efficiently in the context of limited tag hardware resource still need more investigation and results should be proved and verified with experimental analysis and performance evaluation.

1.5 Objective
Although there are many considerations in a practical RFID security system, the practical requirements of any RFID protocol fall into only two basic categories:

i) Strong security level ii) High performance level.

In this work, we will select a lightweight symmetric key algorithm suitable for the passive RFID application to provide desired security level. Based on that, we propose a protocol in which messages are securely handled so that hackers cannot obtain secrets easily. Furthermore, secrets must be dynamically updated as it is not safe to assume that secrets can never be disclosed.

Instead of relying only on theoretical analysis, the practical approach in this work will provide experimental analysis on simulation and prototyping. In order to demonstrate the advantages of

8

our proposal, security and performance levels of our protocol must be compared with similar works that also use symmetric key algorithms.

1.6 Contribution of This Work
In this work, we propose a novel RFID security key management protocol based on symmetric key algorithm eXtended Tiny Encryption Algorithm (XTEA). We summarize our contributions as follows:

i) First of all, we analyze related works regarding RFID security algorithms and protocols and the issues of existing solutions. We review some recent development in RFID hardware resource for security solutions. ii) Then, we propose a novel RFID authentication key management protocol based on XTEA. Key management is handled efficiently so that one sub-key is dynamically updated in every session. iii) The proposed protocol is analyzed using SystemC based modeling and we present the simulation and modeling results of different types of attacks on the protocol to evaluate its security and privacy level. iv) To evaluate the functionality and workability in real application, prototypes of these models are implemented on Altera Field-Programmable Gate Array (FPGA) platform using multiprocessor architecture.

9

Chapter 2
RFID Security and Encryption Techniques
In the following sections, we discuss those research efforts that have inspired our work. First of all, we investigate different types of attacks that may happen in a RFID system. A look into the cryptographic primitives that can be applied in RFID application will follow. Furthermore, we will discuss some lightweight symmetric key algorithms proposed to be used in RFID systems. Finally, the last portion of this chapter also reviews and analyzes some related RFID protocols.

2.1 RFID Security Attacks
As potential adversaries can attack a RFID system in many different ways, a secure protocol should prevent following attacks [9]:

i) Active Scanning Attack: An adversary actively queries a genuine tag to get critical information without the authorization of tag's owner.

ii) Cloning Attack: Cloning attack means the duplication of security features in a system such that an attacker is likely to pass authentication inspection.

iii) Replay Attack: An attacker records the response of a tag and uses it as the message to replay when it is queried, though the message itself does not reveal the critical secrets of the tag.

iv) Man-in-the-middle Attack: It is a form of attack where the attacker acts like a reader to a tag as well as a tag to a reader.

10

v) Denial-of-service Attack: It is a type of attack caused by adversary to block the message exchange between the reader and the tag. The purpose of doing this is to desynchronize the reader and its tag.

vi) Forward Security: Assuming that all the secrets of a tag are compromised by an adversary at present, the security of past sessions is still guaranteed.

vii) Backward Security: Assuming that all the secrets of a tag are compromised by an adversary at present, backward security protects the security of future sessions.

2.2 Cryptographic Algorithms
To achieve high level security and prevent the threats as mentioned above, appropriate cryptographic algorithms must be applied in a communication system. If a series of algorithms must be used in a well-defined way, it is referred to as a protocol [9]. A protocol consists of the cryptographic algorithms that make original messages unreadable to adversaries and the process of how the messages are exchanged between different parties. Essentially, these two factors are equally important in a security solution.

Cryptographic algorithms are classified as unkeyed algorithms, symmetric key algorithms and asymmetric key algorithms [9]. Unkeyed algorithms are not based on any keys in their operations. Symmetric key algorithms use the same key for encryption and decryption, whereas asymmetric key algorithms use a public key for encryption and a private key for decryption.

11

2.2.1 Unkeyed Algorithms
Unkeyed algorithms can be briefly separated into two categories: hash functions and random number generators.

A hash function is a computationally efficient function y = h(x) with the following two properties [16]:

i) Compression ­ The hash function maps a string of arbitrary length to a sting of fixed length. ii) Ease of computation ­ Given a hash function h(x) and an input x, it is easy to compute h(x).

For a good hash function to be used in cryptographic tools, a few requirements have to be satisfied. Firstly, the hash function must be a one way function and secondly, the function must be collision resistant. The first condition implies that there is no simple way and is computationally infeasible to reverse a good hash function. Since the number of input for the function is infinite while the output length is fixed, collision at the output is unavoidable. However, there should not be any simple method to find a pair of input x1 and x2 such that h(x1) = h(x2). Practically, the function should be a random mapping, which implies that distinguishing a hash function from a random mapping is computationally infeasible. Hash functions are very important primitives in cryptography. They are used when fixed length output is required instead of arbitrary length results.

Unkeyed hash functions are often called Modification Detection Codes (MDC) because of their capability to detect whether an original message is altered. Well-known MDCs include MessageDigest Algorithm 5 (MD5) and Secure Hash Algorithm 1 (SHA-1). MD5 is designed by Ron Rivest in 1992 to replace the earlier design of Message-Digest Algorithm 4 (MD4) [17]. It is

12

simple to implement and provides 128-bit message digest of an arbitrary length input. It is intended for applications where a large file must be compressed. However, it has been shown that MD5 is not as collision resistant as it is claimed to be [18]. Therefore, it is no longer secure enough to be applied in protocols, such as the Secure Socket Layer (SSL) protocol for communications over Internet. SHA-1 is designed by the National Security Agency (NSA) and published by the National Institute of Standards and Technology (NIST). SHA-1 is very similar to its predecessor Secure Hash Algorithm 0 (SHA-0), but it corrects a significant error found in SHA-0 that collision can be identified by using two differing 2048 bit files. It is the most widely used among the existing SHA hash functions. However, Wang et al. found its security flaws and attacks were announced [19]. It is shown in their work that collisions of SHA-1 can be found with complexity less than 269 hash operations on the full 80 step SHA-1.

NIST published four additional hash functions in SHA-2 family, named after their digest length in bits, SHA-224, SHA-256, SHA-384, and SHA-512. Collectively these four algorithms are called SHA-2. The attacks found in SHA-1 are not extended to SHA-2. A new standard, specifically SHA-3 is currently under development. An NIST held public competition is underway and the new standard for SHA-3 is expected to be announced in 2012 [20]. Finding a good hash function is a challenging and on-going research area.

Another important type of unkeyed algorithms in cryptography is random number generators. Ideal source of random number should be based on physical means similar to coin flipping and dice rolling. Most random number generators are based on software algorithm. Since pure software algorithms are deterministic, they are not completely random. Therefore, these random number generators are called pseudo-random number generators [9].

13

Physical Unclonable Function (PUF) is another type of random number generators. A PUF is a function embedded in a physical structure that is easy to evaluate but hard to characterize. The first PUF device is invented by Naccache and Fremanteau [21]. Ranasinghe et al. presented an interesting design based on metastability and thermal noise and a PUF random number generator circuit was implemented using CMOS 0.18 µm technology [22]. It is proved that true random number source based on hardware method is feasible on standard CMOS technology. Recent literatures mostly focus on four types of PUF design [23]:

i) Ring Oscillator based PUFs ii) Arbiter PUFs iii) Memory based PUFs iv) Glitch Counter-based PUFs

Unkeyed algorithms are important cryptography tools and are widely used in RFID security systems. As compared to symmetric key algorithms and asymmetric key algorithms, they require less hardware resource for implementation.

14

2.2.2 Symmetric Key Algorithms
Symmetric key algorithm is a system in which the sender and the receiver of a message share a common private key for encryption and decryption. A system based on this type of algorithms is described in Figure 2.1.

Figure 2.1 Symmetric Key Algorithm

In this cryptographic system, a sender A intends to transmit a confidential message to a receiver B through an unsecured channel without allowing any unauthorized party, such as an attacker, to understand the meaning. In order to achieve this goal, A and B agree to use a secret key for encryption and decryption. The private key has to be distributed to A and B through a secured channel. A uses an encryption algorithm to encrypt the message using the private key. Although the message is unreadable to adversaries, B is able to decrypt the message using the same private key. Symmetric key algorithms are simple and fast, but they have a drawback that the two parties must exchange the key in a secure way. As for a good symmetric key algorithm, it is computationally infeasible to recover the cipher text without knowing the key.

15

Symmetric key algorithms can be divided into block ciphers and stream ciphers. Block ciphers divides the message into fixed size blocks. Each block is transformed into a block of cipher text of the same length. The fixed length of the block is called the block size [9]. Decryption is performed using the same secret key. Typical block ciphers include Data Encryption Standard (DES), Advanced Encryption Standard (AES), Tiny Encryption Algorithm (TEA) and eXtended Tiny Encryption Algorithm (XTEA) etc. Unlike block ciphers, stream ciphers operate on smaller units of data, such as bits [16]. A stream cipher generates what is called a keystream (a stream of random bits used as a key). Encryption is performed using the keystream to combine with the information that the sender needs to transmit. One example of stream cipher is Rivest Cipher 4 (RC4), which is designed by Rivest [24]. It is widely used in many protocols, such as Secure Socket Layer (SSL) and TLS (Transport Layer Security).

2.2.3Asymmetric Key Algorithms
Asymmetric key algorithms also referred to as public-key encryption algorithms assume that there exists a key source for a sender to obtain an authentic copy of the receiver's public key [16]. It is also assumed that the receiver owns a private key which is abstained in a secure way. For a receiver, its public and private keys are normally different and not related. A system based on asymmetric key algorithm is shown in Figure 2.2. When A needs to send a message to B, it has to obtain B's public key from the key source at first. Then the message is encrypted using the public key and is sent to B. Upon receiving the message, B decrypts it using its private key. Without knowing the private key, an adversary is not able to decrypt the message sent to B

16

through the communication channel.

Despite the fact that the public key is available to

everyone, it cannot be utilized for decryption.

Figure 2.2 Asymmetric Key Algorithm

There are many techniques by which authentic public keys are distributed, such as exchanging keys over a trusted channel, using a trusted public file, using an on-line trusted server or using an off-line server and certificates. Public-key encryption schemes normally are substantially slower than symmetric key encryption algorithms [16]. Therefore, they are most commonly used to transport keys subsequently used for bulk data encryption by symmetric algorithms or to encrypt small data items such as credit card numbers or PIN number. Major examples of asymmetric key algorithms include Data Security Standard (DSS) and Rivest-Shamir-Adelman (RSA).

2.3 Symmetric Key Encryption and Decryption Algorithms
In the past, it is generally believed that symmetrical key algorithms are very power consuming, thus not suitable for traditional RFID technology. However, with the improvement of CMOS technologies, some lightweight symmetrical key algorithms have shown great potentials to be implemented in next generation passive tags.

17

2.3.1 Advanced Encryption Standard
Advanced Encryption Standard (AES) is a symmetric key encryption and decryption algorithm that attracts a great deal of attention in RFID applications. It was first published by the National Institute of Standards and Technology (NIST) in 2001 to replace the Data Encryption Standard (DES) [25]. The algorithm was selected among fifteen qualifying candidates based on their security, performance and algorithm characteristics. The winner algorithm is called Rijndael designed by Daemen and Rijmen [26]. It is a symmetric cipher that can process 128-bit data blocks, using cipher keys with lengths of 128, 192, and 256 bits.

Figure 2.3 shows the encryption process of AES algorithm. Generally, there are four major operations involved (AddRoundKey, SubBytes, ShiftRows and MixColumns). All the operations in the block diagram are performed on a two-dimensional array of bytes that is called state. A state can be regarded as a rectangular array of bytes consisting of four rows and a number of columns defined by the block size in bytes divided by four. For example, a 128-bit block can be depicted as a state of four rows by four columns. Each round of operation is based on a round key derived from the encryption key. The number of rounds is dependent on the key size. For AES-128, the key length is 128-bits and the number of rounds is 10. The number of rounds for AES-192 and AES-256 are 12 and 14 respectively.

18

Figure 2.3 AES Encryption

AddRoundKey operation combines a 128-bit state with a 128-bit round key using exclusive-or operation. The operation of this stage is described in Figure 2.4, where the input state is A and the output state is B. State B is obtained by exclusive-oring corresponding bytes in the state A and the round key K that are derived from the cipher key using a key expansion routine known as Rijndael's key schedule.

19

Figure 2.4 AddRoundKey Operation SubBytes is an operation that substitutes each byte of a state. It is non-linear and sometimes the transformation is called S-Box. It is often implemented as a look-up table. Figure 2.5 illustrates the effect on the state.

Figure 2.5 S-Box Operation

20

ShiftRows is a cyclic shift operation of the bytes in the rows. The actual value of the offset is equal to the row index. For example, the first row is not rotated but the last row is rotated three bytes to the left. The impact to the state is illustrated in Figure 2.6.

Figure 2.6 ShiftRows Operation MixColumns transforms columns of the input state using matrix multiplication. Following matrix is used in AES-128 algorithm and each column in the output state is obtained by multiplying the matrix with the corresponding column in the original state. The computation is performed such that each column is treated as a polynomial over GF (2 8) and is then multiplied modulo x4 + 1 with a fixed polynomial 3x3 + x2 + x + 2.

Because all the operations in the algorithm are invertible, decryption is possible. The decryption process is the reverse of the encryption also consisting of four major operations, which are

21

AddRoundKey, InvShiftRows, InvSubbytes and InvMixColumns respectively. The decryption algorithm is shown as Figure 2.7.

Figure 2.7 AES Decryption

2.3.2 Tiny Encryption Algorithm
Tiny Encryption Algorithm (TEA) family algorithms belong to symmetric key category in cryptography and became of interest in RFID security solutions during recent years. TEA was proposed by Roger Needham and David Wheeler in 1994 [27]. Their work was to create a Feistel itineration based routine using a large number of rounds rather than complicated and memoryconsuming approaches.

22

The Tiny Encryption Algorithm is believed to be one of the fastest and most efficient cryptographic algorithms. Tiny Encryption Algorithm is a Feistel cipher that uses only XOR, ADD and SHIFT operations to provide Shannon's properties of diffusion and confusion necessary for a secure block cipher without the need for Permutation box (P-box) and Substitution box (S-box). S-box is a non-linear operation, and is typically keyless. It can be applied in an intermediate stage of an algorithm. In cryptography, P-box is used to perform bitshuffling across S-boxes inputs. Tiny Encryption Algorithm operates on a 64-bit data block using a 128-bit key. The C language implementation of encoding and decoding could be expressed as follows: void code(long* v, long* k) { unsigned long y=v[0],z=v[1], sum=0, delta=0x9e3779b9, /* a key schedule n=32 ; while (n-->0) { /* basic cycle start */ sum += delta ; y += ((z<<4)+k[0]) ^ (z+sum) ^ z += ((y<<4)+k[2]) ^ (y+sum) ^ } /* end cycle */ v[0]=y ; v[1]=z ; }

/* set up */ constant */

((z>>5)+k[1]) ; ((y>>5)+k[3]) ;

void decode(long* v,long* k) { unsigned long n=32, sum, y=v[0], z=v[1], delta=0x9e3779b9 ; sum=delta<<5 ; while (n-->0) {/* start cycle */ z-= ((y<<4)+k[2]) ^ (y+sum) ^ ((y>>5)+k[3]) ; y-= ((z<<4)+k[0]) ^ (z+sum) ^ ((z>>5)+k[1]) ; sum-=delta ; }/* end cycle */ v[0]=y ; v[1]=z ; }
23

The code and decode routines use 32 bit words in operations. The inputs of the routines are two words for data, which is 64 bits totally. There are four words for keys, thus the total size of the key is 128-bits. The routine uses XOR, ADD and bit shift operations to provide non-linearity for encryption. One cycle of the encryption is shown in Figure 2.8.

Figure 2.8 One Cycle of Tiny Encryption Algorithm

2.3.3 Extended Tiny Encryption Algorithm
Although TEA algorithm is compact to implement for different platforms, it is reported to suffer from related key attacks and its actual key size is reduced to 126-bits [28]. In order to correct the weakness, Roger Needham and David Wheeler proposed the eXtended Tiny Encryption Algorithm (XTEA) [29]. As compared to TEA, the key scheduling has been changed and its key

24

material is introduced more slowly. Despite the adjustment that was made on the key operation, XTEA remains as compact as TEA. The reference code in C programming language is shown as follows: tean( long * v, long * k, long N) { unsigned long y=v[0], z=v[1], DELTA=0x9e3779b9 ; if (N>0) { /* coding */ unsigned long limit=DELTA*N, sum=0 ; while (sum!=limit) y+= (z<<4 ^ z>>5) + z ^ sum + k[sum&3], sum+=DELTA, z+= (y<<4 ^ y>>5) + y ^ sum + k[sum>>11 &3] ; } else { /* decoding */ unsigned long sum=DELTA*(-N) ; while (sum) z-= (y<<4 ^ y>>5) + y ^ sum + k[sum>>11 &3], sum-=DELTA, y-= (z<<4 ^ z>>5) + z ^ sum + k[sum&3] ; } v[0]=y, v[1]=z ; return; } Like TEA algorithm, the block size is two words and the key size remains four words. XTEA algorithm completes encryption and decryption in 32 Festiel cycles. The only disadvantage is that complete change diffusion is delayed by one cycle, but there is no need to change the number of cycles from 32 to 33. Figure 2.9 shows the structure of one cycle of encryption.

25

Figure 2.9 One Cycle of eXtended Tiny Encryption Algorithm

Under certain weak key assumption, a related-key rectangle attack on the first 36 rounds of XTEA has been reported [30]. The time complexity of the attack is about 2 104. 33, which is faster than exhaustive key search among the 2 110. 67 weak keys. The success probability of the attack is about 80%. It is claimed to be the best known attack on XTEA algorithm. Since XTEA uses 64 rounds, it is still considered to be a very secure cipher. TEA and XTEA are not subject to any patents and are free to use in security applications.

2.4 Related Works of RFID Protocols
An authentication protocol is a safe way to verify if a tag is genuine or not. During recent years, many researchers proposed different solutions. Sarma et al.'s early work defined a so-called Hash-based Access Control (HAC) scheme [31]. The scheme is presented in Figure 2.10.

26

Figure 2.10 Hash-Locking Protocol This scheme assumes that tag is only equipped with a hash function. When being queried, the tag sends out the hash of a random key as its metaID instead of revealing the tag ID directly. The reader forwards it to the back-end server to search the key and unlock the tag. If the key is found, it is passed to the tag. The tag hashes the key and compares it to the stored metaID. If the reader has sent the right key to the tag, the hash value of the key will match the metaID. If the values match, the tag enters un-locked state and sends the ID to reader for authentication. The protocol relies on a back-end server for authentication. However, the key, metaID and ID could be obtained by an eavesdropping adversary and therefore the tag can be cloned easily. To overcome the weakness in Hash-Locking protocol, Sarma et al. also proposed another socalled Randomized Hash-locking Protocol [31]. The scheme is presented in Figure 2.11.

Figure 2.11 Randomized Hash-Locking Protocol

27

It is assumed that the tag is equipped with a hash function and a random number generator. The tag responds to the reader queries by generating a random number R, then computing the hash value h(IDk || R). Both of them are sent back to the reader. The reader performs a brute-force search for the tag ID by calculating the hash value h(IDk || R) for each tag until it finds one value that matches the tag response. Although this protocol works well with a few tags, it is not practical for retail application where a large number of tags are deployed. Ohkubo et al. proposed a Hash-chain protocol to solve the secrecy and forward security issue [32]. The message exchange process of the protocol is shown in Figure 2.12.

Figure 2.12 Hash-chain Protocol

In this protocol, the tag ID is never revealed in plaintext. It is assumed that the tag and back-end server share an initial secret of S1 and it is equipped with two hash functions, H(x) and G(x). In the i-th protocol session, when the tag is queried, it sends out a message Ai = G(Si) to the reader. The reader forwards it to the back-end server for authentication. The back-end server maintains a list of pairs (ID, S). When receiving Ai, it checks all the existing tag secrets and computes the hash value for each of them using function G(x). If a matched value is found, the tag ID is sent to the reader. In every new session, the tag and the back-end database update the secret using H(x)

28

function to get Si+1 = H(S i). The main weakness of the protocol is that the back-end is much overloaded since it has to perform brute force search for the tag ID. Furthermore, if a malicious attacker keeps sending query to the tag, the tag will continuously update its own secret, which will make the tag desynchronized with the server. Furthermore, denial-of-service attack is another possible threat for this protocol.

An improved security solution for RFID security is proposed by Wang et al., which corrects the weaknesses found in hash lock scheme [33]. Their scheme is shown in Figure 2.13.

Figure 2.13 Improved Security Solution

In this protocol, the reader first generates a random number and sends it to the tag when querying it. The tag calculates the hash value h(IDk || R) and sends it back to the reader in response, where IDk is the tag ID. The back-end server search for an IDt where h(IDt || R) = h(IDk || R). The back-end server does not assume that the reader is legitimate and therefore generates a message to be sent to the reader by exclusive-oring the correct reader ID, the random number R and the tag ID. The reader has to generate a reply by exclusive-oring its own ID to get (R  IDk). The tag receives this message and exclusive-ors it to derive IDk. If it matches with its own ID number, the reader is authenticated. Nevertheless, the protocol shows a weakness in the last step.
29

An attacker can get the tag ID by exclusive-oring this message with R, which can be eavesdropped in the first step.

Toiruul and Lee proposed an advanced mutual authentication protocol to address three major problems: forgery of the tags, unwanted tracking of the tags, and unauthorized access to tag memory [34]. Their objective is to provide reader authentication to a tag, exhibit forgery resistance against a simple copy, and prevent the counterfeiting of RFID tags. We use notation shown in Table 2.1 to illustrate this protocol.

30

Table 2.1 Notation used in Toiruul and Lee's Protocol

Symbols T R B k1 , k2 k IDk Ek *

Notations RF tag, or transponder RF tag reader, or transceiver Back-end server, which has a database Random secret keys, shared between T and B Cryptographic key, shared between T and B Unique identification number of T, shared between T and B AES cipher using key k Operation or the value in the real T Exclusive-or



It is assumed that the tag has an AES encryption cryptographic hardware and a memory space to store the identification number IDk and two secrets, k1 and k2. Toiruul and Lee's protocol is presented in Figure 2.14. Initially each T is given two fresh random secrets, k1 and k2, and a unique identification, IDk. The database of B also stores them as the shared secrets and manages a record pair for each tag consisting of (IDk, TagID). T has an AES-128 encryption circuit while both T and B have a 128-bit cipher key k. In the first challenging step, the reader R applies a collision protocol to singularize T out of many tags. In their work, the binary tree walking protocol was suggested as an example [35]. The Reader, R receives Ek(k1  k2) from the back-

31

end server, B. Then R sends Ek(k1  k2) to query T . Ek(k1  k2) is used to authenticate the validity of R.

Figure 2.14 Toiruul and Lee's Protocol [34]

In the second stage of authentication, the tag authenticates the reader's validity. When being queried, T generates E*k (k1  k2) and checks whether the received message Ek(k1  k2) equals to E*k(k1  k2) or not. If they do not match, R is not authenticated and T will keep silent. If they match, T authenticates R and sends out Ek(k1  k2  IDk), which is the encryption of AES-128, to the reader. Then T updates its secrets k1 = k1  Ek(k2  k1) and k2 = k2  Ek(k2  k1).

32

In the third authentication stage, the reader authenticates the tag. R simply forwards Ek(k1  k2  IDk) to B and B decrypts it using cipher key k. IDk is obtained by exclusive-oring the result with k1 and k2. Then B verifies whether IDk is valid by comparing the IDk with ID*k, which is the real tag ID. The secrets, k1 and k2, and the cipher key, k are shared only between B and T. Therefore, B can detect an illegal T and discards the message. When T is authenticated, B retrieves the records corresponding to IDk and sends the real TagID to R. Then it update its secrets k1 and k2 in the same way, k1 = k1  Ek(k2  k1) and k2 = k2  Ek(k2  k1). The protocol is claimed to withstand active attacks such as the man-in-the-middle attack, the replay attack, the eavesdropping attack, and the unwanted tracking of customers.

Inspired by the efficient implementation of AES by Feldhofer et al. [36, 37], Kim et al. proposed a lightweight RFID authentication protocol using step by step symmetric key change [38]. To illustrate the protocol, we use notations in Table 2.2. In a RFID system which may consist of a server, a reader and one or multiple tags, it is assumed that the tag and back-end server can perform AES encryption and decryption operation. They are also equipped with pseudo-random number generators that can generate random numbers.

33

Table 2.2 Notation used in Kim et al.'s Protocol Symbols E( ) M PRNG Rtag Rreader Rserver || K0 K1, K2, K3 Notations Block cryptogram The mask bit of the random number Pseudo-random number generator The random number generated in the tag The random number generated in the reader The random number generated in the server Concatenation Initial symmetric key Changed symmetric key Exclusive-or The unique identifier of the tag


ID

The operation of this protocol can be divided into initialization stage and authentication stage. In the initialization stage, the tag and the server are assigned the same symmetric key (K0) in advance. The tag and the reader share the same mask bit (M) for masking the generated random number. The operation of the authentication stage can be illustrated in Figure 2.15.

34

Figure 2.15 Kim et al.'s Authentication Protocol The protocol consists of five operations. In operation one, the reader generates a random number and exclusive-ors it with M to obtain a mask variable called MOR. Then the reader sends MOR with the query to the tag. In operation two, the tag uses M to exclusive-or with MOR to obtain the random number generated by the reader. Then it is exclusive-ored with K0 to generate the new key K1 which is
35

used to encrypt R'reader || R'tag. The encrypted message is sent to the reader and then is passed to the back-end server. In the third operation, the server obtains Rreader transmitted by the reader. Then K1 is obtained by exclusive-oring it with K0. The server decrypts the message using K1 to get R'reader and R'tag. The authentication is performed by comparing R'reader with Rreader delivered from the reader. If the comparison fails, the operation exits. If it is successful, the back-end server generates the key K2, which is used to encrypt R'server || R'tag. The encrypted message is sent to the reader and is then passed to the tag.

In operation four, the tag obtains K2 by exclusive-oring K1 with Rtag. The message from the server is decrypted using K2, and R'tag and R'server is obtained. Comparing R'tag and tag's Rtag, the tag authenticates the reader. If the operation is successful, the tag generate K3 = K2  R'server. Then the tag encrypts the ID || R'server using K3, and sends it to the server.

In operation five, K3 is computed by the back-end server using its own K2 and Rserver. It is used to decrypt the message from the tag to obtain ID and R'server. If the R'server matches Rserver of its own, the response from the tag is confirmed. By searching the ID, the back-end finds the tag info and sends it to the reader. Their work is to solve the problem of using fixed key in authentication to prevent eavesdropping, replay attack and location tracking security issue. In the mutual authentication process, random numbers are generated by the server, reader and tag to make the messages different in each round.

36

Chapter 3
Novel RFID Authentication Key Management Protocol
Some previous works used hash functions because symmetric key algorithms are considered to be too resource consuming at early development of RFID, while other recent works tried to achieve more security level by using symmetric key algorithm. The objective of our proposal is to achieve mutual authentication using symmetric key algorithm. The key should be dynamically updated and the process should be initiated from the back-end server in a synchronized way to avoid possible vulnerabilities and to make tags as lightweight as possible.

3.1 System Assumptions
Previous research has shown that XTEA has great potential to be utilized in new RFID authentication protocols [42, 49], because of its low power consumption, high speed and high security level characteristics. In order to solve security and privacy issues in RFID systems, we are proposing a novel and robust authentication protocol based on XTEA algorithm. In this protocol, we assume that a tag has a 64-bit non-volatile tag ID number and 128-bit key set, which can be dynamically updated. It is also assumed that the tag has the encryption and decryption capability using XTEA algorithm. One key set consists of four 32-bit sub-keys. Each tag and the back-end server share a random secret key set at initialization. We also assume that the links between back-end server and readers are secure against attacks. This assumption is based on the fact that advanced security mechanisms can be deployed in networked RFID infrastructures.

37

3.2 Robust RFID Authentication Key Management Protocol Design
Our proposed protocol is summarized in Figure 3.1.

Figure 3.1 Novel XTEA Based RFID Authentication Key Management Protocol

38

The protocol is described as follows.

1) 2)

The reader sends a query message to read the tag. Once being queried, the tag transmits an encrypted tag ID. The encryption is carried using XTEA algorithm with current key set k0.

3) 4)

The reader forwards this message to the back-end server for authentication. The back-end server checks the database of expected response of known tags to find the

corresponding tag ID. Then the back-end server immediately generates a key update message and the corresponding acknowledgement message. The message format of key update message is shown in Figure 3.2. It consists of a field containing the last 30 bits of the tag ID, a 2-bit field indicating the number of the sub-key to be updated and a 32-bit field of new sub-key.

Figure 3.2 Key Update Message Format

The number of the sub-key and the new sub-key value are generated using random number generator, such as PUF. The total length of the message is 64 bits and it must be encrypted using the current key set k0. The encrypted message is also 64 bits in length, but the message content is unreadable for outsiders. The back-end server computes the tag response for the next query based on the new key set k1. Meanwhile, it backups the current response just in case the key update process fails for some reasons.

The back-end server also generates a key update acknowledgement message with the format shown in Figure 3.3 and it is expected to come from the tag after the key update process is
39

successful. The message is also 64-bit and is encrypted with the next key set k1. It consists of the first 32 bits of the tag ID and 32 bits of the sub-key that is to be replaced.

The server sends the tag ID, the key update message and the key update acknowledgement to the reader.

Figure 3.3 Key Update Acknowledgement Format

5)

The reader forwards the key update message to the tag. The tag decrypts the message

using the current key set k0 and it verifies the field of the last 30 bits of tag ID to see if it matches with its own. If there is a match, it will continue to extract the sub-key value and subkey number to update the key set to k1. If not, it will continue to wait for other key update message for a time window. 6) The tag generates a key update acknowledgement in the format shown in Figure 3.3 and

sends it back to the reader. It indicates that the key update operation has been successful. 7) The reader verifies if the key update acknowledgement is received. After receiving the

acknowledgement message successfully, the reader terminates the authentication process. 8) If the reader fails to receive the acknowledgement it will re-send the key update message.

The tag will respond with an acknowledgement again even if it has earlier sent it out. In the real implementation, the reader can re-send this key update message several times. If the reader is still not able to receive correct key update acknowledgement, it will send a warning to the backend server that the tag might be a fake one. If the key-update process fails due to a fake tag, the tag response record in back-end server should be reverted to the previous value.
40

3.3 Security Analysis
The key update acknowledgement message in this scheme is important, because it is essential to prove that the key is updated properly by the tag. It also indicates that the tag is a genuine one, because only the tag that possesses the correct key set is able to generate a correct acknowledgement.

A good protocol should allow for mutual authentication of the reader and its tags. In our scheme, the tag verifies if the key update message is coming from a legitimate reader by decoding the message using current key set and verifying the ID field. Only the legitimate reader can pass this verification, since the reader can not generate it by itself and it can only obtain it from the trusted back-end server. In this protocol, the only information source of authentication is kept in the back-end server. The legitimacy of a reader should be verified by the back-end server before any message is sent to the reader, which means some security mechanisms should be implemented in the networked RFID infrastructure. This is beyond the discussion of this work.

In our protocol, the tag ID and the key are never disclosed in plain messages. Unless the current key set is disclosed, the messages being exchanged are unreadable to an adversary. The key length of XTEA is 128 bits and is secure enough against any brute force hacking. Since the key is updated dynamically, guessing the key becomes more difficult.

An adversary can not just record a tag response and replay it to pass the authentication process, because the key set is updated in every new session and therefore the correct response is also changed. As the correct key update acknowledgement is also different in every session, it is even harder for an adversary to counterfeit a genuine tag. Replaying a key update message to the tag is

41

also not effective. Since the key set is changed, the tag will find the field of the first 32 bits of its tag ID does not match its own after decrypting a replayed key update message.

Denial-of-service attack is a bigger threat for RFID security system to deal with. It might desynchronize the tag and the trusted server. The acknowledgement message eliminates such a problem, because it notifies that a correct key update process is finished. In case the acknowledgement is blocked or is not received properly because of noisy environment, the reader will re-send it and the tag should response to it even if it has already updated its key and sent the acknowledgement. How many times the reader should repeat this message if it still cannot get the acknowledgement from a tag depends on the real application. On the tag side, it should stop responding with acknowledgement at some point if the key update message is received repeatedly. This is also a consideration that depends on the practical situation, and therefore we do not make any assumption in our protocol.

Prevention of tracking deals with the threat that privacy might be violated without actually identifying tag IDs. If a specific tag response can be associated with a particular item, this message could indicate the location of the item even the tag ID is not disclosed. In our protocol, the tag's response varies every time when it is queried, because the key is updated in every successful round of operation. This makes attackers unable to track the location of the tag.

Forward security means that if an attacker compromises a tag and knows all the information shared between the tag and its reader, it still cannot identify the previous responses of the tag. It is also impossible for the attackers to guess how the key has been updated previously even it manages to compromise a real tag and learns its secrets because how the key set is updated is

42

only controlled by the trusted server. Therefore, the proposed protocol meets requirements of forward security.

Since the back-end server can make the key set update process truly random, even if a tag's current key is compromised, the tag's future key set is still not predictable. In a formal security model, potential attacker cannot always be at the proximity of a tag to send and receive messages [7]. If the tag is authenticated and the key set is updated while the attacker is not close to the tag, it is impossible for the attacker to get the new key set and understand the messages between the reader and tag again. Therefore, our protocol is also able to provide backward security.

43

Chapter 4
Modeling and Simulation
In this section, we demonstrate the workability and the functionality of our protocol using SystemC modeling technique. In order to verify the security level, we model different kinds of attacks using SystemC. SystemC is a C++ library addressing the modeling of both software and hardware [39]. It supports both high level system modeling and register transfer level (RTL) modeling. However, the major advantage of using this tool in this work is to model a RFID system at a higher abstraction level rather than the RTL level.

First of all, the SystemC modeling of our protocol is explained in details in section 4.1 including the state diagram of the reader and the tag module. Section 4.2 illustrates the cloning attack model and simulation results. Following that, modeling of replay attack is also demonstrated in section 4.3. Then we will discuss man-in-the-middle, denial-of-service and active scanning attack models and their simulation results in Section 4.4, 4.5 and 4.6 respectively.

4.1 Simulation of Protocol Using SystemC
A model of our proposed protocol is implemented using SystemC which is shown in Figure 4.1. This is a simplified model and the back-end server is integrated into the reader, because it is assumed that there is only one reader and one server in this simulation. This means that the reader here is integrated with the capability of saving and retrieving tag messages like a back-end server. Figure 4.2 shows the reader protocol in a state machine diagram. The tag is also implemented as a state machine as shown in Figure 4.3.

44

Figure 4.1 SystemC Model of Proposed Protocol

Figure 4.2 State Diagram of the Reader

45

Figure 4.3 State Diagram of the Tag

The model is simulated on Sun Solaris workstation with SystemC 2.0.1 environment. The results are shown in Figure 4.4. It is observed that in every new session the tag replies with different response which is encrypted with a different key set. However, the reader can decrypt the response using the current key set. The reader generates a different key update message and the tag sends out different key update acknowledgement. The reader can identify the same tag ID in every session of the simulation, and interruption does not happen.

46

Figure 4.4 SystemC Modeling and Simulation of the Proposed Protocol

4.2 Cloning Attack Model
As described in section 2.1, a security system suffers from cloning attack if its security features can be duplicated.

47

Figure 4.5 is the protocol model constructed to simulate this attack on protocol layer. A cloning attacker module is added in the model to examine whether the attacker can duplicate the tag by eavesdropping the tag's secrets.

Figure 4.5 Cloning Attack Model

The simulation results are shown in Figure 4.6. When the attacker intercepts a message sent by the tag, the content is compared with the tag ID. If the content happens to be equal to the tag ID, the simulation code will indicate that the attacker is able to clone the tag. The simulation was run for one hour with a new session triggered in every 200 clock cycles, but we did not observe that the attack has been successful. Therefore, it verifies that the communication channel is secure against cloning attacks.

Since the key size of the XTEA algorithm is 128-bits, it is computationally infeasible for the adversary to launch a brute force attack. Therefore, the cipher is also resistant against cloning attack.

48

Figure 4.6 Cloning Attack Model Simulation

4.3 Replay Attack Model
To prove our protocol is safe against replay attack, a replay attacker module is added to our original model. The attack model is shown in Figure 4.7.

49

Figure 4.7 Replay Attack Model

In this model, an enable signal is added to both attacker and the tag modules, which allows the reader to query the tag and the attacker individually. The attacker records the tag response when it is not enabled. If the attacker is enabled while being queried, it replays the message it recorded. The simulations results of the replay attack are presented in Figure 4.8.

50

Figure 4.8 Replay Attack Model Simulation

The results show that when the reader tries to read the attacker, the attacker replays the same tag response message recorded in the last session. However, the reader finds that the attacker's reply

51

is not correct. The attacker cannot decrypt the key update information because it does not know the correct key set. Therefore, in the real world application, a counterfeit tag using the replay attack technique can be detected by the system.

4.4 Man-in-the-Middle Attack Model
Man-in-the-middle is a form of the attack where the attacker hides itself between the reader and the tag. It acts like a reader to the tag and appears like a tag to the reader. In the previous model, it is proved that the attacker cannot simply clone a real tag or deceive the reader by replying with the same tag message. In this section, we provide an analysis to examine whether a man-in-themiddle attacker can be authenticated by the tag or not. The model of man-in-the-middle attack is shown in Figure 4.9.

Figure 4.9 Man-in-the-Middle Attack Model

In this simulation, the man-in-the-middle attacker simply passes the signal received from port rx1 to tx1. When receiving the query signal from rx0, it forwards the message to the tx0 port. If the reader sends out a key update message, the attacker tries to alter it randomly and sends it to the tag. The attack is simulated, and the results are shown in Figure 4.10.
52

Figure 4.10 Man-in-the-Middle Attack Model Simulation

It is observed that in simulation number four, the attacker tries to send a false message to the tag. The tag finds that the key update message received is illegal and therefore will not send out a key update acknowledgement based on that. Furthermore, the tag cannot be desynchronized from the server because the reader re-sends the key update message and the key set is updated finally.

53

4.5 Denial-of-Service Attack Model
In the denial-of-service attack, an attacker is capable of blocking any specific communication process. In our protocol, blocking the query message in the first step or the tag reply in the second step makes the reader unable to read the tag in the first attempt, but the reader can still read the tag in the next reading operation when the RF channel is not blocked. For this reason, our analysis concentrates on the key update message in this model simulation. The purpose of the attack is to desynchronize the tag and the back-end server. We put the attacker at the downlink to block the key-update message and such a model is described in Figure 4.11.

Figure 4.11 Denial-of-Service Attack Model The simulation results are presented in Figure 4.12. When the attacker launches the denial-ofservice attack in every second session, the key update message is blocked and no signal is passed to the tag module. The reader cannot receive an update acknowledgement in an expected period, and therefore re-sends key update message at a later time. When the tag receives the key update message and it generates a key update acknowledgement. Finally, the reader and the tag are able to achieve synchronization. The simulation results show that the system is secure against denialof-service attacks.

54

Figure 4.12 Denial-of-Service Attack Model Simulation

4.6 Active Scanning Attack Model
In the active scanning attack model, the tag is isolated from the reader. An attacker can scan it continuously without authorization of the tag owner. The purpose of this attack is to retrieve useful messages from the tag. The configuration of the model is shown in Figure 4.13.

55

Figure 4.13 Active Scanning Attack Model In this simulation, the attacker selects the tag as its target and sends query messages repeatedly without giving a key update message. The results of the attack are shown as in Figure 4.14.

Figure 4.14 Active Scanning Attack Model Simulation

56

When the attacker keeps scanning the tag, the tag only responds with an encrypted message. If no other key update message is transmitted to the tag, the tag will go back to its initial state waiting for the next query. Attacker cannot get authenticated by the tag and the tag secrets are not disclosed. The simulation results prove that our scheme is safe against active scanning attacks.

57

Chapter 5
Protocol Analysis by Prototyping
5.1 RFID Authentication Protocol Experimental Analysis System
In the last chapter, the simulation of our protocol is performed using SystemC based modeling techniques. In order to analyze its workability and robustness, it will be interesting to implement our protocol in a hardware experimental platform.

Previous works on RFID protocols presented different implementation options on various platforms. Luo et al.'s work evaluated encryption algorithms in sensor nodes consisting of ATMEGA128 microcontroller and Chipcon CC1100 transceiver [40]. Chae et al. implemented RC5 algorithm on WISP UHF tag, which is a programmable battery-free tag with back-scatter communication capability [41]. Israsena synthesized TEA and XTEA encryption cores in ASIC using Mentor Graphic's LeonardoSpectrum targeting 0.35µm CMOS technology [42]. Luo et al. analyzed their proposal by implementing reader and tag modules using JAVA TCP/IP socket application and database using MySQL [43]. Gilbert proposed a variable key authentication scheme and a variable round authentication scheme with implementation applied on Altera FPGA platform. The reader module was designed as a Nios-II processor using SOPC tool and the tag module was implemented using hardware description language [44]. Borghei's hash based authentication protocol was inspired by SRAC protocol. In her implementation, the reader design was achieved on a PC console using windows application programming interface and the tag was designed as an Altera Nios-II system with smart card [45]. Angerer et al.'s work

58

proposed a flexible RFID prototyping system consisting of a RF front end, a protocol stack operating on a DSP and a signal processing module implemented on FPAG [46].

The methods used in [40, 41] require complex hardware systems, while the implementation in [42, 43] is essentially software based. Overall, we prefer a system that is implemented on a FPGA platform similar to the works in [44, 45 and 46]. As compared with other implementation schemes, FPGA environment enjoy many advantages, including low cost, time saving and flexible prototyping. In this chapter, we present the implementation of our protocol on an Altera FPGA DE2 board. A DE2 board consists of an Altera Cyclone II EP2C35F672C6 FPGA device and an EPCS16 serial configuration device as well as other components including memories, USB port, Ethernet port, VGA port, audio connectors, a number of switches and LEDs [47].

5.2 The Active Scanning Attack Model
In an active scanning attack, the tag is isolated from legitimate readers and the attacker is constantly scanning the tag without owner's authorization. Figure 5.1 shows the Nios system implementation of this model.

Figure 5.1 Active Scanning Attack Model Implementation using Nios-II System
59

The model is implemented using SOPC builder, a powerful tool available in Quartus II environment. The attacker module and the tag module are implemented as individual Nios-II processors. Figure 5.2 shows the configuration of the attacker module processor. Parallel ports are used to connect the attacker and the tag modules and allow them to communicate with each other.

Figure 5.2 Active Scanning Attacker Module In this test, we recorded the messages exchanged in the first seven sessions. The results are summarized in Table 5.1.

60

Table5.1 Active Scanning Attack Messages Exchanged Protocol Round 1 2 3 4 5 6 7 Attacker Send Message Tag Query Tag Query Tag Query Tag Query Tag Query Tag Query Tag Query Tag Response Message B57183930FE7A64B B57183930FE7A64B B57183930FE7A64B B57183930FE7A64B 0000000000000000 0000000000000000 0000000000000000

As it is observed in the test, if the tag is scanned more than four times, the tag will stop responding to further queries with the encrypted reply message. This is due to a parameter introduced for the tag for additional security considerations. If the tag is queried more than this threshold without receiving correct key update messages, it will respond with a meaningless message. In our implementation, the tag simply replies with a constant string of `0', which also serves as a warning that the tag has been attacked by active scanning attackers. The implementation verifies that this protocol is resistant to the active scanning attacks.

5.3 The Cloning Attack Model
Cloning attack happens when a reader and its tag are communicating in a channel which is insecure and attackers can intercept the messages coming from the tag and the reader. Figure 5.3 shows the Nios-II system of this model. Since there is only one UART interface connected to the reader in the configuration, we combine the function of the channel with the attacker module. In the implementation of this attack model, the reader first queries the tag in a normal operation. Then, the reader is going to check whether the message recorded by the attacker matches with

61

the secrets it currently has. If they do not match, it means our protocol is safe against cloning attack.

Figure 5.3 Cloning Attack Model Implementation using Nios-II System The reader, the attacker and the tag modules are implemented as separate Nios-II processors. The communications between these processors are established through parallel ports. In each direction, the rising signal of enable port defines exact timing that the data in the data port is ready for sampling. Figure 5.4 shows the reader modules deployed in this model. For the cloning attack test, we recorded the messages exchanged for a period of an hour with a new session started every five seconds. However, we did not observe any case of failure. The results for the first seven sessions of the protocol operation are given in Table 5.2.

62

Figure 5.4 Reader Module for the Cloning Attack Model

Table 5.2 Cloning Attack Messages Exchanged Session Number 1 2 3 4 5 6 7 Tag Response Message To Query B57183930FE7A64B AF4D7FD9DDF60A22 97E6D6FC8072E812 CF964D1BB89D2299 E06B1A8697863DA6 9F5649FB374A23EC 3A2C61372888A673 Effectiveness of Attack No No No No No No No

Tag ID 2233221221314783 2233221221314783 2233221221314783 2233221221314783 2233221221314783 2233221221314783 2233221221314783

63

As confirmed from the results, the tag replies with an encrypted message in every new session. The cloning attacker cannot obtain the secrets of tag because it does not know the key set. The implementation verifies that our protocol is resistant against cloning attacks.

5.4 The Replay Attack Model
In a replay attack, when a reader and its tags communicate via an insecure channel, an attacker can intercept the messages between the tags and the reader. Figure 5.5 shows the Nios-II system that is prototyped to model such an attack. In this implementation, the reader first queries the tag in a normal way. Then, it queries the attacker to see if the recorded message matches with the secrets it has currently. If there is no match condition, it verifies that our protocol is safe against replay attacks.

Figure 5.5 Replay Attack Model Implementation using Nios-II System

64

The reader, attacker, channel and tag modules are implemented as individual Nios-II processors. The processors are connected with each other through parallel ports so that communications between modules can happen. The attacker module is able to monitor all the messages going through the channel module. Figure 5.6 shows the attacker module created using the SOPC Builder tool.

Figure 5.6 Attacker Module for the Replay Attack Model During the protocol testing, we recorded the messages exchanged for an hour period with a new reading operation triggered every ten seconds. Then the attacker is queried after the reading is finished to verify the effectiveness of replay attack. We did not observe any case of a replay

65

attack succeeding. The results for the first seven sessions of the protocol operation are summarized in Table 5.3.

Table 5.3 Replay Attack Messages Exchanged Attacker Tag Key Set Replay Message AB47856C, 902C729A, 70BC93E4 , 247DC618 AB47856C, 902C729A 70BC93E4, DA6B4E51 7825DFCB, 902C729A 70BC93E4, DA6B4E51 7825DFCB, 9D7A9053 70BC93E4, DA6B4E51 7825DFCB, C217C338 70BC93E4, DA6B4E51 4E9221E0, C217C338 70BC93E4, DA6B4E51 792F11CF, C217C338 70BC93E4, DA6B4E51 B5718393, 0FE7A64B AF4D7FD9, DDF60A22 97E6D6FC, 8072E812 CF964D1B, B89D2299 E06B1A86, 97863DA6 9F5649FB, 374A23EC 3A2C6137, 2888A673

Session Number

Tag Response Message B5718393, 0FE7A64B AF4D7FD9, DDF60A22 97E6D6FC, 8072E812 CF964D1B, B89D2299 E06B1A86, 97863DA6 9F5649FB, 374A23EC 3A2C6137, 2888A673

Effectiveness of Attack

1

No

2

No

3

No

4

No

5

No

6

No

7

No

The prototyping results show that the tag is able to reply with an encrypted message in every new session when being queried. Furthermore, one sub-key in its key set is also updated. The replay attacker tried to impersonate a genuine tag by replaying the previous tag output, but it is not the correct response the reader expects. Therefore, the replay attacker cannot pass the authentication process. The prototyping of the replay attack model verifies that our novel protocol is safe against replay attacks.

66

5.5 The Denial-of-Service Attack Model
In the denial-of-service attack model, the communication channel between a reader and its tag can be blocked by an attacker. The configuration of this model is prototyped as shown in Figure 5.7. In the implementation of this prototype, the reader module first queries the tag module and then receives the reply from it. When the key update message arrives, the denial-of-service attacker tries to block it in attempt to desynchronize the tag and the reader. If the reader and the tag can reestablish normal operation, then it verifies our protocol is robust and safe against denial-of-service attacks.

Figure 5.7 Denial-of-Service Attack Model Implementation using Nios-II System The reader, the attacker and the tag modules are implemented as individual Nios-II processors. Using the same technique in previous models, the processors are linked to each other through

67

parallel ports. Figure 5.8 shows the Nios-II processor for the attacker module configured using SOPC Builder tool environment.

Figure 5.8 Attacker Module for the Denial-of-Service Attack Model During the protocol verification, we recorded the messages exchanged for one hour with a new reading operation triggered every ten seconds. We did not observe a case that an attack could be successful. The results for the first seven sessions are summarized in Table 5.4.

68

Table 5.4 Denial-of-Service Attack Messages Exchanged Tag Response Message To Query B5718393, 0FE7A64B AF4D7FD9, DDF60A22 97E6D6FC, 8072E812 CF964D1B, B89D2299 E06B1A86, 97863DA6 9F5649FB, 374A23EC 3A2C6137, 2888A673 Tag Key Update Message 8EA3D37C, 3F5198CA BE0B6D17, 27D8F698 70F67232, FAA7DB1A EE83D92B, 2D52F3F9 C6C69B41, 94A7E2F1 F2D1EB14, EDEE7EC1 B88CCB65, 1F511A01 Tag Key Update Message Reader Re-send 8EA3D37C, 3F5198CA BE0B6D17, 27D8F698 70F67232, FAA7DB1A EE83D92B, 2D52F3F9 C6C69B41, 94A7E2F1 F2D1EB14, EDEE7EC1 B88CCB65, 1F511A01 Tag Key Update ACK Message 2B6EDC58, 1B49A4D8 A7C5352E, CB059EBD 110D71D7, 99059299 DC693F94 E0076EFE 37BDFDA6, FBE840A1 41D18FB4, 0B60BEBD 92238AA7, B0FE05E7

Session Number

Effectiveness of Attack

1

No

2

No

3

No

4

No

5

No

6

No

7

No

It shows that the tag key update operation is successful in every session. The key update message can be blocked by the denial-of-service attacker periodically in the test. In the timeout period, if the reader does not receive the key update acknowledgement, it will re-send the message and the tag is able to receive it. Finally, the key update acknowledgement arrives indicating that the tag's key set is synchronized with the reader.

69

5.6 The Man-in-the-Middle Attack Model
In the man-in-the-middle attack model, an attacker stays between a reader and its tags and acts like a reader to the tag or appears to be a tag to the reader. Figure 5.9 shows the Nios-II system implemented for the prototype of this model. In this test, the reader first queries the tag and receives its reply. When the key update message is sent out from the reader, the man-in-themiddle attacker attempts to modify it. If the tag is able to detect the message is not legitimate, it verifies that our protocol is safe against man-in-the-middle attacks.

Figure 5.9 Man-in-the-Middle Attack Model Implementation using Nios-II System The reader, attacker and tag modules are implemented as individual Nios-II processors. Figure 5.10 shows the attacker module of this model designed in the SOPC Builder environment.

70

Figure 5.10 Attacker Module for the Man-in-the-Middle Attack Model

In the experimental test, we recorded the messages exchanged for one hour with a new reading operation triggered every ten seconds. We did not observe any case that a successful attack could happen. A sample of the test results from session 28 to 34 is summarized in Table 5.5.

71

Table 5.5 Man-in-the-Middle Attack Messages Exchanged Session Number Tag Response Message To Query 28 BE0F3DF6, DD11E327 29 2962986F, 2B17C3FA 30 D7F46FAE, F0FE0ADF 31 6ACF5229, 4D6B3B82 32 71861D2C, 12174846 33 A8F5EE0, 89E2D8DF 34 D9BD752A, 888FBF27 Tag Key Update Message Reader Send 7C6F3423, DA1EE993 F6D59CA9, F92AF59B 63C4CFEF, C12C399C 20951352, B3E721FD 0CEF9372, BA89253D 71E95F13, 16D89577 FC907F17, B7F84EC8 Tag Key Update Message Reader Re-send 7C6F3423, DA1EE993 F6D59CA9, F92AF59B 63C4CFEF, C12C399C 20951352, B3E721FD 0CEF9372, BA89253D 71E95F13, 16D89577 FC907F17, B7F84EC8 Tag Key Update ACK Message 51B7093F, 4E4B5E76 685BF097, DBECF678 A8A9C526, 4F35367B 2CAB2088, 597F2810 EF222F41, 1FE998C4 80198675 1A0FA400 88781C4F, 64990BE8 No No No No No No No Effectiveness of Attack

The results of model prototyping show that a successful tag key update is realized in every session. The man-in-the-middle attacker tries to modify the key update message. However, when the tag decrypts the key update message, it finds the field of the last 30 bits of the tag ID does not match its own. As a result, the key update operation does not take place based on the false message. In the timeout period, since the reader cannot receive the key update acknowledgement, it re-sends the key update message. The key update acknowledgement in the last step is finally received and the reading process is finished successfully.

72

Chapter 6
Performance and Security Analysis
In the following sections, we analyze and compare our protocol with Toiruul and Lee's protocol and Kim et al.'s protocol [34, 38]. We select them for comparison because, like our work, they both use symmetric key algorithms in their protocols. We apply the same approaches as we make analysis on our authentication scheme. SystemC based modeling is also used to evaluate the security level for different threat models and FPGA prototyping environment is applied to analyze the performance level of these protocols and compare with ours.

6.1 Security Level Analysis
We first analyze the security level of Toiruul and Lee's protocol by building the same model as shown in Figure 4.1. In this simulation, there is no attack module applied in the model. The values of secrets are initialized as follows:

ID:{0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff,0x00} k: {0xe3,0x25,0x87,0x34,0x19,0x34,0x90,0x90,0x56,0x13,0xdf,0x56,0x94,0x61,0x4b,0x1a} k1:{0x23,0x19,0x83,0x84,0x91,0xdc,0xd8,0x3e,0x09,0x59,0x3c,0xb2,0xb6,0x46,0x39,0x92} k2:{0xc1,0x50,0xd7,0xc9,0xb2,0xc8,0xb2,0x89,0xa2,0x79,0x04,0x06,0x82,0x56,0x90,0x23} In every new session, the secrets are changed with the same process as described in the section 2.4. Protocol simulation results of from session number 38 to 43 are shown in Figure 6.1.

73

Figure 6.1 Toiruul and Lee's protocol Simulation Once a tag's current secrets are disclosed, an attacker does not need to intercept the messages in the next sessions to keep track of how the secrets are updated, because this process is fixed in the second stage of the protocol. Therefore, the future secrets can be deduced and the subsequent tag's responses can be computed. Thus, the protocol does not provide backward security.

74

However, it ensures forward security because it is hard to compute k1 and k2 value in a previous session even if the current secrets are known. To analyze the protocol behavior in denial-ofservice attacks, we construct the model using the same configuration as shown in Figure 4.11. The model is simulated and the results are presented in Figure 6.2.

Figure 6.2 Simulation of Denial-of-Service Attack in Toiruul and Lee's Protocol The first simulation is a normal session where the system is not attacked. When the attacker starts the denial-of-service attack at the second session, the attacker attempts to block the tag reply message and the reader cannot receive the tag reply. When the reader tries to start reading operation again it cannot identify the tag because the tag's secrets are already updated but the reader's secrets are not. We also simulated all the other attack models using SystemC modeling, but we did not observe any other successful attacks. Thus, we can conclude that Toiruul and Lee's protocol [34] is not secure against denial-of-service attacks and it is also vulnerable in backwards security.

75

To evaluate the security level of Kim et al.'s protocol [38], we simulate the protocol in all the attack models in SystemC modeling and examine the results. The protocol simulation results of the denial-of-service attack are shown in Figure 6.3.

Figure 6.3 Simulation of Denial-of-Service Attack in Kim et al.'s Protocol

76

It is found that if the denial-of-service attack happens in the third step, the tag is kept in a state that it is waiting for the next message to come from the reader. The reader does not receive any response from the tag and starts the query from the beginning again. At this point the tag could not response with the right message the reader is waiting for. Although the reader must start the reading operation from the beginning, it cannot identify the tag correctly after the attack. Therefore, we can conclude that this protocol is weak against denial-of-service attacks. We also implemented other security attack models, but no other successful attacks are observed. If the current secrets of a tag are disclosed, the tag's previous and subsequent responses are predictable because its secrets are not updated. Although random number generators are used, the values of Rtag, Rreader and Rserver can be computed by intercepting the messages between the reader and the tag. Therefore, it is also weak in both forward security and backward security. We summarize the security level comparison of our proposed protocol with Toiruul and Lee's and Kim et al.'s protocols as shown in Table 6.1.

Table 6.1 Security Level Comparison
Denial-of -Service Attack Resistance Strong Man-inthe-Middle Attack Resistance Strong Active Scanning Attack Resistance Strong

Forward Security

Backward Security

Replay Attack Resistance

Cloning Attack Resistance

Our Proposal Toiruul and Lee 's Protocol [34] Kim et al.'s Protocol [38]

Strong

Strong

Strong

Strong

Strong

Weak

Strong

Strong

Weak

Strong

Strong

Weak

Weak

Strong

Strong

Weak

Strong

Strong

77

6.2 Performance Analysis
To evaluate the performance of a protocol, its efficiency must be measured using different parameters. If two protocols provide the same level of security, the protocol using less resource is obviously more efficient. In this section, we present the performance analysis of Toiruul and Lee's and Kim et al.'s protocols [34, 38] and then compare our proposal with them. The main parameters we will use in this analysis include code size (tag, reader/server), communication cost, execution time, scalability and the type of cipher used.

6.2.1 Code Size
We have implemented our protocol, Toiruul and Lee's and Kim et al.'s protocols in Altera NiosII DE2 development environment. Using the same methodology as shown in chapter 5, a multiprocessor application consisting of only a reader module and a tag module is implemented as a Nios-II system in the same FPGA device. The reader and tag codes for each protocol are applied to the same Nios-II multiprocessor platform to evaluate their efficiency. To facilitate prototyping, the System-on-a-Programmable-Chip (SOPC) Builder tool is used to generate the multiprocessor system as shown in Figure 6.4. The reader and the tag modules are implemented as 32-bit RISC Nios-II processors (economic type) and the top level configuration is designed using VHDL hardware description language. The communication between reader and tag processors are also realized using parallel input/output (PIO) ports. As illustrated in Figure 6.4, the reader_out_en, tag_in_en, tag_out_en and reader_in_en signals are 8-bit PIO ports and the reader_out_data, tag_in_data , tag_out_data and reader_in_data signals are 32-bit PIO ports. The signals of reader_out_en, reader_out_data, tag_out_en and tag_out_data are

78

output type only while the signals of tag_in_en, tag_in_data, reader_in_en and reader_in_data are of input type.

Figure 6.4 Nios-II System with Reader and Tag CPUs

JTAG UART is added to download codes to processors and to serve as a user interface. On-chip memory (RAM) is included to store code and data. After the Nios-II system is generated completely by the SOPC builder, we only need to add connections between PIO ports using VHDL hardware description language. The system architecture is compiled and uploaded into the FPGA on the DE2 board using the programmer utility available in Quartus II design environment.

Implemented as C application, the reader and the tag's protocol source codes use only a reduced subset of device driver and a small C library so that the size of the code is optimized. The communication between Nios-II CPUs is implemented as following C-like pseudo code:

79

Define DELAY_CONSTANT T Send_Function (Value) { Data_Out_Port = Value; Delay(T); Set_Data_Out_En; Delay(T); Clear_Data_Out_En; Clear_Data_Out_Port; Exit; } Receive_Function (Value) { While(Timeout = False) { If ( Detected Rising Edge) { Receive_Data = Data_In_Port; Exit; } } Set_Fail_To_Receive_Flag; Exit; } A screen snapshot of the reader and tag codes after being compiled successfully are displayed in Figures 6.5 and 6.6 respectively.

Figure 6.5 Compilation of the Reader Code
80

Figure 6.6 Compilation of the Tag Code We observe that the reader code size is 3524 bytes and the tag code size is 1944 bytes. The same method is applied to determine the code size of the other two protocols. As for Toiruul and Lee's protocol, the tag code size is 5700 bytes while the reader code size is 7836 bytes. For Kim et al.'s protocol, the tag code size is 6440 bytes while the reader code size is 9544 bytes. The reader and the tag code size for each protocol are summarized as shown in Table 6.2.

Table 6.2 Code Size Comparison Toiruul and Lee's Protocol [34] Reader 7836 Tag 5700 Kim et al.'s Protocol [38] Reader 9544 Tag 6400

Our Proposal Reader Code Size 3523 Tag 1944

81

6.2.2 Communication Cost
In order to evaluate the communication cost of each protocol, we can assume that a reader needs to authenticate "n" number of tags. In our protocol, when a reader query tags, it needs to send out only one query message for all the tags to respond, therefore the communication cost of the first step is only 64 bits. If "n" tags are responding, then "n" tags' response consist of 64n bits. Therefore, the communication cost in the second step is 64n bits. Similarly, it is concluded that the communication cost for step 3 and step 4 are all 64n bits each.

As for the Toiruul and Lee's protocol communication cost, we used the same method to analyze. When a reader queries "n" tags, it has to initiate "n" messages in step one. However, since the output of encryption algorithm AES is 128 bits, the communication cost of the first step is 128n bits. In the second step, n tags send back 128n bits to the reader, making the total communication cost to be 256n bits.

The Kim et al.'s protocol consists of four steps in over-the-air communication channel. If a reader queries n tags, the communication cost in each step is 128n bits due to the message size of AES encryption algorithm. The comparison of communication cost is summarized in Table 6.3. It is demonstrated that our scheme is also more efficient than the other two schemes in terms of communication cost, especially when reading multiple tags.

Table 6.3 Communication Cost Comparison Toiruul and Lee's Protocol [34] 2 x 128n = 256n bits Kim et al.'s Protocol [38] 4 x 128n = 512n bits

Our Proposal 64 + 3 x 64n = 64 +192n bits

Communication Cost

82

6.2.3 Number of Clock Cycles
Generally speaking, the number of clock cycles required for executing a protocol is a critical measurement because it is proportional to power consumption when the clock frequency remains unchanged.

Measuring the number of clock cycles can be achieved using a timestamp timer peripheral. First of all, a timestamp timer, timer_1 is added into the Nios-II system for the reader module in our protocol. The screen snapshot of the reader system in an SOPC Builder is shown in Figure 6.7.

Figure 6.7 Reader System with Timestamp Timer

83

It is selected as a full feature option timer and is specified as timestamp timer in the project system library. The first timestamp is obtained at the beginning of the protocol execution. After the operation is finished, the second timestamp is recorded. The execution time of each session is measured by calculating the difference of the two timestamps. For better accuracy, the timestamp difference is measured 20 times and the average value is calculated for each evaluation. Since the communication between the reader and the tag also takes time, we have to measure the timestamp difference with different delay constant T. The delay constant is initially defined as 60 and the timestamp difference is acquired as shown in Figure 6.8.

Figure 6.8 Timestamp Difference Measured in our Protocol

84

It may be noticed that the timer frequency is 0x2faf080 in hexadecimal value, which is equivalent to 50MHz in decimal number. The average timestamp difference is 0x16721 and is equal to 91937 clock cycles. Since each clock cycle is 0.02µs, it is computed that the average timestamp difference is 1.838 milliseconds.

Since communication between reader processor and tag processor takes certain amount of time, we can only get the protocol execution clock cycle by calculating the ideal execution time when T approaches zero. In fact, if T is set below five in the experiment, the protocol cannot run successfully. Table 6.4 shows the timestamp difference in hexadecimal format with different T values defined in the source code. The execution time is also converted and shown in the bracket beside.

Table 6.4 Timestamp Difference Measured in Our Protocol Delay Constant T 60 50 40 30 20 10 Timestamp Difference 0x16721 ( 1.838 ms) 0x14dda ( 1.709 ms) 0x13482 ( 1.580 ms) 0x11b34 (1.450 ms) 0x101d1 (1.320 ms) 0xe884 (1.190 ms)

A chart is plotted as shown in Figure 6.9 to show the relation between the timestamp difference and different delay constant T values. As it is expected, the pattern is linear.

85

Figure 6.9 Timestamp Difference in Our Protocol It shows that as T decreases, the timestamp difference also decreases linearly and the value drops by 0.13ms whenever T is reduced by 10. We can conclude that in an ideal condition where the communication delay is zero, the execution time of our protocol is 1.060 ms or about 53000 clock cycles.

We apply the same method to analyze the number of clock cycles for Toiruul and Lee's Protocol. Initially, the delay constant is defined as 60 and the average timestamp difference is shown in Figure 6.10. Then the timestamp difference using different delay constants is obtained as shown in Table 6.5.

86

Figure 6.10 Timestamp Difference Measured in Toiruul and Lee's Protocol

Table 6.5 Timestamp Difference Measured in Toiruul and Lee's Protocol Delay Constant T 60 50 40 30 20 10 Timestamp Difference 0x935ff 0x91f83 0x90909 0x8f289 0x8dc07 0x8c587 ( 12.073 ms) ( 11.958 ms) ( 11.843 ms) ( 11.728 ms) ( 11.612 ms) ( 11.497 ms)

87

A chart is plotted as presented in Figure 6.11 to show the relation between the timestamp difference and different delay constant T values.

Figure 6.11 Timestamp Difference in Toiruul and Lee's Protocol

It appears that as T decreases, the timestamp difference also decreases linearly. The average value drops by 0.115ms whenever T is reduced by 10. It can be observed that if T approaches zero, the timestamp difference converges to 11.382ms. Therefore, in an ideal condition where communication delay is zero, the execution time for Toiruul and Lee's protocol is 11.282 or about 569100 clock cycles.

We use the same method to examine the number of clock cycles for Kim et al.'s protocol. When the delay constant T is defined as 60, the average timestamp difference is shown in Figure 6.12. The timestamp difference with different delay constant values is also obtained as shown in Table 6.6.

88

Figure 6.12 Timestamp Difference Measured in Kim et al.'s Protocol Table 6.6 Timestamp Difference Measured in Kim et al.'s Protocol Delay Constant T 60 50 40 30 20 10 Timestamp Difference
0xa989d 0xa6bae 0xa3eab 0xa11ad 0x9e4b4 0x9b7af (13.889ms) (13.659ms) (13.428ms) (13.198ms) (12.967ms) (12.737ms)

In the same way, the relation between the timestamp difference and different delay constant T values can be plotted in a chart as shown in Figure 6.13.

89

Figure 6.13 Timestamp Difference in Kim et al.'s Protocol

It can be observed that as T decreases, the timestamp difference also decreases linearly and the value drops by 0.23ms when T is reduced by 10. It is concluded that if T approaches zero, the timestamp difference converges to 12.507ms. Therefore, if there is no communication delay, Kim et al.'s protocol takes about 625350 clock cycles to execute. As discussed above, our protocol takes far less number of clock cycles than Toiruul and Lee's protocol and Kim et al.'s protocol. The comparison of each protocol's execution time and the number of clock cycles is summarized in Table 6.7.

Table 6.7 Number of Clock Cycles Comparison Toiruul and Lee's Protocol [34] 11.382ms 569100 Kim et al.'s Protocol [38] 12.507ms 625350

Our Proposal Execution Time Number of Clock Cycles 1.060ms 53000

90

The advantages of consuming less number of clock cycles include:

 Less power consumption  Longer reading range  Lower risk of being attacked

6.2.4 Cipher
The cipher used in a protocol is very important for its security as well as resource requirement. As a back-end server have more computational resource than a tag, the efficient implementation of a protocol on tags relies on lightweight ciphers. The right and suitable cipher must have a very small size in real implementation, consume less power and provide satisfactory level of security. We list the ciphers used in our protocol as compared with the other protocols as shown in Table 6.8.

Table 6.8 Cipher Usage Comparison

Our Proposal Back-end Server Tag XTEA XTEA

Toiruul and Lee's Protocol [34] AES AES

Kim et al.'s Protocol [38] AES AES

Our proposal is based on XTEA cipher, while Toiruul and Lee's Protocol and Kim et al.'s protocol are based on AES cipher. As the platform for prototyping is Nios-II CPU based multiprocessor system and protocols are implemented as software, we cannot get the footprint of

91

a cipher directly from compilation results of the source codes. However, both ciphers have been implemented and examined by the academic world extensively during recent years.

Feldhofer and Wolkerstorfer introduced an efficient implementation of AES algorithms in CMOS 0.35 µm process [36]. The results show that the Advanced Encryption Standard (AES128) data path implementation achieves a current consumption of 8.5 A at the frequency of 100 kHz. It consumes 1016 clock cycles to encrypt a 128-bit data block. It is also estimated that the hardware takes about 3595 gates.

Israsena and Wongnamkum compared the implementation of TEA algorithm with AES in CMOS 0.35 µm technology [48]. It shows that TEA encryption takes an equivalent gate count of 3872, but it consumes a much less current of 2.90 A. XTEA algorithm was implemented in .35 µm CMOS technology and was compared with TEA in Israsena's another work [42]. It is estimated that the layout area of XTEA is 0.212 mm2 and its maximum clock throughput is 47.5MHz. The TEA algorithm takes a similar area of 0.207 mm2 and the maximum throughput is 53 MHz. These results demonstrate XTEA consumes less power than AES cipher in the same technology.

Jens-Peter Kaps's work made an in-depth study of ultra low power implementation of XTEA algorithm on FPGA [49]. His work introduced an efficient implementation of XTEA, called TinyXTEA-3 and it was experimented on XC3S50 Xilinx FPGA device [50]. The results show that XTEA-3 uses an area of 254 slices and takes 112 clock cycles. He has also compared with other related works about AES implementations on FPGA. The smallest AES implementation mentioned is the 8-bit AES by Good and Benaissa [51]. It achieved an area of 264 slices which is similar to XTEA-3, but it takes 3900 clock cycles. In another work by Chodowiec and Gaj, AES

92

algorithm uses 112 clock cycles, which is the same as XTEA-3, however its area is 522 slices [52]. It is shown that XTEA is more efficient in ultra-low power and needs less resource than AES algorithm.

Therefore, our proposal selects XTEA as the best candidate of cipher because of its high efficiency proved on both CMOS and FPGA technologies.

As Kim et al.'s protocol is designed based on AES algorithm, using XTEA cipher instead of AES will make the key operations inefficient. As XTEA's message size is 64 bits, the size of Rserver, Rtag, Rreader, M, MOR and ID must be reduced to 32 bits to fit into it, which is too small for a security application. It also means that as the key size of K0 is 128 bits, the generated key K1, K2 and K3 will always have 96 bits unchanged. For the same reason, in Toiruul and Lee's protocol, the secrets of K1 and K2 will also always have 64 bits remained the same if XTEA cipher is applied. These results are not the intention of the original authors as the secrets are not sufficiently altered in every new session.

6.2.5 Scalability
In this subsection, we compare our scheme with Toiruul and Lee's Protocol and Kim et al.'s protocol in terms of scalability. In our protocol, if a reader initiates a reading operation, it just needs to issue a query message. The back-end server compares the tag reply with the list of expected reply from tags. The search time do not increase significantly with more tags added into the system. In Toiruul and Lee's Protocol, the reader relies on other anti-collision protocols to singularize a tag out of many. Therefore, it is considered to be scalable as well. In Kim et al.'s protocol, in order to initiate a reading operation, a reader has to know the tag's mask bit secret M in advance. If a reader does not know the value, a brute force search for known M values must be
93

performed. As the population of tags grows, it will become very time consuming to identify a tag. Obviously, this scheme is not scalable. Table 6.9 summarizes the comparison of each protocol's scalability.

Table 6.9 Scalability Analysis Toiruul and Lee 's Protocol [34] Yes Kim et al.'s Protocol [38] No

Our Proposal

Scalability

Yes

From the performance analysis shown above, our scheme has demonstrated to be more efficient in terms of code size, communication cost, number of clock cycles, cipher used and scalability. Achieving a high security level does not have to come with a high demand of resource.

94

Chapter 7
Conclusion and Future Works
As RFID technology attracts widespread attention from the public, its security issues need to be addressed properly. As "Moore's Law" continues to remain true and silicon chips are becoming more sophisticated with improved computation power and storage capability, stronger cryptographic primitives such as symmetric key encryption and decryption are no longer beyond the considerations for passive tags.

Our work focuses on the security and privacy aspects in the RFID applications. We have investigated a study of authentication methodologies and reviewed some cryptographic tools used in authentication protocols. Then, some related works on symmetric key cipher are studied and some proposed mutual authentication protocols used in RFID systems are reviewed.

To find a robust and efficient solution to RFID security issues, a novel RFID authentication key management protocol based on XTEA algorithm is proposed. Key update process in the protocol ensures high security level and mutual authentication is achieved. The simulation of the protocol and different attack models using SystemC based modeling proves that our scheme is safe against major attacks. Various attack models are prototyped on FPGA device to verify the robustness of our protocol. Unlike previous works, prototyping is realized efficiently on a FPGA multiprocessor platform. Overall, it is demonstrated that our scheme is safe against replay, active scanning, man-in-the-middle, denial-of-service and cloning attacks. It also provides forward security and backward security to the system.

95

We have compared the security and performance level of our protocol with Toiruul and Lee's and Kim et al.'s protocols. It is shown that both protocols are found to have weaknesses under denial-of-service attacks. We also analyzed the performance level in terms of code size, communication cost, execution time, scalability and the type of cipher used in the same FPGA multiprocessor platform. The comparison indicates that our scheme is more advantageous in terms of both security and performance levels.

For future work, it is necessary to implement the authentication protocol in real RFID systems to evaluate its performance. An attacker model should also be a part of the implementation in such a system so that it can launch different kinds of attacks. It will also be interesting to evaluate our scheme using WISP tag platform, because it will demonstrate the possibility for our scheme to be integrated into EPC tags in the future. The performance of power consumption and data rate can also be evaluated on tag level.

As silicon technology continues to evolve, the tag in the future will change significantly. The hardware and software co-design concept will play a key role in the efficient implementation of a RFID authentication protocol.

As discussed in our work, XTEA cipher has shown great potential in low power wireless security applications. Our scheme is proved to be helpful to create mutual authentication and trust between two entities. Therefore, some efficient applications in wireless sensor networks will be an interesting area to investigate in the future.

96

In our protocol, we used XTEA as cryptographic cipher because of its simplicity and high security level. As cryptographic technology keep evolving, new algorithms might come out in the future, therefore new encryptions can also be adapted into our protocol to improve its level of the security and performance.

97

Bibliography
[1] M. R. Rieback, B. Crispo and A. S. Tanenbaum, "The Evolution of RFID Security", IEEE Pervasive Computing, Vol. 5, No. 1, pp. 62-69, January ­ March 2006 [2] M. W. Cardullo and W. L. Parks III., "Transponder Apparatus and System", United State Patent 3713148 [Online], Available at: http://patft.uspto.gov/, January 1973 [3] Elisabeth Ilie-Zudor, Zsolt Kemeny, Peter Egri and Laszlo Monostori, "The RFID Technology and its Current Applications", in Proceedings of the 8th International Conference on The Modern Information Technology in the Innovation Processes of the Industrial Enterprises, pp. 29-36, Budapest, Hungary, September 2006 [4] Nick Long, "Frequency Bands for Short Range Devices", in Proceedings of the IEE Seminar on Telemetry & Telematics, pp. 6/1-6/5, London, UK, April 2005 [5] R. Want, "An Introduction to RFID Technology", IEEE Pervasive Computing, Vol. 5, No. 1, pp. 25-33, January-March 2006 [6] G. Barber and E. Tsibertzopoulos, "An Analysis of Using EPCglobal Class-1 Generation2 RFID Technology for Wireless Asset Management", in Proceedings of Military Communications Conference 2005, Vol. 1 , pp. 245­251, Atlantic City, New Jersey, USA, October 2005 [7] Ari Juels, "RFID Security and Privacy: A Research Survey", IEEE Journal on Selected Areas in Communications, Vol. 24, No. 2, pp. 381-394, February 2006

98

[8]

EPC Global, "Specification for RFID Air Interface, EPC Global (2005) EPC RadioFrequency Identity Protocols Class-1 Generation-2 UHF RFID Protocol for Communications at 860 MHz­960 MHz. Version 1.0.9" [Online], Available at: http://www.epcglobalinc.org

[9]

M. Jantscher,.R. Ghosal, A. Grasso, and P. H. Cole, "A Security Primer, Networked RFID Systems and Lightweight Cryptography ­ Raising Barriers to Product Counterfeiting" , First Edition, Springer, 2008

[10]

S.E. Schechter, "Quantitatively Differentiating System Security," in Proceedings of the 1st Workshop on Economics and Information Security, Berkeley, California, USA, May 2002,

[11]

S. E. Schechter, "Toward Econometric Models of the Security Risk From Remote Attacks", IEEE Security & Privacy, Vol. 3, No. 1, pp. 40-44, January-February 2005

[12]

M. Langheinrich and R. Marti, "Practical Minimalist Cryptography for RFID Privacy" IEEE Systems Journal, Vol. 1, NO. 2, December 2007

[13]

M. O. Lehtonen, , F. Michahelles, and E. Fleisch, "Trust and Security in RFID-Based Product Authentication Systems", IEEE Journal on Selected Areas in Communications, Vol. 24, No. 2, pp. 381-394, February 2006

[14]

M. Lehtonen, T. Staake, F. Michahelles, and E. Fleisch, "From Identification to Authentication--A Review of RFID Product Authentication Techniques", Presented at the Workshop on RFID Security, Graz, Austria, 2006.

[15]

Z. Nochta, T. Staake, and E. Fleisch, "Product Specific Security Features Based on RFID Technology", in Proceedings of International Symposium on Applications and the Internet Workshops , pp. 72­75, Phoenix, Arizona, USA, 2006

99

[16]

A. J. Menezes, P. C. Oorschot and S. A. Vanstone "Handbook of Applied Cryptography", CRC Press, 1997

[17]

J. Deepakumara, H. M. Heys and R. Venkatesan, "FPGA Implementation of MD5 HASH Algorithm", in Proceedings of Canadian Conference on Electrical and Computer Engineering 2001, Vol. 2, pp. 919 ­ 924, Toronto, Canada, 2001

[18]

X. Wang and H. Yu, "How to Break MD5 and Other Hash Functions", in Proceedings of EUROCRYPT 2005, Lecture Notes in Computer Science, Vol. 3494, pp. 19-35, Springer, 2005

[19]

X. Wang, Y. L. Yin and H. Yu, "Finding Collisions in the Full SHA-1", in Proceedings of CRYPTO 2005, Lecture Notes in Computer Science, Vol. 3621, pp. 17-36, Springer, 2005

[20]

National Institute of Standards and Technology, U.S. Department of Commerce, "Announcing Request for Candidate Algorithm Nominations for a New Cryptographic Hash Algorithm (SHA-3) Family", U.S. Office of Federal Register Notices, Vol. 72, No. 212, pp. 62212-62220, [Online], Available at: http://csrc.nist.gov/groups/ST/hash/sha3/index.html, November 2007

[21]

D. Naccache and P. Fremanteau, "Unforgeable Identification Device, Identification Device Reader and Method of Identification", United States Patent 5434917 [Online], Available at: http://patft.uspto.gov/, July 1995

[22]

D. C. Ranasinghe, D. Lim, S. Devadas, D. Abbott and P.H. Cole, "Random Numbers from Metastability and Thermal Noise", IEE Electronic Letters, Vol. 41, No. 16, pp.1314, 2005

100

[23]

J. H. Anderson, "A PUF Design for Secure FPGA-Based Embedded Systems", in Proceedings of the 15th Asia and South Pacific Design Automation Conference, pp.1-6, Taipei, January 2010

[24]

J. Xie and X. Pan, "An Improved RC4 Stream Cipher", in Proceedings International Conference on Computer Application and System Modeling, Vol. 7, pp. 156-159, Taiyuan, China, October 2010

[25]

National Institute of Standards and Technology, "Advanced Encryption Standard", Federal Information, Processing Standards Publication 197 [Online], Available at: http://csrc.nist.gov/ publications/fips/fips197/fips-197.pdf, November 2001

[26]

W. E. Burr, "Selecting the Advanced Encryption Standard", IEEE Security & Privacy, Vol. 1, No.2, pp. 43-52, March-April 2003

[27]

R. M. Needham and D. J. Wheeler, "TEA, a Tiny Encryption Algorithm", in Proceedings of the 2nd International Workshop on Fast Software Encryption, Lecture Notes in Computer Science, Vol. 1008, pp. 363-366, Springer, 1994

[28]

J. Kelsey, B. Schneier and D. Wagner, "Related Key Cryptanalysis of 3-WAY, BihamDES, CAST, DES-X, New DES, RC2, and TEA", in Proceedings of the 1st International Conference of Information and Communications Security, Lecture Notes in Computer Science, Vol. 1334, pp. 233-246, Springer, 1997

[29]

R. M. Needham and D. J. Wheeler, "TEA Extensions", Technical Report, Computer Laboratory, University of Cambridge, England, October 1997

[30]

J. Lu, "Related-key Rectangle Attack on 36 Rounds of the XTEA Block Cipher", International Journal of Information Security, Vol. 8, No.1, pp. 1-11, Springer, February 2009

101

[31]

S. A. Weis , S. E. Sarma , R. L. Rivest and D. W. Engels. "Security and Privacy Aspects of Low-cost Radio Frequency Identification Systems", in Proceedings of the 1st International Conference of Security in Pervasive Computing, Lecture Notes in Computer Science, Vol. 2802, pp. 201-212, Springer, 2004

[32]

M. Ohkubo, K. Suzuki and S. Kinoshita, "Cryptographic Approach to Privacy-Friendly Tags", in Proceedings of RFID Privacy Workshop 2003, Massachusetts, USA, 2003

[33]

X. Wang, X. Zhou and B. Sun, "An Improved Security Solution of RFID System", in Proceedings International Conference on Wireless Communications, Networking and Mobile Computing, pp.2081-2084, Shanghai, China, September 2007

[34]

B. Toiruul and K. Lee, "An Advanced Mutual-Authentication Algorithm Using AES for RFID Systems", International Journal of Computer Science and Network Security, Vol. 6, No. 9, pp. 156-162, September 2006

[35]

R. Juels, R. L. Rivest and M. Szydlo, "The Blocker Tag: Selective Blocking of RFID Tags for Consumer Privacy", in Proceedings of the 8th ACM Conference on Computer and Communications Security, pp. 103­111, Philadelphia, PA, USA , November 2001

[36]

M. Feldhofer, S. Dominikus and J. Wolkerstorfer, "Strong Authentication for RFID System Using the AES Algorithm", in Proceedings of the 6th International Workshop of Cryptographic Hardware and Embedded Systems, Lecture Notes in Computer Science , Vol. 3156, pp. 357-370, Springer, 2004

[37]

M. Feldhofer, J. Wolkerstorfer, and V. Rijmen, "AES Implementation on a Grain of Sand", IEE Proceedings Information Security, Vol. 152, No. 1, pp. 13-20, October 2005

102

[38]

K. Kim, K. Chung, J. Shin, H. Kang, S. Oh, C. Han and K. Ahn, "A Lightweight RFID Authentication Protocol using Step by Step Symmetric Key Change", in Proceedings of the 8th IEEE International Conference on Dependable, Autonomic and Secure Computing, pp. 853 ­ 854, Chengdu, China, December 2009

[39]

Open SystemC Initiative, "SystemC Version 2.0 User's Guide" [Online], Available at: http://www. systemc.org

[40]

X. Luo, K. Zheng, Y. Pan and Z. Wu, "Encryption Algorithms Comparisons for Wireless Networked Sensors", in Proceedings IEEE International Conference on Systems, Man and Cybernetics, Vol. 2, pp. 2081-2084, Hangzhou, China, October 2004

[41]

H. Chae, D. J. Yeager, J. R. Smith and K. Fu, "Maximalist Cryptography and Computation on the WISP UHF RFID Tag", in Proceedings Conference on RFID Security, Malaga, Spain, July 2007

[42]

P. Israsena, "On XTEA-based Encryption/Authentication Core for Wireless Pervasive Communication", in Proceedings of International Symposium on Communications and Information Technologies 2006, pp. 59-62, Bangkok, Thailand, September, 2006

[43]

Z. Luo, T. Chan, J. S. Li, E. Wong, W. Cheung, V. Ng and W. Fok, "Experimental Analysis of an RFID Security Protocol", In Proceedings IEEE International Conference on e-Business Engineering, pp. 62-70, Shanghai, China, October 2006

[44]

S. Gilbert, "RFID Security: Tiny Encryption Algorithm and Authentication Protocols", Master Project, Ryerson University, Toronto, Canada, 2009

[45]

L. Borghei, "FPGA-Based Smart RFID Tag With Robust Authentication Protocol", Master Project, Ryerson University, Toronto, Canada, 2009

103

[46]

C. Angerer, B. Knerr, M. Holzer, A. Adalan, and M. Rupp, "Flexible Simulation and Prototyping for RFID Designs", in Proceedings of the 1st International EURASIP Workshop on RFID Technology, September 2007

[47]

"Altera

Development

and

Education

Board",

[Online],

Available

at:

http://www.altera.com/education/ univ/ materials/boards/unv-de2-board.html [48] P. Israsena and S. Wongnamkum, "Hardware Implementation of a TEA Based Lightweight Encryption for RFID Security", "RFID Security", pp. 417­433, Springer, 2009 [49] Jens-Peter Kaps, "Chai-Tea, Cryptographic Hardware Implementations of xTEA", in Proceedings of the 9th International Conference on Cryptology: Progress in Cryptology, Lecture Notes in Computer Science, Vol. 5365, pp. 363-375, Springer, 2008 [50] Spartan-3 FPGA Family Data Sheet, [Online], Available at: http://www.xilinx.com/ support/documentation/data_sheets/ds099.pdf [51] T. Good and M. Benaissa, "AES on FPGA from the Fastest to the Smallest", in Proceedings of the 7th International Workshop of Cryptographic Hardware and Embedded Systems, Lecture Notes in Computer Science, Vol. 3659, pp. 427­440, Springer, 2005 [52] P. Chodowiec and K. Gaj, "Very Compact FPGA Implementation of the AES Algorithm", in Proceedings of Workshop on Cryptographic Hardware and Embedded Systems 2003, Lecture Notes in Computer Science, Vol. 2779, pp. 319­333, Springer, 2003

104

Glossary
AES C1G2 CMOS CRC CTB DES DSS EPC FPGA HAC IFF ISM ISO JTAG MD4 MD5 MDC NIST NSA PIO PRNG PUF Advanced Encryption Standard Class-1 Generation-2 Complementary Metal Oxide Semiconductor Cyclic Redundancy Code Cost to Break Data Encryption Standard Data Security Standard Electronic Product Code Field-Programmable Gate Array Hash-based Access Control Identification Friend or Foe Industrial-Scientific-Medical International Organization for Standardization Joint Test Action Group Message-Digest Algorithm 4 Message-Digest Algorithm 5 Modification Detection Codes National Institute of Standards and Technology National Security Agency Parallel Input/Output Pseudo-random Number Generator Physical Unclonable Function

105

RC4 RF RFID RISC RSA RTL SHA SOPC SSL TEA TID TLS UART UHF VHDL WISP XOR XTEA

Rivest Cipher 4 Radio Frequency Radio Frequency Identification Reduced Instruction Set Computing Rivest-Shamir-Adelman Register Transfer Level Secure Hash Algorithm System on a Programmable Chip Secure Socket Layer Tiny Encryption Algorithm Tag Identification Transport Layer Security Universal Asynchronous Receiver/Transmitter Ultra High Frequency Very High Speed Integrated Circuit Hardware Description Language Wireless Identification and Sensing Platform Exclusive OR eXtended Tiny Encryption Algorithm

106


