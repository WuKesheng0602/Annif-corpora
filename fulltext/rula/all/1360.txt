Ryerson University

Digital Commons @ Ryerson
Theses and dissertations

1-1-2011

Cops and robbers on graphs and hypergraphs
William David Baird
Ryerson University

Follow this and additional works at: http://digitalcommons.ryerson.ca/dissertations Part of the Applied Mathematics Commons Recommended Citation
Baird, William David, "Cops and robbers on graphs and hypergraphs" (2011). Theses and dissertations. Paper 821.

This Thesis is brought to you for free and open access by Digital Commons @ Ryerson. It has been accepted for inclusion in Theses and dissertations by an authorized administrator of Digital Commons @ Ryerson. For more information, please contact bcameron@ryerson.ca.

Cops and Robbers on Graphs and Hypergraphs

by William David Baird, B.Sc. Wilfrid Laurier University, 2009

A thesis presented to Ryerson University in partial fulfillment of the requirements for the degree of Master of Science in the Program of Applied Mathematics

Toronto, Ontario, Canada, 2011

c Copyright by William David Baird, 2011

I hereby declare that I am the sole author of this thesis or dissertation.

I authorize Ryerson University to lend this thesis or dissertation to other institutions or individuals for the purpose of scholarly research.

I further authorize Ryerson University to reproduce this thesis or dissertation by photocopying or by other means, in total or in part, at the request of other institutions or individuals for the purpose of scholarly research.

ii

Abstract

Cops and Robbers on Graphs and Hypergraphs Master of Science, 2011 William Baird Applied Mathematics Ryerson University

Cops and Robbers is a vertex-pursuit game played on a graph where a set of cops attempts to capture a robber. Meyniel's Conjecture gives an asymptotic upper bound on the cop number, the number of cops required to win on a connected graph. The incidence graphs of affine planes meet this bound from below, they are called Meyniel extremal. The new parameters mk and Mk describe the minimum orders of k -copwin graphs. The relation of these parameters to Meyniel's Conjecture is discussed. Further, the cop number for all connected graphs of order 10 or less is given. Finally, it is shown that cop win hypergraphs, a generalization of graphs, cannot be characterized in terms of retractions in the same manner as cop win graphs. This thesis presents some small steps towards a solution to Meyniel's Conjecture.

iii

Acknowledgments
I would like to thank the many people at Ryerson who have helped me in completing this work. The Faculty and Staff in the Department of Mathematics have contributed in innumerable small ways to this end product. In particular I would like to thank Steve Kanellis for his technical guidance and patience. I would also like to thank Dr. Pavel Pralat for his guidance in the area of computer programming. Special thanks also go to Dr. Peter Danziger and Dr. Dejan DeliÂ´ c for being part of my thesis commitee and their part in my mathematical development. My deepest thanks go to my supervisor Dr. Anthony Bonato. From early on in my undergraduate career Dr. Bonato has been a driving force in my pursuit of mathematics. His love of the discipline and his commitment to excellence are an inspiration to me. Without his guidance, wisdom and mentorship this thesis would not have been possible. I am also deeply endebted to my family and friends. My parents Eric and Rose-Mary, and my sister Emily have all been a constant source of support and inspiration. I also extend my thanks to my girlfriend Shelbie, for her ceaseless encouragement and support. Finally, I wish to thank my friends who have encouraged me through this entire process.

iv

Contents
List of Figures Chapter 1. Introduction 1.1. Introduction to Cops and Robbers 1.2. Graphs 1.3. Incidence Graphs 1.4. Asymptotic Notation 1.5. Outline of Thesis Chapter 2. Meyniel Extremal Graphs 2.1. Steiner 2-designs 2.2. Projective Planes 2.3. Affine and partial affine planes Chapter 3. Growth Rates and Minimum Orders of k -Cop-Win Graphs 3.1. Introduction 3.2. Minimum orders and growth rates 3.3. Algorithms for computing cop number 3.4. The k -cop-win Algorithm 3.5. Lower bounds Chapter 4. The Game of Cops and Robbers on Hypergraphs
v

vii 1 1 3 7 9 10 13 14 15 19

25 25 26 29 39 43 49

4.1. Introduction 4.2. Definitions and Notation 4.3. Cops and Robbers on hypergraphs Chapter 5. Conclusions and Future Work 5.1. Summary 5.2. Open Problems Appendix A. Source Code A.1. Cop-win Checker A.2. Cops and Robbers Game Simulator A.3. 2-cop-win Checker Bibliography

49 50 52 57 57 58 61 63 70 84 99

vi

List of Figures
1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 A cop-win graph, G. A 2 cop-win graph, C4 . A graph G. A subgraph of G. An induced subgraph of graph G. A corner in a graph. An example of a dominating set in a graph. A hypergraph. The Fano plane. 2 2 4 4 4 6 6 7 8 9 17 19 20 21 30 35 36

1.10 The Incidence graph of the Fano plane. 2.1 2.2 2.3 2.4 3.1 3.2 3.3 The incidence graph of a projective plane of order q. The robber has q + 1 escape routes. The q + 1 cops can dominate the position of the robber. The robber again has q + 1 escape routes. The Petersen Graph. The graph G, a cop-win graph. A cop-win ordering for the graph G.
vii

3.4

The cop computes her second-to-last move, F2 (a) = b, and so moves to b. 38 40 44 45 49 50 50 51 51 52 56

3.5 3.6 3.7 4.1 4.2 4.3 4.4 4.5 4.6 4.7

The graph G, a cop-win graph. The construction of G . The isomorphism h : G  J . A hypergraph with hyperedges of cardinality 3 and 5. The vertex a is internal, the vertex b is external. A 5-regular 2-joined hypergraph. The graph G(H ) for H, the hypergraph in Figure 4.1. A hyperpath. A hypercycle. The deleted hyperedges give the robber an escape route.

viii

CHAPTER 1

Introduction
1.1. Introduction to Cops and Robbers A well-known, anonymous quote is "Philosophy is a game with objectives but no rules. Mathematics is a game with rules but no objectives". Cops and Robbers is a game within Mathematics with both rules and objectives. Cops and Robbers is a vertex-pursuit game played on a graph for reasons that will be more clear as we give the rules for the game. The game is played as follows. First the players, a cop and a robber, each select a vertex of a graph on which to begin the game. The cop selects the first vertex. In alternating rounds the cop and the robber take turns moving from vertex-to-vertex along edges. The object of the game for the cop is to occupy the same vertex as the robber, while the object for the robber is to prevent this from happening. We say the cop has captured the robber if the cop occupies the same vertex as the robber. A graph is said to be cop-win if after some finite number of rounds a cop can move so as to capture the robber. Otherwise, the graph is robber-win. Cop-win graphs, such as the graph in Figure 1.1, have a well known characterization based on the successive deletion of corners. This characterization will be discussed later in Section 3.3 of Chapter 3.
1

Figure 1.1. A cop-win graph, G. Cops and Robbers can be played with any number of cops. For k > 0 an integer, if k cops are sufficient to capture a robber on a given graph, then we say that graph is k -cop-win. For example, the graph in Figure 1.2 is not cop-win. If the game is played on this graph with just one cop, then the robber can evade the cop indefinitely. However, if the game is played by two cops, then the cops win since there is no way for the robber to escape.

Figure 1.2. A 2 cop-win graph, C4 . A 1-cop-win graph is simply a cop-win graph. We define the cop number of a graph G, written c(G) = k, to be the minimum number of cops required for the graph G to be k -cop-win. For example a cop-win graph, like the graph in Figure 1.1, has c(G) = 1. The graph in Figure 1.2 satisfies c(C4 ) = 2. This parameter is well-defined since placing a cop on every vertex will always result in a win (in one move) for
2

the cops. This fact gives a trivial upper bound on the cop number: c(G)  |V (G)|. Cops and Robbers was introduced by Nowakowski and Winkler in [15] and independently by Quilliot in his Ph.D. Thesis [18]. Both sets of authors give a characterization of cop-win graphs. Later on, Aigner and Fromme [1] considered the game played with multiple cops. Cops and Robbers belongs to a family of combinatorial games called vertex-pursuit games or graph searching games. These games provide a simplistic model for network security. We can think of the robber as an intruder in a network and cops as network monitors. 1.2. Graphs The graph on which Cops and Robbers is played is crucial to the outcome of the game. In this section we give preliminary definitions and terminology that will be useful throughout the remaining chapters. A graph G consists of a non-empty set of vertices, written V (G), and a set of edges, written E (G). Edges are unordered pairs of vertices. If two vertices are connected by an edge, then we say they are adjacent. If u and v are adjacent, then we write uv  E (G) or u  v. The order of G is the number of vertices, |V (G)|. A graph is reflexive if all vertices have a loop. We will assume all our graphs are reflexive as this allows the cops and robbers to pass or stay on the same vertex, although we will omit reference to loops in figures. All the graphs we consider are of finite order. A subgraph H of a graph G is a graph such that the vertices of H are a subset of the vertices of G and the edges of H are a subset of the
3

vertices of G. An induced subgraph J is a graph with vertices a subset of the vertices of G and containing all edges of G with both ends in the vertex set of J. That is, an edge uv is in the edge set of J if and only if uv is in the edge set of G and both u and v are vertices in J. Figure 1.3 shows a graph G, Figure 1.4 shows a subgraph of G, and Figure 1.5 shows an induced subgraph of G.

Figure 1.3. A graph G.

Figure 1.4. A subgraph of G.

Figure 1.5. An induced subgraph of graph G.
4

The degree of a vertex u in a graph G is the number of edges incident with it, and is written degG (u) (we drop the subscript G if it is clear from context). The maximum degree of a graph G, denoted (G), is the degree of a vertex with largest degree in G. Similarly, the minimum degree of G, denoted by  (G), is the degree of the vertex with the smallest degree in G. A graph is said to be k -regular if all vertices in the graph have degree k. A path of order n, written Pn , is a graph with vertices v1 , v2 , . . . , vn , so that vi is adjacent to vi+1 , where 1  i  n - 1. A cycle, written Cn , is formed by adding the edge v1 vn in the path Pn . The graph in Figure 1.2 is a cycle. The girth of a graph, written g (G), is the order of a smallest cycle contained in G as a subgraph. Aigner and Fromme in [1] give the following lower bound on cop number using girth and minimum degree.

Theorem 1. Let G be a graph of minimum degree  (G)  n with girth g (G)  5. Then c(G)  n.

A graph is connected if for all vertices u and v there exists a path from u to v . Usually when playing the game of Cops and Robbers we consider graphs to be connected. The neighbour set of a vertex v is the set of all vertices adjacent to v , written N (v ). The closed neighbour set of a vertex v is the union of N (v ) and v itself, denoted N [v ]. A vertex u is a corner if there is a vertex v such that N [u]  N [v ]. Figure 1.6 shows a corner in a graph. We say that a vertex v dominates or covers u.
5

Figure 1.6. A corner in a graph. A dominating set S of a graph G is a set of vertices such that all vertices of G are either in S or adjacent to a vertex in S . The domination number, written  (G), is the minimum number of vertices required for a dominating set in G. Note that c(G)   (G), as placing a cop on each vertex of a dominating set ensures a win for the cops. The circled vertices in Figure 1.7 show a dominating set in a graph.

Figure 1.7. An example of a dominating set in a graph. A graph G is called bipartite if the vertices of G can be partitioned into two colour classes, say red and blue, such that no red vertex is adjacent to any other red vertex and no blue vertex is adjacent to any other blue vertex. Alternatively, a bipartite graph is one whose vertex set is partitioned into sets of vertices containing no edges between them. We call such sets of vertices independent sets.
6

Hypergraphs are a generalization of graphs. A hypergraph H consists of a non-empty set of vertices, written V (H ), and a set of edges (or hyperedges), written E (H ). Edges are sets of vertices of any cardinality. The order of an edge in a hypergraph is the number of vertices contained in the edge. We will discuss hypergraphs further in Chapter 4.

Figure 1.8. A hypergraph.

1.3. Incidence Graphs An incidence structure consists of a set of points and lines, denoted P and L respectively, together with an incidence relation of pairs of points and lines. Incidence structures are generalizations of familiar geometric structures such as planes. We will deal with several specific incidence structures. A Steiner 2-design or a 2-(v, k, 1) design is an incidence structure with v -many points, with lines (sometimes called blocks ) containing k points, such that any pair of points is contained in exactly one block. It is assumed
7

that 2 < k < v . A finite projective plane of order n is a Steiner 2-design on n2 + n + 1 points, that has blocks of size n + 1. Projective planes are then 2-(n2 + n + 1, n + 1, 1) designs. They can also be defined as a set of n2 + n + 1 points with the properties that any two points determine a unique line and any two lines determine a unique point. Note that every point has n + 1 lines incident with it, and every line contains n + 1 points. The smallest example of a projective plane is the Fano plane (see Figure 1.9). It is a projective plane of order n = 2. Projective planes are known to exist if the order n = pk , where p is prime, and k  1. All known projective planes have such orders. In fact it is conjectured that only the only possible orders for projective planes are prime powers (see [6]).

Figure 1.9. The Fano plane. An affine plane of order n is a 2-(n2 , n, 1) design. An affine plane of order n exists if and only if a projective plane of order n exists. A partial affine plane is an incidence structure obtained from an affine plane by the deletion of one or more lines. An incidence graph is a graph that is constructed from an incidence structure as follows. The vertices of the graph are the points and lines, and there is an edge between two
8

vertices if they are incident with each other; that is, there is an edge between a vertex representing a point and a vertex representing a line if and only if the point is on the line. Incidence graphs are bipartite since no points are incident with any other points and no lines are incident with any other lines hence, the graph is the union of two independent sets. Figure 1.10 shows the incidence graph of the Fano plane from Figure 1.9.
1 2 3 4 5 6 7 Points 123 147 156 246 257 345 367 Lines

Figure 1.10. The Incidence graph of the Fano plane.

1.4. Asymptotic Notation Asymptotic notation gives a simple and succinct method for describing how a function f (x) behaves for large values of x. This notation is especially useful for describing the running time of an algorithm, though we will also use it to describe the asymptotic behaviour of other functions. Let f (x) and g (x) be real-valued functions. We
9

write f (x)  O(g (x)) if and only if there exists a constant c > 0 and an integer N > 0 such that for x > N , f (x)  cg (x). Equivalently, f (x)  O(g (x)) if
x

lim sup

f ( x) . g ( x)

exists and is finite. It is a common abuse of notation to write f (x) = O(g (x)) or simply f = O(g ). If f = O(g ), then g = (f ). If f = O(g ) and f = (g ), then f = (g ). We say that f = o(g ) if f ( x) = 0. x g (x) lim If f = o(g ), then g =  (f ). Equivalently, g =  (f ) if lim g (x) = . f ( x)

x

Note that if f = o(1), then lim f (x) = 0.

x

We say f and g are asymptotically equivalent, written f  g if f ( x) = 1. x g (x) lim 1.5. Outline of Thesis Perhaps the deepest open problem in the study of Cops and Robbers is Meyniel's Conjecture. The conjecture, due to Henri Meyniel [11], is that for a connected graph G, c(G) = O( |V (G)|).

10

In Chapter 2, we give some background on Meyniel's Conjecture, discuss some results related to the conjecture and give the cop number of incidence graphs of projective and partial affine planes. We introduce so-called Meyniel extremal graphs which realize the upper bound in the conjecture, and give infinitely many new examples of such families satisfying certain regularity conditions. In Chapter 3 we consider the minimum orders of a k -cop-win graph and their relation to Meyniel's Conjecture. We also present experimental results about the cop number of connected graphs of order 10 or less, as well as the algorithms used to obtain these results. The implementations of the algorithms used in this chapter are included as an appendix. Chapter 4 discusses the game of Cops and Robbers played on hypergraphs and its relationship to the game played on graphs. Our final chapter summarizes open problems in the area and describes some future directions.

11

CHAPTER 2

Meyniel Extremal Graphs
Difficult mathematical challenges often serve to motivate study in a particular area. For Cops and Robbers, one such problem is Meyniel's Conjecture. The conjecture states that if G is a graph of order n, then  c(G) = O( n). Equivalently, for n sufficiently large there exists a constant d > 0 such that  c(G)  d n. Although it was first introduced by Frankl in 1987 [11] the problem went largely unstudied for many years. In this initial paper Frankl proved that c(G) = o(n); In particular, he proved that if G is a graph of order n, then c(G) = O n log log n log n .

This bound has been improved upon incrementally since the introduction of the topic. The best known upper bound on the cop number is the following, which was recently proven independently by three sets of researchers.

13

Theorem 2. [13, 12, 21] For a graph G of order n, (2.1) c(G)  O n  .

2(1-o(1))

log2 n

Note that although the bound in (2.1) is currently the best known upper bound for general graphs, it is still far from proving Meyniel's conjecture. In the search for proof or disproof of the conjecture it is interesting to see if there are graphs that meet the bound predicted by Meyniel's Conjecture from below. These graphs would be, in a sense, the graphs with largest possible cop number relative to their order. We present here a new infinite family of graphs, so-called Meyniel Extremal graphs, that have cop number meeting the Meyniel bound from below. To make this precise, an infinite family of graphs (Gn : n  0) is Meyniel extremal if there is a constant d > 0 such that for sufficiently large n, c(Gn )  d |V (Gn )|. 2.1. Steiner 2-designs In order to describe Meyniel extremal families, we need some background from combinatorial designs. If t, v, k and  are positive integers, then a t-(v, k, ) block design or a t-design, is an incidence structure with the following properties. It contains v points, each block contains k points, and every set of t points is contained in exactly  blocks. A Steiner 2-design is a t-design in which and two points uniquely determine a block. Thus, Steiner 2-designs are 2-(v, k, 1) designs. For a

14

general t-design, with b blocks, it can be shown that (see [6]) b k t = v . t

In a Steiner 2-design this gives that b Rearranging yields k 2 = v . 2

(2.2)

b=

v 2 k 2

=

v (v - 1) . k (k - 1)
v (v -1) . k(k-1)

Thus, the number of blocks in a Steiner 2-design is

Let

r be the number of blocks incident with each point, also called the replication number. It can be shown that

(2.3)

r=

v-1 . k-1
v -1 k-1

Thus, each point is incident with

blocks.

2.2. Projective Planes With the notation of the previous section we can describe projective planes. Projective planes of order q are Steiner 2-designs with q 2 + q +1 points and q + 1 points on a line. Thus, projective planes are 2 - (q 2 + q + 1, q + 1, 1) designs. Projective planes are also often defined as a set of q 2 + q + 1 points with the following properties.
15

(1) There is exactly one line incident with every pair of distinct points. (2) There is exactly one point incident with every pair of distinct lines. (3) There are four points such that no line is incident with more than two of them. Note that the second axiom means that any pair of distinct lines intersect and thus, there are no parallel lines in projective planes. From the definition we know that projective planes contain q 2 + q + 1 points and that each point is incident with q + 1 lines. Using this information with the formulas derived above for general Steiner 2-designs, we find from Formula (2.2) that the number of lines is q 2 + q + 1 and from Formula (2.3) that each point is incident with q + 1 lines (and so by duality for projective planes, each line contains q + 1 points). Recall that incidence structures such as t-designs and projective planes can be used to construct incidence graphs. Given an incidence structure P we will denote its incidence graph G(P ). Also recall that since edges only exist between points and blocks, G(P ) is bipartite. The following lemma is part of folklore, and we include it for completeness. Lemma 3. If P is a Steiner 2-design, then g (G(P ))  6. Proof. Since bipartite graphs cannot contain odd cycles the girth of G(P ) must be even. Suppose there exists a cycle of length four in
16

q+1 lines

q+1 points

Points P |P|=q2+q+1

Lines L |L|=q2+q+1

Figure 2.1. The incidence graph of a projective plane of order q. G(P ). The vertices of a cycle of length four would be vertices corresponding to two points and two blocks in the design. This implies that two points are incident with two distinct blocks, which is a contradiction since two points determine a unique line. Therefore, G(P ) has girth at least 6. Lemma 3, along with a theorem due to Aigner and Fromme [1] can be used to give our first explicit family of Meyniel extremal graphs. Theorem 4. [16] If P is a projective plane of order q, then c(G(P )) = q + 1.
17

We include a proof of Theorem 4 from [16] for completeness.

Proof. Since  (G(P )) = q + 1 and by Lemma 3 g (G(P ))  6 the cop number is greater than or equal to q + 1 (see [1]). We now prove the upper bound. We place q + 1 cops, say C1 ,C2 ,...,Cq+1 , on a fixed set of points and consider cases for the location of the robber. Case 1: Robber in L. Suppose the robber R begins in the vertices corresponding to lines in the plane. Call the vertex that R occupies L(x1 ,x2 ,. . .,xq+1 ), where x1 , x2 ,..., xq+1 represent the points on the line. Since lines are incident with q + 1 points, L(x1 ,x2 , . . . , xq+1 ) has degree q + 1 in the graph G(P ). Thus, the robber has q + 1 escape routes from which he can leave the line. Each pair of points (x1 , C1 ),(x2 , C2 ),. . .,(xq+1 , Cq+1 ) determines a unique line by properties of projective planes. Let these lines be

L(x1 , C1 ), L(x2 , C2 ),. . . ,L(xq+1 , Cq+1 ), respectively. The cops can then each move to these q + 1 lines. Now on the next time-step the robber may remain at L(x1 ,x2 , . . . , xq+1 ) or move to any one of x1 ,x2 , . . . , xq+1 . To capture the robber the cops need only to travel to x1 ,x2 , . . . , xq+1 , respectively and the robber will be caught at this round or in the following round. Case 2: Robber in P . Suppose the robber R begins in P . We identify the vertex occupied by the robber as R. Since any two points determine a unique line the point occupied by the robber, R, and the points occupied by the cops C1 ,C2 ,...,Cq+1 ,
18

P
x1 x2 x3

L

R

xq+1

Figure 2.2. The robber has q + 1 escape routes. uniquely determine a set of q + 1 distinct lines. These lines are denoted L(R, C1 ), L(R, C2 ), . . . , L(R, Cq+1 ). Since the degree of the vertex occupied by the robber is q + 1 this set of q + 1 lines dominates the position of the robber. In order to cover the escape routes of the robber, the cops can move from their initial positions C1 ,C2 ,...,Cq+1 to the lines L(R, C1 ), L(R, C2 ), . . . , L(R, Cq+1 ), respectively. The cops then win in at most two rounds. 2.3. Affine and partial affine planes Affine planes are another well-known example of an incidence structures. An affine plane of order q is a 2-(q 2 , q, 1) design. By applying the
19

P
x1 x2 x3

L

R

xq+1 L(x1,C1) L(x2,C2) C1 C2 C3 L(xq+1,Cq+1) L(x3,C3)

Cq+1

Figure 2.3. The q + 1 cops can dominate the position of the robber. formulas (2.2) and (2.3) derived for Steiner 2-designs, it can be shown that in an affine plane, any point lies on q + 1 lines and there are q 2 + q lines in total. A projective plane can be obtained from an affine plane by the addition of a point and a line at infinity. Similarly, an affine plane can be obtained from an projective plane by the deletion of any one line and all the points incident with it. In fact, an affine plane of order q exists if and only if a projective plane or order q exists; see [6]. An affine plane can be defined axiomatically in a similar manner to projective planes. An affine plane is a set of q 2 points and q 2 + q lines with the following properties.
20

P

L

L(C1,R) R L(C2,R) L(C3,R)

L(Cq+1,R) C1 C2 C3

Cq+1

Figure 2.4. The robber again has q + 1 escape routes.

(1) There is exactly one line incident with every pair of distinct points. (2) Given a point p and a line L, there is a unique line incident with p and containing no point of L. (3) There exist three non-collinear points. Item (2) from the above list is sometimes referred to as Playfair's Axiom or Euclid's Parallel Postulate. Like the incidence graph for a projective plane, the incidence graphs G of an affine planes is bipartite and has g (G)  6. There are 2q 2 + q vertices in the incidence graph of an affine
21

plane of order q . By properties of affine planes the vertices corresponding to points have degree q + 1 and vertices corresponding to lines have degree q . The incidence graph is then said to be (q, q + 1)-regular. Using affine planes, we derive a new family of Meyniel extremal graphs. For this, we need the notion of parallelism in affine planes. In contrast to projective planes, where all lines intersect one another, lines in affine planes do not necessarily intersect. If two lines in an affine plane are equal or do not intersect, then they are said to be parallel to one another. Parallelism is an equivalence relation on the set of lines. Parallel classes (or parallel pencils ) are the equivalence classes that partition the set of lines. Affine planes are said to be resolvable since each line can be identified with a unique parallel class. An affine plane of order q contains (q + 1)-many parallel classes, each containing q lines. Note that every point in an affine plane is incident with exactly one line from each parallel class. A new incidence structure can be constructed from an affine plane A by deleting the lines in some fixed set of k > 0 parallel classes. This structure, a partial affine plane A-k of order q, contains q 2 + q - kq lines and q 2 points. Each point in an affine plane is incident with q + 1 lines and each of those lines belongs to a distinct parallel class therefore, every point in A-k is incident with q + 1 - k lines. Thus, the minimum degree, written  (G), of a vertex in the incidence graph is min (q, q + 1 - k ). The new main result of this section is the following.

22

Theorem 5. If A-k is a partial affine plane of order q with 0  k < q parallel classes deleted, then G(A-k ) are (q + 1 - k, q )-regular graphs with cop number between q + 1 - k and q. If k = o(q ), then the graphs described in Theorem 5 have order (1 - o(1))q 2 and cop number (1 - o(1))q . In particular, we can set k = q 1- , for   (0, 1) and obtain infinitely many distinct Meyniel families. Proof of Theorem 5. Since  (G(A-k )) = min (q, q + 1 - k ) and g (G(A-k ))  6, we know by the result of [1] that the cop number is greater than or equal to min (q, q + 1 - k ). This proves the lower bound, and so we now show that (2.4) c(G)  q.

To prove (2.4), we play with q cops. Fix a parallel class which was not deleted, say , and place one cop on each line of the parallel class. As each point is on some line in , the robber must move to some line L to avoid being captured in the first round. which intersects L

Fix a point P of L, and let L be the line of

at P. Move the cop on L to P. Now the robber cannot remain on L without being captured, and so must move to some point. However, each point not on L is joined to some cop, so the robber must move
23

to a point of L . But the unique point on L joined to L is P, which is occupied by a cop. We note that although the proof of Theorem 5 is elementary, it gives a new family of Meyniel extremal graphs.

24

CHAPTER 3

Growth Rates and Minimum Orders of k -Cop-Win Graphs
3.1. Introduction Meyniel's Conjecture is concerned with the cop number of a graph of a given order. The conjecture posits that the asymptotic upper  bound on the cop number for a graph of order n is O( n). In this chapter we consider a different problem: How many k -cop-win graphs of order n exist? In this chapter we define two new parameters mk and Mk that describe the minimum orders of k -cop-win graphs. We continue to define a new function fk (n) to describe the number of k cop-win graphs of order n. In this chapter the values of mk and Mk for k = 1, 2, and 3 are given. The values of M3 and m3 were not previously known. We also determine the values of fk (n) for n  10. These values were computed by an exhaustive computer search that characterizes the cop number of all connected graphs of order 10 or less. In this chapter we also describe the algorithms used to complete this computer search. We conclude this chapter with a novel lower bound for the function fk (n).

25

3.2. Minimum orders and growth rates For an integer k  1, define mk to be the minimum order of a connected graph satisfying c(G)  k . Define Mk to be the minimum order of a connected k -cop-win graph. Note that in general these values may not be the same; in fact mk  Mk since it may be the case that there exists a (k + 1)-cop-win graph of order n but there do not exist any k -cop-win graphs of order less than or equal to n. Although mk is monotonically increasing, Mk may not be monotonically increasing. Only the first three values of mk and Mk are known. It is trivial to see that m1 = M1 = 1 as a single vertex is cop-win. The cycle of order 4, C4 , is the minimum order 2-cop-win graph; thus, m2 = M2 = 4. Through a computer search we have determined that m3 = M3 = 10. Please see Section 3.3 below for the details of the computer search and a complete discussion of our results. The following theorem gives the asymptotic upper bound of the parameter mk and relates Meyniel's conjecture to mk . If Meyniel's conjecture holds, then it also gives the lower asymptotic bound for mk and thus, the asymptotic behaviour of mk .

Theorem 6. Let k > 0 be an integer. (1) mk = O(k 2 ).
26

(2) Meyniel's conjecture is equivalent to the property that mk = (k 2 ). Hence, if Meyniel's conjecture holds, Theorem 6 tells us that mk = (k 2 ). Proof. For item (1), note that the incidence graph of a projective plane has order 2(q 2 + q + 1) and has cop number q + 1, where q is a prime power [16]. This implies that mq+1 = O(q 2 ). Fix k a positive integer. Bertrand's postulate gives us a prime power q such that k  q  2k [7]. Hence, mk  mq  mk+1 = O(q 2 ) = O((2k )2 ) = O(k 2 ). Item (1) follows. For (2), if mk = o(k 2 ), then there exists a connected graph G with order o(k 2 ) and cop number k . This is a contradiction since Meyniel's conjecture implies that c(G) = o(k ). Therefore, by Meyniel's conjecture we have that mk = (k 2 ). For the reverse direction of item (2), suppose for contradiction that mk = (k 2 ) and that Meyniel's conjecture does not hold. We then have that there exists a connected graph G with order n such that  c(G) = k =  ( n).
27

This implies that



n = o(k ), which gives n = o(k 2 ). Therefore, mk  n = o(k 2 )

which is a contradiction.

Determining whether Mk are non-increasing is an open problem. The first few values of mk and Mk suggests that these parameters are equal, for all k  1, but this is also an open problem. Define fk (n) to be the number of non-isomorphic connected k -copwin graphs of order n. Define g (n) to be the number of non-isomorphic (possibly disconnected) graphs of order n and gc (n) to be the number of connected non-isomorphic graphs of order n. By definition of these functions we have that fk (n)  gc (n)  g (n) for all k and n. The table below presents the values of g , gc , f1 , f2 and f3 for small orders. The values of g and gc are from The On-Line Encyclopedia of Integer Sequences [22]. The values for f1 are the result of applying the algorithm to check whether a given graph is cop-win given in [15] to the data from [14]. To compute the values for f2 , the algorithm to check whether c(G) is less than or equal to two given in [4] was applied to the same data set. The value for f2 is then the number of graphs of order n that have cop-number less than or equal to two, minus the number of cop-win graphs of order n. The value for f3 was computed in a similar manner. The algorithms used to complete these computations are discussed in the next section.
28

order n 1 2 3 4 5 6 7 8 9

g (n) 1 2 4 11 34 156 1044 12,346 274,668

gc (n) 1 1 2 6 21 112 853 11,117 261,080

f1 (n) 1 1 2 5 16 68 403 3,791 65,561

f2 (n) f3 (n) 0 0 0 1 5 44 450 7,326 195,519 0 0 0 0 0 0 0 0 0 1

10 12,005,168 11,716,571 2,258,313 9,458,257

As a result of the classification of all connected graphs of order 10 or less we determined that m3 = M3 = 10. Further, the graph that realizes these minimum orders, the Petersen graph, is the unique minimum order 3-cop-win graph. The Petersen graph is a very famous graph that arises often as a counterexample in many areas of graph theory. Similar to the unique minimum order 2-cop-win graph C4 which is 2-regular and has girth 4, it is 3-regular and has girth 5. 3.3. Algorithms for computing cop number Cop-win graphs have been well understood since the introduction of the game Cops and Robbers. Both Nowakowski and Winkler [15], and Quilliot [18] give a characterization of cop-win graphs based on the idea of a cop-win ordering or elimination ordering. These characterizations can be used to define cop-win graphs in an algorithmic manner. A
29

Figure 3.1. The Petersen Graph. cop-win graph can be recognized by the repeated deletion of a vertex with certain adjacency properties called a corner. A corner is a vertex whose closed neighbour set is contained in the closed neighbour set of some other vertex in the graph. More succinctly, a corner is a vertex v such that N [v ]  N [u], for some u  V (G). Corners play an important role in the mechanics of the game of Cops and Robbers. If a robber is on a corner, then the cop can dominate the neighbour set of the robber. If the cop is on a vertex that dominates a corner, then no matter where the robber moves the cop can capture the robber on the next time-step. A critical, though elementary, fact we prove now is the following. Lemma 7. [5] A cop-win graph contains a corner. Proof. Consider the last move of the robber before being captured by the cop. If the cop can capture the robber on the next move, then the cop is in a position that is both adjacent to the robber and adjacent to all of the neighbours of the robber. Hence, the robber is on a corner dominated by the vertex occupied by the cop.
30

Moreover, this result implies that when a corner is deleted from a cop-win graph the resulting graph contains a corner. In a cop-win graph this process can be repeated until only a single vertex remains. The order in which corners are deleted is the cop-win or elimination ordering. If a graph can be reduced to a single vertex (that is, to K1 ) by the successive deletion of corners, then it is called dismantlable. Cop-win graphs are exactly those that are dismantlable. Theorem 8. [5] A graph G is cop-win if and only if it is dismantlable. Proof. By induction on the order of G, we show that if G is a cop-win graph, then G is dismantlable. In the base case G has order 1 and so must be isomorphic to K1 , which is dismantlable. Suppose G has order n  1, where n is some fixed integer. Since G is cop-win, it must contain a corner, say u, by Lemma 7. Let v dominate u. Let H = G - u. We claim H is cop-win. If H is cop-win, then H itself will contain a corner, and this will prove the forward direction by induction. We consider two parallel Cops and Robbers games: one played in G and one in H . The game in H may be considered as being played in G; since H is an induced subgraph of G. The strategy in G may not be sufficient alone to capture the robber in H . For example, the robber may need to leave H to be captured in G. Let the cop in H be labeled C . Let C move as C does in G; however, when C moves to u, then C moves to v. We claim this is a winning strategy for C in H. Let the cop play in G with R restricted
31

to H. Suppose that the cop is about to win in G. But then N [R] is contained in N [C ] in G. As v dominates u, we must have that N [R] is contained in N [C ]. Hence, the robber loses in the next round played in H. Now suppose G is dismantlable. By induction on the order of the graph we show that G is cop-win. As before in the base case G is isomorphic to K1 and hence, is cop-win. Suppose G has order n +1 and is dismantlable for some fixed integer n  1. Since G is dismantlable, it contains a corner. Label the corner u and the vertex dominating it v. The graph resulting from the deletion of u, G - u is also dismantlable. Since G - u has order n, it is cop-win by induction hypothesis. We will show that G is cop-win. A single cop has a winning strategy on G - u, since it is a cop-win graph. A cop can play this strategy on G with the following modification: if the robber is on the vertex u, the cop plays as if the robber is on v the vertex that dominates u. We say the cop moves to capture the shadow of the robber in G - u. If the cop is able to capture the shadow of the robber on the vertex v , then the cop can capture the robber on the vertex u in the graph G because u is a corner dominated by v. Since the cop has a winning strategy on G - u the cop has a winning strategy for G. Therefore, if a graph G is dismantlable, then it is cop-win.

This characterization of a graph in terms of the deletion of corners gives an algorithm for recognizing cop-win graphs. This algorithm is given below in pseudocode. In natural language it can be summarized as follows: While the graph G contains a corner, delete the corner to
32

obtain G . Set G=G and repeat the process. When the graph G no longer contains a corner, and if G  = K1 , then the initial graph G is cop-win; otherwise, G is not cop-win.

Algorithm 1 CHECK COP-WIN Require: G = (V, E ) 1: while |V (G)| > 1 do 2: if G contains a corner, x then 3: V (G)  V (G) \ {x} 4: E (G)  E (G) \ {(a, b)  E (G) : a = x or b = x} 5: else 6: return FALSE 7: end if 8: end while 9: return TRUE

The process of dismantling the graph by successive deletion of corners gives a linear ordering of the vertices, called a cop-win (or elimination) ordering. The cop-win ordering can be used to construct a winning strategy for the cop. The No-backtrack strategy, first described by Clarke and Nowakowski [9], defines a strategy for the cop that results in the capture of the robber in at most n moves. Given a cop-win ordering of G, [n] = [1, 2, . . . , n], define Gi = G {n, n - 1, . . . , i} for i  [n]. The graph Gi is the induced subgraph of G restricted to vertices not appearing in the cop-win ordering before i. Note that G1 = G and Gn is just the vertex n. If u is a corner dominated (or covered) by v in G, then a retraction is a mapping f : G  G - u
33

defined by   v f ( x) =  x if x = u, otherwise.

Each deletion of a corner in the graph G corresponds to a retraction. The No-backtrack strategy is defined by the cop-win ordering which can be encoded in the composition of retractions. Let fi : Gi  Gi+1 be the retraction mapping i onto the vertex that dominates i in Gi , for each 1  i  n - 1. Define F1 to be the identity mapping on G, defined by F1 (x) = x for all x  V (G). For 2  i  n define F i = f i- 1  . . .  f 2  f 1 . Since the maps fi correspond to the deletion of corners, the maps Fi correspond to the successive deletion of all corners the cop-win ordering up to but not including i. Note that for all i, since the retractions fi either map a vertex to itself or to an adjacent vertex, Fi+1 (x) and Fi (x) are equal or adjacent because they are composed of the retractions fi . The No-backtrack strategy is as follows. The cop begins on Gn , which is just the vertex n. In every round the cop plays a winning strategy on the graph restricted to the vertices not appearing in the cop-win ordering before i, namely Gi . The cop determines the position of the "shadow" of the robber on Gi and captures the "shadow" of the robber in Gi . In the first round the cop plays on Gn , in which there is only one possible position for the robber, n. Note that every vertex in G maps to vertex n under Fn . In the next round the cop computes Fn-1 (u) where u is the vertex of G currently occupied by the
34

robber. The vertex determined by the map Fn-1 (u) is the shadow of the robber on Gn-1 . We think of the shadow as the position of the robber in the restricted graph. The cop then moves to capture the robber on Gn-1 . In each remaining round the cop repeats this process. First, the cop determines the position of the shadow robber by computing Fi (u), where i is the current round numbered from n to 1 and u is the vertex currently occupied by the robber and then moves to capture the shadow robber. After n rounds the cop is playing on G1 = G and can capture the robber. We now consider an example. Consider the application of the copwin algorithm to the graph G in Figure 3.2 below. We note that the order in which we delete corners is not unique. The graph G contains four corners: a, c, d, and e. We could begin the algorithm by deleting any one of these corners.

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

b
x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

c
x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

a

d

e

f

Figure 3.2. The graph G, a cop-win graph.

Suppose we begin by deleting a, and note that it is dominated by the vertices b and e. Again we could choose to record either of these as the dominator for a, we will choose b. The function f1 then becomes:
35

  b f1 (x) =  x

if x = a, otherwise.

It is useful to note that every retraction fi maps a corner to a vertex that dominates it and keeps all other vertices fixed. In order to represent the retraction all that is necessary is the corner and dominating vertex. Thus, the first retract could be written as f1 : a  b. It can be easily checked that (a, e, b, f, c, d) is a valid cop-win ordering for the graph in Figure 3.2. The cop-win ordering for the graph G is given in Figure 3.3.
3 b
x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

5 c
x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

1 a

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

e 2

f 4

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

d 6

Figure 3.3. A cop-win ordering for the graph G. The following is a list of possible retractions that correspond to the given cop-win ordering: f1 : a  b. f2 : e  b. f3 : b  f. f4 : f  c. f5 : c  d.
36

The maps Fi are constructed from last used to first used. The first map computed is F1 which is the same as f1 . This function as above maps a  b and leaves all other vertices fixed. In each step of constructing the maps Fi we only need to compose the previous F map with the next f map. This can be seen by noting that we can write Fi , the composition of the first i - 1 f -maps as Fi = fi  Fi-1 . The next map can then be computed as F2 = f2  F1 . The retraction f2 maps e  b. The function F2 then maps both vertices a and e to vertex b and leaves all others fixed. Here are the explicit mappings Fi for 1  i  5.   b F 1 ( x) =  x   b F 2 ( x) =  x   f F 3 ( x) =  x   c F 4 ( x) =  x if x = a, otherwise.

if x = a or e otherwise.

if x = a, b or e otherwise.

if x = a, b, e or f otherwise.

F 5 ( x) =

d

for all x  V (G)

37

Now, the maps, Fi can be used to determine the cops strategy. The cop's first move is determined by F5 , so the cop will always begin on the vertex d. It makes sense that the cops initial decision should not depend on the robber's actions since the cop chooses the start vertex before the robber has been placed in the graph. Suppose the robber chooses the vertex a, the vertex with the greatest distance from the initial position of the cop. The next move of the cop is then computed by finding F4 (a), which indicates the cop should move to the vertex c. Suppose the robber moves to the vertex e; since F3 (e) = f , the cop moves to f. Now, the robber's only option is to move to the vertex a. The map F2 (a) = b, tells the cop to move to the vertex b which dominates the position of the robber thus, the cop wins in the next round regardless of the choice of the robber in the next round.

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

b
x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

c
x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x x

R a

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

d

e

f C

Figure 3.4. The cop computes her second-to-last move, F2 (a) = b, and so moves to b.

38

3.4. The k -cop-win Algorithm The problem of deciding whether a given graph is cop-win is relatively easy computationally speaking. Although it is a more difficult problem, there is an algorithm to check whether a graph has cop number k or less for a fixed k. This algorithm, originally due to Berarducci and Intriglia [2], relies on the idea of a graph product. The graph product of two graphs, G and H , is a new graph. The vertices of the product are the Cartesian product of the vertices of the original graphs. That is, each vertex of the product graph is an ordered pair of vertices from the constituent graphs. There are several different types of graph product. The difference between these types of graph product is in how the edges of the product graph are determined. The edges of all graph products are determined by the edges of the original graphs. The most common graph product is the Cartesian product, denoted G H. Suppose (g1 , h1 ) and (g2 , h2 ) are two vertices in V (G H ). An edge exists between (g1 , h1 ) and (g2 , h2 ) if they are adjacent in one component and equal in the other. Note that we write g  h if the vertices g and h are adjacent. More precisely, if g1  g2 and h1 = h2 or g1 = g2 and h1  h2 . Another common graph product is categorical product, denoted G Ã H. Edges are adjacent in the categorical product if the components are both adjacent in the original graphs, g1  g2 and h1  h2 . The graph product used by the algorithm to decide whether a graph has cop number k or less is the strong product, denoted G H. This notation hints

at the relationship it shares with the Cartesian product and the categorical product. The edge set of the strong product can be thought of
39

as the union of the edge sets of the Cartesian and categorical product. There is an edge between (g1 , h1 ) and (g2 , h2 ) if and only if: g1  g2 and h1 = h2 ; or g1 = g2 and h1  h2 ; or g1  g2 and h1  h2 . Vertices in the product are adjacent if they are adjacent or equal in each component. Figure 3.4 below shows the strong product of two graphs in terms of the Cartesian and categorical products.

P4

P3

P3

P4
Categorical Product Cartesian Product

Figure 3.5. The graph G, a cop-win graph. The product of graphs can be generalized to the notion of the exponentiation of a graph. Like the exponentiation of numbers, exponentiation of graphs is just repeated application of products. The k th strong power of a graph is constructed in a similar manner to the product of graphs. A vertex in the k th strong power of a graph G is a k -tuple of vertices of G. A pair of k -tuples are adjacent if they are adjacent or equal in each component. The algorithm to check whether a graph is k -cop-win, for a fixed k uses the k th strong power, written
40
k

G, to

simulate the movements of the cops. Each coordinate of the k -tuple represents the position of the k cops in the original graph. Using this approach the algorithm rules out possible positions for the robber in the original graph. The following theorem is the basis of this algorithm. Note that 2V (G) is the set of all subsets of V (G). Theorem 9. [2] Suppose k  1 is an integer. Then c(G) > k if and only if there is a mapping f : V ( properties. (1) For every u  V (
k k

G)  2V (G) with the following

G),

 = f (u)  V (G)\NG [u]. (2) For every uv  E (
k

G),

f (u)  NG [f (v )]. We omit the proof, which can be found in [4]. The value of f (u) is the set of vertices in the graph G such that, if the cops occupy the k vertices in G specified by the vertex u, then the robber has a strategy to escape capture in the next round. If any one of the maps f (u) is empty for some u in V (
k

G), then the robber

can be captured by the cops from this position. That is, k or fewer cops have a winning strategy on the graph G. Algorithm 2 gives the statement of the algorithm in pseudocode. The first phase of the algorithm is to initialize the sets f (u) to be V (G)\NG [u], where NG [u] contains the k vertices of G that make up u, as well as their neighbours in G. This step rules out the vertices that
41

Algorithm 2 CHECK K-COP-WIN Require: G = (V, E ), k  0 1: initialize f (u) to V (G) \ NG [u], for all u  V ( k G) 2: repeat 3: for all (u, v )  E ( k G) do 4: f (u)  f (u)  NG [f (v )] 5: f (v )  f (v )  NG [f (u)] 6: end for 7: until the value of f is unchanged or f (u) =  for some u  V ( 8: if there exists u  V ( k G) such that f (u) =  then 9: return c(G)  k 10: else 11: return c(G) > k 12: end if

k

G)

are dominated by the cops when they are in the position specified by u. If after this initialization phase, we have that f (u) = , then k or fewer cops can form a dominating set in G. The main phase of the algorithm uses the second rule to rule out possible escape routes for the robber. The second rule of Theorem 9 guarantees that the robber will always have a way to get from one safe set of vertices to another, from f (u) to f (v ) or from f (v ) to f (u), along the edge uv. Also note that if any f (u) is empty at any point in the algorithm, then by repeated application of the second rule of Theorem 9, all maps will eventually be empty. If f (u) is empty for any u in V (
k

G), then there exists a position in

the graph from which the robber cannot escape and therefore there is a strategy for k or fewer cops to win in G. Note that Algorithm 2 has polynomial running time. The worst case running time of this algorithm O(n3k+3 ) (see[4]). The main contribution to the running time of the algorithm comes from lines 2Â­7.
42

Since the cardinality of f (u) is reduced by at least one in every iteration of lines 2Â­7. This section is then executed at most O(nk+1 ) times. In each of these iterations all edges of the product graph ing processed in lines 3Â­6. Since there are at most original graph, there are at most ( n(n2-1) )k edges in ing through the edges of
k n(n-1) 2 k k

G are be-

edges in the

G. Thus, iterat-

G has computational complexity O(n2k ).

Finally, the operation of taking intersections and finding the neighbourhoods of each vertex (lines 4Â­5) have complexity O(n) and O(n2 ), respectively. The total running time is then the product of these complexities as follows: O(nk+1 )O(n2k )(O(n) + O(n2 )) = O(nk+1 )O(n2k )O(n2 ) = O(nk+1 )O(n2k+2 ) = O(n3k+3 ). 3.5. Lower bounds Recall from the beginning of this chapter that fk (n) is the number of non-isomorphic connected k -cop-win graphs of order n and that g (n) is the number of non-isomorphic (possibly disconnected) graphs of order n. As previously mentioned, we have a trivial upper bound on fk (n) in terms of g (n): fk (n)  g (n) for all k and n. In this section we give an original lower bound on fk (n) in terms of g (n). We begin with a lemma that shows that given a k -cop-win graph, we can construct another k -cop-win graph of arbitrarily large order.

43

Theorem 10. Given graph G of order n and a k -cop-win graph H of order mk , there exists a k -cop-win graph G constructed from G and H with order n + mk + 1. Proof. Construct G as follows. Attach a new vertex, say x, to all vertices of G. The vertex x is universal in the new graph G  {x}. Attach x to a fixed vertex in H, say y, to form G from H and G  {x}.

G'

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

H

y

x

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

G

Figure 3.6. The construction of G . If there are less than k cops, then the robber has a winning strategy. The robber can remain in H since k cops are required to win in H . Thus, c(G )  k . Now to show c(G )  k we give a winning strategy for k cops in G . Place one cop on x and the remaining k - 1 cops on some vertices of G.
44

G'

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

J'
h

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

H

H

yG

yJ

h

xG

xJ

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

G

h

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

J

Figure 3.7. The isomorphism h : G  J . The robber cannot start in G since the vertices of G are dominated by x. The robber then begins in H . The cops can then all move to play their winning strategy for k cops on H . If the robber leaves H , then the cops play as if the robber is on y . Eventually either the robber is caught in H or the robber has moved to G  {x}. If the robber has moved to V (G)  {x}, then at least one cop occupies y . One of these cops moves to x which dominates G and the robber is caught in the next round. Theorem 11. Suppose that n > mk and let G and J be connected graphs of order n and H be a minimum order connected k -cop-win graph of order less than n. Let G and J be the graphs constructed as above. If G J , then G J.
45

Proof. Suppose for contradiction that G  = J , but G

J and

let h be an isomorphism from G to J . We claim that the vertex with maximum degree in G is xG . The degree of xG is n + 1 since it is connected to all vertices of G and one vertex of HG . It is the unique vertex with maximum degree since no vertex in HG can have more than n - 1 neighbours in HG and a vertex in G has at most n - 1 neighbours in G. A similar argument shows that the unique vertex with maximum degree in J is xJ . Since xG and xJ are the unique vertices with maximum degree in G and J , respectively, h must map xG to xJ . The vertex yG is the unique vertex of G that is adjacent to xG and adjacent to vertices that are not adjacent to xG . Similarly, yJ is the unique vertex in J adjacent to xJ and no other neighbours of xJ . Thus, yG must be mapped to yJ by f . This implies that h maps HG to HJ and that the restriction of h to G is an isomorphism mapping G to J . This contradicts our assumption that G is not isomorphic to J . Therefore, G is not isomorphic to J . The following theorem gives us the central result of this section. The theorem gives a lower bound for the number of k -cop-win graphs of a given order in terms of the function g (n). Theorem 12. (1) For all n > 1, g (n - 1)  f1 (n). (2) For k > 1 and all n > 2mk , g (n - mk - 1)  fk (n).
46

Proof. For item (1), fix a graph G of order n - 1. Form G by adding a universal vertex to G. The graph G is cop-win since placing a single cop on the universal vertex is a winning strategy for a cop. If G H , then we show that G H . Suppose for contradiction that

there exists an isomorphism h : G  H . Let GU and HU be the sets of universal vertices in G and H , respectively. The isomorphism h must map GU to HU . Fix some vertex in GU , call it x. If h is restricted to the vertices of G excluding x, then we have that h G - x : G - x  H - h(x) is an isomorphism. This is a contradiction since G - x  = G and H - h(x)  = H, and thus, G  = H. Since for every isomorphism type of order n - 1 we can construct a cop-win graph of order n it follows that for all n > 1, g (n - 1)  f1 (n). For (2) note that there are g (n - mk - 1)-many non-isomorphic graphs of order n - mk - 1. By Theorem 10 for each of these g (n - mk - 1)-many graphs, a k -cop-win graph of order n can be constructed. By Theorem 11 each of these k -cop-win graphs are non-isomorphic so long as n - mk + 1  mk . But the latter inequality is equivalent to n > 2mk , which is our hypothesis. Therefore, there are at least g (n - mk - 1) distinct k -cop-win graphs of order n.

47

CHAPTER 4

The Game of Cops and Robbers on Hypergraphs
4.1. Introduction While the game Cops and Robbers is usually played on a graph, the game can be played on many other mathematical structures. One such structure is a hypergraph. A hypergraph is set of vertices and subsets of vertices, called hyperedges. Hypergraphs are a generalization of graphs, where hyperedges have cardinality 2. Instead of connecting two vertices like edges, hyperedges can connect some number of vertices. In this chapter we give some definitions and notation to describe hypergraphs and discuss the game of Cops and Robbers played on hypergraph. We conclude the chapter with a discussion of some open problems.

Figure 4.1. A hypergraph with hyperedges of cardinality 3 and 5.

49

4.2. Definitions and Notation If a vertex is contained in just one hyperedge, then we call this vertex internal. We call a vertex that is contained in two or more hyperedges external.

a

b

Figure 4.2. The vertex a is internal, the vertex b is external. In contrast to the notion of regularity in graphs, in hypergraphs, regularity describes the number of vertices in each edge rather than the number of edges incident with a vertex. A hypergraph is k -regular if every hyperedge contains exactly k vertices. or the remainder of the chapter, all the hypergraphs we consider will be k -regular for some k > 1. We say that a hypergraph is t-joined if each intersection of hyperedges contains exactly t vertices.

Figure 4.3. A 5-regular 2-joined hypergraph. Similar to the incidence graphs of designs, we can define an incidence graph of a hypergraph. The graph of a hypergraph H , written G(H ), is a graph with the vertices of H and an edge between these vertices if they are connected by a hyperedge in H. That is, V (G(H )) = V (H ) and (u, v )  E (G(H )) if and only if {u, v }  e for some e  E (H ). Note that a 1-joined, 2-regular hypergraph H is isomorphic to its own underlying graph.
50

Figure 4.4. The graph G(H ) for H, the hypergraph in Figure 4.1. In the subject of graph theory there are many types of special graphs. Paths and cycles are among the most common of these. We define a hypergraph analogue of paths and cycles. A hyperpath is a sequence of hyperedges E1 , E2 , . . . , Ek , such that Ei and Ei+1 are tjoined, for some t > 0, and for i = 1, 2, . . . , k - 1 and Ei  Ej =  when j = i + 1 mod k .

Figure 4.5. A hyperpath. For k > 2 an integer, a k -hypercycle is a collection of k hyperedges, Ei , with two hyperedges Ei and Ej incident if i = j + 1 (mod k ). For more information about hypergraphs we direct the reader to the books by Berge [3] and Voloshin [23].
51

Figure 4.6. A hypercycle. 4.3. Cops and Robbers on hypergraphs The game of Cops and Robbers played on a hypergraph is analogous to the game played on graphs. Some set of cops choose vertices to occupy, and then the robber choose a vertex. The players can move to vertices by moving from their present vertex u to any vertex v such that u and v are in hyperedge. The remaining rules of the game, along with the definition of the cop number of hypergraphs is analogous to the case for graphs. As before, a hypergraph where one cop has a winning strategy is called cop-win. Corners are defined analogously as in graphs. Hyperpaths are cop-win. To see that a hyperpath is cop-win we will consider a strategy for a cop that relies upon the following lemmas. Lemma 13. A cop playing on a connected hypergraph with at least two hyperedges can always move from an external vertex to another distinct external vertex. Proof. As the cops can move from any vertex of a hyperedge to any vertex of an incident hyperedge, the lemma follows.
52

Lemma 14. The cop can play a winning strategy by remaining on external vertices until, perhaps, the final move of the game. Proof. By Lemma 13, the cop can always travel from external vertex to external vertex. To capture a robber on an internal vertex, the cop needs only to occupy the same hyperedge as the robber. If the robber is on an external vertex, then the cop can follow the robber to the next edge by traveling along external vertices. Theorem 15. If Hp is a hyperpath, then c(Hp ) = 1. Proof. The cop begins on an external vertex of the edge E1 at one end of the path. By Lemma 14 the cop may move from external vertex to external vertex though the path. The cop moves via external vertices from one end to the other. If the cop encounters the robber on an internal vertex, then the cop can capture the robber on the next move. Theorem 16. If Hc is a hypercycle, then c(Hc ) = 2. Proof. If the game is played on hypergraph with a single cop, then the robber can always evade the cop. The robber evades capture by moving on external vertices around the cycle. Thus, hypercycles are not cop-win. However, if the game is played with two cops, the following strategy for the cops is sufficient to win the game. Place the first cop C1 on an external vertex of edge E1 , place the second cop C2 on the edge Ek . Since there are no edges in between the edges E1 and Ek , the
53

robber cannot choose to begin between the cops. The cops can then each move away from each other on each successive round, with C1 , moving to edges with higher index, and C2 moving to edges with lower index. Eventually, the cops will occupy the same edge and the robber will be caught on the next round. Consider a Steiner 2-design, or a 2-(v ,k ,1) design. Recall from Chapter 2 that 2-(v ,k ,1) designs are a set of v points, and a set of blocks of size k , such that any two points determine a unique block. We assume always that v > k. Steiner 2-designs, and indeed any other design, can be thought of as a hypergraph with the vertices being points and hyperedges defined by the blocks. In the following theorem we show that Steiner 2-designs are in fact cop-win. Theorem 17. 2-(v, k, 1) designs are cop-win. Proof. The cop begins on some vertex, and the robber then chooses some vertex. Since any two points uniquely determine a line the positions of the cop and robber uniquely determine a hyperedge. Thus, the cop can capture the robber in the round after the robber chooses a vertex. In fact, any position that the cop occupies in a Steiner 2-design dominates the entire graph. That is, the cop is adjacent to every vertex in the hypergraph, a universal vertex in the hypergraph. We define a corner in a hypergraph to be a vertex x such that x and all vertices connected to x by a hyperedge are also adjacent via hyperedges to some other vertex, just as in the case of graphs. This leads us to think we
54

might be able to characterize cop-win hypergraphs in the same way we characterize cop-win graphs. The following theorem shows that this is not the case. The proof of this theorem shows that the result of deleting a corner in a cop-win hypergraph is not necessarily cop-win. Formally, H - x is the result of removing the vertex x and all edges incident with x from the hypergraph H. Theorem 18. There exist cop-win hypergraphs H , such that for all vertices x, the hypergraph H - x is not cop-win. Proof. We choose H to be the hypergraph defined from a fixed Steiner 2-design. Since all vertices can be dominated by any vertex in the hypergraph, all vertices in H are corners. Delete one of them, say x. Suppose the cop begins at vertex C1 of H - x. In order to avoid the cop in the first round the robber selects a vertex that is on the hyperedge that has been deleted that contained both x and C1 . This hyperedge must exist and is unique since any two points determine a unique line. Call this point occupied by the robber R1 . Now, in order to capture the robber, the cop moves to some point C2 which is not on the line determined by x and C1 . To evade the cop the robber must move to some vertex on the deleted hyperedge determined by x and C2 . If the parameter k  3, then such a vertex must exist. If there exists a vertex R2 that is not equal to x or C2 , on the line determined by x and C2 , then there is a hyperedge connecting R1 and R2 . This hyperedge could not have been deleted since it is not
55

C2 R2

R1 x

C1

Figure 4.7. The deleted hyperedges give the robber an escape route. incident with the deleted vertex x. The robber now simply moves to R2 to evade capture. This escape strategy for the robber can be repeated indefinitely. Since the robber can escape the cop indefinitely, H - x is not cop-win. The preceding theorem gives the following corollary. Corollary 19. Cop-win hypergraphs cannot be characterized by successive deletion of corners. Many questions about the game of Cops and Robbers on hypergraphs remain open. The principal open problem in this area finding a characterization of cop-win hypergraphs. Many other problems about generalizing the results on graphs to hypergraphs remain open. In this chapter we give examples of 2-cop-win hypergraphs that are analogues of 2-cop-win graphs. Are there other classes of 2-cop-win hypergraphs that are not analogues of 2-cop-win graphs? Another area of interest is the asymptotic behaviour of cop-number in hypergraphs. Is there an analogue of Meyniel's conjecture for hypergraphs?
56

CHAPTER 5

Conclusions and Future Work
5.1. Summary In Chapter 2 we gave some background on Meyniel's Conjecture, and discussed some results related to the conjecture. We introduced so-called Meyniel extremal graphs which realize the upper bound in the conjecture. Using the incidence graphs of projective and partial affine planes we gave new examples of such infinite families satisfying certain regularity conditions. In Chapter 3 we considered the minimum orders of a k -cop-win graph and their relation to Meyniel's Conjecture. We characterized the cop number of all connected graphs of order 10 or less. We also discussed the theoretical underpinnings of the algorithm used to obtain the computational results. We defined two new parameters mk and Mk that describe the minimum orders of k -cop-win graphs and related the asymptotic behaviour of these parameters to Meyniel's Conjecture. In the course of characterizing the cop number of connected graphs of order 10 or less we determined the previously unknown values of M3 and m3 . We also defined a new function fk (n) to describe the number of k -cop-win graphs of order n. We concluded Chapter 3 with a lower bound for the function fk (n).

57

In Chapter 4 we examined the game of Cops and Robbers played on hypergraphs. We discussed some terminology to describe hypergraphs and gave examples of hypergraphs and their cop number. The central result of this chapter was that the characterization of cop-win graphs by successive deletion of corners does not characterize cop-win hypergraphs.

5.2. Open Problems Meyniel's Conjecture on the asymptotic upper bound of the cop number of a connected graph is perhaps the deepest open problem in Cops and Robbers research. The conjecture is that for a connected graph G of order n,  c(G) = O( n). The conjecture is far from being proven for general connected graphs. In fact, even the so-called soft Meyniel's conjecture is open, which states that for a fixed constant c > 0 and a connected graph G of order n, c(G) = O(n1-c ). Some work has been done towards proving the conjecture for some special classes of graphs such as random graphs [17]. However, there are many classes of graphs for which there is no proof of the conjecture. Another interesting problem is looking at the lower bounds for the cop number. Recently Pralat [16] showed that c(G)  n - n0.2625 . 2
58

It remains to be shown whether this is the best possible lower bound. Recall from Chapter 3 that in general mk may not be equal to Mk . It may be the case that there exists a (k + 1)-cop-win graph of order n but there do not exist any k -cop-win graphs of order less than or equal to n, thus mk  Mk . Although mk is monotonically increasing, it is unknown whether Mk is monotonically increasing. The first few values of mk and Mk suggests that these parameters are equal, for all k  1, but there is no proof of this intuition. In Chapter 3 we determined that the Petersen graph is the unique minimum order 3-cop-win graph. While an exhaustive computer search is sufficient to show this fact, a direct proof of this fact would be preferable. The minimum order of a 4-cop-win graph remains unknown. Perhaps identifying the minimum order of a 4-cop-win graph would give insight into the structure of small graphs with large cop number. The minimum order 2-cop-win and 3-cop-win graphs suggest that minimum order k -cop-win graphs are k -regular and have relatively large girth. The study of Cops and Robbers on hypergraphs and other incidence structures is in its infancy. As such very little is known about the game on hypergraphs. The first step towards understanding the game on these structures is developing a characterization of cop-win hypergraphs. In this document all examples of 2-cop-win hypergraphs are analogues of 2-cop-win graphs. It would be interesting to see examples of 2-cop-win hypergraphs that are not analogues of 2-cop-win

59

graphs. Another area of interest is the asymptotic behaviour of copnumber in hypergraphs and the problem of developing an analogue of Meyniel's Conjecture for hypergraphs.

60

APPENDIX A

Source Code
This appendix gives implementations of three algorithms from Chapter 3. All programs given here are implemented in the C programming language and were compiled using the Gnu Compiler Collection (gcc). These programs have been successfully compiled and run on Windows XP, Windows Vista and Windows 7 using MinGW and on Ubuntu. All graph data used by these program is specified by adjacency matrices in text files, delimited by the number of vertices in the graphs. The data on connected graphs used came from Brendan McKay's Homepage in the graph6 (.g6) format and was converted to adjacency matrix format using the program `showg' from the nauty graph package. Instructions on using nauty and showg are available on Brendan McKay's Homepage. In order to convert a list of graph in the .g6 format to the adjacency matrix format used here, run `showg' from the command line as follows:
showg -aq input.g6 output.txt

The file "input.g6" specifies the graph6 file containing the graphs to be converted to adjacency format. The arguments "output.txt" is optional and allows the user to specify the output filename. The output file from the program `showg' can be used as the data for any of the programs presented here. For example, the following text file is
61

a representation of the Petersen graph that is suitable for use by these programs:

Listing A.1. Input format for the Petersen graph.
1 2 3 4 5 6 7 8 9 10 11 12 10 0100110000 1010001000 0101000100 0010100010 1001000001 1000000110 0100000011 0010010001 0001011000 0000101100 10

The first program is the cop-win checker based on the algorithm given by Nowakowski and Winkler in [15] to check whether a given graph is cop-win or not. The second program is a modification of the first program that computes a cop-win ordering of a graph and then simulates the game allowing the user to play the game against a cop controlled by the program. The third program is an implementation of the algorithm to check whether a graph has c(G)  2. This implementation is similar in conception to the algorithm given by Bonato and Chiniforooshan in [4].
62

A.1. Cop-win Checker

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37

/* Cop-win Checker Liam Baird liam.baird@gmail.com Input: a list of graphs in adjacency matrix format delimited by the number of nodes in each graph. Output: a list of statements that state whether each graph in the list is cop-win or not. */ #include<stdlib.h> #include <time.h> #include<stdio.h> #define MAXNOV 10 #define TRUE 1 #define FALSE 0 int nov=0; struct node { int val; struct node * next; }; typedef struct node node; void initialize(node *graph[]){ int k; for(k=0;k<MAXNOV;k++){ graph[k] = NULL; } } void printgraph(node *graph[],int graph_no){ int q; node *curr=NULL; if(graph_no==0){ printf("GRAPH:\n"); }else{ printf("GRAPH #%d:\n",graph_no);
63

38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79

} for(q=0;q<MAXNOV;q++){ curr=graph[q]; while(curr!=NULL) { if(curr->val!=q){ printf("(%d,%d)\n",q,curr->val); } curr = curr->next ; } } } void deletegraph(node *graph[]){ int q=0; node *curr=NULL; node *prev=NULL; for(q=0;q<MAXNOV;q++){ curr=graph[q]; prev=graph[q]; while(curr!=NULL) { curr = curr->next; free(prev); prev=curr; } graph[q] = NULL; } } void deletenode(int i,node *graph[]){ int q=0; node *curr=NULL; node *prev=NULL; curr=graph[i]; prev=graph[i]; while(curr!=NULL) { curr = curr->next; free(prev);
64

80 prev=curr; 81 } 82 83 graph[i] = NULL; 84 85 for(q=0;q<MAXNOV;q++){ 86 curr=graph[q]; 87 prev=graph[q]; 88 if(curr!=NULL){ 89 if(curr->val==i){ 90 graph[q]=curr->next; 91 free(curr); 92 curr=graph[q]; 93 prev=graph[q]; 94 curr=curr->next; 95 }else{ 96 curr=curr->next; 97 } 98 } 99 100 while(curr!=NULL) { 101 if(curr->val==i){ 102 prev->next=curr->next; 103 free(curr); 104 curr=prev->next; 105 }else{ 106 prev=prev->next; 107 curr=curr->next; 108 } 109 } 110 } 111 } 112 113 int checkcorner(int i,int j,node *graph[]){ 114 //compares two adjacency lists. 115 node *a=graph[i]; 116 node *b=graph[j]; 117 118 if ((a==NULL)||(b==NULL)){ 119 return(FALSE); 120 } 121
65

122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163

while (TRUE){ if (( a == NULL && b == NULL )||( a==NULL )){ return(TRUE); }else if (( b == NULL )||(a->val < b->val)){ return(FALSE); }else if (b->val < a->val){ if (b->next!=NULL){ b=b->next; }else{ return(FALSE); } }else{ a = a->next; b = b->next; } } } int hascorner(node *graph[]){ int i,j; for(i=0;i<nov;i++){ for(j=0;j<nov;j++){ if(checkcorner(i,j,graph)){ if(i!=j){ return(i); } } } } return(-1); } int getsize(node *graph[]){ int q=0,size=0; node *curr=NULL; for(q=0;q<MAXNOV;q++){ curr=graph[q]; while(curr!=NULL) { size++; curr = curr->next ; }
66

164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205

} return(size); } int main(void) { node *curr=NULL,*tail=NULL; node *graph[MAXNOV]; char ch; char str[5]; char filenamein[20]; char filenameout[20]; int i=0,j=0,k,c=0,q,graph_no=0,copwin_count=0; //initialize vertices initialize(graph); //prompt for filename printf("please enter graph filename\n"); scanf("%19s",filenamein); strcpy(filenameout,filenamein); //open file FILE *input=fopen(strcat(filenamein,".txt"),"r"); FILE *output=fopen(strcat(filenameout,"r.txt"),"w"); fgets(str,5,input); nov=atoi(str); printf("nov = %d\n",nov); graph_no++; //get input for(ch=getc(input);ch!=EOF;ch=getc(input)){ if(i==nov){ c=hascorner(graph); while(c>=0){ deletenode(c,graph); c=hascorner(graph); } if(getsize(graph)==1){ fprintf(output,"Graph #%d is COPWIN\n",graph_no); copwin_count++; }else{
67

206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 } 247

fprintf(output,"Graph #%d is not COPWIN\n",graph_no); } deletegraph(graph); i=0; j=0; //increment graph # counter graph_no++; //grab next line fgets(str,5,input); } else if (ch=='\n'){ //new row i++; //one more row j=0; //start from zeroth column } else if ((ch=='1')||(i==j)){ //add edge i,j curr = (node *)malloc(sizeof(node)); //allocate memory curr->val = j; //set value curr->next=NULL; //set next //if this is the first edge for this node if (graph[i]==NULL){ graph[i]=curr; } else{ tail->next=curr; } tail=curr; //increment j j++; }//end add edge i,j else if (ch=='0'){ //printf("L: ch=0\n"); //add no vertex //increment j j++; }

68

248 249

printf("%d of %d graphs of order %d are copwin\n", copwin_count,graph_no-1,nov); fprintf(output,"%d of %d graphs of order %d are copwin\n", copwin_count,graph_no-1,nov);

250 251 return(0); 252 }

69

A.2. Cops and Robbers Game Simulator

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35

/* Cops and Robber Simulator Liam Baird liam.baird@gmail.com Input: a list of graphs in adjacency matrix format delimited by the number of nodes in each graph. Output: a list of statements that specify whether each graph in the list is cop-win or not. Also determines a cop-win ordering. If the graph is cop-win, then the program simulates a game of Cops and Robbers. The program allows the user to specify the movements of the robber with the program determing the movements of the cop using the cop-win ordering. */ #include<stdlib.h> #include <time.h> #include<stdio.h> #define MAXNOV 20 #define TRUE 1 #define FALSE 0 int nov=0; struct node { int val; struct node * next; }; typedef struct node node; void initialize(node *graph[]){ int k; for(k=0;k<MAXNOV;k++){ graph[k] = NULL; } } void printgraph(node *graph[],int graph_no){ int q;
70

36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77

node *curr=NULL; if(graph_no==0){ printf("GRAPH:\n"); } else { printf("GRAPH #%d:\n",graph_no); } for(q=0;q<nov;q++){ curr=graph[q]; while(curr!=NULL) { if(curr->val!=q){ printf(" (%d,%d) ",q,curr->val); } curr = curr->next ; } printf("\n"); } } void deletegraph(node *graph[]){ int q=0; node *curr=NULL; node *prev=NULL; for(q=0;q<MAXNOV;q++){ curr=graph[q]; prev=graph[q]; while(curr!=NULL) { curr = curr->next; free(prev); prev=curr; } graph[q] = NULL; } } void deletenode(int i,node *graph[]){ int q=0;
71

78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119

node *curr=NULL; node *prev=NULL; //delete node with index i curr=graph[i]; prev=graph[i]; while(curr!=NULL) { curr = curr->next; free(prev); prev=curr; } graph[i] = NULL; for(q=0;q<MAXNOV;q++){ curr=graph[q]; prev=graph[q]; if(curr!=NULL){ if(curr->val==i){ graph[q]=curr->next; free(curr); curr=graph[q]; prev=graph[q]; curr=curr->next; }else{ curr=curr->next; } } while(curr!=NULL) { if(curr->val==i){ prev->next=curr->next; free(curr); curr=prev->next; } else{ prev=prev->next; curr=curr->next; } }
72

120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161

} } void copygraph(node *graph[],node *copygraph[]){ int q; node *curr=NULL; node *copy=NULL; node *tail=NULL; for(q=0;q<MAXNOV;q++){ curr=graph[q]; while(curr!=NULL) { //add edge i,j copy = (node *)malloc(sizeof(node)); //allocate memory copy->val = curr->val; //set value copy->next=NULL; //set next //if this is the first edge for this node if (copygraph[q]==NULL){ copygraph[q]=copy; }else{ tail->next=copy; } tail=copy; curr=curr->next; } } } int checkcorner(int i,int j,node *graph[]){ node *a=graph[i]; node *b=graph[j]; if ((a==NULL)||(b==NULL)){ return(FALSE); } while (TRUE){ if (( a == NULL && b == NULL )||( a==NULL )){ //equal or a smaller => corner return(TRUE);
73

162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203

}else if (( b == NULL )||(a->val < b->val)){ //b smaller than a => not corner return(FALSE); }else if (b->val < a->val){ //b larger than a => increment b if (b->next!=NULL){ b=b->next; }else{ return(FALSE);} }else{ a = a->next; b = b->next; } } } int hascorner(node *graph[],int *c,int *ci){ int i,j; for(i=0;i<nov;i++){ for(j=0;j<nov;j++){ if(checkcorner(i,j,graph)){ if(i!=j){ *c=i; *ci=j; return(1); } } } } *c=-1; *ci=-1; return(-1); } int getsize(node *graph[]){ int q=0,size=0; node *curr=NULL; for(q=0;q<MAXNOV;q++){ curr=graph[q];
74

204 while(curr!=NULL) { 205 size++; 206 curr = curr->next ; 207 } 208 } 209 return(size); 210 } 211 212 void relabel(node *graph[],int labeling[]){ 213 int i; 214 node *temp[MAXNOV]; 215 node *curr,*prev; 216 217 copygraph(graph,temp); 218 219 //remove reflexive edges 220 for(i=0;i<nov;i++){ 221 222 curr=graph[i]; 223 224 if(curr!=NULL){ 225 if(curr->val==i){ 226 graph[i]=curr->next; 227 free(curr); 228 curr=graph[i]; 229 prev=graph[i]; 230 curr=curr->next; 231 }else{ 232 curr=curr->next; 233 } 234 } 235 236 while(curr!=NULL){ 237 if(curr->val==i){ 238 prev->next=curr->next; 239 free(curr); 240 curr=prev->next; 241 }else{ 242 prev=prev->next; 243 curr=curr->next; 244 } 245 }
75

246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287

} //delete node from the graph and relabel for(i=0;i<nov;i++){ curr=graph[i]; prev=graph[i]; while(curr!=NULL) { curr = curr->next; free(prev); prev=curr; } graph[i]=temp[labeling[i]]; curr=graph[i]; //switch labels while(curr!=NULL){ curr->val=labeling[curr->val]; curr=curr->next; } } //add reflexive edges for(i=0;i<nov;i++){ curr=graph[i]; while(curr->next!=NULL) { curr=curr->next; } curr = (node *)malloc(sizeof(node)); //allocate memory curr->val = i; //set value curr->next=NULL; } } int main(void) { node *curr=NULL,*tail=NULL; node *graph[MAXNOV]; node *pgraph[MAXNOV]; node *temp[MAXNOV];
76

288 char ch; 289 char str[5]; 290 char filenamein[20]; 291 char filenameout[20]; 292 int cw_ord[20]; 293 int cw_inv[20]; 294 node *cmovelist; 295 node *rmovelist; 296 int i=0,j=0,k=0; 297 int c=0,ci=0; 298 int t=0,q=0,graph_no=0,copwin_count=0; 299 int cmovecount=0; 300 int r_move=-1,c_move=-1; 301 int r_move_valid; 302 int F[MAXNOV][MAXNOV]; 303 int f[MAXNOV]; 304 int temp_f[MAXNOV]; 305 306 //initialize F and f 307 for(c=0;c<MAXNOV;c++){ 308 f[c]=-1; 309 for(t=0;t<MAXNOV;t++){ 310 F[c][t]=-1; 311 } 312 } 313 c=0; 314 t=0; 315 316 //initialize vertices 317 initialize(graph); 318 initialize(pgraph); 319 initialize(temp); 320 321 //prompt for filename 322 printf("please enter the name of a file containing the graph you want to play on\n"); 323 scanf("%19s",filenamein); 324 325 //open file 326 FILE *input=fopen(strcat(filenamein,".txt"),"r"); 327 328 //read first line
77

329 fgets(str,5,input); 330 nov=atoi(str); 331 printf("The number of vertices is %d\n",nov); 332 graph_no++; 333 334 //processing input 335 for(ch=getc(input);ch!=EOF;ch=getc(input)){ 336 if(i==nov){ //end processing for this graph 337 copygraph(graph,pgraph); 338 printf("the graph is: "); 339 hascorner(graph,&c,&ci); 340 341 //check graph for corner 342 while(c>=0){ 343 f[c]=ci; 344 cw_ord[t]=c; 345 t++; 346 deletenode(c,graph); 347 hascorner(graph,&c,&ci); 348 } 349 350 //get last remaining element of graph 351 for(q=0;q<MAXNOV;q++){ 352 curr=graph[q]; 353 if(curr!=NULL){ 354 cw_ord[t]=q; 355 } 356 } 357 358 if(getsize(graph)==1){ 359 printf("COPWIN\n"); 360 copwin_count++; 361 }else{ 362 printf("NOTCOPWIN\n"); 363 } 364 365 deletegraph(graph); 366 i=0; 367 j=0; 368 //increment graph # counter 369 graph_no++; 370 //grab next character which is a newline
78

371 fgets(str,5,input); 372 }else if (ch=='\n'){ 373 i++; 374 j=0; 375 }else if ((ch=='1')||(i==j)){ 376 //add edge i,j 377 curr = (node *)malloc(sizeof(node)); 378 curr->val = j; 379 curr->next=NULL; 380 381 //if this is the first edge for this node 382 if (graph[i]==NULL){ 383 graph[i]=curr; 384 }else{ 385 tail->next=curr; 386 } 387 tail=curr; 388 389 //increment j 390 j++; 391 }else if (ch=='0'){ 392 j++; 393 } 394 } 395 396 //RESET variables 397 i=0; 398 j=0; 399 c=0; 400 401 //invert cw_ord 402 for(i=0;i<nov;i++){ 403 cw_inv[cw_ord[i]]=i; 404 } 405 406 node *prev; 407 copygraph(pgraph,temp); 408 409 //print initial graph 410 printf("\nORIGINAL "); 411 printgraph(pgraph,0); 412 printf("\n");
79

413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454

//relabel graph with cw_ord for(i=0;i<nov;i++){ //delete node from the pgraph curr=pgraph[i]; prev=pgraph[i]; while(curr!=NULL) { curr = curr->next; free(prev); prev=curr; } //assign new node lists pgraph[i]=temp[cw_ord[i]]; curr=pgraph[i]; //change labels while(curr!=NULL){ curr->val=cw_inv[curr->val]; curr=curr->next; } }

//make temporary f for computing f reordering for(i=0;i<nov;i++){ temp_f[i]=f[i]; } //print relabeled graph printf("\nRELABELED "); printgraph(pgraph,0); printf("\n"); //FIND F and f //reassign f[] for(i=0;i<nov;i++){ f[cw_inv[i]]=cw_inv[temp_f[i]]; } //assign F[0][]=F_1
80

455 for(i=0;i<nov;i++){ 456 for(j=0;j<nov;j++){ 457 F[i][j]=j; 458 } 459 } 460 461 //assigning F[1][] to F[nov][] 462 for(i=1;i<nov;i++){ 463 for(j=i;j<nov;j++){ 464 F[j][i-1]=f[i-1]; 465 } 466 } 467 468 for(i=1;i<nov;i++){ 469 for(j=0;j<nov;j++){ 470 if (F[i][j]<i){ 471 for(t=i;t<nov;t++){ 472 F[t][j]=f[F[t][j]]; 473 } 474 } 475 } 476 } 477 478 479 /* game simulation*/ 480 481 //pick the start vertex 482 k=nov-1; 483 c_move=k; 484 k--; 485 printf("the cop is starting on vertex %d\nwhich vertex do you want to start on?:\n",c_move); 486 scanf("%d",&r_move); 487 488 //get initial robber position 489 while((r_move<0)||(r_move>=nov)||r_move==c_move){ 490 printf("That is not a valid move, please select another vertex\n"); 491 scanf("%d",&r_move); 492 } 493 494 printf("you are moving to vertex: %d\n",r_move);
81

495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536

while(TRUE){ //check possible cop moves cmovelist=pgraph[c_move]; curr=cmovelist; cmovecount=0; printf("the vertices available to the cop are:\n"); while(curr!=NULL){ printf("%d\n",curr->val); if(curr->val==r_move){ F[k][r_move]=r_move; } cmovecount++; curr=curr->next; } scanf(""); //compute cop move c_move=F[k][r_move]; k--; printf("COP MOVES TO:%d\n",c_move); //check win condition if(c_move==r_move){ printf("the cop wins!\n"); break; } //check possible robber moves rmovelist=pgraph[r_move]; curr=rmovelist; printf("the vertices available to you the robber are:\n"); while(curr!=NULL){ printf("%d\n",curr->val); curr=curr->next; } printf("where do you want to move?\n"); scanf("%d",&r_move);
82

537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 }

curr=rmovelist; r_move_valid=FALSE; while(curr!=NULL){ if(curr->val==r_move){ r_move_valid=TRUE; } curr=curr->next; } while(!r_move_valid){ printf("That is not a valid move, please select another vertex\n"); scanf("%d",&r_move); curr=rmovelist; //check that the robber move is in valid while(curr!=NULL){ if(curr->val==r_move){ r_move_valid=TRUE; } curr=curr->next; } } printf("you are moving to vertex: %d\n",r_move); } printf("press ctrl-c to quit\n"); while(TRUE){} return(0);

83

A.3. 2-cop-win Checker

/* 2-cop-win Checker Liam Baird liam.baird@gmail.com Input: a list of graphs in adjacency matrix format delimited by the number of nodes in each graph. 6 Output: a list of statements that state whether each graph in the list has c(G)<=2 or not. 7 */ 8 9 #include <stdlib.h> 10 #include <time.h> 11 #include <stdio.h> 12 #include <string.h> 13 #define MAXNOV 10 14 #define TRUE 1 15 #define FALSE 0 16 int nov=0; 17 18 //defines a node 19 struct node { 20 int val1; 21 int val2; 22 struct node * next; 23 }; 24 typedef struct node node; 25 26 void initialize(node *graph[]){ 27 int k; 28 for(k=0;k<MAXNOV;k++){ 29 graph[k] = NULL; 30 } 31 } 32 33 void initializep(node *pgraph[MAXNOV][MAXNOV]){ 34 int j,k; 35 for(k=0;k<MAXNOV;k++){ 36 for(j=0;j<MAXNOV;j++){ 37 pgraph[k][j] = NULL;
84

1 2 3 4 5

38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79

} } } void initializeeff(node *eff[MAXNOV][MAXNOV]){ int i,j; for(i=0;i<MAXNOV;i++){ for(j=0;j<MAXNOV;j++){ eff[i][j] = NULL; } } } void printgraph(node *graph[],int graph_no){ int q; node *curr=NULL; if(graph_no==0){ printf("GRAPH:\n"); }else{ printf("GRAPH #%d:\n",graph_no); } for(q=0;q<MAXNOV;q++){ curr=graph[q]; while(curr!=NULL) { if(curr->val1!=q){ printf("(%d,%d)\n",q,curr->val1); } curr = curr->next ; } } } void printpgraph(node *graph[MAXNOV][MAXNOV],int graph_no){ int i=0,j=0; node *curr=NULL; printf("P.GRAPH #%d:\n",graph_no); for(i=0;i<MAXNOV;i++){ for(j=0;j<MAXNOV;j++){ curr=graph[i][j];
85

80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120

while(curr!=NULL) { if((curr->val1!=i)||(curr->val2!=j)){ printf("(%d,%d),(%d,%d)\n",i,j,curr->val1,curr-> val2); } curr = curr->next ; } } } } void printeff(node *eff[MAXNOV][MAXNOV],int nov){ int i=0,j=0; node *curr=NULL; printf("EFF:\n"); for(i=0;i<nov;i++){ for(j=0;j<nov;j++){ curr=eff[i][j]; printf("F([%d,%d]): ",i,j); while(curr!=NULL){ printf("%d ",curr->val1); curr = curr->next ; } printf("\n"); } } } void printadj(node *adj[MAXNOV][MAXNOV],int nov){ int i=0,j=0; node *curr=NULL; printf("ADJ:\n"); for(i=0;i<nov;i++){ for(j=0;j<nov;j++){ curr=adj[i][j]; printf("F([%d,%d]): ",i,j); while(curr!=NULL){ printf("%d ",curr->val1); curr = curr->next ; } printf("\n");
86

121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162

} } printf("\n"); } void deletegraph(node *graph[]){ int q=0; node *curr=NULL; node *prev=NULL; for(q=0;q<MAXNOV;q++){ curr=graph[q]; prev=graph[q]; while(curr!=NULL) { curr = curr->next; free(prev); prev=curr; } graph[q] = NULL; } } void deletepgraph(node *graph[MAXNOV][MAXNOV]){ int i=0,j=0; node *curr=NULL; node *prev=NULL; for(i=0;i<MAXNOV;i++){ for(j=0;j<MAXNOV;j++){ curr=graph[i][j]; prev=graph[i][j]; while(curr!=NULL){ curr = curr->next; free(prev); prev=curr; } graph[i][j] = NULL; } }
87

163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204

} void deleteeff(node *graph[MAXNOV][MAXNOV]){ int i=0,j=0; node *curr=NULL; node *prev=NULL; for(i=0;i<MAXNOV;i++){ for(j=0;j<MAXNOV;j++){ curr=graph[i][j]; prev=graph[i][j]; while(curr!=NULL){ curr = curr->next; free(prev); prev=curr; } graph[i][j] = NULL; } } } void deletenode(int i,node *graph[]){ int q=0; node *curr=NULL; node *prev=NULL; curr=graph[i]; prev=graph[i]; while(curr!=NULL) { curr = curr->next; free(prev); prev=curr; } graph[i] = NULL; for(q=0;q<MAXNOV;q++){
88

205 curr=graph[q]; 206 prev=graph[q]; 207 208 if(curr!=NULL){ 209 if(curr->val1==i){ 210 graph[q]=curr->next; 211 free(curr); 212 curr=graph[q]; 213 prev=graph[q]; 214 curr=curr->next; 215 } 216 else{ 217 curr=curr->next; 218 //prev=prev->next; 219 } 220 } 221 222 while(curr!=NULL) { 223 if(curr->val1==i){ 224 prev->next=curr->next; 225 free(curr); 226 curr=prev->next; 227 } 228 else 229 { 230 prev=prev->next; 231 curr=curr->next; 232 } 233 } 234 235 236 } 237 238 } 239 240 int isadj(int i, int j,node *graph[]){ 241 //determine whether or not i and j are adjacent in graph 242 node *curr=NULL; 243 curr=graph[i]; 244 245 while(curr!=NULL) { 246 if (curr->val1==j){
89

247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287

return(TRUE); } curr=curr->next; } return(FALSE); } int iseq(int i, int j){ if (i==j){ return(TRUE); } return(FALSE); } void makeeff(node *eff[MAXNOV][MAXNOV],node *adj[MAXNOV][ MAXNOV],int nov){ int i=0,j=0,k=0,v=0; node *curr=NULL; node *prev=NULL; node *list=NULL; for(i=0;i<nov;i++){ for(j=0;j<nov;j++){ prev=eff[i][j]; list=adj[i][j]; for(k=0;k<nov;k++){ if(list!=NULL){ v=list->val1; }else{ v=MAXNOV+10; } if(k!=v){ //add node with value k curr=(node *)malloc(sizeof(node)); curr->val1=k; curr->val2=-1; curr->next=NULL;
90

288 if (eff[i][j]==NULL){ 289 eff[i][j]=curr; 290 }else{ 291 prev->next=curr; 292 } 293 294 prev=curr; 295 }else{ 296 list=list->next; 297 } 298 } 299 } 300 } 301 } 302 303 void makeadjacency(node *adj[MAXNOV][MAXNOV],node *graph[ MAXNOV],int nov){ 304 int i=0,j=0,va=0,vb=0; 305 node *curr=NULL; 306 node *prev=NULL; 307 node *list_a=NULL; 308 node *list_b=NULL; 309 310 for(i=0;i<nov;i++){ 311 for(j=0;j<nov;j++){ 312 prev=adj[i][j]; 313 list_a=graph[i]; 314 list_b=graph[j]; 315 316 while((list_a!=NULL)||(list_b!=NULL)){ 317 318 if(list_a!=NULL){ 319 va=list_a->val1; 320 }else{ 321 va=MAXNOV+10; 322 } 323 324 if(list_b!=NULL){ 325 vb=list_b->val1; 326 }else{ 327 vb=MAXNOV+10; 328 }
91

329 330 curr=(node *)malloc(sizeof(node)); 331 curr->next=NULL; 332 333 if(va<vb){ 334 curr->val1=va; 335 list_a=list_a->next; 336 } else if(vb<va){ 337 curr->val1=vb; 338 list_b=list_b->next; 339 } else if(va==vb){ 340 curr->val1=va; 341 list_a=list_a->next; 342 list_b=list_b->next; 343 } 344 345 if (adj[i][j]==NULL){ 346 adj[i][j]=curr; 347 }else{ 348 prev->next=curr; 349 } 350 prev=curr; 351 } 352 } 353 } 354 } 355 356 int intersect(node *adj[MAXNOV][MAXNOV],node *eff[MAXNOV][ MAXNOV],int i,int j, int k, int l){ 357 node *curr_a=adj[i][j]; 358 node *curr_f=eff[k][l]; 359 node *prev_f=NULL; 360 node *curr=NULL; 361 node *prev=NULL; 362 int changed=FALSE; 363 int va=0,vf=0; 364 365 eff[k][l]=NULL; 366 prev_f=curr_f; 367 368 while(curr_f!=NULL){ 369 if(curr_a!=NULL){
92

370 va=curr_a->val1; 371 }else{ 372 changed=TRUE; 373 return(changed); 374 } 375 376 vf=curr_f->val1; 377 curr=(node *)malloc(sizeof(node)); 378 curr->next=NULL; 379 380 if(va<vf){ 381 curr_a=curr_a->next; 382 } else if(vf<va){ 383 curr_f=curr_f->next; 384 free(prev_f); 385 prev_f=curr_f; 386 changed=TRUE; 387 } else if(va==vf){ 388 curr->val1=va; 389 curr_a=curr_a->next; 390 curr_f=curr_f->next; 391 392 if (eff[k][l]==NULL){ 393 eff[k][l]=curr; 394 }else{ 395 prev->next=curr; 396 } 397 prev=curr; 398 } 399 } 400 return(changed); 401 } 402 403 int main(void) { 404 node *curr=NULL,*tail=NULL,*curr_a=NULL,*tail_a=NULL,* tail_p=NULL; 405 node *graph[MAXNOV]; 406 node *(eff[MAXNOV][MAXNOV]); 407 node *(adj[MAXNOV][MAXNOV]); 408 node *(pgraph[MAXNOV][MAXNOV]); 409 char ch; 410 char str[5];
93

//read first character, should be a # (need to fix, input could be "10" ie not a single char 433 fgets(str,5,input); 434 nov=atoi(str); 435 graph_no++; 436 437 //loop through characters 438 for(ch=getc(input);ch!=EOF;ch=getc(input)){ 439 if(i==nov){ 440 //make product graph 441 for(x=0;x<nov;x++){ 442 for(y=0;y<nov;y++){ 443 for(u=0;u<nov;u++){ 444 for(v=0;v<nov;v++){ 445 if((iseq(x,u)&&iseq(y,v))||(isadj(x,u,graph)&& iseq(y,v))||(iseq(x,u)&&isadj(y,v,graph))||( isadj(x,u,graph)&&isadj(y,v,graph))){ 446 curr = (node *)malloc(sizeof(node)); 447 curr->val1 = u; 448 curr->val2 = v; 449 curr->next=NULL;
94

411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432

char filenamein[20]; char filenameout[20]; int i=0,j=0,k,c=0,q,graph_no=0,twocopwin_count=0; int x=0,y=0,u=0,v=0,u1=0,u2=0,v1=0,v2=0; int flag1=FALSE,flag2=FALSE,changed=TRUE,twocopwin=FALSE; //initialize data structures; initialize(graph); initializep(pgraph); initializeeff(eff); initializeeff(adj); //prompt for filename printf("please enter graph filename\n"); scanf("%19s",filenamein); strcpy(filenameout,filenamein); //open file FILE *input=fopen(strcat(filenamein,".txt"),"r"); FILE *output=fopen(strcat(filenameout,"r.txt"),"w");

450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491

//add the node if (pgraph[x][y]==NULL){ pgraph[x][y]=curr; }else{ tail_p->next=curr; } tail_p=curr; } } } } } makeadjacency(adj,graph,nov); makeeff(eff,adj,nov); printadj(adj,nov); printeff(eff,nov); changed=TRUE; while(changed==TRUE){ //LOOP THROUGH vertices u1 v1 for(u1=0;u1<nov;u1++){ for(u2=0;u2<nov;u2++){ curr=pgraph[u1][u2]; if(curr!=NULL){ //pick out the vertex this is connected to v1=curr->val1; v2=curr->val2; //find intersection of eff[u1][u2] and adj[v1][v2] flag1=intersect(adj,eff,u1,u2,v1,v2); //find intersection of eff[v1][v2] and adj[u1][u2] flag2=intersect(adj,eff,v1,v2,u1,u2); //CHECK FOR EMPTY EFF if((eff[u1][u2]==NULL)||(eff[u1][u2]==NULL)){ flag1=FALSE; flag2=FALSE; changed=FALSE; } //check for flags
95

492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533

if((flag1==TRUE)||(flag2==TRUE)){ changed=TRUE; } } } } printeff(eff,nov); } twocopwin=FALSE; for(x=0;x<nov;x++){ for(y=0;y<nov;y++){ if(eff[x][y]==NULL){ twocopwin=TRUE; } } } if(twocopwin==TRUE){ twocopwin_count++; printf("GRAPH #%d is 2cw\n",graph_no); }else{ printf("GRAPH #%d is NOT 2cw\n",graph_no); } deleteeff(eff); deletegraph(graph); deletepgraph(pgraph); deleteeff(adj); i=0; j=0; //increment graph # counter graph_no++; fgets(str,5,input); }else if (ch=='\n'){ i++; j=0; }else if ((ch=='1')||(i==j)){ //add edge i,j curr = (node *)malloc(sizeof(node)); //allocate memory curr->val1 = j; //set val1ue curr->next=NULL; //set next
96

534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 }

//if this is the first edge for this node if (graph[i]==NULL){ graph[i]=curr; }else{ tail->next=curr; } tail=curr; j++; }else if (ch=='0'){ j++; } } printf("%d of %d graphs of order %d are <=2 copwin\n", twocopwin_count,graph_no-1,nov); fprintf(output,"%d of %d graphs of order %d are copwin\n", twocopwin_count,graph_no-1,nov); return(0);

97

Bibliography
[1] M. Aigner, M. Fromme, A game of cops and robbers, Discrete Applied Mathematics 8 (1984) 1Â­12. [2] A. Berarducci, B. Intrigila, On the cop number of a graph, Advances in Applied Mathematics 14 (1993) 389Â­403. [3] C Berge, Hypergraphs: Combinatorics of Finite Sets, North Holland, 1989. [4] A. Bonato, E. Chiniforooshan, P. Pralat, Cops and Robbers from a distance, Theoretical Computer Science 411 (2010) 3834-3844. [5] A. Bonato, R.J. Nowakowski, The Game of Cops and Robbers on Graphs, American Mathematical Society, Providence, Rhode Island, 2011. [6] P.J. Cameron, Combinatorics: Topics, Techniques, Algorithms, Cambridge University Press, Cambridge, 1995. [7] P. Chebyshev, MÂ´ emoire sur les nombres premiers, MÂ´ em. Acad. Sci. St. PÂ´ etersbourg 7 (1850) 17-33. [8] E. Chiniforooshan, A better bound for the cop number of general graphs, Journal of Graph Theory 58 (2008) 45Â­48. [9] N.E. Clarke, R.J. Nowakowski, Cops, robber, and traps, Utilitas Mathematica 60 (2001) 91Â­98. [10] P. Frankl, On a pursuit game on Cayley graphs, Combinatorica 7 (1987) 67Â­70. [11] P. Frankl, Cops and robbers in graphs with large girth and Cayley graphs, Discrete Applied Mathematics 17 (1987) 301Â­305. [12] A. Frieze, M. Krivelevich, P. Loh, Variations on Cops and Robbers, accepted to Journal of Graph Theory. [13] L. Lu, X. Peng, On Meyniel's conjecture of the cop number, Preprint 2011.
99

[14] B.D. McKay, Combinatorial Data, Brendan McKay's Home Page published electronically at http://cs.anu.edu.au/bdm/data/, Accessed June 20, 2011. [15] R.J. Nowakowski, P. Winkler, Vertex-to-vertex pursuit in a graph, Discrete Mathematics 43 (1983) 235Â­239. [16] P. Pralat, When does a random graph have constant cop number?, Australasian Journal of Combinatorics 46 (2010), 285-296. [17] P. Pralat, N. Wormald, Meyniel's conjecture holds in random graphs, Preprint 2011. [18] A. Quilliot, Jeux et pointes fixes sur les graphes, Th` ese de 3` eme cycle, UniversitÂ´ e de Paris VI, 1978, 131Â­145. [19] A. Quilliot, Probl` emes de jeux, de point Fixe, de connectivitÂ´ e et de represÂ´ esentation sur des graphes, des ensembles ordonnÂ´ es et des hypergraphes, Th` ese d'Etat, UniversitÂ´ e de Paris VI, 1983, 131Â­145. [20] A. Quilliot, A short note about pursuit games played on a graph with a given genus, J. Combin. Theory (B) 38 (1985) 89Â­92. [21] A. Scott, B. Sudakov, A new bound for the cops and robbers problem, Preprint 2011. [22] N.J.A. Sloane, Sequences A000088 and A001349, The On-Line Encyclopedia of Integer Sequences published electronically at http://oeis.org, 2010. [23] V.I. Voloshin, Introduction to Graph and Hypergraph Theory, Nova Science Publishers, Inc., 2009. [24] D.B. West, Introduction to Graph Theory, 2nd edition, Prentice Hall, 2001.

100


