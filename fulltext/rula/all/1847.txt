CONSTRAINT SATISFACTION PROBLEMS AND THEIR REDUCTION TO DIRECTED GRAPHS

by

Muhanda Stella Mbaka Muzala B.A.(Hons) Mathematics and Computer Science, York University, 2007

A thesis presented to Ryerson University in partial fulfillment of the requirements for the degree of Master of Science in the Program of Applied Mathematics

Toronto, Ontario, Canada, 2012 c Muhanda Stella Mbaka Muzala 2012

I hereby declare that I am the sole author of this thesis. This is a true copy of the thesis, including any required final revisions, as accepted by my examiners.

I authorize Ryerson University to lend this thesis to other institutions or individuals for the purpose of scholarly research.

I further authorize Ryerson University to reproduce this thesis by photocopying or by other means, in total or in part, at the request of other institutions or individuals for the purpose of scholarly research.

I understand that my dissertation may be made electronically available to the public.

ii

CONSTRAINT SATISFACTION PROBLEMS AND THEIR REDUCTION TO DIRECTED GRAPHS Master of Science 2012 Muhanda Stella Mbaka Muzala Applied Mathematics Ryerson University

Abstract
Constraint satisfaction problems present a general framework for studying a large class of algorithmic problems such as satisfaction of Boolean formulas, solving systems of equations over finite fields, graph colourings, as well as various applied problems in artificial intelligence (scheduling, allocation of cell phone frequencies, among others.) CSP (Constraint Satisfaction Problems) bring together graph theory, complexity theory and universal algebra.

It is a well known result, due to Feder and Vardi, that any constraint satisfaction problem over a finite relational structure can be reduced to the homomorphism problem for a finite oriented graph. Until recently, it was not known whether this reduction preserves the type of the algorithm which solves the original constraint satisfaction problem, so that the same algorithm solves the corresponding digraph homomorphism problem. iii

We look at how a recent construction due to Bulin, Deli´ c, Jackson, and Niven can be used to show that the polynomial solvability of a constraint satisfaction problem using Datalog, a programming language which is a weaker version of Prolog, translates from arbitrary relational structures to digraphs.

iv

Acknowledgements
I would like to thank Ryerson University for allowing me to complete this great milestone in my education. The professors in the Department of Mathematics have been of great support in this journey to complete my graduate studies. I would like to thank Dr. Anthony Bonato, whose brilliant teaching and interest in Graph Theory have captured my attention. Thanks to Professor Katrin Rohlf and Silvana Ilie for being an inspiration as female experts in the field of Mathematics.

My deepest thanks go to my supervisor Dr. Dejan Deli´ c. I believe no one could have been a better candidate to be my mentor. Without his guidance and expertise this thesis would not have been sealed.

I would not close this by omitting to thank my entire family. Thanks to the man of my life, Jean-Robert Djulus, for his ceaseless support and believing in my brain. I sincerely thank my dearest parents, my father, Ambroise Mbaka and my mother Marie-Claire Ngoya who have always been the voice of encouragement from my early childhood.

Thanks to all for investing in me and leaving your footprints on this unforgettable journey.

v

Contents

1 Introduction 1.1 1.2 1.3 Graphs and digraphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Homomorphism and adjacency . . . . . . . . . . . . . . . . . . . . . . . . Homomorphisms and colourings . . . . . . . . . . . . . . . . . . . . . . .

1 3 4 7 11 14 16

2 Complexity 2.1 3 CSP 3.1 3.2 Primitive positive formulas . . . . . . . . . . . . . . . . . . . . . . . . . . More properties of relational structures . . . . . . . . . . . . . . . . . . . Polynomial time reduction . . . . . . . . . . . . . . . . . . . . . . . . . .

18 19 21 25 28 29

4 Bounded Width 4.1 4.2 4.3 Consistency check . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Pair consistency check . . . . . . . . . . . . . . . . . . . . . . . . . . . . Majority polymorphism . . . . . . . . . . . . . . . . . . . . . . . . . . . vi

5 CSP Dichotomy 5.1 5.2 5.3 Reduction digraph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Relational structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Reduction to digraphs . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5.3.1 5.3.2 Translation to a bipartite structure . . . . . . . . . . . . . . . . . Transformation to digraph . . . . . . . . . . . . . . . . . . . . . .

34 35 36 40 41 42 45 49 49 50 51 57

6 Preservation of Bounded Width 7 Conclusion and Open Problems 7.1 7.2 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Open problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7.2.1 Bibliography Datalog and LFP . . . . . . . . . . . . . . . . . . . . . . . . . . .

vii

List of Figures
1.1 1.2 1.3 1.4 1.5 2.1 2.2 3.1 4.1 4.2 4.3 4.4 5.1 A graph with edges and a digraph with arcs. . . . . . . . . . . . . . . . . A mapping f from C7 to C5 . . . . . . . . . . . . . . . . . . . . . . . . . Each vertex in C7 has an image in C5 . . . . . . . . . . . . . . . . . . . . Balanced graph G . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Balanced graph G with its level function . . . . . . . . . . . . . . . . . . Classes P and NP. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . A diagram for three known NP problems. . . . . . . . . . . . . . . . . . A digraph not admitting a weak near unanimity polymorphism. . . . . . A 2-colouring of even and odd cycles. . . . . . . . . . . . . . . . . . . . . Consistency check performed on two oriented paths. . . . . . . . . . . . . A digraph admitting the majority polymorphism. . . . . . . . . . . . . . Connectivity of triples built from 0, 1, and 2. . . . . . . . . . . . . . . . . A minimal path. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . viii 3 5 5 8 9 13 15 20 23 25 30 31 35

5.2 5.3 5.4 5.5 5.6

Levels in the minimal path from Figure 5.1. . . . . . . . . . . . . . . . . The oriented path N . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Process diagram for reduction to digraph. . . . . . . . . . . . . . . . . . Path representing (x1 , (x1 , y1 )). . . . . . . . . . . . . . . . . . . . . . . . Path representing (x1 , (y1 , x1 )). . . . . . . . . . . . . . . . . . . . . . . .

36 38 40 43 43

ix

Chapter 1 Introduction
The central topic of this thesis are Constraint Satisfaction Problems and their reduction to digraph homomorphisms. Constraint satisfaction problems play an important role in the area of computer science (in particular, artificial intelligence) and have attracted significant attention in the past 30 years, using methods and tools from logic, universal algebra, and combinatorics. A paper by Feder and Vardi [7], resulted in a famous conjecture asserting that any constraint satisfaction problem over a finite relational structure is either tractable (solvable in polynomial runtime) or intractable (NP-complete). So far, all gathered evidence points to the conjecture being true. In addition, Feder and Vardi showed in the same exposition that every constraint satisfaction problem over a finite structure can be reduced to the homomorphism problem for a finite balanced digraph. We refer the reader to [10] 1

CHAPTER 1. INTRODUCTION for a detailed study of graph and digraph homomorphisms. Recently, algebraic methods have been explored in the study of constraint satisfaction problems and their complexity (see [3], [4]). One of the most important results is the categorization of constraint satisfaction problems that are solvable using a simple class of algorithms, called bounded width problems [2]. A recent result of Bulin, Deli´ c, Jackson, and Niven [5] shows that the original Feder and Vardi reduction to digraphs can be modified so that a variety of polymorphisms are preserved. In particular, in their paper, it is shown that this transformation reduces structures of bounded width to digraphs of bounded width. The main result of this thesis is to give an alternative proof of this result using the Datalog approach to prove bounded width. This is in contrast to a purely algebraic approach used in [5] and [1], to give a similar proof for Feder and Vardi construction.

2

CHAPTER 1. INTRODUCTION

1.1. GRAPHS AND DIGRAPHS

1.1

Graphs and digraphs

To introduce the notion of CSP s (Constraint Satisfaction Problems) and their reduction to digraphs, we must first consider some definitions related to graphs and digraphs. Our main references for the material of this chapter are [10] and [19]. Definition 1.1. A graph G is a non-empty set of vertices denoted by V (G) together with a set of edges E (G), where an edge joins two given vertices u and v . For this reason, we often say that the edge relation is a symmetric binary relation on V (G). If u and v are joined by an edge then these vertices are adjacent. Definition 1.2. A digraph G is a non-empty set of vertices denoted by V (G) together with a set of arcs E (G). An arc is marked by an orientation of the edge. Definition 1.3. If u and v are adjacent in the direction from u to v , we say that u is an in-neighbour of v and consequently v is an out-neighbour of u.

Figure 1.1: A graph with edges and a digraph with arcs.

Definition 1.4. Given two (di)graphs G and H , a mapping f from G to H is called a homomorphism, if (arcs) edges of G can be mapped to (arcs) edges in H while preserving 3

1.2. HOMOMORPHISM AND ADJACENCY vertex relations. We have:

CHAPTER 1. INTRODUCTION

for all u, v 2 E (G), f (u)f (v ) 2 E (H )

Homomorphisms will preserve edge relations in a graph but will also preserve the direction of the arc in a digraph. A homomorphism f between G and H is commonly denoted "G ! H ", where G is said to be homomorphic to H or that G is H -colourable.

1.2

Homomorphism and adjacency

As stated in the previous section, homomorphisms preserve adjacency. We can introduce more definitions related to graphs. Definition 1.5. Given two vertices u and v of G, a walk from u to v is a sequence of adjacent vertices allowing a connection from u to v . Definition 1.6. In a closed walk the starting vertex and the ending vertex are the same. Definition 1.7. A path P from u to v is a walk consisting of distinct vertices. If m edges are traversed in the sequence from u to reach v , then we say that the path P is of length m, denoted Pm . Definition 1.8. A cycle C is a sequence of distinct vertices, with the starting vertex 4

CHAPTER 1. INTRODUCTION

1.2. HOMOMORPHISM AND ADJACENCY

and the ending vertex being the same. If m edges are traversed in the sequence from u back to u, then we say that the cycle C is of length m, denoted Cm . Proposition 1.1. (Hell, Ne set ril [10]) A mapping f : V (Cm ) ! V (G) is a homomorphism of Cm to G if and only if f (0), f (1), . . . , f (m 1) is a closed walk in G.

Proof. We refer the reader to [10] for a complete proof. In Example 1.1 we will demonstrate that a mapping f between C7 and C5 preserves adjacency. Example 1.1. f : C7 ! C5
0 6 5 1 e 2 d c f a b

4

3

Figure 1.2: A mapping f from C7 to C5

f(0)=a f(4)=f(6)=e f(1)=b

Mapping f, results in:

f(3)=f(5)=d

f(2)=c

Figure 1.3: Each vertex in C7 has an image in C5 . 5

1.2. HOMOMORPHISM AND ADJACENCY

CHAPTER 1. INTRODUCTION

We see the closed walk f (0), f (1), . . . , f (6), f (0) in C5 . All edge relations in C7 are preserved in C5 after performing the mapping. The above definitions are important tools in the study of homomorphism and adjacency. Similar definitions and properties exist for digraphs, which we proceed to introduce next. Definition 1.9. Digraphs are often referred to as oriented graphs. Definition 1.10. To distinguish a graph from a digraph, we refer to it as an undirected graph. Definition 1.11. Given an oriented walk of m vertices, adjacent in the following sequence {v1 , v2 , . . . , vm }, a f orward arc is defined as an arc from vi to vi+1 and a backward arc is an arc from vi+1 to vi . Definition 1.12. When a path or a walk is composed of both forward and backward arcs, we refer to it as an oriented path or walk. When it is composed of forward arcs only, we say that the walk or the path is directed. Definition 1.13. A digraph is connected if any given two vertices are joined by an oriented walk. Definition 1.14. If a denotes the number of forward arcs and b the number of backward arcs of an oriented walk, then the algebraic length of the walk is calculated as a 6 b.

CHAPTER 1. INTRODUCTION

1.3. HOMOMORPHISMS AND COLOURINGS

Proposition 1.2. (Hell, Ne set ril [10]) Let G and H be digraphs, and f : G ! H a homomorphism. If v0 , v1 , . . . , vm is a walk in G, then f (v0 ), f (v1 ), . . . , f (vm ) is a walk in H of the same algebraic length. Proof. We refer the reader to [10] for the complete proof. ! ! Definition 1.15. An oriented path and cycle, denoted Pm and Cm respectively, are defined similarly as the path Pm and cycle Cm , only that every vi v(i+1) is an arc and not an edge. ! ! Definition 1.16. A digraph G is balanced if any two oriented paths P1 and P2 between vertices u and v have the same algebraic length.

1.3

Homomorphisms and colourings

In the previous section we had mentioned that a homomorphism from G to H is also called an H -colouring of G. One of the most important and extensively studied problems in graph theory is that of graph colouring. It is a constraint satisfaction problem that requires colouring vertices of a given graph G such that the following constraint is satisfied: any two adjacent vertices should not be assigned the same colour. We can define our mapping f as the assignment of m colours to vertices of G so that no pair of adjacent vertices is assigned the same colour. Following this concept, the graph H is the set of m vertices, where each vertex is labelled as a distinct colour from 7

1.3. HOMOMORPHISMS AND COLOURINGS its neighbour.

CHAPTER 1. INTRODUCTION

Definition 1.17. A graph of m vertices, is a complete graph (denoted Km ) if every pair of distinct vertices are connected by an edge. Proposition 1.3. (Hell, Ne set ril [10]) A homomorphism f : G ! Km is the m-colouring of G. Proof. We refer the reader to [10] for the complete proof. Definition 1.18. Given a connected balanced digraph G, starting at a given vertex a, we can label all vertices of G to produce levels. We start by labeling a as 0, then all its out-neighbours incremented by 1 and in-neighbours decremented by 1. If applying this procedure results in some negative labels, then we can add the same positive integer to all labels so that the smallest label is 0. The label of each vertex is called the level of the vertex. We call the height of G the maximum level of G. Example 1.2. We start with G, then we proceed with the labeling a · · · ·
   

· · ·
 

Figure 1.4: Balanced graph G

8

CHAPTER 1. INTRODUCTION

1.3. HOMOMORPHISMS AND COLOURINGS 0 1 2 3 4
   

1 2 3
 

Figure 1.5: Balanced graph G with its level function Proposition 1.4. (Hell, Ne set ril [10]) If G and H are two balanced digraphs of the same height, then any homomorphism of G to H preserves the levels of vertices. Proof. We refer the reader to [10] for the complete proof. Definition 1.19. If G ! H and H ! G, then we say that G and H are homomorphically equivalent. Definition 1.20. Let H be a nonempty subset of V (G). Then, the graph with the vertex set H and the set of edges E (G) \ (H  H ) is called an induced subraph of G, which we will also denote H . Definition 1.21. Suppose H is an induced subgraph of G, a retraction from G to H is a homomorphism f : G ! H such that each vertex u in H is mapped to itself in G. Definition 1.22. Let H be an induced subgraph of G. An inclusion from H to G is a homomorphism g : H ! G, which maps each vertex u in H to itself. By composing the retraction and the inclusion in H and G, we can conclude that G and H are homomorphically equivalent. 9

1.3. HOMOMORPHISMS AND COLOURINGS

CHAPTER 1. INTRODUCTION

Definition 1.23. A core is the smallest induced subgraph onto which the graph can retract. Every finite graph must contain a core. For a proof, we refer the reader to [10].

10

Chapter 2 Basic Notions from Computational Complexity Theory
Algorithms are built to determine the existence of homomorphisms. If we consider homomorphism problems based on the simplicity or complexity of the problem, then we can classify them as P or NP problems. Our main reference for the material in this chapter is [17].

Definition 2.1. A problem or a function f : N ! N is computable in polynomial time (we say that f is in the class P or f is tractable) if there exists at least one algorithm A which can solve f (n) in a finite number of steps that is bounded by a polynomial function of n, the length of the input. P stands for the class of problems (functions) computable in polynomial time. 11

CHAPTER 2. COMPLEXITY

Example 2.1. The following are in P: 1. Solving a linear equation over the field of real numbers R ([17]): Given I = {{a, b, c} 2 R|c (a, b, c) such that c b + a = x, x 2 R}, the problem of finding all triples

b + a = x can be solved by a polynomial algorithm, the usual

Gaussian elimination; 2. 2-colouring of Cn , with n an even integer ([17]), This can be achieved by assigning colours 1 and 2 respectively to adjacent vertices. Definition 2.2. A function f : N ! N is in NP, if there exists at least one algorithm A that verifies in polynomial time whether a proposed solution a is the correct solution to f (n). This algorithm does not calculate the solution to the problem, it simply verifies its correctness. NP stands for non-deterministic polynomial time. Following these definitions, we know for certain that P is a subset of NP. Indeed, if we can find a solution to a function f in polynomial time, then we can also verify its correctness in polynomial time. Example 2.2. The following problems are in NP but not known to be in P: 1. 3-satisfiability in Boolean logic ([17]); 2. Traveling Salesman Problem (TSP) ([17]): Given a list of distinct cities c1 , c2 , . . . , cn , the problem involves finding the shortest 12

CHAPTER 2. COMPLEXITY distance, a cycle of length l from c1 back to c1 , while visiting each city exactly once. Observe that l  between ci and cj . P i =n P j = n
i=1 j =1

d(ci , cj ), where d(ci , cj ) is the distance in miles

The relationship between the classes P and NP is one of the central problems of the theory of computational complexity. Though P is a subset of NP, the question remains to determine if these two classes are identical. P=NP means that for every problem we can find an algorithm that verifies the correctness of a solution to the problem, but also an algorithm that can find this solution, if unknown, and this performed in polynomial time. The most famous conjecture in this area is the so-called "P 6= NP", which is still open.

Conjecture 1. (Cook, [6]) P 6= NP.

The following diagram represents the relationship between the classes P and NP:

NP P NP-complete NP-hard

Figure 2.1: Classes P and NP.

13

2.1. POLYNOMIAL TIME REDUCTION

CHAPTER 2. COMPLEXITY

2.1

Polynomial time reduction

Definition 2.3. Given two problems C and D. We say that C is polynomial time or poly -time reducible to D (denoted by C  D) if there exists a polynomial time computable function f : C ! D such that for every x 2 C , we have that f (x) 2 D. Definition 2.4. We say that two problems C and D are poly -time equivalent if C  D and D  C . Definition 2.5. Given a class of problems C we shall say that C1 (a problem) is C -hard if there exists C2 2 C such as C2  C1 . If an algorithm exists that is capable to transform C2 to C1 in polynomial time, then C1 is at least as hard as C2 2 C . Definition 2.6. We say that a problem C1 is NP-complete if it is NP-hard and in NP (see Figure 2.1). There exists several notable problems that are NP-complete, one of them being the SAT problem. The SAT problem consists of all satisfiable Boolean formulas using boolean symbols ^, _, ¬ and variables. SAT can be reduced in polynomial time to other problems in order to prove their NP-completeness. We state the following fundamental theorems but their proofs are rather involved and can be found in [17] 14

CHAPTER 2. COMPLEXITY

2.1. POLYNOMIAL TIME REDUCTION

Theorem 2.1. (See [17]) SAT is NP-complete. Theorem 2.2. (See [17]) 3-SAT is NP-complete Theorem 2.3. (See [17]) 3-colourability of graphs is NP-complete. By definition, 3-SAT is the problem to determine satisfiability of a Boolean formula, which is a conjunction of disjunctions, where each disjunction consists of at most three terms, each being a variable or a negation of a variable. Figure 2.2 depicts the relationship between SAT, 3-SAT and 3-colourability of a graph.

SAT

is polynomial time reducible to

3-SAT

is polynomial time reducible to

3-colourability of a graph

Figure 2.2: A diagram for three known NP problems.

15

Chapter 3 CSP for relational structures
Definition 3.1. Let A be a nonempty set. A finitary relation R on A is any

R  An = A  · · ·  A

for some n greater or equal to 0. In that case, we say that R is n-ary and call n the arity of R. An is called the n-th power of A or the Cartesian product on A. Definition 3.2. The arity of R is the number of variables on which it is defined. For example, E , the symbol for edge relation is a binary relation so its arity is 2. Definition 3.3. A relational structure S is a nonempty set S equipped with a collection of relations Ri , with i = 1, 2, . . . ,k . We write:

S = ( S ; R 1 , R2 , . . . , R k ) 16

CHAPTER 3. CSP Definition 3.4. Two relational structures S and T are similar if they have the same set of relation symbols and arities. Definition 3.5. Let T be a nonempty subset of S . T , along with the restrictions of relations of S, form a structure T, and we say that T is a substructure of S or T is included in S. The inclusion mapping T ! S is also a homomorphism. Following are some properties of a homomorphism f : S ! T: 1. f is an isomorphism if there exists an inverse homomorphism T ! S. 2. f is an endomorphism if S = T. 3. f is an automorphism if it is both an endomorphism and an isomorphism. A relational structure S is a core if all of its endomorphisms are automorphisms. Definition 3.6. Let S be a relational structure. We define a constraint satisfaction problem of S as the collection of all relational structures denoted CSP(S) which consists of all structures that are homomorphic to S. CSPs are therefore problems of finding homomorphisms between two given general relational structures S and T. The constraint satisfaction problem of S is in NP for all S. In fact, any given homomorphism between S and T can easily be encoded in a string whose length is linear in |S | and verifying its correctness can be done in polynomial runtime. Thus, CSP(S) is in NP. There is a famous conjecture by Feder and Vardi which relies on the assumption that P6=NP. 17

3.1. PRIMITIVE POSITIVE FORMULAS

CHAPTER 3. CSP

Conjecture 2. (Feder, Vardi, [7]) Every CSP is either P or NP-complete.

3.1

Primitive positive formulas

Definition 3.7. An atomic formula is a formula of the form R(x1 , . . . , xn ), where R is an n-ary relation symbol. Given the class of all atomic formulas µ in some fixed signature, we can produce a formula:

9 1 . . . 9 n ,

1 (, . . . , )

^ ··· ^

n (, . . . , ),

where the stars are free variables (say, x1 , . . . , xm ) and 1 . . . n are bound variables. All the
i

belong to µ and are operation symbols.

If the class µ consists of formulas of the form R(x1 , x2 , . . . , 1 , . . . , n ), where R is a k -ary relation, then we call a formula 91 , . . . , 9n [ 1 (, . . . , ) ^ · · · ^ positive.
n (, . . . , )]

primitive

Example 3.1. If E is the binary relation of an undirected graph, then an example of a primitive positive formula in the language of graphs is, for instance,

9x9y 9z (xEy ^ yEz ). 18

CHAPTER 3. CSP

3.2. MORE PROPERTIES OF RELATIONAL STRUCTURES

3.2

More properties of relational structures

Definition 3.8. Given a relational structure S = (S, R), a k -ary function f defined on the set S , where k 1, is called a polymorphism if it preserves all relations in R.

Definition 3.9. We say that an n-ary polymorphism f : S n ! S is idempotent if we have that f (x, x, . . . , x) = x, for every x 2 S. Definition 3.10. Let S be a finite relational structure. We say that a polymorphism f (x1 , . . . , xn ), n 2, is a weak near-unanimity polymorphism if

1. f (x, . . . , x) = x, 2. f (x, . . . , x, y ) = f (x, . . . , x, y, x) = · · · = f (y, x, . . . , x). Using a result of Mar´ oti and McKenzie [16], Larose and Zad´ ori were able to prove the following theorem, which gives a general criterion for a relational structure to have an NP-complete CSP. Theorem 3.1. (Larose, Zad´ ori [15]). Let S be a finite relational structure which does not admit a weak near-unanimity polymorphism. Then there exists a finite relational structure T whose only idempotent polymorphisms are projections, such that CSP(T) is poly-time reducible to CSP(S). Therefore, if T does not have a weak near-unanimity polymorphism, CSP(S) is NP-complete. 19

3.2. MORE PROPERTIES OF RELATIONAL STRUCTURES Proof. We refer the reader to [15] for the complete proof.

CHAPTER 3. CSP

Due to Theorem 3.1, the Dichotomy Conjecture of Feder and Vardi can be reformulated as follows: Conjecture 3. (Bulatov, Jeavons and Krokhin [4]) Let S be a finite relational structure, then CSP(S) is in P if and only if S admits a weak near-unanimity polymorphism.
2

3

0

1

Figure 3.1: A digraph not admitting a weak near unanimity polymorphism.

Example 3.2. It can be shown that the digraph in Figure 3.1 does not admit a weak near unanimity polymorphism and consequently, its homomorphism problem is NP-complete [10].

20

Chapter 4 Datalog and Bounded Width
Definition 4.1. A Datalog program is a finite set of rules of the form:

t0 :- t1 , t2 , . . . , tn where ":-" separates the head and the body of the clause and each ti , i = 0, 1, . . . , n is an atomic formula R(xi1 , . . . , xik ). Then we call t0 the head of the rule, and the sequence t1 , t2 ,. . . , tn the body of the rule. Definition 4.2. The signature of the input of the program is the language of a relational structure. For example, the signature of a graph is a single binary relation.

Definition 4.3. The predicates (atomic formulas) or statements in the heads of the rules are not from the signature and are called IDBs (or intentional database predicates ) 21

CHAPTER 4. BOUNDED WIDTH while all other predicates come from the signature and are called EDBs (or extentional database predicates ).

One of the IDBs, which is usually nullary, as it does not depend on any variables, is designated as the goal predicate of the program. The goal predicate is assumed to be initially set to FALSE and we say that a Datalog program accepts a structure S if its goal predicate evaluates to TRUE on S. Example 4.1. The following Datalog program accepts an undirected graph if and only if the graph is not 2-colourable. In essence, the program is searching for the occurence of an odd cycle, as odd cycles are not 2-colourable. Once such a cycle is found, the program evaluates to TRUE.

Odd(X, Y ) : Odd(X, Y ) : non2col :

E (X, Y ) Odd(X, Z ), E (Z, T ), E (T, Y ) Odd(X, X )

The first clause provides the definition of an odd path between X and Y. The second clause is used to define odd paths recursively; it does so by adding two edges to an odd path, which also results in an odd path. The goal predicate decides whether the path between X and X (a cycle) is either odd or even. In this example, Odd and non2col are the IDBs and non2col is the program's goal 22

CHAPTER 4. BOUNDED WIDTH
0 C returns TRUE R B C returns FALSE R B 0

C returns TRUE R R

R

B

R

B

B

R C returns FALSE R B C returns TRUE R B R: Red B: Blue

B

R

R B

R B

R

B

R

Figure 4.1: A 2-colouring of even and odd cycles. predicate. The only EDB is the signature predicate E .

EDBs consist of the relations provided by the signature, while IDBs are "new" relations derived from EDBs. An important observation is that each program line or clause is, in fact, a positive primitive formula, which defines an IDB in terms of basic structure relations. Definition 4.4. Given S a finite relational structure with a finite signature , we define the class coCSP (S) to consist of all finite structures T in the same signature as S such 23

CHAPTER 4. BOUNDED WIDTH that T is not homomorphic to S. Definition 4.5. We say that a finite relational structure S, with a finite signature , is of bounded width if there exists a Datalog program which accepts precisely the structures from coCSP(S). Example 4.2. [10] 1. If S is a 2-colourable undirected graph or a 2-colourable digraph, then S is of bounded width. 2. Any finite undirected graph or a digraph containing a loop is of bounded width. 3. For every k ! ! 2, Ck is of bounded width. It can be shown ([10]) that G 6! Ck if and

! only if Cm ! G for some oriented cycle of algebraic length m not divisible by k . So, ! coCSP(Ck ) consists of all digraphs G which contain oriented cycles whose algebraic ! length is not divisible by k . The Datalog program which accepts coCSP(Ck ) can be constructed similarly to the one from Example 4.1.

Proposition 4.1. (Hell, Ne set ril [10]) If a finite relational structure S is of bounded width, then CSP(S) is in P. Proof. Fix a finite relational structure S with a finite signature  so that S is of bounded width. There exists a Datalog program which accepts coCSP(S). Suppose T is a finite relational structure in signature . Since a Datalog program always terminates its run 24

CHAPTER 4. BOUNDED WIDTH

4.1. CONSISTENCY CHECK

in a number of steps which is a polynomial function in |T |, we can decide in polynomial time whether T is homomorphic to S or not. For digraphs, the run of a Datalog program can be formulated in terms of a purely graph-theoretic algorithm. Such algorithms are called consistency checks.

4.1

Consistency check

Given two digraphs G and H with ui 2 V (G), i = 1, 2, 3 . . . , |V (G)|. We define a vertexto-vertex assignment, denoted by " ", where ui vj , with vj 2 V (H ), and j =

1, 2, 3 . . . , |V (H )|. Initially the possible vertices candidates for the assignment to ui constitute the domain
ui ,

the list of all vertices vj in H .

This is how the consistency check works: Remove vertex vj from vj +1 in
ui+1 , ui

if for ui+1 (adjacent to ui in a given direction), there is no

adjacent to vj in the same direction as ui ui+1 . We say that the domain of

each vertex in G is consistent if it remains nonempty after possible changes (removals). It is said to be inconsistent if the domains become empty, meaning that all vertices were removed from their lists.
a c e 0 G b d f H 1 2 3 4 5

Figure 4.2: Consistency check performed on two oriented paths. 25

4.1. CONSISTENCY CHECK

CHAPTER 4. BOUNDED WIDTH

Example 4.3. Given the two oriented paths G and H from Figure 4.2, let us check if they are consistent. Initially the domains are:
a= b= c= d= e= f=

{0, 1, 2, 3, 4, 5} {0 , 1 , 2 , 3 , 4 , 5 } {0, 1, 2, 3, 4, 5} {0 , 1 , 2 , 3 , 4 , 5 } {0 , 1 , 2 , 3 , 4 , 5 } {0, 1, 2, 3, 4, 5}
a

We now consider

and check for a possible change. Since there exists an arc ab we

must remove any vertex from the domain that does not oer the same adjacency in H , thus, 5 needs to be removed. After applying the check to each domain, the lists are nonempty and consequently consistent:
a=
#

{0, 1, 2, 3, 4, 6 5} {6 0, 1, 2, 3, 4, 5} {0, 1, 2, 3, 4, 6 5} {6 0, 1, 2, 3, 4, 5} {0 , 1 , 2 , 3 , 4 , 6 5 } {6 0, 1, 2, 3, 4, 5}

"

b=

#

c=

d=
"

e=
#

f=
"

The arrow index below each vertex of G shows the direction of the arc.

26

CHAPTER 4. BOUNDED WIDTH

4.1. CONSISTENCY CHECK

Lemma 4.1. (Hell, Ne set ril [10]) If G is H -colourable, then the consistency check will succeed. Proof. We refer the reader to [10] for the complete proof. Example 4.4. We have previously established that any even cycle is 2-colourable. Let us consider C6 and K2 . Initially the domains are :
a= f=

{red, blue}, {red, blue}.

b=

{red, blue},

c=

{red, blue},

d=

{red, blue},

e=

{red, blue},

After applying the consistency check, the list remains intact as neither red nor blue needs to be removed, because the edge relation constraint is satisfied at every step of the check. Theorem 4.1. (Hell, Ne set ril [10]) If H is an oriented path, then H is of bounded width. Proof. Example 4.3 confirms this theorem, but we will prove it in its generality. A theorem from Hell, Ne set ril [10] states that a given H is of bounded width if and only if there exists G such that G ! H when the consistency check performed on G succeeds. Using this notion on H , an oriented path, we will use the consistency check. If it succeeds, then we will define an H -colouring and thus prove that H is of bounded width. Let us label all the vertices of the path H as 1, 2, 3, . . . , |V (H )|. If indeed the consistency check succeeds on H , then
u,

for all u 2 V (G) will be nonempty but will contain

at least one vertex of H . And the list being consistent means that for any given vertex 27

4.2. PAIR CONSISTENCY CHECK v1 in
ui ,

CHAPTER 4. BOUNDED WIDTH
ui+1 .

there must exist its adjacent vertex v2 in

This is important to note and
ui+1 .

for consistency, in order to ensure arc relations between

ui

We claim that

we can find an homomorphism f , by assigning to each f (u) the corresponding smallest labeled vertex residing in the consistent domain
u.

This is our H -colouring.

4.2

Pair consistency check

Pair consistency check applies to pairs of vertices. In the pair consistency check procedure, the arc-to-arc assignment is (u1 , u2 ) (v1 , v2 ), where u1 is taken to v1 and u2 is

taken to v2 following arc adjacency and direction constraint. Initially possible pairs of vertices, candidates for any assignment are all tuples (v1 , v2 ) 2 V (H ) with connecting arcs. This is how the pair consistency check works: Remove any pairs (v1 , v2 ) from
(u1 ,u3 ) u1 ,u2 ,

if there is no v in the tuples of the domain

and

(u2 ,u3 ) ,

assuming there exists an arc between vertices (u1 , u2 ), (u1 , u3 ) and
(u1 ,u3 )

(u2 , u3 ) such that (v1 , v ) belongs to

and (v2 , v ) belongs to

(u2 ,u3 ) .

We say

that the domain of each pair of vertices is consistent if the list remains nonempty after possible changes (removals). It is said to be inconsistent if the domains become empty. 28

CHAPTER 4. BOUNDED WIDTH

4.3. MAJORITY POLYMORPHISM

4.3

Majority polymorphism

Let S be a finite relational structure with a finite signature. We say that S admits a majority polymorphism if there exists a ternary polymorphism m : S3 ! S such that m(x, x, y ) = m(x, y, x) = m(y, x, x) = x, for all x, y 2 S. Theorem 4.2. (Hell, Ne set ril, [10]) If H admits a majority polymorphism, then H has bounded width. Proof. The proof [10] uses the fact that if a given digraph admits a majority polymorphism, then the pair consistency check will be successful, and a homomorphism can be defined based on the success of the pair consistency check. Corollary 1. (Hell, Ne set ril, [10]) If H admits a majority polymorphism, then the H colouring problem is polynomial time solvable. Example 4.5. Using the digraph in Figure 4.3, let us define a majority polymorphism. We have the following possible scenarios 8 > > > (1) > > > > > > > < (2) > > > (3) > > > > > > > : (4)

xyz are some permutations of {0,1,2}; xyz are in {0,1,2} but at least two terms are equal; xyz are all dierent but contains one instance of 3; xyz contain 3 but are not all dierent;

xyz =

We are giving special attention to vertex 3 as it does not have any out-neighbours, it is 29

4.3. MAJORITY POLYMORPHISM

CHAPTER 4. BOUNDED WIDTH

2

3

0

1

Figure 4.3: A digraph admitting the majority polymorphism. a dead end. We will try to avoid going to 3. (1) In consideration for the length of this thesis, we will consider only few permutations of {0, 1, 2}. The same operation can be applied to all other permutations. Considering the order 012, we study out-neighbours of each vertex 0,1 and 2. From 0 , we can either go to 1 or 3. Since the rule is to avoid the dead end, we choose 1. From 1 , we can either go to 2 or 3, we avoid 3 by choosing 2 . From 2 , we will choose 0 . Figure 4.4 represents a fragment of the Cartesian product graph G3 , which consists of the triples in {0, 1, 2}3 all of whose coordinates are distinct: We quickly notice the following pattern 0 ! 1 ! 2 ! 0 ! 1 ! 2 ! . . . Hence, the majority polymorphism here is defined as it would be in C3 . (2) Since two coordinates are equal, we take the majority element, m(112) = 1. 30
!

CHAPTER 4. BOUNDED WIDTH

4.3. MAJORITY POLYMORPHISM

0 # 1 # 2

1 # 2 # 0

2 # 0 # 1

1 # 2 # 0

0 # 1 # 2

2 # 0 # 1

2 # 0 # 1

0 # 1 # 2

1 # 2 # 0

2 # 0 # 1

1 # 2 # 0

0 # 1 # 2

Figure 4.4: Connectivity of triples built from 0, 1, and 2. (3) With all xyz dierent but including 3, we decide to take m(xyz ) = 3. (4) Since two coordinates are equal, we take the majority element m(223) = 2.

The existence of a majority polymorphism for a given structure, among many other polymorphisms, is su cient to prove the CSP can be solved in polynomial time. Definition 4.6. Let S be a relational structure of finite signature. We say that a k -ary polymorphism f : S k ! S is a k -ary near-unanimity polymorphism on S if

f (xx . . . xy ) = f (xx . . . yx) = · · · = f (yx . . . xx) = x, for all x, y 2 S

.

Theorem 4.3. (Barto, Kozik [2]) Any finite relational structure which admits a k -ary near-unanimity polymorphism is of bounded width.

Proof. We refer the reader to [2] for the complete proof. 31

4.3. MAJORITY POLYMORPHISM

CHAPTER 4. BOUNDED WIDTH

We are now in position to sketch the proof of the homomorphism dichotomy for undirected graphs, due to Hell and Ne set ril [10]. Theorem 4.4. (Hell, Ne set ril, [10]) Let H be a graph admitting loops. (1) If H is bipartite or contains a loop, then the H -colouring problem is in P. (2) Otherwise, the H -colouring problem is NP-complete. Proof. (1) follows directly from Example 4.1 at the beginning of this section. (2) Suppose H = (V, E ) is an undirected graph without any loops and containing an odd cycle. Let C be an odd cycle in H . The heart of the proof consists in showing that C cannot be compatible with a k -ary weak near-unanimity of any arity k of the proof are rather technical and involved and, therefore, omitted. Theorem 4.3 shows that if a finite relational structure admits a near-unanimity polymorphism, then it is of bounded width. This naturally leads us to the question whether the property of being of bounded width (having a set of homomorphism recursively defined by a Datalog program) can be characterized by the existence of a particular polymorphism. This conjecture, originally posed by Larose and Zad´ ori [15] was finally resolved recently through a very deep result of Barto and Kozik ([2]). Theorem 4.5. (Barto, Kozik [2]) For a finite relational structure S, the following are equivalent. 1. S is of bounded width. 32 2. The details

CHAPTER 4. BOUNDED WIDTH

4.3. MAJORITY POLYMORPHISM

2. S admits a pair of weak near unanimity polymorphisms f,g of consecutive arities n, n + 1, for some n 3. 3. S admits a ternary weak near unanimity polymorphism f and a 4-ary weak near unanimity polymorphism g, such that f (xxy ) = g (xxxy ). Proof. We refer the reader to [2] for the complete proof.

33

Chapter 5

CSP Dichotomy Conjecture to Digraphs
Feder and Vardi [7] assert that, for every finite relational structure S, CSP(S) is polynomial time equivalent to the homomorphism problem for a suitable balanced digraph DS , where DS is such that the following equivalences are true: CSP (S) , CSP (DS ), coCSP (S) , coCSP (DS ), RET (S) , RET (DS ). RET is the retraction transformation. We are interested in the representation of a finite relational structure in a language that is purely graph-theoretical followed by the translation of the finite relational structure to a suitable digraph to ensure optimal polymorphism preservation. Our main reference for the material in this chapter is [5]. In that paper, a simplification of the original reduction 34

CHAPTER 5. CSP DICHOTOMY

5.1. REDUCTION DIGRAPH

of Feder and Vardi is given, and will be the main tool used to obtain the original result of the next chapter.

5.1

A suitable digraph for reduction

We mention essentially the results that were revealed by the work of [5] in their proof of the reduction of CSPs to digraphs. Let us contemplate some of the identified properties of a suitable digraph DS . (1) DS must be built from a collection of minimal paths. Definition 5.1. A path P from vertex a to b is called minimal if P starts with two forward arcs from vertex a and ends with two forward arcs at b. The vertex a is called the initial vertex and b is called the terminal verted of P , denoted init(P ) and term(P ), respectively. Figure 5.1 is an example of a minimal path.

a· ! · ! ·

·!·!·!·

·!·!· b

Figure 5.1: A minimal path.

Furthermore, if we use the direction of the arcs to create levels for P , with a at level 0 and b at level 5, then in a minimal path when going from a to b we never revisit level 0 or reach level 5 before we get to b. Forward arcs are usually counted as "1" and backward arcs as "0". Hence, P can be 35

5.2. RELATIONAL STRUCTURES

CHAPTER 5. CSP DICHOTOMY

·O b · O _ · O · O _ · O a· Figure 5.2: Levels in the minimal path from Figure 5.1. annotated with the string 110111011. (2) DS must be balanced and h-bipartite. Recall that a balanced digraph G is one for which any given two paths P1 and P2 between a and b have the same algebraic length. Definition 5.2. A balanced digraph is h-bipartite if all its paths are minimal and have algebraic length h. (3) In DS , intersections of minimal paths are not permitted. As long as a 2 V (DS ) is neither an initial vertex nor a terminal vertex to all minimal paths Pi in DS , a must solely belong to a unique Pi . · O · · O ·

5.2

Relational structures and algebra

Given f and g , two functions, they form a linear identity if at most one function symbol appears on either side of the equation, f (x, y, z ) = g (x, z, x, x). 36

CHAPTER 5. CSP DICHOTOMY

5.2. RELATIONAL STRUCTURES

Definition 5.3. A linear identity is balanced if the same variables occur in f and g , f (x, y, z, y ) = g (x, y, y, y, z ). Definition 5.4. A linear identity f is idempotent if f (x, x, x . . . , x) = x. Definition 5.5. A given relational structure S is said to satisf y a set of identities  if, when these identities are evaluated in S , they are all true. Definition 5.6. A relational structure T is primitive positive def inable (pp def inable) by a relational structure S, if the set T of T form a relation on S that is directly ppdefinable from S and each relation of T defined on the set of T is pp-definable from S. We will show that every relational structure S is pp-definable by a balanced digraph DS where CSP (DS ) is polynomial time equivalent to CSP(S). Definition 5.7. M altsev conditions are conjunctions of equations which polymorphisms may satisfy in a given relational structure. For more details on important Maltsev conditions in universal algebra, see [11]. When Maltsev conditions are satisfied in a relational structure, it implies applicability of certain algorithms which solve the CSP of the relational structure. Let N denote the oriented path 101: The path N satisfies most of the important Maltsev conditions relevant to the algebraic theory of CSPs and will later on be used in the reduction of CSP to a digraph. 37

5.2. RELATIONAL STRUCTURES

CHAPTER 5. CSP DICHOTOMY

G W

G

 Figure 5.3: The oriented path N . Definition 5.8. We say that a finite relational structure S is congruence 3-permutable, if it admits two ternary polymorphisms f and g such that

f (x, y, y ) = x f (x, x, y ) = g (x, y, y ) g (x, x, y ) = y,

for all x, y 2 S . Lemma 5.1. (Bulin, Deli´ c, Jackson and Niven, [5]) The path N admits a majority polymorphism, congruence 3-permutability polymorphisms, and it satisfies any balanced set of identities. Proof. The three polymorphisms listed in Lemma 5.2.1 imply most of the Maltsev conditions that have been studied in applications of universal algebra in the study of CSPs. (1) N admits a majority polymorphism. We can define the majority operation as described in the previous chapter to be the majority element of {x, y, z } when at least two elements are equal. In the event that 38

CHAPTER 5. CSP DICHOTOMY

5.2. RELATIONAL STRUCTURES

x 6= y 6= z , we can choose to have m(x, y, z ) = . The majority operation is a polymorphism because it preserves relations in N .

(2) N admits congruence 3-permutability polymorphisms. Two linear polymorphisms f and g witnessing 3-permutability can be defined as follows: 8 > > > > > > > > <

if if

2 {x, y, z } and y 6= z ; 2 {x, y, z } and 2 / {x, y, z } and y 6= z ;

f (x, y, z ) =

g (x, y, z ) =

8 > > > > > > > > > > > > > <

> > > > > > > > :x

otherwise.

if if

2 {x, y, z } and x 6= y ; 2 {x, y, z } and 2 / {x, y, z } and x 6= y ;

If the tuple (x1 , y1 , z1 ) is sent to (x2 , y2 , z2 ) coordinate-wise, then in N, (x1 , y1 , z1 ) must belong to {, } and (x2 , y2 , z2 ) consequently must belong to { , }. This satisfies the definition of f and g . Also f (x1 , y1 , y1 ) = x1 and g (x1 , x1 , y1 ) = y1 can be observed directly from the definition of f and g . In f when variables y = z , by definition the value assigned to the operation is x, in our case x1 . Then in g , when variables x = y , the value 39

> > > > z > > > > > > > > > :x

if x = y ; otherwise.

5.3. REDUCTION TO DIGRAPHS assigned to the operation is z , in our case y1 .

CHAPTER 5. CSP DICHOTOMY

The identity f (x1 , x1 , y1 ) = g (x1 , y1 , y1 ) = x1 can also be proven by assuming x1 6= y1 . In f when x = y , the value of the operation is x, in our case x1 , and in g , when y = z , the value of the operation is x, in our case x1 . Hence, both functions f and g yield the same results x1 . (3) N satisfies any balanced set of identities. Let  denote the balanced set of identities. For any given operations applied to N from , we can define them as the vertex that is closest to .

5.3

Reduction to digraphs

We have identified some prerequisites on relational structures and digraphs necessary for the reduction transformation. The process of the transformation is illustrated in Figure 5.4.

Relational structure

Bipartite structure

Balanced digraph

Figure 5.4: Process diagram for reduction to digraph.

Definition 5.9. A bipartite relational structure is a structure S = (S, R), where R is a S binary relation, and S = A  B (S is a disjoint union of A and B ), and R  A  B . 40

CHAPTER 5. CSP DICHOTOMY

5.3. REDUCTION TO DIGRAPHS

5.3.1

Translation to a bipartite structure

In the bipartite structure translated from the relational structure the set of vertices are connected to the set of relations where they appear as coordinates. Here is how we can ensure this: Let S be a relational structure, we define two components of S, the set S and the set of relations R1 , R2 , . . . , Rn . Each of the Ri relations have arity ki (1  i  n). We define the transversal relation R = R1  R2  · · ·  Rn . Now let us define the edge relation Ri between the set S and the relations component R. In our bipartite structure, Ri will be defined as the edge connecting vertex a 2 S to the relation which has a as the ith coordinate of the tuple:

Ri = {(xi , (x1 , . . . , xm )) | (x1 , . . . , xm ) 2 R}.

or using primitive positive formulas, we can define R:

R = {(x1 , . . . , xk ) | 9y ((x1 , y ) 2 R1 ^ · · · ^ (xk , y ) 2 Rk )}.

Following the definition of pp-definable structures introduced at the beginning of this section, we can conclude that the relational structure S is pp-definable by the bipartite structure, denoted BS . Theorem 5.1. (Bulin, Deli´ c, Jackson and Niven, [5]) Given a relational structure S and 41

5.3. REDUCTION TO DIGRAPHS

CHAPTER 5. CSP DICHOTOMY

its corresponding bipartite structure BS . S satisfies a set of identities , if and only if BS satisfies . Proof. We refer the reader to [5] for the complete proof.

5.3.2

Transformation to digraph

We will begin to transform our bipartite graph BS to the desired balanced digraph DS . Let us replace every edge e 2 Ri by an oriented path Pe (of algebraic length 2k + 1) defined as Pe = 1 + Pe1 + 1 + Pe2 + 1 + · · · + 1 + Pek + 1, 8 > > > <1 if e 2 Ri else.

Pei =

where 101 is the path N, discussed earlier.

> > > :101

Example 5.1. Given the following tuples representing a relation from a bipartite structure BS , (a) (x1 , (x1 , y1 )) (b) (x1 , (y1 , x1 )) we will build the corresponding Pe . Since k = 2, Pe = 1 + Pe1 + 1 + Pe2 + 1,

(a)Because x1 2 R1 , Pe1 = 1, Pe is 42

CHAPTER 5. CSP DICHOTOMY

5.3. REDUCTION TO DIGRAPHS

· O · O _ · O · O · O · Figure 5.5: Path representing (x1 , (x1 , y1 )). (b) Because x1 2 R2 , Pe2 = 1, Pe is · O · O · O · O _ · O · Figure 5.6: Path representing (x1 , (y1 , x1 )). · O · · O ·

Note that the algebraic length of both paths in (a) and (b) is 5 (by definition 2k + 1).

After replacing every edge e by Pe , we obtain a (2k + 1)-bipartite balanced digraph with minimal paths and

|V (DS )| = |S | + |R| + 4|S ||R|k 43

2| R | k

5.3. REDUCTION TO DIGRAPHS and

CHAPTER 5. CSP DICHOTOMY

|E (DS )| = (|S ||R|(4k + 1) .

2|R | k

Lemma 5.2. (Bulin, Deli´ c, Jackson, Niven [5]) The relational structure S is pp-definable in DS on the set S . Proof. In [8], H¨ aggkvist, Hell, Miller and Neumann established the existence of a minimal path of height h that is homomorphic to the set of minimal paths in the balanced digraph DS (of height h). Let Pm denote such a minimal path that maps to all Pe . This means there is a trajectory Pm that connects the vertices in S to the relation component. Hence, the set S is pp-defined by DS :

S = {9b 2 DS |a ! b}

Pm

Lemma 5.3. (Bulin, Deli´ c, Jackson, Niven [5]) CSP(DS ) reduces in polynomial time to CSP(S). Proof. We refer the reader to [5] for the complete proof.

44

Chapter 6 Preservation of Bounded Width
The content of this section revolves around a new proof by Bulin, Deli´ c, Jackson and Niven on the reduction of a finite relational structure to a balanced digraph. According to Theorem 4.5, the property of a CSP being of bounded width can be expressed by a conjunction of two balanced identities. Since the construction from the previous chapter preserves the validity of balanced identities, we have the following theorem: Theorem 6.1. (Bulin, Deli´ c, Jackson and Niven, [5]) Given a finite relational structure S=(S,R), where R is k-ary relation (k CSP(DS ) is of bounded width. Proof. The complete proof can be found in [5]. It is largely algebraic and does not truly reflect the algorithmic reasons for such an equivalence. Namely, we would like to gain a better insight into how expressibility in Datalog gets preserved under this 45 2), CSP(S) is of bounded width if and only if

CHAPTER 6. PRESERVATION OF BOUNDED WIDTH construction. We now proceed to give an alternative proof of Theorem 6.1 working strictly within the Datalog-based definition of bounded width. Theorem 6.1 can be restated in the following way: Theorem 6.2. coCSP(S) is expressible in Datalog if and only if coCSP(DS ) is expressible in Datalog. Proof. It is a well-known fact that if a finite relational structure S is positive-primitive definable within a finite relational structure T, then if coCSP (T) is expressible in Datalog, so is coCSP(S) [7]. For that reason, we only need to show that if coCSP(S) is expressible in Datalog, so is coCSP(DS ). First, we need to establish two claims: Claim 6.1. Given m 1, the set of all finite oriented paths whose algebraic length is

greater or equal to m + 1 is definable in Datalog. Proof. An oriented path P is of algebraic length greater or equal to m + 1 if and only if P 6! Pm (no homomorphism exists between P and Pm ). Since Pm is of bounded width, for every m 1, the claim follows.
! ! ! ! ! ! ! !

Claim 6.2. For every finite oriented path P , coCSP (P ) is definable in Datalog. Proof. This follows directly from the fact that every finite oriented path is of bounded width ([10]). This was proven in Chapter 4. 46

CHAPTER 6. PRESERVATION OF BOUNDED WIDTH Suppose S = (S, R) is a finite relational structure such that R is a k -ary (k 2) relation,

and assume that coCSP (S) is definable in Datalog. Since the height of the associated balanced digraph DS is 2k + 1, we can construct the Datalog program which will accept coCSP(DS ) as follows: (1) Include the clauses which will guarantee acceptance of any digraph which contains a path of algebraic length at least 2k + 2. This can be done using the reasoning in Claim 6.1. (2) For each path P1 ,. . . ,Pk used in the construction of DS , include clauses that will guarantee the acceptance of all coCSP (Pi ), i = 1, . . . , k . This can be done using Claim 6.2. (3) For each clause of the program which accepts coCSP (S) in
! ! !

t:

t 0 , t1 , . . . , t m

ti is a relation that can be written as

R ( x i 1 , xi 2 , . . . , x i k )

for some elements xi1 , xi2 , . . . , xik , we replace it by a conjunction of the form

9y ("xi1 ! y " ^ · · · ^ "xik ! y ")

P1

Pk

47

CHAPTER 6. PRESERVATION OF BOUNDED WIDTH so that " xij ! y " is a positive-primitive formula asserting that xij and y are connected by an oriented path isomorphic to Pj . Finally, we claim that the Datalog program constructed in this way accepts a digraph G if and only if G 6! DS . If G is accepted by clauses from (1), then it contains a path of algebraic length greater or equal to 2k + 2, so it cannot be homomorphic to DS . If G is accepted by clauses (2), then it is either such that all the paths in G are of algebraic length at most 2k with G not homomorphic to DS , or G contains a path of algebraic length at least 2k+2. In the latter case, the clauses from (3) will accept G if it is not homomorphic to DS . Similarly, if G 6! DS , then one of the sets of clauses (1)-(3) will guarantee the acceptance of G.
Pj

48

Chapter 7 Conclusion and Open Problems

7.1

Summary

In Chapter 1, we gave basic definitions involving the concepts of homomorphisms on graphs and digraphs and established elementary consequences of the existence of a homomorphism between two graphs or digraphs. Chapter 2 presented basic notions from the theory of computational complexity, such as problems being in complexity classes P and NP. In addition, we found out that a well-known NP-complete problem, such as SAT, can be polynomially reduced to 3-SAT and 3-colouring problems for graphs. In Chapter 3, we introduced the notion of the constraint satisfaction problem for a finite relational structure and investigated the role played by positive-primitive first-order formulas in the polynomial reduction of one CSP to another. The concept of bounded width CSPs was investigated in Chapter 4, where we studied 49

7.2. OPEN PROBLEMS

CHAPTER 7. CONCLUSION AND OPEN PROBLEMS

several aspects in which it can be viewed using definability in Datalog, an algebraic problem asking whether a certain structure admits particular polymorphisms or, in the context of digraphs, whether particular intuitive algorithms are adequate to solve the CSP in question. The original work in this thesis lies in a new method of reducing CSPs for relational structure to homomorphism problems for balanced digraphs, based on a recent work of Bulin, Deli´ c, Jackson, and Niven. The exposition of Chapter 5 follows closely the content of [5]. Finally, Chapter 6 consists of original work, based on the techniques developed in the previous chapter, to give an original proof that CSPs of bounded width transform to homomorphism problems for digraphs which are also of bounded width. Unlike the result of Atserias ([1]) and those of Bulin, Deli´ c, Jackson, and Niven ([5]), our proof does not rely on involved techniques from model theory or validity of algebraic conditions but simply using Datalog-based definitions.

7.2

Open problems

As stated in Chapter 3, the main open problem in the area is the so-called Dichotomy Conjecture, due to Feder and Vardi. Conjecture 4. (Dichotomy Conjecture, [7]). Every CSP with a finite relational structure is either in P or it is NP-complete. 50

CHAPTER 7. CONCLUSION AND OPEN PROBLEMS

7.2. OPEN PROBLEMS

So far, all known evidence points to the a rmative answer to the conjecture. The two major results in the area ([2],[3]) indicate that the majority of CSPs over finite relational structures which are tractable seems to be so for two reasons: 1. They are of bounded width, or 2. They can be solved using a generalization of Gaussian elimination ("few subpowers algorithm" [3]). It is known that there are finite structures (see [7]) which are solvable using the few subpowers algorithm but are not of bounded width, and conversely. In Chapter 5, we showed that if a relational structure S is such that coCSP(S) is expressible in Datalog, so is coCSP(DS ).

7.2.1

Datalog and LFP

The logic LFP (Least Fixed Point) is an extension of first-order logic that has an operator allowing to define least fixed points of a given formula. The LFP is formed by closing first-order logic under the rule: if µ is a formula, positive in the relational symbol R, then so is lf pR,! µ( t ) x We interpret this to mean that the tuple t is the least fixed point of the operator that maps R to µ(R, x ). 51
! ! !

7.2. OPEN PROBLEMS

CHAPTER 7. CONCLUSION AND OPEN PROBLEMS

Example 7.1. The formula 8u8v [lf pT,xy (x = y _ 9z (E (x, z ) ^ T (z, y )))](u, v ) is satisfied in a graph G = (V, E ) if and only if G is connected.

This example shows that a Datalog program can be written as a single formula in the LFP logic. One can show that, similarly, every Datalog program can be written as a single LFP formula. However, there are examples (complicated) that show that the converse is not true: there are queries which can be expressed using formulas in the LFP logic, but which cannot be verified using Datalog programs. Thus, Datalog is a proper subset (in terms of what it can express) of the LFP logic. Hence, our result from Chapter 6 naturally leads to the following two problems: Problem 1. If a finite relational structure S is such that coCSP(S) is definable in LFP, then is the same true for coCSP(DS )? Problem 2. Is there an extension of the logic LFP such that, for a finite relational structure S, coCSP(S) is definable in this extension if and only if CSP(S) is in P? We notice that if such an extension of LFP indeed exists and if given a finite structure S and a formula µ in this logic, we can decide whether

S |= µ.

That means if µ is true in S in runtime which is a polynomial function of |S|, the 52

CHAPTER 7. CONCLUSION AND OPEN PROBLEMS

7.2. OPEN PROBLEMS

Dichotomy Conjecture is true. For that reason, we believe that further investigation of these problems may play an important role in settling the Dichotomy Conjecture and it will be the focus of our future research.

53

Bibliography
[1] A. Atserias, On digraph coloring problems and treewidth duality, European J. Combin. 29 (2008), 796­820. [2] L. Barto and M. Kozik, Constraint satisfaction problems of bounded width, 50th Annual IEEE Symposium on Foundations of Computer Science (FOCS 2009). [3] J. Berman, P. Idziak, P. Markovi´ c, R. McKenzie, M. Valeriote and R. Willard, Varieties with few subalgebras of powers. Trans. Amer. Math. Soc. 362 (2010), 1445­ 1473. [4] A. A. Bulatov, P. G. Jeavons and A. Krokhin, Classifying the complexity of constraints using finite algebras. SIAM J. Comput., 34 (3). (2005) 720-742. [5] J. Bulin, D. Deli´ c, M. Jackson, T. Niven, On the Reduction of the CSP Conjecture to Digraphs, submitted to SIAM Journal of Computing. [6] S. A. Cook, The Complexity of Theorem Proving Procedures, Proceedings Third Annual ACM Symposium on Theory of Computing, May 1971, 151- 158 54

BIBLIOGRAPHY

BIBLIOGRAPHY

[7] T. Feder and M. Y. Vardi, The computational structure of monotone monadic SNP and constraint satisfaction: a study through Datalog and group theory, SIAM J. Comput., 28 (1), 1998, 57­104.

[8] R. H¨ aggkvist, P. Hell, D.J. Miller and V. Neumann Lara, On multiplicative graphs and the product conjecture, Combinatorica 8 (1988), 63­74.

[9] P. Hell and J. Ne set ril, On the complexity of H -colouring, J. Combin. Theory Ser. B 48 (1990), 92­110.

[10] P. Hell and J. Ne set ril, Graphs and Homomorphisms, Oxford Lecture Series in Mathematics and its Applications 28, Oxford University Press, 2004.

[11] D. Hobby and R. McKenzie The structure of finite algebras. Contemporary Mathematics, 76. American Mathematical Society, Providence, RI, 1988. xii+203 pp. ISBN: 0-8218-5073-3.

[12] P. Idziak, P. Markovi´ c, R. McKenzie, M. Valeriote and R. Willard Tractability and learnability arising from algebras with few subpowers, SIAM J. Comput. 39 (2010), no. 7., 3023­3037.

[13] R. Ladner, On the Structure of Polynomial Time Reducibility, J. ACM 22 (1975), 155­171. 55

BIBLIOGRAPHY

BIBLIOGRAPHY

[14] B. Larose and P. Tesson Universal algebra and hardness results for constraint satisfaction problems. Theoret. Comput. Sci. 410 (2009), no. 18. [15] B. Larose and L. Zad´ ori Bounded width problems and algebras, Algebra Universalis, 56 no. 3­4, 439­466, 2007. [16] M. Mar´ oti and R. McKenzie, Existence theorems for weakly symmetric operations, 2006. (to appear in Algebra Universalis) [17] C. Papadimitriou, Computational Complexity, Addison Wesley, 1994. [18] T. J. Schaefer, The Complexity of Satisfiability Problems, STOC (1978), pp. 216­226. [19] D.B. West, Introduction to Graph Theory, 2nd edition, Prentice Hall, 2001.

56

