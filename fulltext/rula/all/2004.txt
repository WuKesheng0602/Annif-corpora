MODELS AND MINING OF ON-LINE SOCIAL NETWORKS

by

Yanhua Tian, B.Sc. Tianjin University, 1999

A thesis presented to Ryerson University in partial fulfillment of the requirements for the degree of Master of Science in the Program of Applied Mathematics

Toronto, Ontario, Canada, 2011 c Copyright by Yanhua Tian 2011

I hereby declare that I am the sole author of this thesis or dissertation. I authorize Ryerson University to lend this thesis or dissertation to other institutions or individuals for the purpose of scholarly research.

Signature:

I further authorize Ryerson University to reproduce this thesis or dissertation by photocopying or by other means, in total or in part, at the request of other institutions or individuals for the purpose of scholarly research.

Signature:

ii

Abstract
Models and Mining of On-line Social Networks Master of Science, 2011 Yanhua Tian Applied Mathematics, Ryerson University Power law degree distribution, the small world property, and bad spectral expansion are three of the most important properties of On-line Social Networks (OSNs). We sampled YouTube and Wikipedia to investigate OSNs. Our simulation and computational results support the conclusion that OSNs follow a power law degree distribution, have the small world property, and bad spectral expansion. We calculated the diameters and spectral gaps of OSNs samples, and compared these to graphs generated by the GEO-P model. Our simulation results support the Logarithmic Dimension Hypothesis, which conjectures that the dimension of OSNs is m = log N . We introduced six GEO-P-type models. We ran simulations of these GEO-P-type models, and compared the simulated graphs with real OSN data. Our simulation results suggest that, except for the
iii

GEO-P(GnpDeg) model, all our models generate graphs with power law degree distributions, the small world property, and bad spectral expansion.

iv

Acknowledgements
First and foremost I offer my sincerest gratitude to my supervisor, Dr. Anthony Bonato, for his encouragement, guidance and support from the initial stage of this project and giving me extraordinary academic experiences through out the work. I extend my thanks to the Department of Mathematics at Ryerson University, and especially to Mr. Stephen Kanellis, who supplied computer support. A special thanks to Dr. Peter Danziger and Dr. Dejan DeliÂ´ c for being part of my thesis committee. Finally, I would like to thank my family, especially my husband Yong, for their constant support in all aspects of my life.

v

Contents
Abstract Acknowledgements List of Figures Chapter 1. Introduction of On-line Social Networks 1. Graph Theory 2. Overview of Thesis Chapter 2. Geometric models for OSNs 1. Introduction to the GEO-P model 2. Results on GEO-P 3. Dimension of the GEO-P model Chapter 3. Properties of Real OSN Data 1. Properties of Real OSNs 2. Properties of Graphs Generated by the GEO-P Model 3. Logarithmic Dimension Hypothesis Chapter 4. New models for OSNs
vii

iii v ix 1 3 14 15 15 22 28 31 31 36 38 41

1. Ranking by Age 2. Ranking by Degree 3. Tension Parameter Chapter 5. Conclusion and Open Problems Chapter 6. Appendix Bibliography

41 45 51 57 61 131

viii

List of Figures
1.1 A friendship graph sampled from Wikipedia. 1.2 An undirected graph G with 4 vertices and 5 edges. 1.3 The subgraph H induced by {v1 , v2 , v3 }. 1.4 A random graph G 20, 1 . 2 3 4 6 7 10

1.5 Wikipedia degree distribution log-log plot.

2.1 20 randomly chosen vertices in a 2-dimensional unit hypercube. 16 2.2 Graph generated by 20 vertices at p = 1. 2.3 Graph generated by the GEO-P model,  = 0.7,  = 0.15, and p = 1. 3.1 YouTube sample degree distribution. 3.2 YouTube sample degree distribution log-log plot. 3.3 GEO-P degree distribution log-log plot, N = 7115,  = 0.7,  = 0.15, p = 1. 3.4 GEO-P degree distribution log-log plot, N = 7115,  = 0.4,  = 0.5, p = 1.
ix

20

21 32 32

37

37

4.1 Degree distribution of a graph generated by the GEO-P(Age) model. 4.2 Degree distribution of a graph generated by the GEOP(InvAge) model. 4.3 Degree distribution of graph generated by the GEO-P(Deg) model. 4.4 Degree distribution of graph generated by the GEO-P(GnpDeg) model. 4.5 Influence region of vertices 5, 7 and 16. 4.6 Degree distribution of graph generated by the GEO-P(Ten) model, with tension parameter h = -0.1. 4.7 Degree distribution of graph generated by the GEO-P(Ten) model, with tension parameter h = -0.3. 4.8 Degree distribution of graph generated by the GEO-P(Ten) model, with tension parameter h = -0.7. 55 55 54 50 52 50 44 44

x

CHAPTER 1

Introduction of On-line Social Networks
With the development of computer and network technology, On-line Social Networks (OSNs) have become increasingly important in human society. An OSN is an internet-based platform to communicate, network, and share information among people. Examples of OSNs include Facebook and Twitter. Compared to traditional social networks, OSNs allow users to spread information quickly and to a large audience. Facebook, one of the most popular OSNs, has now more than 500 million active users and an average user has 130 friends (see [17]). Computed-mediated communication stretches back to the late 1970s. Usenet, the oldest computer network communications systems, was created by two Duke University graduate students, Tom Truscott and Jim Ellis (see [19, 20]). By the late 1990s, with the boom of the Internet, a new generation of internet-mediated communication services began to flourish. Today there are over 200 major active on-line social networking websites (see, for example, [14]).

1

The studies of social networking go back to the 1960s. In 1967, Milgram and other researchers conducted several experiments examining the interconnectedness among human beings. Milgram and his research group proposed the theory that in human society every person can on average approximately reach another person in just six steps, which refers to the famous phrase "six degrees of separation" (see [15]). In 1998, Watts and Strogatz did further study on this topic. They defined the small world property for social networks, and introduced a random graph generation model that produces graphs with the small world property (see [21]). From 2000 onwards, as they have become more and more popular, OSNs have attracted more attention from scientists. In 2003, Adamic et al. gave an early study of OSNs. They chose Club Nexus as a sample to investigate properties, such as distance between users and the clustering coefficient (see [1]). In 2005, in his Ph.D thesis, LibenNowell studied Livejournal and showed that this OSN follows the small world property (see [13]). In 2006, Kumar et al. studied the evolution of OSNs by studying with Flickr and Yahoo! 360 (see [12]). Moreover, Golder et al. (see [11]), Ahn et al. (see [2]), Mislove et al. (see [6]) have studied the OSNs Facebook, Myspace, Orkut, and Flickr.

2

1. Graph Theory Graph theory is a natural tool to model and simulate the evolution of OSNs. To present an OSN by a graph, we represent people as vertices, and friendship between people as edges. For example, we retrieved a sample of the Wikipedia OSN (see [18]) to generate its friendship network; see Figure 1.1.

Figure 1.1. A friendship graph sampled from Wikipedia.

1.1. Introduction to graphs. We now give a precise definition of a graph. A graph G consists of a non-empty vertex set V (G), and
3

an edge set E (G) of unordered 2-elements sets from V (G); we may also consider E (G) as a binary relation on V (G). A graph G can be written as G = (V (G), E (G)), or if G is clear from the context, G = (V, E ). In a graph G, elements of V (G) are vertices, and the edge set E (G) can be empty. We call a graph as undirected graph if relations between pairs of vertices are symmetric and edges are not directed. In this case, an edge is represented by uv for vertices u and v . In this thesis, we will mainly focus on simple graphs, which are undirected graphs without loops, and where there is at most one edge between every pair of distinct vertices.

Figure 1.2. An undirected graph G with 4 vertices and 5 edges.
4

Figure 1.2 shows an example of an undirected graph. The vertex set and edge set of this graph G are:

V (G) = {v1 , v2 , v3 , v4 }, E (G) = {v1 v2 , v1 v3 , v1 v4 , v2 v3 , v3 v4 }.

The cardinality |V (G)| is the order of the graph G. With the example of Figure 1.2, the order of the graph G is 4. We use degG (x) to present the degree of a given vertex x in graph G, which is the number of edges joined to the vertex x. With the example of Figure 1.2,

degG (v1 ) = degG (v3 ) = 3,

degG (v2 ) = degG (v4 ) = 2. A subgraph of graph G is a graph whose vertex set is a subset of V (G), and whose edge set is a subset of E (G). A subgraph H is called an induced subgraph of graph G if V (H )  V (G), and for any pair of vertices u and v of H, uv  E (H ) if and only if uv  E (G). For example, Figure 1.3 shows a induced subgraph H of the graph G of Figure 1.2. We now give a formal definition of random graphs. Define a probability space on graphs of a given order N  1 as follows. Fix a
5

Figure 1.3. The subgraph H induced by {v1 , v2 , v3 }.

vertex set V consisting of N distinct elements, usually taken as [N ] = {1, 2, . . . , N }, and fix p  [0, 1]. Define the space of random graphs of order N with edge probability p, written G(N, p) with sample space
N equalling the set of all 2( 2 ) (labelled) graphs with vertex set V, and

N P(G) = p|E (G)| (1 - p) 2

- |E (G)| ,

where P(A) is the probability that event A occurs. Informally, we may view G(N, p) as the space of graphs with vertex set V , so that two distinct vertices are joined independently with probability p. Even more informally: toss a (biased) coin to determine the edges of your graph. Hence, V does not change, but the number of
6

edges is not fixed: it varies according to a binomial distribution with expectation N p. Despite the fact that G(N, p) is a space of graphs, 2

we will abuse language and call it the random graph of order N with edge probability p. We will consider the cases when p is fixed, and when it is a function of N. Graph parameters, such as diameter and average degree, become random variables in G(N, p). We say that an event holds asymptotically almost surely (or a.a.s. for short) if it holds with probability tending to 1 as N  . Figure 1.4 shows a random graph with 20 vertices, and with edge drawn randomly with probability of 1 . 2

Figure 1.4. A random graph G 20,
7

1 . 2

As we often use asymptotic notation to present results, we will introduce some main asymptotic notation. Let f (x) and g (x) be two functions defined on some subset of the real numbers, we can write: f (x) = O(g (x)) if
x

lim sup

f (x) |g (x)|

exists and is finite. It is equivalent that there exists a constant c and a real number x0 , such that for all x > x0 ,

f (x)  cg (x).

Similarly, we write: f (x) = o(g (x)), if f ( x) = 0. x g (x) lim Another asymptotic notation we introduce is

f (x) = (g (x));

that is, there exists positive constants c1 and c2 , and a real number x0 , such that for all x > x0 ,

c1 |g (x)|  |f (x)|  c2 |g (x)|.

8

1.2. Power law degree distribution. Power law degree distributions are one of the most prominent properties of OSNs and other complex networks (see [3]). Analysis and experiments on OSNs found that the degree distribution of vertices follows a power law, which means that a large proportion of vertices have low degree, but a small (but non-negligible) proportion of vertices have substantially higher degree. In particular, the number of vertices of degree k (where k is non-negative integer) is proportional to an inverse power of k . We define the number of vertices of degree k as:

Nk = |{x  V (G) : degG (x) = k }|.

Then we have the formula: Nk  k - , N

(1)

where  > 2 is a positive real number, N is the order of graph G. If we take the logarithms on (1), then we can express the power law as: log Nk  log N -  log(k ), which gives a line with the slope of negative  . In 2006, Kumar et al. found that the degree distribution of the Flickr OSN follows a power law (see [12]). Note that the power law
9

degree distribution may only fit a certain range of degrees; for small and large degree vertices, the log-log plot may show more noise. We analyzed Wikipedia sample data and checked the degree distribution. Figure 1.5 shows that the degree distribution log-log plot of Wikipedia follows a power law, we can see that log-log plot of out-degree of those low degree vertices follows a straight line.

Figure 1.5. Wikipedia degree distribution log-log plot.

1.3. Small world property. The small world property is an important feature of OSNs, which was implicitly introduced by Milgram (see [15]), and explicitly by Watts and Strogatz (see [21]). The neighbours of a vertex x are defined as all vertices which are joined to x. We use notation N (x) to represent the neighbour set of vertex x. We define the distance between pairs of vertices as the number of edges of
10

a shortest path joining them. We use notation d(x, y ) to present the distance between vertices x and y . In the example above of Figure 1.2, we have that N (x) = {y, u, v }, N (y ) = {x, u}, d(x, y ) = d(x, u) = d(x, v ) = d(y, u) = d(u, v ) = 1, d(y, v ) = 2. We now give the definition of diameter, average distance, and clustering coefficient. The diameter of a graph is defined as the maximum distance between any two vertices (and  if the graph is disconnected). We usually use the notation diam(G) to represent the diameter of graph G. We define the average distance of an undirected graph G of order N as 1 2 D(G) = d(x, y )
x,y V (G)

N 2

.

Let S be the subgraph induced by N (x) and x, and let |E (S )| be the number of edges in S. For a given vertex x in G with degree at least two define the clustering coefficient of x as |E (S )| . degS (x) 2
11

C ( x) =

The clustering coefficient of G is the average of the clustering coefficients over all vertices of G, written C (G), where 1 |V (G)|

C (G) =

C (x).
xV (G)

With the graph of Figure 1.2, diam(G) = 2, and D(G) = 5 11 C (v1 ) = C (v3 ) = , C (v2 ) = C (v4 ) = 2, and C (G) = . 3 6

7 . Further, 12

The small world property demands a low average distance of O(log log N ) (or a diameter of O(log N )), and a higher clustering coefficient than found in a random graph G(N, p) with the same order N and approximately same average degree.

1.4. Bad spectral expansion. Social networks often organize into separate clusters in which the intra-cluster links are significantly higher than the number of inter-cluster links. It is reported that social networks possess bad spectral expansion properties realized by small gaps between the first and second eigenvalues of their adjacency matrices (see [10]). An adjacency matrix is a numerical way to present a graph. For a graph of order N , it is an N Ã N square matrix with binary entries. That is, entry aij can take the value of either 0 or 1, with 1 if there is an edge between the ith and j th vertices, and 0 if there is no edge
12

between the ith and j th vertices. With the graph of Figure 1.2, and the order of {v1 , v2 , v3 , v4 }, we can write adjacency matrix as:   0 1 1    1 0 1  A=   1 1 0   1 0 1  1    0   .  1    0

A nonzero scalar  and nonzero vector v, which satisfy

Av = v,

are called the eigenvalues and eigenvectors, respectively, of the matrix A. Note that if G is undirected, then its adjacency matrix is symmetric and so has all real eigenvalues. We sort the eigenvalues of matrix A such that |1 |  |2 |  ...  |N -1 |  |N |. Here 1 and 2 are called the first and second eigenvalues of G. With the undirected graph of Figure 1.2, we have that 1 = 2.56 and 2 = 0. Fix a graph G of order N with first and second eigenvalues 1 and 2 , respectively. Suppose that p is chosen so that the random graph G(N, p) has the same expected average degree as G, and let 1 and 2 be the first and second eigenvalues of G(N, p), respectively. We say
13

that G has bad spectral expansion if

|1 - 2 | < |1 - 2 |.

2. Overview of Thesis In this thesis, the remaining chapters focus on the following topics. In Chapter 2, we introduce the Geometric Protean models for OSNs, written GEO-P (first presented in [7]). We summarize the main theoretical results proved about this model in [7]. We simulate graphs using GEO-P, analyze their properties, and verify if graphs generated by those models follow the observed OSNs properties, such as power law degree distribution, small world property, and bad spectral expansion. In Chapter 3, we present results on real OSNs data, compute properties of graphs simulated by sampled data, and verify if the OSN samples obey the main properties described in Chapter 1. In Chapter 4, we introduce and simulate new models based on the GEO-P model. We compare these models to real OSN data. In Chapter 5, we summarize the results of the previous chapters, and state open problems. We note that the results of this thesis are original work. Parts of Chapters 2 were included in the accepted paper [7].

14

CHAPTER 2

Geometric models for OSNs
In this chapter, we introduce the Geometric Protean (or GEO-P) model for OSNs, first presented in [7].

1. Introduction to the GEO-P model The GEO-P model has vertices in a fixed metric space. We choose N vertices in a m-dimensional Euclidean space by some random process, assign vertices integers as their ranks, and determine edges by the probability based on ranks of vertices. There are four parameters in this model: the attachment strength   (0, 1), the density parameter   (0, 1 - ), the dimension m  N, and the link probability p  (0, 1]. The GEO-P model generates a sequence of graphs Gt over an infinite sequence of discrete time-steps. At each time-step t, one new vertex is born and one existing vertex dies. For each vertex x, we define a radius of influence, at each timestep we place an edge between pairs of vertices with probability p if one lies within the other's radius of influence. We begin by defining
15

r(x, t) to indicate the (unique) rank of vertex x at time-step t. Hence,

r(x, t)  [N ],

where [N ] = {1, 2, 3, ..., N - 1, N }. In this model, 1 is the highest rank and N is the lowest rank. At initial time-step t = 0, vertices are assigned ranks by a random order. Figure 2.1 shows 20 randomly chosen vertices in the 2-dimensional unit hypercube with ranks assigned by a random order.

Figure 2.1. 20 randomly chosen vertices in a 2dimensional unit hypercube.
16

At time-step t, where t > 0 the new vertex u is assigned a rank randomly chosen from set [N ], written r(u, t). We name the deleted vertex as v , and its rank at time-step t - 1 is written as r(v, t - 1). We assign ranks to vertices x at time-step t by

(2)

r(x, t) = r(x, t - 1) +  - ,

where x  V (Gt-1 )  V (Gt ),  = 1 if r(x, t - 1) > r(u, t), and 0, otherwise, and  = 1 if r(x, t - 1) > r(v, t - 1), and 0, otherwise. Every vertex has a unique rank at a given time-step; that is, r(x, t) = r(y, t) if and only if x = y . We define the influence region of vertex x at time-step t  0, written R(x, t), to be the ball around x with volume

(3)

|R(x, t)| = r(x, t)- N - .

Since the exponent - is negative, we have that the vertex with rank 1 has the largest influence region, and vertex with rank N has the smallest influence region. We assume that the volume of influence region corresponds to the ability to gain edges. Hence, higher ranked vertices are more likely to receive more edges than lower rank vertices. In Table 1 we list ranks, coordinates, and influence region volume of
17

20 vertices which are randomly chosen in Figure 2.1, where we choose  = 0.7 and  = 0.15. Table 1. Ranks, coordinates, and influence region volume of 20 vertices in the 2-dimensional unit hypercube. rank 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 coordinates volume (0.6712 , 0.7152) 0.137 (0.6537 , 0.9326) 0.1488 (0.06 , 0.8668) 0.0878 (0.1807 , 0.2554) 0.1191 (0.6421 , 0.419) 0.2418 (0.0642 , 0.7673) 0.0812 (0.7947 , 0.5774) 0.3928 (0.1202 , 0.525) 0.1059 (0.8092 , 0.7486) 0.1634 (0.44 , 0.2576) 0.1273 (0.3989 , 0.4151) 0.0916 (0.3908 , 0.8161) 0.182 (0.1635 , 0.9211) 0.638 (0.7891 , 0.8523) 0.2068 (0.3174 , 0.8145) 0.1121 (0.7519 , 0.2287) 0.0958 (0.3258 , 0.5464) 0.1006 (0.9509 , 0.444) 0.0784 (0.0205 , 0.9237) 0.0844 (0.5056 , 0.6357) 0.2957

We use defined as:

Â·



to indicate the infinity norm or maximum norm,

v



= max(|v1 |, |v2 |, ..., |vm-1 |, |vm |),

where v is a vector in Rm , and v = (v1 , v2 , ..., vm-1 , vm )  Rm . Let S be the unit hypercube in Rm . We define the torus metric on S as
18

follows. For x, y  S define

(4)

d(x, y ) = min{||x - y + u|| : u  {-1, 0, 1}m }.

The torus metric thus "wraps around" the boundaries of the unit cube, so every point in S is equivalent. The torus metric is chosen so that there are no boundary effects, and altering the metric will not significantly affect the main results. With the example of Figure 2.1,

d(17, 11) = 0.1314, d(17, 5) = 0.3162.

We define the m-dimensional radius of a vertex in terms of a parameter Cm as R(x, t) Cm
1 m

(5)

Rad(x) =

,

where, if m is even, then 2 Cm = m , ( 2 )! and if m is odd, then Cm = 2
m+1 2 m

 m!!

m-1 2

.

19

Here, m!! is defined as double factorial of an odd integer m; that is, for m = 2k - 1, and k a positive integer:
k

m!! =
i=1

(2i - 1) =

(2k )! . k !2k

We apply (5) to calculate the influence region radius for vertices 17, 11 and 5; Table 2 shows their radius values. If we simply choose parameter p = 1, then for every pair of vertices there will be an edge if at least one of those two verties falls in another one's influence region. Vertex 11 falls in 17's influence region as depicted in Figure 2.2(a), so there is an edge between them; vertices 17 and 5 are too far apart to fall in each other's influence region as Figure 2.2 (b) showed. Hence, no edge is between vertices 17 and 5; see Figure 2.3.

(a) Influence region of vertices 17 and 11. (b) Influence regions of vertices 17 and 5.

Figure 2.2. Graph generated by 20 vertices at p = 1.

20

Figure 2.3. Graph generated by the GEO-P model,  = 0.7,  = 0.15, and p = 1.

Table 2. Radius of vertices 17, 11, and 15. rank coordinates volume radius 17 (0.325834, 0.546449) 0.087807 0.1672 11 (0.398881, 0.415093) 0.119089 0.1947 5 (0.642061, 0.419048) 0.2068 0.2566

We now describe precisely how the GEO-P model generates graphs. 1. At the initial time-step t = 0, we randomly choose N vertices in S , and randomly assign vertex unique rank chosen from set [N ]. An edge between pair of vertices x and y is created with probability p,
21

if d(x, y )  max{Rad(x), Rad(y )}. 2. At time-step t > 0, a randomly chosen vertex v  V (Gt-1 ) dies, a new vertex u is born and is assign a rank randomly chosen from set [N ]. We update ranks of vertices x  V (Gt-1 )  V (Gt ) by (2), and determine edges by influence region, distance and probability p. It can be shown that this stochastic process converges to a stationary distribution (see [7]). The random graph corresponding to this distribution with given parameters , , m, p is called the geo-protean (or GEO-P model) graph, and is written GEO-P(, , m, p).

2. Results on GEO-P We now introduce some properties of graphs generated by the GEO-P model. Recall that an event holds asymptotically almost surely (a.a.s.) if it holds with probability tending to 1 as n tends to infinity. The following theoretical results for the GEO-P model were stated and proved in [7]. Let Nk = Nk (m, p, ,  ) denote the number of vertices of degree k in a graph of order n, generated by the GEO-P model with parameters p, , and  . Define Nk =
lk

Nl to be the number of vertices of
22

degree greater than or equal to k . The following theorem shows that the GEO-P model generates graphs with power law degree distribution.

Theorem 2.1 ([7]). Let   (0, 1),   (0, 1 - ), m  N, p  (0, 1], and n1-- log1/2 n  k  n1-/2- log-2-1 n. Then a.a.s. GEO-P(, , m, p) satisfies  +1

(6)

Nk = 1 + O(log-1/3 n)

p1/ n(1- )/ k -1/ .

From (6), for fixed parameters  and  , we have that
1 Nk  k-  . n

Hence,
1 Nk  k -  -1 n

(see, for example, [3]). Theorem 2.1 demonstrates that for a range of degrees, the GEO-P model generates power law graphs with exponent

(7)

b = 1 + 1/.
23

For a graph G = (V (G), E (G)) of order n, define the average degree of G by d = 2|E (G)| . The second theoretical results shows that graphs n

generated by the GEO-P model are dense; that is, the average degree tends to infinity with n.

Theorem 2.2 ([7]). A.a.s. the average degree of GEO-P(, , m, p) is p 1-

(8)

d = (1 + o(1))

n1-- .

By the small world property, OSNs require a diameter of O(log n). Following theorem describes the diameter features of graphs generated by GEO-P model.

Theorem 2.3 ([7]). Let   (0, 1),   (0, 1 - ), m  N, and p  (0, 1]. Then a.a.s. the diameter of GEO-P(, , m, p) is



(9)

D = O(n (1-)m log (1-)m n).

2

If we assume that the dimension m grows as a logarthmic function of n, then the diameter of the GEO-P model is constant. To see this,
24

if we let m = C log n, C  (0, 1), then we have by (9) that  2 log n + log log n (1 - )C log n (1 - )C log n  log n + o(1) (1 - )C log n  (1 - )C .

log D = O = O = O

If  =

 , then we have that (1 - )C log D = O( ) = O(1).

Hence, D = exp (O(1)) = O(1). Recall that another main feature of small world property is a higher clustering coefficient than found in random graphs with the same expected average degree. The next theorem proves that this does indeed hold in the GEO-P model.

25

Theorem 2.4 ([7]). A.a.s. the clustering coefficient of G sampled from GEO-P(, , m, p) satisfies the following inequality: 3 4 2 1- 3K m K
m

C (G)  (1 + o(1))

1- 1+
m

p p,

= (1 + o(1)) exp O

3 4

1- 1+

where K= n1-- log3 n
1/m

- ,

with  either 0 or 1 so K is even.

For example, when m = o(log n) it can be shown that a.a.s. 3 4
m+o(m)

C (G) 

= no(1) .

Note that for random graph G(n, p), the clustering coefficient of a vertex satisfies C (x) = p (see [3]). Hence, 1 n

C (G(n, p)) =

C (x) = p.
xV (G)

Hence, C (G)  no(1) C (G(n, d/n)) = d/n.
26

That is, the clustering coefficient of graphs generated by the GEO-P model is larger than in a random graph with the same order. Let A denote the adjacency matrix and D denote the diagonal degree matrix of a graph G. Then the normalized Laplacian of G is

L = I - D-1/2 AD-1/2 .

Let 0 = 0  1  Â· Â· Â·  n-1  2 denote the eigenvalues of L. The spectral gap of the normalized Laplacian is defined as

 = max{|1 - 1|, |n-1 - 1|}.

We state that random graphs have good spectral expansion, since  = o(1) (see [8, 9]). The next theorem shows that graphs generated by the GEO-P model have bad expansion properties, compared to random graphs.

Theorem 2.5 ([7]). Let   (0, 1),   (0, 1 - ), m  N, and p  (0, 1]. Let (n) be the spectral gap of the normalized Laplacian of GEO-P(, , m, p). Then a.a.s we have the following.

(1) If m = m(n) = o(log n), then (n) = 1 + o(1).
27

(2) If m = m(n) = C log n for some C > 0, then + C

(n)  1 - exp -

.

Note that in either case (1) or (2), (n) is close to 1, unlike in the random graph G(n, p) (where (n) tends to 0).

3. Dimension of the GEO-P model Given an OSN, its dimension is the minimum number m of attributes needed to identify users or a small set of users. Here attributes correspond to location, career, or hobbies, for example. We think that users with similar attributes are more likely to be friends. Hence, there should be an embedding of the OSN in m-dimensional Euclidean space where users with similar attributes are clustered together. The results stated for the GEO-P model in the previous section point to a theoretical estimate of the dimension of an OSN. The Logarithmic Dimension Hypothesis (or LDH ) states that the dimension m of an OSN satisfies m = O(log n). Let the OSN order to be n, power law exponent to be b, average degree to be d, and let D be the diameter. Then (7) shows us how to estimate
28

for  based on the power law exponent b. Let

d = log d/ log n, D = log D/ log n.

Equations (8) and (9) imply that (ignoring constants)

(10) (11)

d = 1 -  - , D =  . (1 - )m

Thus, by (10) and (11) we estimate m as: 1 D b-1 b-2

(12)

m = =

1-

d .

log n (1 - o(1)) log D

If D is a constant, then (12) suggests that the dimension m depends on log n/ log D. That is, m grows logarithmically with n. Hence, support for the LDH comes from the GEO-P model, although it is yet to be proved in practice (see Section 3 of Chapter 3). Table 3 predicts the dimensions of OSNs Cyworld, Flickr, Twitter, and YouTube based on (12) (see [7]). Let b be the power law exponent

29

for the in-degree distribution, n be the order of given OSN, and let m be rounded up to the nearest integer. Table 3. Dimensions of the OSNs: Cyworld, Flickr, Twitter, and YouTube. Parameter n b d D m OSN Cyworld 2.4 Ã 107 5 0.22 0.11 7

Flickr 3.2 Ã 107 2.78 0.17 0.19 4

Twitter 7.5 Ã 107 2.4 0.17 0.1 5

YouTube 3 Ã 108 2.99 0.1 0.16 6

30

CHAPTER 3

Properties of Real OSN Data
In this chapter, we consider data sampled from real OSNs. We analyze their properties viewed as complex networks, and contrast them to graphs simulated by the GEO-P model. Our sampled data was retrieved from the OSNs Wikipedia (see [18]) and YouTube (see [16]). Their orders are 7,115 and 570,774, respectively, and there are 103,689 and 4,945,382 edges in those two samples samples, respectively. We mainly focus on investigating their degree distribution, spectral gap and diameter.

1. Properties of Real OSNs In Chapter 1, we have shown that the Wikipedia sample follows a power law degree distribution. Figure 3.1 shows the degree distribution of a graph sampled from YouTube with order 570,774 (see [16]). It is evident that it follows a power law degree distribution. Figure 3.2 shows that the log-log plot is a straight line for medium degree vertices; that is, informally, vertices which are not of low or high degree.
31

Figure 3.1. YouTube sample degree distribution.

Figure 3.2. YouTube sample degree distribution loglog plot. We next analyzed OSN data for their diameters. We considered graph samples from Wikipedia and YouTube. We applied the software
32

SNAP (see [18]) to calculate the diameters, and calculated that they are 10 and 23, respectively. Finally, we checked the spectral gap of graphs in our OSNs samples. To evaluate the spectral gap, we calculate the first and second eigenvalues of their adjacency matrix. OSNs have large-scale adjacency matrices. To make the calculations more efficient, we applied the power method (see [3]) to approximate the first eigenvalue 1 . Let A be the N Ã N adjacency matrix, and let v1 be any N Ã 1 vector (here we let v1 = (1, 1, ..., 1)). Then we have the iteration: A v1 A v1 = Av1 v1
(k) (0) (0)

(k+1) v1

=

(k)

,

(k+1)

1

(k+1)

(k+1)

.

We run this iteration until

+1 k - k 1 1 < , where , as the accuracy k+1 1

control, is a fixed positive real number. To approximate the second eigenvalue, we apply the deflation method (see [4]). Let 1 and v1 be the largest eigenvalue and eigenvector, respectively, and let A still be the adjacency matrix, then we have that

T A = A - 1 v1 v1 ,

T where v1 is the transpose of v1 .

33

Next, we apply power method to A to compute its largest eigenvalue. This in turn should be the second largest eigenvalue of the initial matrix A. Using these eigenvalue approximation algorithms, we obtain that the spectral gap of the Wikipedia sample is about

|1 - 2 | = 45.1290 - 26.9872 = 18.1419.

We generated a random graph with the same order to contrast this result. The spectral gap of random graph of the same order G(7115, 1/2) is approximately

|1 - 2 | = 3499.9 - 82.8528 = 3417.0472.

We now introduce the first and second neighbour set. The first neighbour set of x, written N (x) = N1 (x), consists of the neighbours of x. Correspondingly, the second neighbour set of x, written N2 (x) is the set of vertices with distance two from x. We consider ten subgraphs S of YouTube by sampling first and second neighbour sets. More precisely, we first choose a vertex x uniformly at random from the YouTube graph. We consider the subgraph be induced by the closed first and second neighbour sets of x; that is,
34

the subgraph induced by

{x}  N1 (x)  N2 (x).

Table 1 shows the spectral gaps of our YouTube samples, and the spectral gaps of random graphs with the same order (to contrast with our OSN samples). Table 1. Spectral gaps of YouTube samples and random graphs of same order. order 4497 5505 5503 6409 5897 3528 7507 6089 5053 6788 gap YouTube random graph 13.28 2193.76 53 2696.47 12.63 2680.92 22.38 3115.31 10.9 2923.18 18.39 1727.80 20.56 3619.51 14.57 2997.98 15.56 1709.70 60.8 3223.98

With OSNs Wikipedia and YouTube as samples, the above calculation results suggest that OSNs have the following properties. 1. For some range of degree vertices (mostly, medium degree vertices), OSNs follow a power law degree distribution. 2. OSNs have a small diameter, which is one of the main features of the small world property.
35

3. OSNs have smaller spectral gaps than a random graph, which indicates OSNs have bad spectral expansion.

2. Properties of Graphs Generated by the GEO-P Model We now simulate graphs using the GEO-P model in several dimensions, and compare and contrast these samples with real OSN data. Once again, we measure the degree distribution, diameter, and spectral gap. Figures 3.3 and 3.4 show the degree distributions of graphs generated by the GEO-P model, where the order N is 7115 (the same order as our Wikipedia samples). We used dimensions m from 1 to 5, and we used two sets of values for parameters  and  . We can see that for the medium degree vertices, the log-log plot is a straight line, which suggests that graphs generated by the GEO-P model follow a power law degree distribution. Table 2 displays the spectral gap of graphs generated by the GEO-P model. Recall that we calculated a spectral gap of a sampled random graph G(7115, 1/2) to be 3417.0472 (see Section 3.1). We may conclude that graphs generated by the GEO-P model have small spectral gap. Correspondingly, they have bad spectral expansion.
36

Figure 3.3. GEO-P degree distribution log-log plot, N = 7115,  = 0.7,  = 0.15, p = 1.

Figure 3.4. GEO-P degree distribution log-log plot, N = 7115,  = 0.4,  = 0.5, p = 1. Table 3 displays the diameters of graphs generated by the GEO-P model. We can see that graphs generated by the GEO-P model have small diameter, and the diameter decreases as m increases.
37

Table 2. Spectral gaps of graphs generated by the GEO-P model. N = 7115, p = 1  = 0.7,  = 0.15  = 0.4,  = 0.5 dimension gap dimension gap 1 23.700163 1 0.070531 2 35.04388 2 0.028725 3 57.751959 3 0.380326 4 48.840852 4 3.21985 5 95.301035 5 4.555701

Table 3. Diameters of graphs generated by the GEO-P model. N = 7115, p = 1  = 0.7,  = 0.15  = 0.4,  = 0.5 dimension diameter dimension diameter 1 34 1 23 2 9 2 58 3 5 3 18 4 4 4 4 5 2 5 5

3. Logarithmic Dimension Hypothesis In Chapter 2, we introduced the Logarithmic Dimension Hypothesis (or LDH), which states the dimension m of an OSN satisfies

m = O(log N ),

where N is the order of the OSN. For our datasets, we simplify this to

m = log N .
38

We now explain how we attempted to validate the LDH by comparing real OSNs with the same order graphs generated by the GEO-P model with various dimensions, and find the most appropriate dimension. Table 1 lists the spectral gaps of 10 YouTube samples of order around 5000. We take the average of the spectral gaps, giving a gap of 24.21. On the other hand, we simulated GEO-P model to generate the same order graphs from dimension 1 to 6. Table 4 lists their spectral gaps. We can see that the best fit is between 19.2611 and 47.8424, which is for m = 3 and m = 4, respectively. Hence, we suggest that the OSNs of order 5000 have a dimension 3.5 = 4. It is consistent with the LDH, which demands a dimension of

log 5000 = 3.69 = 4.

Table 4. Spectral gaps of graphs generated by the GEO-P model. N = 5000,  = 0.7,  = 0.15, p = 1 dimension 1 2 gap 1 27.5004 27.3945 0.10593 2 60.66 54.522 6.138 3 82.9547 63.6936 19.2611 4 134.5345 86.6921 47.8424 5 221.943124 132.411872 89.531252 6 379.201601 203.734353 175.467248 Now we compare the diameters. Table 5 lists the 10 YouTube samples' diameters, we calculate the average diameter which is 7.8. Table
39

6 lists the diameters of graphs generated by the GEO-P model, with dimension from 1 to 6. We can see that the three-dimensional graph's diameter is close to the average diameter (with the average taken over all our samples); that is, 7.8. Hence, we have additional support for the LDH. Table 5. Diameters of YouTube samples of order around 5000.
order 4497 5505 5503 6409 5897 diameter 8 9 11 9 7 order 3528 7507 6089 5053 6788 diameter 5 8 7 6 8

Table 6. Diameters of graphs generated by the GEO-P model.
N = 5000,  = 0.7,  = 0.15, p = 1 dimension(m) diameter 1 51 2 10 3 5 4 4 5 2 6 2

While our results are supportive of the LDH, we do not claim to prove it. Larger samples would be necessary for that (ideally the entire network), or many more small samples. Further, there are many other graph properties we could check which is suggestive of two graphs being "similar" (although not necessarily isomorphic). We do speculate further on such similarity measures, but leave that for future work.
40

CHAPTER 4

New models for OSNs
We described the GEO-P model in the previous chapter. In this chapter we simulate some new models based on the GEO-P model, analyse their properties, and check if they accurately fit OSN data. These new models are similar (but not identical to) to the GEO-P model, but use different ranking schemes such as age or degree. Recall from Chapter 2 that we use r(x, t) to indicate the rank of vertex x at time-step t.

1. Ranking by Age We first introduce the GEO-P(Age) model. In this model, an older vertex is more likely to attract more edges than a younger one. For a positive integer t > 0, we define

age(x) = t,

where t is the time-step when vertex x is born. The GEO-P(Age) model has four parameters: the attachment strength   (0, 1), the density parameter   (0, 1 - ), the dimension
41

m  N, and the link probability p  (0, 1]. Let S be unit hypercube in Rm . The GEO-P(Age) model generates graphs via the following process. 1. At the initial time-step t = 0, we choose N vertices in S at random, randomly assign each vertex a unique rank chosen from the set [N ], and set all vertices ages as 0. An edge between a pair of vertices x and y is created with probability p if

d(x, y )  max{Rad(x), Rad(y )}.

2. At time-step t > 0, a randomly chosen vertex v  V (Gt-1 ) dies. For the remaining vertices, if r(x, t - 1) > r(v, t - 1), then we update their ranks by r(x, t) = r(x, t - 1) - 1, where x  V (Gt-1 ) \ {v }. Hence, the rank of a vertex is determined by its age. Older vertices receive higher rank. On the other hand, a new vertex u is born and is assigned rank N . We set its age as t. Then we add edges by the method described in Item 1 above. The GEO-P(InvAge) model is similar to the GEO-P(Age) model. The difference is we assign new vertex higher rank as follows in item (2) below.
42

1. At the initial time-step t = 0, we choose N vertices in S at random, randomly assign each vertex a unique rank chosen from the set [N ], and set all vertices ages as 0. An edge between a pair of vertices x and y is created with probability p if

d(x, y )  max{Rad(x), Rad(y )}.

2. At time-step t > 0, a randomly chosen vertex v  V (Gt-1 ) dies, for remaining vertices, if r(x, t - 1) > r(v, t - 1), then we update their ranks by r(x, t) = r(x, t - 1) + 1, where x  V (Gt-1 ) \ {v }. Hence, a new vertex is more likely to be higher ranked. On the other hand, a new vertex u is born and is assigned rank 1. We set its age as t. Then we determine edges by the method described in Item (1) above.

Now we analyse degree distribution, diameter, spectral gap of graphs generated by the GEO-P(Age) and the GEO-P(InvAge) models. We applied the GEO-P(Age) and the GEO-P(InvAge) models to generated graphs embedded in Rn , where 1  n  5. Figures 4.1 and 4.2 display the degree distribution log-log plot. Tables 1 and 2 list the diameters and spectral gaps.
43

Figure 4.1. Degree distribution of a graph generated by the GEO-P(Age) model.

Figure 4.2. Degree distribution of a graph generated by the GEO-P(InvAge) model. Comparing with the graphs generated by the GEO-P, GEO-P(Age), and GEO-P(InvAge) models, our results suggest that the models generate graphs with similar degree distributions; the diameters all decrease
44

Table 1. Spectral gaps of graphs generated by the GEO-P(Age) and the GEO-P(InvAge) model. N = 7115,  = 0.7,  = 0.15, p = 1 GEO-P(Age) GEO-P(InvAge) dimension gap dimension gap 1 35.201192 1 0.913422 2 32.509603 2 129.049955 3 2.678022 3 32.13571 4 52.84162 4 48.921797 5 95.301035 5 96.451019 Table 2. Diameters of graphs generated by the GEOP(Age) and the GEO-P(InvAge) model. N = 7115,  = 0.7,  = 0.15, p = 1 GEO-P(Age) GEO-P(InvAge) dimension diameter dimension diameter 1 33 1 61 2 10 2 10 3 5 3 5 4 4 4 4 5 3 5 2 when the dimension increases; and the spectral gaps all decrease until the third dimension, then begin to increase. We may conclude that there is no significant difference between these models. In particular, all fit real OSNs well, and ranking by age does not provide a better fit to OSNs than the GEO-P model.

2. Ranking by Degree The second group of OSN models we investigated are the GEOP(Deg) model and the GEO-P(GnpDeg) model. These two models
45

have a new ranking system, where ranking is determined by the degrees of vertices. We assign larger degree vertex higher rank as it is plausible that more popular users in OSN may receive more invitations to become friends from other users. Hence, a higher degree vertex has a stronger ability of attracting new edges. If two vertices coincidentally have the same degree, then we take age as the second measurement to break ties. The GEO-P(Deg) and the GEO-P(GnpDeg) models have four parameters: the attachment strength   (0, 1), the density parameter   (0, 1 - ), the dimension m  N, and the link probability p  (0, 1]. Let S be unit hypercube in Rm , and [N ] be integers set from 1 to N . We describe the evolution process of the GEO-P(Deg) model: 1. At the initial time-step t = 0, we choose N vertices in S at random, randomly assign each vertex a unique rank chosen from the set [N ], and set all vertices ages as 0. An edge between a pair of vertices x and y is created with probability p if

d(x, y )  max{Rad(x), Rad(y )}.

We record degrees of all vertices at time-step t = 0. 2. At time-step t > 0, a randomly chosen vertex v  V (Gt-1 ) dies, we remove all edges connected to v . For remaining vertices, if vx 
46

E (Gt-1 ), then we update their degrees by

degGt (x) = degGt-1 (x) - 1, where x  V (Gt-1 ) \ {v }. On the other hand, a new vertex u is born, we assign its age as t, and assign its degree and rank both 0. We now determine edges between every pair of vertices based on their ranks at time-step t - 1. In the last step, we update and record vertices' ranks at time-step t by as follows.

(13) (14) (15)

K =| {y  V (Gt ), degGt (y ) > degGt (x)} |, L =| {y  V (Gt ), degGt (y ) = degGt (x) and age(y ) < age(x)} |, r(x, t) = K + L + 1.

In (13), (14), and (15), K indicates the number of vertices which degrees are bigger than vertex x, L indicates the number of vertices which degree are equal to vertex x, but older than vertex x. Hence, K + L is the number of vertices whose ranks are higher than vertex x. Note that only one vertex is born at every time-step t, so we will not have duplicated ranks.

The GEO-P(GnpDeg) model is similar to the GEO-P(Deg) model, the only difference is the GEO-P(GnpDeg) model starts from a random
47

graph other than a GEO-P graph at time-step t = 0. The GEOP(GnpDeg) models generates graphs by following process:

1. At initial time-step t = 0, we choose N vertices in S at random and generate a random graph G(N, p). Thus, we determine edges between every pair of vertices by a fixed probability. Then we apply Formula 13, 14 and 15 to calculate vertices' ranks. Ages of all vertices are set to 0. 2. At time-step t > 0, a randomly chosen vertex v  V (Gt-1 ) dies, we remove all edges connected to v . For remaining vertices, if vx  E (Gt-1 ), then we update their degrees by

degGt (x) = degGt-1 (x) - 1,

where x  V (Gt-1 ) \ {v }. On the other hand, a new vertex u is born, we assign its age as t, and assign its degree and rank both 0. We now determine edges between every pair of vertices based on their ranks at time-step t - 1. The last step, we update and record vertices' ranks at time-step t by formulas (13), (14) and (15).

Note that in graphs generated by the GEO-P(GnpDeg) model, vertices ranks may not be unique, because vertices' ranks at time-step
48

t = 0 are determined by degrees, we may have some vertices with the same ranks and ages, which may cause a tie in following time-step t. Now we analyse degree distribution, diameter, spectral gap of graphs generated by the GEO-P(Deg) and the GEO-P(GnpDeg) models. We applied the GEO-P(Deg) and the GEO-P(GnpDeg) models to generated graphs in dimensions 1 to 5, and 1 to 4, respectively. Figures 4.3 and 4.4 display the degree distribution log-log plot. Tables 4 and 3 list the diameters and gaps. We can see that the GEO-P(Deg) and the GEO-P(GnpDeg) models have different properties. Graphs generated by the GEO-P(Deg) model have similar properties as other GEO-Ptype models. But graphs generated by the GEO-P(GnpDeg) have some different properties. Their degree distribution does not follow a power law distribution, have a larger spectral gap comparing to other GEOP-type models, and their diameters do not shrink when the dimension increases. Their behaviors are closer to random graphs and this model is not a good one for OSNs.

49

Figure 4.3. Degree distribution of graph generated by the GEO-P(Deg) model.

Figure 4.4. Degree distribution of graph generated by the GEO-P(GnpDeg) model.

50

Table 3. Spectral gaps of graphs generated by the GEO-P(Deg) and the GEO-P(GnpDeg) model. N = 7115,  = 0.7,  = 0.15, p = 1 GEO-P(Deg) GEO-P(GnpDeg) dimension gap dimension gap 1 27.508783 1 3440.284205 2 17.59291 2 3443.40596 3 17.618218 3 3450.151086 4 94.816041 4 3466.83475 5 112.3931 Table 4. Diameters of graphs generated by the GEOP(Deg) and the GEO-P(GnpDeg) model. N = 7115,  = 0.7,  = 0.15, p = 1 GEO-P(Deg) GEO-P(GnpDeg) dimension diameter dimension diameter 1 30 1 3 2 9 2 3 3 5 3 3 4 4 4 3 5 2

3. Tension Parameter Figure 4.5 shows the influence regions of vertices 5, 7 and 16. We see that vertices 7 and 16 both fall in the influence region of vertex 5. Based on the GEO-P model, the pairs of vertices 5, 7 and 5, 16 may both obtain edges (let us assume the link probability parameter p = 1). But on the other hand, we see that vertex 7 has a larger influence region then vertex 16, and correspondingly vertex 7 should have stronger ability of attracting edges. Hence, the overall ability of
51

obtaining edge of vertices 5 and 7 should be stronger than vertices 5 and 16.

Figure 4.5. Influence region of vertices 5, 7 and 16.

We introduce tension parameter h  (-, 0). Recall that the influence region is determined by the rank of vertex; that is, a higher rank vertex has stronger ability of obtaining edges than lower rank vertex. We define the tension probability, written

T P (x, t) = r(x, t)h ,
52

where x is a given vertex, and r(x, t) is the rank of vertex x at time-step t. Note that r(x, t)  1, so T P (x, t)  (0, 1). We use T P (x, t) + T P (y, t) 2 to donate the overall tension probability of vertices x and y . Based on the tension parameter, we introduce the GEO-P(Ten) model. This model has four parameters: the attachment strength   (0, 1), the density parameter   (0, 1 - ), the dimension m  N, and the tension parameter h  (-, 0). The GEO-P(Ten) model is the same as the GEO-P model, except for how to determine edges between every pair of vertices. Let S be unit hypercube in Rm , and [N ] be integers set from 1 to N . The GEO-P(Ten) model generates graphs by following process:

1. At the initial time-step t = 0, we randomly choose N vertices in S , randomly assign vertex unique rank chosen from set [N ]. An edge between pair of vertices x and y is created, if T P (x, t) + T P (y, t) 2

(16)

d(x, y )  max(Rad(x), Rad(y ))

.

2. At time-step t > 0, a randomly chosen vertex v  V (Gt-1 ) dies, a new vertex u is born and is assign a rank randomly chosen from set
53

[N ]. We update ranks of vertices x  V (Gt-1 )  V (Gt ) by (2), then evaluate edges by (16) Now we analyse degree distribution, diameter, spectral gap of graphs generated by the GEO-P(Ten) model. We applied the GEO-P(Ten) model to generated graphs in dimensions 1 to 5 inclusive, and we choose different values for tension parameter: h = -0.1, h = -0.3 and h = -0.7. Figures 4.6, 4.7 and 4.8 display the degree distribution log-log plots. Tables 6 and 5 list the diameters and gaps.

Figure 4.6. Degree distribution of graph generated by the GEO-P(Ten) model, with tension parameter h = -0.1. We can see that graphs generated by the GEO-P(Ten) model have small spectral gaps and diameters, which are almost of the same order of the GEO-P model. From Figures 4.6, 4.7, and 4.8, we can see
54

Figure 4.7. Degree distribution of graph generated by the GEO-P(Ten) model, with tension parameter h = -0.3.

Figure 4.8. Degree distribution of graph generated by the GEO-P(Ten) model, with tension parameter h = -0.7.

55

Table 5. Spectral gaps of graphs generated by the GEO-P(Ten) model, in dimensions 1 to 5 inclusive. GEO-P(Ten) N = 7115,  = 0.7,  = 0.15, p = 1 h = -0.1 h = -0.3 h = -0.7 dim gap dim gap dim gap 1 14.170589 1 9.048678 1 13.048242 2 0 2 9.286437 2 12.406163 3 11.410871 3 10.354512 3 13.150765 4 15.54475 4 10.186001 4 14.226928 5 20.845548 5 12.422439 5 15.133812 Table 6. Diameters of graphs generated by the GEOP(Ten) model. GEO-P(Ten) N = 7115,  = 0.7,  = 0.15, p = 1 h = -0.1 h = -0.3 h = -0.7 dimension diam | V (C ) | diam | V (C ) | diam | V (C ) | 1 20 7098 6 6300 4 2673 2 20 6953 7 3149 4 990 3 20 6847 7 1648 3 571 4 15 6744 6 1152 3 415 5 12 6747 5 977 2 428 that graphs generated by the GEO-P(Ten) model follow a power law degree distribution in a larger range than the GEO-P model. Our initial results indicate that the GEO-P(Ten) model accurately fits OSN data as well as the GEO-P model.

56

CHAPTER 5

Conclusion and Open Problems
We introduced OSNs and verified graph theoretic properties of OSNs. Our computational results provide support for observed properties of OSNs: namely, power law degree distributions, the small world property, and bad spectral expansion. The simulation results in sections 3.1 and 3.3 support the Logarithmic Dimension Hypothesis, which conjectures that the dimension of OSNs is m = log N , where N is the order of the network. We compared the spectral gap of OSN samples and graphs generated by the GEO-P model in different dimensions, and our results suggest that the best fitting dimension is about log N . We also compared the diameter of OSN samples and graphs generated by the GEO-P model, and found this was best fit to real OSN data when the dimension was about log N. We also introduced variants of GEO-P-type models which naturally simulate OSNs. We used the models to simulate OSNs, and verify how they fit OSNs by calculating the three main properties. Table 1
57

summarizes results from our simulations. According to that table, most of the GEO-P-type models fit OSNs well, and the degree distribution of graphs generated by the GEO-P(Ten) model follow a power law degree distribution for a bigger range of vertices. Only the GEO-P(GnpDeg) model does not fit OSNs well because of it does not seem to generate power law graphs.

Table 1. The GEO-P-type models simulation and calculation results model power law GEO-P yes GEO-P(Age) yes GEO-P(InvAge) yes GEO-P(Deg) yes GEO-P(GnpDeg) no GEO-P(Ten) yes small wold spectral gap yes small yes small yes small yes small yes large yes small

Several open problems arose while this research was conducted. We hope to be able to address these problems in future work. We collect and state these problems below. 1. OSNs usually have large orders, with many millions of vertices and edges. Owing to computational bottlenecks, we chose to work with smaller samples of OSNs, with orders in the thousands of vertices and edges. Higher order samples or even a whole OSN sample will likely give a more accurate result.
58

2. In Chapters 3 and 4, we only evaluate diameters of graphs to verify the small word property. The clustering coefficient is also a measurement of the small world property. Calculating clustering coefficients is another step to verify the small world property in both the models and the sampled OSN data. Tuning the models to give the correct clustering coefficient may give more evidence for the LDH. 3. For the GEO-P model, we have a few parameters, such as: the attachment strength, the density parameter, the dimension, and the link probability. How do we best choose these parameters? 4. In our OSN models, we use consecutive integers to assign vertices ranks, which leads to similar influence regions at different time-step t. Assigning vertices with positive real number as ranks may be more natural. One idea is that vertices ranks could be determined based on their popularity. We calculate the degree ratio for every vertex, which is defined as degGt (x) degGt (v )
v V (Gt )

RA(x, t) =

.

Hence, the degree ratio indicates how popular the corresponding user is; that is, a bigger degree ratio refers to a more popular user. Note that since RA(x, t)  [0, 1), we can then define rank function
59

based on the degree ratio. For example, we may define

R(x, T ) = RA(x, t)k ,

where k is a negative real number. 5. For the GEO-P Model, rigorous proofs were given that the model a.a.s. generates graphs with a power law degree distribution, low diameter, high clustering coefficient, and bad spectral expansion. See Chapter 2, Theorems 2.1, 2.2, 2.3, 2.4, and 2.5 for the rigorous results for the GEO-P model. Can we rigorously prove with probability tending to 1 as n and t tend to infinity, that the models for OSNs presented in this thesis satisfy the desired properties? 6. From our simulation results, the GEO-P(GnpDeg) model does not fit the real OSN data well. However, we may need to run the time t much longer for the model to generate graphs with the desired properties.

60

CHAPTER 6

Appendix
The following original code of mysql database and matlab was used to simulate OSNs and the various stochastic models presented in this thesis. Further, we provide the code used to mine the real OSN data for various properties.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- Table structure for geopdegdist -- - - - - - - - - - - - - - - - - - - - - - - - - - - - DROP TABLE IF EXISTS ` geopdegdist `; CREATE TABLE ` geopdegdist ` ( `seq ` int (11) default NULL , ` degree ` int (11) default NULL , ` dist ` int (11) default NULL , ` flag ` varchar (10) default NULL , `N ` int (11) default NULL , `dim ` int (11) default NULL , `a ` decimal (10 ,2) default NULL , `b ` decimal (10 ,2) default NULL , `T ` int (11) default NULL ) ENGINE = MyISAM DEFAULT CHARSET = latin1 ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- Table structure for geopsample -- - - - - - - - - - - - - - - - - - - - - - - - - - - - DROP TABLE IF EXISTS ` geopsample `; CREATE TABLE ` geopsample ` ( `seq ` int (11) NOT NULL default '0 ' , ` userid ` int (11) NOT NULL default '0 ' , ` userlabel ` int (11) default NULL , ` outdegree ` int (11) default NULL , ` indegree ` int (11) default NULL , `u ` int (11) default '0 ' , `N ` int (11) NOT NULL default '0 ' , `dim ` int (11) NOT NULL default '0 ' , `a ` decimal (10 ,2) NOT NULL default '0.00 ' , `b ` decimal (10 ,2) NOT NULL default '0.00 ' , `T ` int (11) NOT NULL default '0 ' ,

61

34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86

PRIMARY KEY ( ` seq ` , ` userid ` , `N ` , `a ` , `b ` , ` dim ` , `T `) , KEY ` ind_userid ` USING BTREE ( ` userid ` , ` seq `) ) ENGINE = MyISAM DEFAULT CHARSET = latin1 ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- Table structure for g e o p s a m p l e _ l i n k s -- - - - - - - - - - - - - - - - - - - - - - - - - - - - DROP TABLE IF EXISTS ` geopsample_links `; CREATE TABLE ` geopsample_links ` ( ` userid ` int (11) NOT NULL default '0 ' , ` friendid ` int (11) NOT NULL default '0 ' , ` userlabel ` int (11) default NULL , ` friendlabel ` int (11) default NULL , `seq ` int (11) NOT NULL default '0 ' , `dim ` int (11) NOT NULL default '0 ' , `N ` int (11) NOT NULL default '0 ' , `a ` decimal (10 ,2) NOT NULL default '0.00 ' , `b ` decimal (10 ,2) NOT NULL default '0.00 ' , `T ` int (11) NOT NULL default '0 ' , PRIMARY KEY ( ` seq ` , ` userid ` , ` friendid ` , `N ` , `a ` , `b ` , ` dim ` , `T `) , KEY ` ind_userid ` USING BTREE ( ` userid ` , ` seq ` , ` dim ` , `N ` , `a ` , `b `) , KEY ` ind_friendid ` USING BTREE ( ` friendid ` , ` seq ` , ` dim ` , `N ` , `a ` , `b `) ) ENGINE = MyISAM DEFAULT CHARSET = latin1 ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- Table structure for geopsampleN -- - - - - - - - - - - - - - - - - - - - - - - - - - - - DROP TABLE IF EXISTS ` geopsampleN `; CREATE TABLE ` geopsampleN ` ( `seq ` int (11) default '0 ' , ` userid ` int (11) default NULL , ` Nlevel ` int (11) NOT NULL default '0 ' , ` friendid ` int (11) default NULL , `N ` int (11) default NULL , `dim ` int (11) default NULL , `a ` decimal (10 ,2) default NULL , `b ` decimal (10 ,2) default NULL , `T ` int (11) default NULL , KEY ` ind_userid ` ( ` seq ` , ` userid ` , ` Nlevel `) ) ENGINE = MyISAM DEFAULT CHARSET = latin1 ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- Table structure for wiki_degdist -- - - - - - - - - - - - - - - - - - - - - - - - - - - - DROP TABLE IF EXISTS ` wiki_degdist `; CREATE TABLE ` wiki_degdist ` ( `seq ` int (11) default NULL , ` degree ` int (11) default NULL , ` dist ` int (11) default NULL , ` flag ` varchar (10) default NULL ) ENGINE = MyISAM DEFAULT CHARSET = latin1 ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -

62

87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139

-- Table structure for wikilinks -- - - - - - - - - - - - - - - - - - - - - - - - - - - - DROP TABLE IF EXISTS ` wikilinks `; CREATE TABLE ` wikilinks ` ( ` userid ` int (11) default NULL , ` friendid ` int (11) default NULL ) ENGINE = MyISAM DEFAULT CHARSET = latin1 ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- Table structure for wikisample -- - - - - - - - - - - - - - - - - - - - - - - - - - - - DROP TABLE IF EXISTS ` wikisample `; CREATE TABLE ` wikisample ` ( `seq ` int (11) NOT NULL default '0 ' , ` userid ` int (11) NOT NULL default '0 ' , ` userlabel ` int (11) default NULL , ` outdegree ` int (11) default NULL , ` indegree ` int (11) default NULL , `u ` int (11) default '0 ' , PRIMARY KEY ( ` seq ` , ` userid `) , KEY ` ind_userid ` USING BTREE ( ` userid ` , ` seq `) ) ENGINE = MyISAM DEFAULT CHARSET = latin1 ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- Table structure for w i k i s a m p l e _ l i n k s -- - - - - - - - - - - - - - - - - - - - - - - - - - - - DROP TABLE IF EXISTS ` wikisample_links `; CREATE TABLE ` wikisample_links ` ( ` userid ` int (11) NOT NULL default '0 ' , ` friendid ` int (11) NOT NULL default '0 ' , ` userlabel ` int (11) default NULL , ` friendlabel ` int (11) default NULL , `seq ` int (11) NOT NULL default '0 ' , PRIMARY KEY ( ` userid ` , ` friendid ` , ` seq `) , KEY ` ind_userid ` USING BTREE ( ` userid ` , ` seq `) , KEY ` ind_friendid ` USING BTREE ( ` friendid ` , ` seq `) ) ENGINE = MyISAM DEFAULT CHARSET = latin1 ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- Table structure for wikisampleN -- - - - - - - - - - - - - - - - - - - - - - - - - - - - DROP TABLE IF EXISTS ` wikisampleN `; CREATE TABLE ` wikisampleN ` ( `seq ` int (11) default '0 ' , ` userid ` int (11) default NULL , `N ` int (11) NOT NULL default '0 ' , ` friendid ` int (11) default NULL , KEY ` ind_userid ` ( ` seq ` , ` userid ` , `N `) ) ENGINE = MyISAM DEFAULT CHARSET = latin1 ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- Table structure for yo utube_de gree -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -

63

140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192

DROP TABLE IF EXISTS ` youtube_degree `; CREATE TABLE ` youtube_degree ` ( ` userid ` int (20) NOT NULL , ` indegree ` int (20) NOT NULL , ` outdegree ` int (20) NOT NULL , PRIMARY KEY ( ` userid `) ) ENGINE = MyISAM DEFAULT CHARSET = latin1 ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- Table structure for y o u t u b e d e g r e e _ d i s t -- - - - - - - - - - - - - - - - - - - - - - - - - - - - DROP TABLE IF EXISTS ` youtubedegree_dist `; CREATE TABLE ` youtubedegree_dist ` ( ` degree ` int (11) default NULL , ` dist ` int (11) default NULL ) ENGINE = MyISAM DEFAULT CHARSET = latin1 ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- Table structure for youtubelinks -- - - - - - - - - - - - - - - - - - - - - - - - - - - - DROP TABLE IF EXISTS ` youtubelinks `; CREATE TABLE ` youtubelinks ` ( ` userid ` int (11) default NULL , ` friendid ` int (11) default NULL , KEY ` Ind_youtubelinks ` ( ` userid `) , KEY ` ind_youtubelinks2 ` ( ` friendid `) ) ENGINE = MyISAM DEFAULT CHARSET = latin1 ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- Table structure for y o u t u b e l i n k s _ d e g r e e -- - - - - - - - - - - - - - - - - - - - - - - - - - - - DROP TABLE IF EXISTS ` youtubelinks_degree `; CREATE TABLE ` youtubelinks_degree ` ( ` userid ` int (11) default NULL , ` degree ` int (11) default NULL ) ENGINE = MyISAM DEFAULT CHARSET = latin1 ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- Table structure for youtubesample -- - - - - - - - - - - - - - - - - - - - - - - - - - - - DROP TABLE IF EXISTS ` youtubesample `; CREATE TABLE ` youtubesample ` ( `seq ` int (5) NOT NULL , ` source ` varchar (50) default NULL , ` userid ` int (11) NOT NULL , ` userlabel ` int (11) default NULL , ` outdegree ` int (11) default NULL , ` indegree ` int (11) default NULL , `u ` int (11) default '0 ' , PRIMARY KEY ( ` seq ` , ` userid `) , KEY ` ind_userid ` ( ` seq ` , ` userid `) ) ENGINE = MyISAM DEFAULT CHARSET = latin1 ;

64

193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- Table structure for y o u t u b e s a m p l e _ l i n k s -- - - - - - - - - - - - - - - - - - - - - - - - - - - - DROP TABLE IF EXISTS ` youtubesample_links `; CREATE TABLE ` youtubesample_links ` ( ` userid ` int (11) NOT NULL , ` friendid ` int (11) default NULL , ` userlabel ` int (11) default NULL , ` friendlabel ` int (11) default NULL , `seq ` int (11) NOT NULL , KEY ` ind_userid ` ( ` seq ` , ` userid `) , KEY ` ind_friendid ` ( ` seq ` , ` friendid `) ) ENGINE = MyISAM DEFAULT CHARSET = latin1 ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- Table structure for yo utubesam pleN -- - - - - - - - - - - - - - - - - - - - - - - - - - - - DROP TABLE IF EXISTS ` youtubesampleN `; CREATE TABLE ` youtubesampleN ` ( `seq ` int (11) default NULL , ` userid ` int (11) default NULL , `N ` int (11) default NULL , ` friendid ` int (11) default NULL ) ENGINE = MyISAM DEFAULT CHARSET = latin1 ;

223 224

225 226

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- procedure structure for pr oc _g e op sa mp l e -- generate geop sample user information from 1 to Nnum ( update table geopsample ) , calcuate indegree and outdegree ( update table geopsample ) , calculate degree distribution ( update table geopdegdist ) -- - - - - - - - - - - - - - - - - - - - - - - - - - - - CREATE DEFINER = ` amandatian `@ `% ` PROCEDURE ` proc_geopsample `( in Seq int , in Nnum int , in Dim int , in A decimal (5 ,2) , in B decimal (5 ,2) , in Ttime int ) BEGIN /* generate geop sample user information from 1 to Nnum ( update table geopsample ) , calcuate indegree and outdegree ( update table geopsample ) , calculate degree distribution ( update table geopdegdist ) */ DECLARE DECLARE DECLARE DECLARE DECLARE N1 int ; N2 int ; Exsist int default 0; rowstatus int default 0; i int default 1;

227 228 229 230 231 232 233 234 235 236 237

DECLARE User int ; DECLARE degree int ; DECLARE num int default 0;

65

238 239 240

DECLARE U int ; DECLARE csr_user2 CURSOR FOR select geopsample . userid from geopsample where geopsample . seq = Seq and geopsample . N = Nnum and geopsample . dim = Dim and geopsample . a = A and geopsample . b = B and geopsample . T = Ttime ; DECLARE CONTINUE HANDLER FOR NOT FOUND SET rowstatus =1; delete from geopsample where geopsample . seq = Seq and geopsample . N = Nnum and geopsample . dim = Dim and geopsample . a = A and geopsample . b = B and geopsample . T = Ttime ; /* generate geop sample user information from 1 to Nnum */ while i <= Nnum do insert into ` geopsample ` ( userid , userlabel , seq ,N , dim ,a ,b , T ) values ( i , i , Seq , Nnum , Dim ,A ,B , Ttime ) ; set i = i + 1; end while ; commit ;

241 242 243

244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260

/* calculate degree */ set rowstatus =0; OPEN csr_user2 ; FETCH csr_user2 INTO User ; WHILE rowstatus =0 DO select count (*) into degree from g e o p s a m p l e _ l i n k s where g e o p s a m p l e _ l i n ks . userid = User and g e o p s a m pl e _ l i n k s . seq = Seq and g e o p sa m p l e _ l i n k s . N = Nnum and g e o p s a m p l e _ l i n k s . dim = Dim and g e o p sa m p l e _ l i n k s . a = A and g e o p sa m p l e _ l i n k s . b = B and ge o p s a m p l e _ l i n k s . T = Ttime ; if degree = 0 then set U = 1; else set U = 0; end if ; set num = num +1; update geopsample set geopsample . outdegree = degree , geopsample . indegree = degree , geopsample . u = U where geopsample . userid = User and geopsample . seq = Seq and geopsample . N = Nnum and geopsample . dim = Dim and geopsample . a = A and geopsample . b = B and geopsample . T = Ttime ; FETCH csr_user2 INTO User ; END WHILE ; CLOSE csr_user2 ; commit ;

261 262 263 264 265 266 267 268 269 270

271 272 273 274 275 276

66

277 278

/* calculate degree distribution */ delete from geopdegdist where geopdegdist . seq = Seq and geopdegdist . N = Nnum and geopdegdist . dim = Dim and geopdegdist . a = A and geopdegdist . b = B and geopdegdist . T = Ttime ; insert into geopdegdist ( flag , seq , N , dim , a , b , T , degree , dist ) select '', geopsample . seq , geopsample .N , geopsample . dim , geopsample .a , geopsample .b , geopsample .T , geopsample . indegree , count (*) from geopsample where geopsample . seq = Seq and geopsample . N = Nnum and geopsample . dim = Dim and geopsample . a = A and geopsample . b = B and geopsample . T = Ttime group by geopsample . indegree ; END ;

279 280 281

282

283 284 285 286 287 288 289 290 291 292

293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- procedure structure for p r o c _ g e o p s a m p l e c a l l -- to generate geop sample information and geop degree distribution data for multiple dimensions -- - - - - - - - - - - - - - - - - - - - - - - - - - - - CREATE DEFINER = ` amandatian `@ `% ` PROCEDURE ` proc_geopsamplecall `( in Seq int , in num int , in A decimal (5 ,2) , in B decimal (5 ,2) , in DimS int , in DimE int , in Ttime int ) BEGIN /* to generate geop sample information and geop degree distribution data for multiple dimensions */ Declare i int ; set i = DimS ; while i <= DimE do call p ro c_ ge o ps am pl e ( Seq , num , i , A , B , Ttime ) ; set i = i +1; end while ; END ;

310 311 312 313 314 315

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- procedure structure for p r o c _ g e o p s a m p le N -- generate neighbour lists for some given vertices , used to calculate diameter , update table geopsampleN -- - - - - - - - - - - - - - - - - - - - - - - - - - - - CREATE DEFINER = ` amandatian `@ `% ` PROCEDURE ` proc_geopsampleN `( in Seq int , in Nnum int , in Dim int , in A decimal (5 ,2) , in B decimal (5 ,2) , in Ttime int ) BEGIN /* generate neighbour lists for some given vertices , used to calculate diameter , update table geopsampleN */ DECLARE num int default 0; DECLARE Neigh int ; DECLARE NPare int ; DECLARE insertCnt int ;

67

316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331

DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE

PareUserCnt int default 0; strLength int ; Nparelist varchar (10000) ; Exsist1 int default 0; Exsist2 int default 0; PareUser int DEFAULT 1; rowstatus int default 0; GoStatus int default 0; tbl varchar (40) ; sqldel varchar (1000) ; sqlinsert1 varchar (1000) ; sqlsel1 varchar (1000) ; sqlsel2 varchar (1000) ;

332 333 334

335 336 337 338

339 340 341 342 343 344 345 346 347 348 349

/* declare cursor for every node in geop sample */ DECLARE csr_user0 CURSOR FOR select geopsample . userid from geopsample where geopsample . userid <=2 and geopsample . seq = Seq and geopsample . N = Nnum and geopsample . dim = Dim and geopsample . a = A and geopsample . b = B and geopsample . T = Ttime order by geopsample . userid ; /* select all distinct neibourgh of level num of PareUser , using neibourgh list */ DECLARE csr_user1 CURSOR FOR select distinct ( g e o p s a m p l e _ l i n k s . friendid ) from g e o p s a m p l e _ l i nk s where g e o p s a m p l e _ l i n k s . seq = Seq and g e o p s a m p l e _ li n k s . N = Nnum and g e o p s a m p l e _ l in k s . dim = Dim and g e o p s a m p l e _ l i n k s . a = A and g e o p s a m p l e _ l in k s . b = B and g e o p s a m p l e _ l i nk s . T = Ttime and FIND_IN_SET ( g e o p s a m p l e _ l i n k s . userid , Nparelist ) ; /* generage neibourgh list of level num of PareUser */ DECLARE csr_user2 CURSOR FOR select distinct ( geopsampleN . friendid ) from geopsampleN where geopsampleN . seq = Seq and geopsampleN . N = Nnum and geopsampleN . dim = Dim and geopsampleN . a = A and geopsampleN . b = B and geopsampleN . T = Ttime and geopsampleN . userid = PareUser and geopsampleN . Nlevel = num ; DECLARE CONTINUE HANDLER FOR NOT FOUND SET rowstatus =1; set tbl = ' geopsampleN '; select Seq ; select Nnum ; select A ; select B ; select Dim ; set @sqldel = concat ( ' delete from ', tbl , ' where ', tbl , '. seq = ', Seq , ' and ', tbl , '. N = ' , Nnum , ' and ', tbl , '. dim = ' , Dim , ' and ', tbl , '. a = ' , A , ' and ', tbl , '. b = ' , B , ' and ', tbl , '. T = ' , Ttime ); PREPARE stmt FROM @sqldel ; EXECUTE stmt ; DEALLOCATE PREPARE stmt ; OPEN csr_user0 ;

350 351 352 353 354

68

355 356 357 358 359 360 361 362 363

FETCH csr_user0 INTO PareUser ; WHILE rowstatus =0 DO /* initial all counter or parameters */ set PareUserCnt = PareUserCnt +1; set num = 0; set Nparelist = PareUser ; set GoStatus = 0; /* insert the node itself as level 0 neighbour */ insert into geopsampleN ( seq , N , dim , a , b , T , userid , Nlevel , friendid ) values ( Seq , Nnum , Dim , A , B , Ttime , PareUser , num , Pareuser ) ; /* do the loop before all new level neighbours have been found */ While GoStatus = 0 Do set num = num +1; set insertCnt = 0; OPEN csr_user1 ; FETCH csr_user1 INTO Neigh ; WHILE rowstatus =0 DO /* verify if this neighbour has been insert into the table */ set @sqlsel1 = concat ( ' select count (*) into @Exsist1 from ', tbl , ' where ', tbl , '. friendid = ' , Neigh , ' and ', tbl , '. userid = ', PareUser , ' and ', tbl , '. seq = ', Seq , ' and ', tbl , '. N = ' , Nnum , ' and ', tbl , '. dim = ' , Dim , ' and ', tbl , '. a = ' , A , ' and ', tbl , '. b = ' , B , ' and ', tbl , '. T = ' , Ttime ) ; PREPARE stmt FROM @sqlsel1 ; EXECUTE stmt ; DEALLOCATE PREPARE stmt ; if @Exsist1 =0 then set @sqlinsert1 = concat ( ' insert into ', tbl , ' ( seq , N , dim , a , b , T , userid , Nlevel , friendid ) values ( ' , Seq , ', ', Nnum , ', ', Dim , ', ', A , ', ', B , ', ' , Ttime , ', ' , PareUser , ', ' , num , ', ', Neigh , ') ') ; PREPARE stmt FROM @sqlinsert1 ; EXECUTE stmt ; DEALLOCATE PREPARE stmt ; set insertCnt = insertCnt +1; end if ; set @Exsist1 = 0; FETCH csr_user1 INTO Neigh ; END WHILE ;

364 365 366 367 368 369 370 371 372 373 374

375 376 377 378 379 380

381 382 383 384 385 386 387 388 389

69

390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435

/* stop the loop when no new level neighbour can be found */ if insertCnt = 0 then set GoStatus = 1; end if ; CLOSE csr_user1 ; set rowstatus =0 ; /* generate neighbour list for level num , will be used at next round of loop */ set Nparelist = ' '; OPEN csr_user2 ; FETCH csr_user2 INTO NPare ; WHILE rowstatus =0 DO set Nparelist = concat ( Nparelist , Npare , ' , ') ; FETCH csr_user2 INTO NPare ; END WHILE ; CLOSE csr_user2 ; set rowstatus =0 ; set strLength = char_length ( Nparelist ) ; set Nparelist = substring ( NpareList , 1 , strLength -1) ; END WHILE ; commit ; FETCH csr_user0 INTO PareUser ; END WHILE ; CLOSE csr_user0 ;

select Dim ; END ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- procedure structure for p r o c _ w i k i _ d e g d i s t -- calculate wiki user indegree and outdegree , alldegree ( update table wiki_degdist ) -- - - - - - - - - - - - - - - - - - - - - - - - - - - CREATE DEFINER = ` amandatian `@ `% ` PROCEDURE ` proc_wiki_degdist `() BEGIN /* calculate wiki user indegree and outdegree , alldegree ( update table wiki_degdist ) */ delete from wiki_degdist ; insert into wiki_degdist ( seq , flag , degree , dist ) select 0 , 'in ' , wikisample . indegree , count (*) from wikisample group by wikisample . indegree ; insert into wiki_degdist ( seq , flag , degree , dist ) select 0 , 'out ' , wikisample . outdegree , count (*) from wikisample group by wikisample . outdegree ; insert into wiki_degdist ( seq , flag , degree , dist )

70

436

select 0 , 'all ' , wikisample . outdegree + wikisample . indegree , count (*) from wikisample group by wikisample . outdegree + wikisample . indegree ; END ;

437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- procedure structure for pr oc _w i ki sa mp l e -- create wiki user information , check userid and friendid , then take distinct ( update table wikisample ) -- - - - - - - - - - - - - - - - - - - - - - - - - - - - CREATE DEFINER = ` amandatian `@ `% ` PROCEDURE ` proc_wikisample `() BEGIN /* create wiki user information , check userid and friendid , then take distinct ( update table wikisample ) */ DECLARE N1 int ; DECLARE N2 int ; DECLARE Exsist int default 0; DECLARE rowstatus int default 0; DECLARE csr_user1 CURSOR FOR select distinct ( userid ) from ` wikisample_links ` order by userid ; DECLARE csr_user2 CURSOR FOR select distinct ( friendid ) from ` wikisample_links ` order by friendid ; DECLARE CONTINUE HANDLER FOR NOT FOUND SET rowstatus =1; delete from ` wikisample `; OPEN csr_user1 ; FETCH csr_user1 INTO N1 ; WHILE rowstatus =0 DO insert into ` wikisample ` ( userid ) values ( N1 ) ; FETCH csr_user1 INTO N1 ; END WHILE ; CLOSE csr_user1 ; SET rowstatus =0; OPEN csr_user2 ; FETCH csr_user2 INTO N2 ; WHILE rowstatus =0 DO select count (*) into Exsist from ` wikisample ` where userid = N2 ; if Exsist = 0 then insert into ` wikisample ` ( userid ) values ( N2 ) ; set Exsist = 0; end if ; FETCH csr_user2 INTO N2 ; END WHILE ; CLOSE csr_user2 ; END ;

71

482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- procedure structure for p r o c _ w i k i s a m p l e l i n k s -- update wiki user lables in table w i k i s a m p l e_ l i n k s -- - - - - - - - - - - - - - - - - - - - - - - - - - - - CREATE DEFINER = ` amandatian `@ `% ` PROCEDURE ` proc_wikisamplelinks `() BEGIN /* update wiki user lables in table w i k i s a m p l e _ l i n k s */ update ` wikisample_links ` , wikisample set w i k i s a m p l e _ l i n k s . userlabel = ` wikisample `. userlabel where w i k i s a m p l e _ l i n k s . userid = wikisample . userid ; update ` wikisample_links ` , wikisample set w i k i s a m p l e _ l i n k s . friendlabel = ` wikisample `. userlabel where w i k i s a m p l e _ l i n k s . friendid = wikisample . userid ; END ;

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- procedure structure for p r o c _ w i k i s a m p le N -- generate neighbour list for some given vertices , used to calculate diameter ( update table wikisampleN ) -- - - - - - - - - - - - - - - - - - - - - - - - - - - - CREATE DEFINER = ` amandatian `@ `% ` PROCEDURE ` proc_wikisampleN `() BEGIN /* generate neighbour list for some given vertices , used to calculate diameter ( update table wikisampleN ) */ DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE num int default 0; N int ; NPare int ; insertCnt int ; PareUserCnt int default 0; strLength int ; Nparelist varchar (10000) ; Exsist1 int default 0; Exsist2 int default 0; PareUser int DEFAULT 1; rowstatus int default 0; GoStatus int default 0; tbl varchar (40) ; sqldel varchar (1000) ; sqlinsert1 varchar (1000) ; sqlsel1 varchar (1000) ; sqlsel2 varchar (1000) ;

DECLARE Seq int ; /* declare cursor for every node in wiki sample */ DECLARE csr_user0 CURSOR FOR select wikisample . userid from wikisample where wikisample . seq = Seq order by wikisample . userid ; /* select all distinct neibourgh of level num of PareUser , using neibourgh list */

72

531

532 533

534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566

DECLARE csr_user1 CURSOR FOR select distinct ( w i k i s a m p l e _ l i n k s . friendid ) from w i k i s a m p l e _ l i n ks where w ik i s a m p l e _ l i n k s . seq = Seq and FIND_IN_SET ( w i k i s a m p l e _ l i n k s . userid , Nparelist ) ; /* generage neibourgh list of level num of PareUser */ DECLARE csr_user2 CURSOR FOR select distinct ( wikisampleN . friendid ) from wikisampleN where wikisampleN . seq = Seq and wikisampleN . userid = PareUser and wikisampleN . N = num ; DECLARE CONTINUE HANDLER FOR NOT FOUND SET rowstatus =1; set tbl = ' wikisampleN '; set Seq = 0;

set @sqldel = concat ( ' delete from ', tbl , ' where ', tbl , '. seq = ', Seq ) ; PREPARE stmt FROM @sqldel ; EXECUTE stmt ; DEALLOCATE PREPARE stmt ; OPEN csr_user0 ; FETCH csr_user0 INTO PareUser ; WHILE rowstatus =0 DO /* initial all counter or parameters */ set PareUserCnt = PareUserCnt +1; select PareUserCnt ; set num = 0; set Nparelist = PareUser ; set GoStatus = 0; /* insert the node itself as level 0 neighbout */ insert into wikisampleN ( seq , userid , N , friendid ) values ( Seq , PareUser , num , Pareuser ) ; /* do the loop before all new level neighbours have been found */ While GoStatus = 0 Do set num = num +1; set insertCnt = 0; OPEN csr_user1 ; FETCH csr_user1 INTO N ; WHILE rowstatus =0 DO /* verify if this neighbour has been insert into the table */ set @sqlsel1 = concat ( ' select count (*) into @Exsist1 from ', tbl , ' where ', tbl , '. friendid = ' , N , ' and ', tbl , '. userid = ', PareUser , ' and ', tbl , '. seq = ', Seq ); PREPARE stmt FROM @sqlsel1 ; EXECUTE stmt ; DEALLOCATE PREPARE stmt ; if @Exsist1 =0 then

567 568 569 570 571

73

572

573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615

set @sqlinsert1 = concat ( ' insert into ', tbl , ' ( seq , userid , N , friendid ) values ( ' , Seq , ', ', PareUser , ', ' , num , ', ',N , ') ') ; PREPARE stmt FROM @sqlinsert1 ; EXECUTE stmt ; DEALLOCATE PREPARE stmt ; set insertCnt = insertCnt +1; end if ; set @Exsist1 = 0; FETCH csr_user1 INTO N ; END WHILE ; /* stop the loop when no new level neighbour can be found */ if insertCnt = 0 then set GoStatus = 1; end if ; CLOSE csr_user1 ; set rowstatus =0 ; /* generate neighbour list for level num , will be used at next round of loop */ set Nparelist = ' '; OPEN csr_user2 ; FETCH csr_user2 INTO NPare ; WHILE rowstatus =0 DO set Nparelist = concat ( Nparelist , Npare , ' , ') ; FETCH csr_user2 INTO NPare ; END WHILE ; CLOSE csr_user2 ; set rowstatus =0 ; set strLength = char_length ( Nparelist ) ; set Nparelist = substring ( NpareList , 1 , strLength -1) ; END WHILE ; FETCH csr_user0 INTO PareUser ; END WHILE ; CLOSE csr_user0 ; commit ; END ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- procedure structure for p r o c _ w i k i S a m p l e O r d e r -- create user lable informaiton for wiki sample , update table wikisample -- - - - - - - - - - - - - - - - - - - - - - - - - - - - CREATE DEFINER = ` amandatian `@ `% ` PROCEDURE ` proc_wikiSampleOrder `() BEGIN

74

616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640

/* create user lable informaiton for wiki sample , update table wikisample */ DECLARE rowstatus int DEFAULT 0; DECLARE User int ; DECLARE Num int ; DECLARE csr_user CURSOR FOR select userid from wikisample order by userid ; DECLARE CONTINUE HANDLER FOR NOT FOUND SET rowstatus =1; SET Num =0; OPEN csr_user ; FETCH csr_user INTO User ; while rowstatus =0 DO SET Num = Num +1; /* if User = 1156640 THEN select Num ; end if ;*/ UPDATE ` wikisample ` SET userlabel = Num WHERE userid = User ; FETCH csr_user INTO User ; END WHILE ; CLOSE csr_user ; END ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- procedure structure for p r o c _ w i k i s a m p le U -- calculate wiki sample user indegree and outdegree ( update table wikisample ) , if outdegree is 0 , then update table wikisample , set u =1 , is userd for to calculate NL gap -- - - - - - - - - - - - - - - - - - - - - - - - - - - - CREATE DEFINER = ` amandatian `@ `% ` PROCEDURE ` proc_wikisampleU `() BEGIN /* calculate wiki sample user indegree and outdegree ( update table wikisample ) , if outdegree is 0 , then update table wikisample , set u =1 , is userd for to calculate NL gap */ DECLARE rowstatus int default 0; DECLARE User int ; DECLARE Outdegree int ; DECLARE Indegree int ; DECLARE Seq int ; DECLARE num int default 0; DECLARE csr_user CURSOR FOR select wikisample . userid from wikisample where wikisample . seq = Seq ; DECLARE CONTINUE HANDLER FOR NOT FOUND SET rowstatus =1; set Seq = 0; OPEN csr_user ; FETCH csr_user INTO User ; WHILE rowstatus =0 DO select count (*) into Outdegree from w i k i s a m p l e _ l i n k s where w i k i s a m p l e _ l i n ks . userid = User and w i k i s a mp l e _ l i n k s . seq = Seq ;

641 642 643 644

645 646 647 648 649 650 651 652 653 654 655 656 657 658 659

75

660

661 662 663

select count (*) into Indegree from w i k i s a m p l e _ li n k s where w i k i s a m p l e _ l i n k s . friendid = User and w i k i s a m p l e _ l i n k s . seq = Seq ; set num = num +1; update wikisample set wikisample . outdegree = Outdegree , wikisample . indegree = Indegree where wikisample . userid = User and wikisample . seq = Seq ; if Outdegree = 0 then update wikisample set wikisample . u =1 where wikisample . userid = User and wikisample . seq = Seq ; end if ; FETCH csr_user INTO User ; END WHILE ; CLOSE csr_user ; commit ; /* select num ;*/

664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679

END ;

680 681 682 683 684 685 686 687

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- procedure structure for p r o c _ y o u t u b e s a m p l e -- generate youtube samples with smaller order by choosing first two level neighbours of given vertex ( specified by degree ) , update table youtubesample -- Seq : sequence -- K : degree to choose given vertex -- Pare : how many given vertices as pareanet vertices . -- - - - - - - - - - - - - - - - - - - - - - - - - - - - CREATE DEFINER = ` amandatian `@ `% ` PROCEDURE ` proc_youtubesample `( in Seq int , in K int , in Pare int ) BEGIN /* generate youtube samples with smaller order by choosing first two level neighbours of given vertex ( specified by degree ) , update table youtubesample Seq : sequence K : degree to choose given vertex Pare : how many given vertices as pareanet vertices .*/ DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE num int default 1; N1 int ; N2 int ; Exsist0 int default 0; Exsist1 int default 0; Exsist2 int default 0; PareUser int DEFAULT 1; rowstatus int default 0; tbl varchar (40) ; sqldel varchar (1000) ; sqlinsert0 varchar (1000) ;

688 689 690 691 692 693 694 695 696 697 698 699 700 701 702

76

703 704 705 706 707 708 709 710 711 712

DECLARE sqlinsert1 varchar (1000) ; DECLARE sqlinsert2 varchar (1000) ; DECLARE sqlsel1 varchar (1000) ; DECLARE sqlsel2 varchar (1000) ; DECLARE Source varchar (50) ; /* DECLARE K int DEFAULT 2; DECLARE Pare int ; DECLARE Seq int ;*/ DECLARE csr_user0 CURSOR FOR select y o u t u b e l i n k s _ d e g r e e . userid from ` youtubelinks_degree ` where y o u t u b e l i n k s _ d e g r e e . degree = K order by userid desc ; DECLARE csr_user1 CURSOR FOR select youtubelinks . friendid from ` youtubelinks ` where youtubelinks . userid = PareUser order by youtubelinks . friendid ; DECLARE csr_user2 CURSOR FOR select youtubelinks . friendid from ` youtubelinks ` where youtubelinks . userid = N1 order by youtubelinks . friendid ; DECLARE CONTINUE HANDLER FOR NOT FOUND SET rowstatus =1;

713

714

715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737

set tbl = ' youtubesample '; set Source = ' youtube '; /* set Seq = 11; set Pare =1;*/

set @sqldel = concat ( ' delete from ', tbl , ' where ', tbl , '. seq = ', Seq ) ; PREPARE stmt FROM @sqldel ; EXECUTE stmt ; DEALLOCATE PREPARE stmt ; OPEN csr_user0 ; FETCH csr_user0 INTO PareUser ; WHILE ( rowstatus =0 and num <= Pare ) DO select PareUser ; set @sqlsel0 = concat ( ' select count (*) into @Exsist0 from ', tbl , ' where ', tbl , '. userid = ' , PareUser , ' and ', tbl , '. seq = ', Seq ) ; PREPARE stmt FROM @sqlsel0 ; EXECUTE stmt ; DEALLOCATE PREPARE stmt ; if @Exsist0 =0 then set num = num + 1;

738 739 740 741 742 743 744

77

745

746 747 748 749 750 751 752 753 754 755 756 757

set @sqlinsert0 = concat ( ' insert into ', tbl , ' ( seq , source , userid ) values ( ', Seq , '\ , \ ' ' , Source , '\ '\ , ' , PareUser , ') ') ; select @sqlinsert0 ; PREPARE stmt FROM @sqlinsert0 ; EXECUTE stmt ; DEALLOCATE PREPARE stmt ; end if ; set @Exsist0 = 0; OPEN csr_user1 ; FETCH csr_user1 INTO N1 ; WHILE rowstatus =0 DO set @sqlsel1 = concat ( ' select count (*) into @Exsist1 from ', tbl , ' where ', tbl , '. userid = ' , N1 , ' and ', tbl , '. seq = ', Seq ) ; PREPARE stmt FROM @sqlsel1 ; EXECUTE stmt ; DEALLOCATE PREPARE stmt ; if N1 = 180 then select @sqlsel ; select N1 ; select @Exsist1 ; end if ; if @Exsist1 =0 then set @sqlinsert1 = concat ( ' insert into ', tbl , ' ( seq , source , userid ) values ( ' , Seq , '\ , \ ' ' , Source , '\ '\ , ' , N1 , ') ') ; PREPARE stmt FROM @sqlinsert1 ; EXECUTE stmt ; DEALLOCATE PREPARE stmt ; end if ; set @Exsist1 = 0; OPEN csr_user2 ; FETCH csr_user2 INTO N2 ; WHILE rowstatus =0 DO set @sqlsel2 = concat ( ' select count (*) into @Exsist2 from ', tbl , ' where ', tbl , '. userid = ' , N2 , ' and ', tbl , '. seq = ', Seq ) ; PREPARE stmt FROM @sqlsel2 ; EXECUTE stmt ; DEALLOCATE PREPARE stmt ; if N2 = 1 then select @sqlsel2 ; select N2 ; select @Exsist2 ;

758 759 760 761 762 763 764 765 766 767 768 769

770 771 772 773 774 775 776 777 778 779 780

781 782 783 784 785 786 787 788

78

789 790 791 792

end if ; if @Exsist2 =0 then set @sqlinsert2 = concat ( ' insert into ', tbl , ' ( seq , source , userid ) values ( ' , Seq , '\ , \ ' ' , Source , '\ '\ , ' , N2 , ') ') ; PREPARE stmt FROM @sqlinsert2 ; EXECUTE stmt ; DEALLOCATE PREPARE stmt ; end if ; set @Exsist2 = 0; FETCH csr_user2 INTO N2 ; END WHILE ; CLOSE csr_user2 ; set rowstatus =0 ; FETCH csr_user1 INTO N1 ; END WHILE ; CLOSE csr_user1 ; set rowstatus =0 ; FETCH csr_user0 INTO PareUser ; END WHILE ; CLOSE csr_user0 ; commit ; END ;

793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830

831 832 833 834 835

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- procedure structure for p r o c _ y o u t u b e S a m p l e O r d e r -- update youtube sample user label , update table youtubesample -- - - - - - - - - - - - - - - - - - - - - - - - - - - - CREATE DEFINER = ` amandatian `@ `% ` PROCEDURE ` proc_youtubeSampleOrder `( in Seq int ) BEGIN /* update youtube sample user label , update table youtubesample */ DECLARE rowstatus int DEFAULT 0; DECLARE User int ; DECLARE Num int ; DECLARE tbl varchar (40) ; /* DECLARE Seq int ;*/ DECLARE csr_user CURSOR FOR select youtubesample . userid from youtubesample where youtubesample . seq = Seq order by youtubesample . userid ; DECLARE CONTINUE HANDLER FOR NOT FOUND SET rowstatus =1; SET Num =0; /* SET Seq =11;*/ OPEN csr_user ; FETCH csr_user INTO User ;

79

836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883

while rowstatus =0 DO SET Num = Num +1; if User = 1156640 THEN select Num ; end if ; UPDATE ` youtubesample ` SET youtubesample . userlabel = Num WHERE youtubesample . userid = User and youtubesample . seq = Seq ; FETCH csr_user INTO User ; END WHILE ; CLOSE csr_user ; select Num ; END ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- procedure structure for p r o c _ y o u t u b e s a m p l e l i n k s -- select youtube samples links from youtubelinks by youtube sample user , update table y o u t u b e s a m p l e _ l i n k s -- - - - - - - - - - - - - - - - - - - - - - - - - - - - CREATE DEFINER = ` amandatian `@ `% ` PROCEDURE ` proc_youtubesamplelinks `( in Seq int ) BEGIN /* select youtube samples links from youtubelinks by youtube sample user , update table y o u t u b e s a m p l e _ l i n k s */ Declare Str varchar (1000000) ; Declare S varchar (1000000) ; Declare UserSample int ; Declare User varchar (20) ; Declare K int ; Declare rowstatus int default 0; /* Declare Seq int ;*/ declare num int default 0;

DECLARE csr_user CURSOR FOR select userid from youtubesample where youtubesample . seq = Seq order by youtubesample . userid ; DECLARE CONTINUE HANDLER FOR NOT FOUND SET rowstatus =1; /* Set Seq = 11;*/ OPEN csr_user ; FETCH csr_user INTO UserSample ; Set Str = '( ' ; while rowstatus =0 DO set User = concat ( UserSample ) ; Set Str = concat ( Str , User , ', ') ; set num = num + 1 ; FETCH csr_user INTO UserSample ; END WHILE ; CLOSE csr_user ; select num ;

80

884 885 886 887

set set set set

K = length ( Str ) ; Str = substr ( Str ,1 , K -2) ; Str = concat ( Str , ') ') ; @Str = concat ( ' INSERT INTO y o u t u b e s a m p l e _ l i n k s ( seq , userid , friendid ) SELECT ', Seq , ' , userid , friendid FROM youtubelinks where youtubelinks . userid in ', Str ) ;

888 889 890 891 892 893 894 895 896 897 898 899

delete from y o u t u b e s a m p l e _ l i n k s where y o u t u b e s a m p l e _ l i n k s . seq = Seq ; select @Str ; PREPARE stmt FROM @Str ; EXECUTE stmt ; DEALLOCATE PREPARE stmt ; /* select * from y o u t u b e s a m p l e _ l i n k s ;*/ delete from ` youtubesample_links ` where y o u t u b e s a m p l e _ l i n k s . seq = Seq and y o u t u b e s a m p l e _ l i n k s . friendid not in ( select youtubesample . userid from ` youtubesample ` where youtubesample . seq = Seq ) ;

900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920

update y o u t u b e s a m p l e _ l i n k s , youtubesample set y o u t u b e s a m p l e _ l i n k s . userlabel = youtubesample . userlabel where y o u t u b e s a m p l e _ l i n k s . userid = youtubesample . userid and youtubesample . seq = Seq and y o u t u b e s a m p l e _ l i n k s . seq = Seq ;

update ` youtubesample_links ` , youtubesample set y o u t u b e s a m p l e _ l i n k s . friendlabel = ` youtubesample `. userlabel where y o u t u b e s a m p l e _ l i n k s . friendid = youtubesample . userid and youtubesample . seq = Seq and y o u t u b e s a m p l e _ l i n k s . seq = Seq ;

END ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- procedure structure for p r o c _ y o u t u b e s a m p l e U -- calculate youtube sample users ' indegree and outdegree , if outdegree is 0 , then set u =1 which is for NL gap , update table youtubesample -- - - - - - - - - - - - - - - - - - - - - - - - - - - - CREATE DEFINER = ` amandatian `@ `% ` PROCEDURE ` proc_youtubesampleU `( in Seq int ) BEGIN /* calculate youtube sample users ' indegree and outdegree , if outdegree is 0 , then set u =1 which is for NL gap , update table youtubesample */ DECLARE rowstatus int default 0; DECLARE User int ;

921 922 923 924

925 926 927

81

928 929 930 931 932 933 934 935 936 937 938 939 940

DECLARE Outdegree int ; DECLARE Indegree int ; /* DECLARE Seq int ;*/ DECLARE num int default 0; DECLARE csr_user CURSOR FOR select youtubesample . userid from youtubesample where youtubesample . seq = Seq ; DECLARE CONTINUE HANDLER FOR NOT FOUND SET rowstatus =1; /* set Seq = 9;*/ OPEN csr_user ; FETCH csr_user INTO User ; WHILE rowstatus =0 DO select count (*) into Outdegree from y o u t u b e s a m p l e _ l i n k s where y o u t u b e s a m p l e _ l i n k s . userid = User and y o u t u b e s a m p l e _ l i n k s . seq = Seq ; select count (*) into Indegree from y o u t u b e s a m p l e _ l i n k s where y o u t u b e s a m p l e _ l i n k s . friendid = User and y o u t u b e s a m p l e _ l i n k s . seq = Seq ; set num = num +1; update youtubesample set youtubesample . outdegree = Outdegree , youtubesample . indegree = Indegree where youtubesample . userid = User and youtubesample . seq = Seq ; if Outdegree = 0 then update youtubesample set youtubesample . u =1 where youtubesample . userid = User and youtubesample . seq = Seq ; end if ; FETCH csr_user INTO User ; END WHILE ; CLOSE csr_user ; commit ; /* select num ;*/

941

942 943 944

945 946

947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969

END ; -- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- procedure structure for p r o c _ y o u t u b e s a m p l e N -- generate youtubesample neighbour list , used to calculate diameter , update table youtubes mapleN -- - - - - - - - - - - - - - - - - - - - - - - - - - - - CREATE DEFINER = ` amandatian `@ `% ` PROCEDURE ` proc_youtubesampleN `() BEGIN /* generate youtubesample neighbour list , used to calculate diameter , update table youtubes mapleN */ DECLARE DECLARE DECLARE DECLARE DECLARE num int default 0; N int ; NPare int ; insertCnt int ; strLength int ;

82

970 971 972 973 974 975 976 977 978 979 980 981 982 983 984

DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE DECLARE

Nparelist varchar (10000) ; Exsist1 int default 0; Exsist2 int default 0; PareUser int DEFAULT 1; rowstatus int default 0; GoStatus int default 0; tbl varchar (40) ; sqldel varchar (1000) ; sqlinsert1 varchar (1000) ; sqlsel1 varchar (1000) ; sqlsel2 varchar (1000) ;

DECLARE Seq int ; DECLARE csr_user0 CURSOR FOR select youtubesample . userid from youtubesample where youtubesample . seq = Seq order by youtubesample . userid ; DECLARE csr_user1 CURSOR FOR select distinct ( y o u t u b e s a m p l e _ l i n k s . friendid ) from y o u t u b e s a m p l e _ l i n k s where y o u t u b e s a m p l e _ l i n k s . seq = Seq and FIND_IN_SET ( y o u t u b e s a m p l e _ l i n k s . userid , Nparelist ) ; DECLARE csr_user2 CURSOR FOR select distinct ( y outubesa mpleN . friendid ) from youtubes ampleN where youtube sampleN . seq = Seq and yout ubesampl eN . userid = PareUser and yout ubesamp leN . N = num ; DECLARE CONTINUE HANDLER FOR NOT FOUND SET rowstatus =1; set tbl = ' youtubesampleN '; set Seq = 1;

985

986

987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014

set @sqldel = concat ( ' delete from ', tbl , ' where ', tbl , '. seq = ', Seq ) ; PREPARE stmt FROM @sqldel ; EXECUTE stmt ; DEALLOCATE PREPARE stmt ; OPEN csr_user0 ; FETCH csr_user0 INTO PareUser ; WHILE rowstatus =0 DO set num = 0; insert into you tubesam pleN ( seq , userid , N , friendid ) values ( Seq , PareUser , num , Pareuser ) ; set Nparelist = PareUser ; set GoStatus = 0; While GoStatus = 0 Do set num = num +1; set insertCnt = 0; OPEN csr_user1 ; FETCH csr_user1 INTO N ; WHILE rowstatus =0 DO

83

1015

1016 1017 1018 1019 1020 1021

set @sqlsel1 = concat ( ' select count (*) into @Exsist1 from ', tbl , ' where ', tbl , '. friendid = ' , N , ' and ', tbl , '. userid = ', PareUser , ' and ', tbl , '. seq = ', Seq ); PREPARE stmt FROM @sqlsel1 ; EXECUTE stmt ; DEALLOCATE PREPARE stmt ; if @Exsist1 =0 then set @sqlinsert1 = concat ( ' insert into ', tbl , ' ( seq , userid , N , friendid ) values ( ' , Seq , ', ', PareUser , ', ' , num , ', ',N , ') ') ; PREPARE stmt FROM @sqlinsert1 ; EXECUTE stmt ; DEALLOCATE PREPARE stmt ; set insertCnt = insertCnt +1; end if ; set @Exsist1 = 0; FETCH csr_user1 INTO N ; END WHILE ; if insertCnt = 0 then set GoStatus = 1; end if ; CLOSE csr_user1 ; set rowstatus =0 ; set Nparelist = ' '; OPEN csr_user2 ; FETCH csr_user2 INTO NPare ; WHILE rowstatus =0 DO set Nparelist = concat ( Nparelist , ; FETCH csr_user2 INTO NPare ; END WHILE ; CLOSE csr_user2 ;

1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058

Npare , ' , ')

set rowstatus =0 ; set strLength = char_length ( Nparelist ) ; set Nparelist = substring ( NpareList , 1 , strLength -1) ; END WHILE ; FETCH csr_user0 INTO PareUser ; END WHILE ; CLOSE csr_user0 ; commit ; /*

84

1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106

*/

END ;

-- - - - - - - - - - - - - - - - - - - - - - - - - - - - -- procedure structure for p r o c _ y o u t u b e s a m p l e c a l l -- generate youtubesamples , samples ' links , indegree outdegree ... information in bach ( by seq ) -- - - - - - - - - - - - - - - - - - - - - - - - - - - - CREATE DEFINER = ` amandatian `@ `% ` PROCEDURE ` proc_youtubesamplecall `( in Seq int , in k int , in Pare int ) BEGIN /* generate youtubesamples , samples ' links , indegree outdegree ... information in bach ( by seq ) */ call call call call END ; p r o c _ y o u t u b e s a m p l e ( Seq , k , Pare ) ; p r o c _ y o u t u b e s a m p l e o r d e r ( Seq ) ; p r o c _ y o u t u b e s a m p l e l i n k s ( Seq ) ; p r o c _ y o u t u b e s a m p l e U ( Seq ) ;

function [K ,A ,u , outdegree , indegree , P ] = FUNdbA ( dbo , account , pswd , tbl , seq , sql ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - % K : amount of nodes % A : Adjency Matrix % outdegree : vector of outdegree count % indegree : vector of indegree count % P : nomalized adjency matrix %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % dbo : dbo name ( database server host ) % account : database account % pswd : database pswd % tbl : table name % seq : sample sequence %------------------------------------------% check OS OS = isunix ; % connect to specified database , specifying username and password if OS == 1 % unix operation system connection = database ( dbo , account , pswd , ' com . mysql . jdbc . Driver ' , ' jdbc : mysql : / / 1 2 7 . 0 . 0 . 1 : 3 3 0 6 / OSN ') ; else % windows operation system connection = database ( dbo , account , pswd ) ; end % found how many users are there in samples

85

1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157

if isempty ( sql ) Str1 = [ ' select u , outdegree , indegree from ', tbl , ' where seq = ' , seq , ' order by userlabel ']; Str2 = [ ' select userlabel , friendlabel from ', tbl , ' _links where seq = ', seq , ' order by userlabel ']; else Str1 = sql (1) ; Str2 = sql (2) ; end cursor1 = exec ( connection , Str1 ) ; % set the reture data format as int / numeric setdbprefs ( ' DataReturnFormat ' , ' numeric ') ; % retrieve R rows of data cursor1 = fetch ( cursor1 ) ; u = cursor1 . data (: ,1) ; outdegree = cursor1 . data (: ,2) ; indegree = cursor1 . data (: ,3) ; K = length ( u ) ; % open cursor and issue SQL statement to select links cursor2 = exec ( connection , Str2 ) ; % set the reture data format as int / numeric setdbprefs ( ' DataReturnFormat ' , ' numeric ') ; % retrieve R rows of data cursor2 = fetch ( cursor2 ) ; Data = cursor2 . data ; UserLabel = Data (: ,1) ; FriendLabel = Data (: ,2) ; Links = length ( UserLabel ) ; A (1: K ,1: K ) =0; for i = 1: Links Row = UserLabel ( i ) ; Col = FriendLabel ( i ) ; A ( Row , Col ) = 1; end P=A; for i =1: K if outdegree ( i ) ~=0 for j = 1: K P (i , j ) = A (i , j ) / outdegree ( i ) ; end end end

86

1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207

% execute sql to insert data into database function [ Flag ] = FUNdbInsert ( dbo , account , pswd , tbl , Col , Data , Del ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - % Flag : nothing %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % dbo : dbo name ( database server host ) % account : database account % pswd : database pswd % tbl : table name % Col : fields of table % Data : data to be insert into tbl %------------------------------------------% Col = { ' userid ' , ' friendid ' , ' userlabel ' , ' friendlabel ' , ' seq ' , ' dim ' , 'N ' , 'a ' , 'b '}; % Data = [1 ,2 ,1 ,2 ,1 ,1 ,5 ,0.7 ,0.15]; OS = isunix ; % connect to specified database , specifying username and password if OS == 1 % unix operation system connection = database ( dbo , account , pswd , ' com . mysql . jdbc . Driver ' , ' jdbc : mysql : / / 1 2 7 . 0 . 0 . 1 : 3 3 0 6 / OSN ') ; else % windows operation system connection = database ( dbo , account , pswd ) ; end cur = exec ( connection , Del ) ; insert ( connection , tbl , Col , Data ) ; Flag = exec ( connection , ' commit ') ;

function [ Flag ] = FUNdegdi stFile ( FileName , FilePath , DimensionS , DimensionE ) % write matrix to file % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - % Flag : nothing , no useful %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % A : Data matrix % FileName : file name %-------------------------------------------

for i = DimensionS : DimensionE File = [ FilePath FileName ]; fid = fopen ( File , 'r ') ; if fid == -1 display ([ ' Error opening the ' File ]) ; end Num =0; s = sprintf ( ' DegDist % d =[]; ' , i ) ;

87

1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257

eval ( s ) ; s = sprintf ( ' DegDist % d ( Num ,:) = Line ' '; ' , i ) ; while feof ( fid ) == false Num = Num +1; Line = fgetl ( fid ) ; Line = sscanf ( Line , ' % f % f ') ; eval ( s ) ; end end

% plot degree distribution for every dimension % y : yellow , m : pink , c : light blue , r : red , g : green , b : blue , k : black Color =[ ' y ' , 'm ' , 'c ' , 'r ' , 'g ' , 'b ' , 'k ']; LegendStr = [ ' legend ( ' ' wiki indegree ' ' , ' ' wiki outdegree ' ' , ' ' wiki alldegree ' ' ']; for i = DimensionS : DimensionE Str = [ ' plot ( log ( DegDist % d (: ,1) ) , log ( DegDist % d (: ,2) ) , ' , ' ' ' - ' , Color ( i ) , ' ' ') ']; s = sprintf ( Str ,i , i ) ; eval ( s ) ; xlabel ( ' log ( Degree ) ') ; ylabel ( ' log ( Distribution ) ') ; LegendStr = [ LegendStr ','' GEOP ' num2str ( i ) ' dimension ' ' ']; end hold off ; LegendStr = [ LegendStr , ') ']; eval ( LegendStr ) ; fileNM = [ ' GEOP_DegDist_ ' num2str ( N ) '_ ' num2str ( DimensionS ) '_ ' num2str ( DimensionE ) ]; saveas ( gcf , fileNM ) ;

function [ Flag ] = FUNfileA (A , FileName , type ) % write matrix to file % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - % Flag : nothing , no useful %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % A : Data matrix % FileName : file name % type : number type % ' int ': integer % ' dec ': decimal or float %------------------------------------------% A = [1 ,2 ,3;4 ,5 ,6];

88

1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309

fid = fopen ( FileName , 'w ') ; for i = 1: size (A ,1) for j = 1: size (A ,2) if type == 'int ' fprintf ( fid , '% d \t ' , A (i , j ) ) ; elseif type == 'dec ' fprintf ( fid , '% f \t ' , A (i , j ) ) ; end end fprintf ( fid , '\ r \n ' , ' end ') ; end Flag = fclose ( fid ) ;

% verify if a graph is GEN by compare if log ( A ) and log ( Scodd ) are linear function [ LogA , SCodd ] = FUNgen ( Lambda , Evector ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - % LogA : a parameter from the formular % SCodd : odd walk number begin from nodes %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % Lambda : dominant eigenvalue % Evector : dominant eigenvector %------------------------------------------LogA = log (( sinh ( Lambda ) ) ^( -0.5) ) ; SCodd = ( Evector .^2) * sinh ( Lambda ) ; subplot (1 ,2 ,1) ; plot ( log ( Evector ) , log ( SCodd ) ) ; title ( ' log - log plot ') ; I = 1: length ( Evector ) ; subplot (1 ,2 ,2) ; hold on ; plot (I , log ( Evector ) ,'-r ') ; plot (I , LogA + 0.5* log ( SCodd ) , ':b ') ; hold off ; title ( ' right - left match ') ;

function [ G ] = FUNgeo (N ,a ,b , m ) % generate cordinators matrix for geop models % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - % G : cordinators of random nodes . % G (i ,1: m ) : cordinators % G (i , m +1) : rank

89

1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362

% G (i , m +2) : influcial area % G (i , m +3) : time T of birth % G (i , m +4) : degree at time T % G (i , m +5) : rank at time T -1 % G (i , m +6) : if node ' s influcial area need to be re - evaluated % 1: yes , rank changed , need to be evaluated % 0: no , no changes of rank , not need to be evalueated %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % N : amount of nodes % a , b : parameters of GEO - P model , used to calculate influcial area % m : dimension %-------------------------------------------

% % % %

N =5; a = 0.7; b =0.15; m =2;

if b >= 1 - a display ( ' wrong parameter b ') ; end G = []; for i =1: N G (i ,:) = rand (1 , m ) ; end % rank of every node % G (: , m +1) = randperm ( N ) ; [ ignore , Perm ] = sort ( rand (1 , N ) ) ; G (: , m +1) = Perm ; % influcial area of every node G (: , m +2) = ( G (: , m +1) .^( - a ) ) .*( N ^( - b ) ) ; % time T of birth G (: , m +3) =0; % initial degree of nodes at time T to be 0 G (: , m +4) =0; % initial rank of nodes at time T -1 to be the same of at time T G (: , m +5) = G (: , m +1) ; % initial all nodes ' degree need to be evalueated . G (: , m +6) =1;

% resort degree / rank of GEOP datas function [ NewA , NewG ] = FUNgeoDeg (A ,G ,u ,a , m ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - % A : adjency matrix of GEO - P

90

1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413

%------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % G : cordinates matrix of N nodes % G (i ,1: m ) : cordinators % G (i , m +1) : rank % G (i , m +2) : influcial area , % G (i , m +3) : time T of birth % G (i , m +4) : degree at time T % u : vectors of m - spare , generated by { -1 ,0 ,1} % m : dimension %------------------------------------------N = size (G ,1) ; for i = 1: N -1 d =[]; % calculate distance of every pair of nodes for k = 1: length ( u ) d ( k ) = norm ( G (i ,1: m ) -G (N ,1: m ) + u (k ,:) , inf ) ; end D = min ( d ) ; % check node if node N falls in influtial area of node i if m == 2 Cn = pi ; else if mod (m ,2) ==1 % odd n = ( m +1) /2; Cn = (2^(( m +1) /2) ) *( pi ^(( m -1) /2) ) /(( factorial (2* n ) ) /( factorial ( n ) *2^ n ) ) ; else % even Cn = ( pi ^( m /2) ) /( factorial ( m /2) ) ; end end r = max (( G (i , m +2) / Cn ) ^(1/ m ) ,( G (N , m +2) / Cn ) ^(1/ m ) ) ; % compare distance of two nodes and maxmum influcial raius to decide the edge if r >= D % should add an edge G (i , m +4) = G (i , m +4) +1; G (N , m +4) = G (N , m +4) +1; A (i , N ) =1; A (N , i ) =1; else A (i , N ) =0; A (N , i ) =0; end end % sort nodes ' rank by degree , and calcuclate new influcial area for i = 1: N BigerDeg = length ( find ( G (: , m +4) >G (i , m +4) ) ) ;

91

1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465

OlderAge = length ( find ( G (: , m +4) == G (i , m +4) & G (: , m +3) < G (i , m +3) ) ) ; G (i , m +1) = BigerDeg + OlderAge +1; G (i , m +2) = ( G (i , m +1) ^( - a ) ) /( N ^ a ) ; end NewA = A ; NewG = G ;

function [A , GT ] = FUNgeoedge (G ,u ,m ,A , flag , h ) % create edges for graph generated by geop models % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - % A : adjency matrix of GEO - P %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % G : initial cordinates matrix of time 0 % G (i ,1: m ) : cordinators % G (i , m +1) : rank % G (i , m +2) : influcial area % G (i , m +3) : time T of birth % G (i , m +4) : degree at time T % G (i , m +5) : rank at time T -1 % G (i , m +6) : if node ' s influcial area need to be re - evaluated % 1: yes , rank changed , need to be evaluated % 0: no , no changes of rank , not need to be evalueated % u : vectors of m - spare , generated by { -1 ,0 ,1} % m : dimension % flag : model flag % 1: GEOP % 2: Age % 3: Degree by changing N % 4: Degree by fix N % 5: Age Inverse % 6: Degree fix N by Radom Ranking & Tension Parameter % 7: GEOP - Tension Parameter % 8: GEOP - Pr ( radius ) % 9: GEOP - Pr ( distance & radius ) % 10: GEOP - Pr ( distance & radius Pr ( distance ) + Pr ( radius ) ) % TnsFlag : count tension parameter ? % 1: yes % 0: no % h : Tension Parameter , if TnsFlag =0 , h ' s value does not matter , can be 0 % P : probability matrix %------------------------------------------N = size (G ,1) ; d =[]; if m == 2 Cn = pi ; else

92

1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516

if mod (m ,2) ==1 % odd n = ( m +1) /2; Cn = (2^(( m +1) /2) ) *( pi ^(( m -1) /2) ) /(( factorial (2* n ) ) /( factorial ( n ) *2^ n ) ) ; else % even Cn = ( pi ^( m /2) ) /( factorial ( m /2) ) ; end end G (: , m +4) =0; % clear degree column before check edges

% tension parameter of nodes TEN = zeros (N ,1) ; TEN ( G (: , m +1) ~=0 ,1) = G ( G (: , m +1) ~=0 , m +1) .^ h ; % calculate radius and diameter of m - sphear Far = zeros (1 ,3) ; Far (1 ,:) =1; GDiam = norm ( Far , inf ) ; % GDiam = m ^0.5; GRad = 0.5* GDiam ; for i = 1: N for j = i +1: N if i == 3 && j == 14 ss = 1; end % calculate distance of every pair of nodes Diff = G (i ,1: m ) -G (j ,1: m ) ; for k = 1: length ( u ) d ( k ) = norm ( Diff + u (k ,:) , inf ) ; end D = min ( d ) ;

% calculate max and min influcial radius of two nodes MaxI = max ( G (i , m +2) ,G (j , m +2) ) ; rMax = ( MaxI / Cn ) ^(1/ m ) ; MinI = min ( G (i , m +2) ,G (j , m +2) ) ; rMin = ( MinI / Cn ) ^(1/ m ) ; if flag == 7 || flag == 6 % calculate modified influcial radius by tension parameter TENP = ( TEN ( i ) + TEN ( j ) ) /2; r = rMax * TENP ; else r = rMax ; % take maximum radius of two nodes to compare with distance end if flag == 8 % GEOP - Pr ( radius )

93

1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567

if rMax + rMin >= D % two nodes have overlap area Pr = rMin / rMax ; if rand (1) >= Pr A (i , j ) =1; else A (i , j ) =0; end else A (i , j ) =0; end elseif flag == 9 % GEOP - Pr ( distance & radius ) if rMax + rMin >= D % two nodes have overlap area Pr = ( m ^0.5 - D ) /( m ^0.5 + 1/ rMax + 1/ rMin ) ; if rand (1) >= Pr A (i , j ) =1; else A (i , j ) =0; end else A (i , j ) =0; end elseif flag == 10 % GEOP - Pr ( distance & radius Pr ( distance ) + Pr ( radius ) ) if rMax + rMin >= D % two nodes have overlap area PrD = ( GRad -D ) / GRad ; PrR = ( rMax + rMin ) / GDiam ; Pr = ( PrD + PrR ) /2; if rand (1) >= Pr A (i , j ) =1; else A (i , j ) =0; end else A (i , j ) =0; end else % compare distance of two nodes and maxmum influcial raius to decide % the edge if r >= D A (i , j ) =1; else A (i , j ) =0; end end % symetry the matrix A (j , i ) = A (i , j ) ; end % display ( num2str ( i ) ) ; end % calculate the degree of matrix

94

1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619

G (: , m +4) = sum ( A ) '; GT = G ;

function [A , GT ] = FUNgeoedgeDeg (G ,u ,m , A ) % create edges for geop ( deg ) models % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - % A : adjency matrix of GEO - P %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % G : initial cordinates matrix of time 0 % G (i ,1: m ) : cordinators % G (i , m +1) : rank % G (i , m +2) : influcial area % G (i , m +3) : time T of birth % G (i , m +4) : degree at time T % G (i , m +5) : rank at time T -1 % G (i , m +6) : if node ' s influcial area need to be re - evaluated % 1: yes , rank changed , need to be evaluated % 0: no , no changes of rank , not need to be evalueated % u : vectors of m - spare , generated by { -1 ,0 ,1} % m : dimension %------------------------------------------N = size (G ,1) ; d =[]; if m == 2 Cn = pi ; else if mod (m ,2) ==1 % odd n = ( m +1) /2; Cn = (2^(( m +1) /2) ) *( pi ^(( m -1) /2) ) /(( factorial (2* n ) ) /( factorial ( n ) *2^ n ) ) ; else % even Cn = ( pi ^( m /2) ) /( factorial ( m /2) ) ; end end

for i = 1: N if G (i , m +6) ==1 % this node ' s need to be re - evaluated for j = 1: N if i ~= j && A (i , j ) ==0; % no edge between i , j yet % calculate distance of every pair of nodes Diff = G (i ,1: m ) -G (j ,1: m ) ; for k = 1: length ( u ) d ( k ) = norm ( Diff + u (k ,:) , inf ) ; end D = min ( d ) ;

95

1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669

% calculate max influcial radius of tow nodes MaxI = max ( G (i , m +2) ,G (j , m +2) ) ; r = ( MaxI / Cn ) ^(1/ m ) ; % compare distance of two nodes and maxmum influcial raius to decide % the edge , and change the value degree : G (: , m +4) if r >= D A (i , j ) =1; A (j , i ) =1; % when i , j nodes both have 1 at m +6 col , it may count % the same edge twice , so only do once . if ( G (j , m +6) ==1&& i < j ) || ( G (j , m +6) ==0) G (i , m +4) = G (i , m +4) +1; G (j , m +4) = G (j , m +4) +1; end end end end % display ( num2str ( i ) ) ; end end

GT = G ;

% generate GEOP adjency matrix at time 0 and time T with N nodes and m dimension function [A , AT , degree ] = FUNgeoP (a ,b ,N ,m ,T , flag , modelT0 , h ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - % A : adjency matrix of GEO - P % AT : adjency matrix of GEO - P at time T % degree : degree of A %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % a , b : GEOP parameters % N : order of graph % m : dimention of graph % T : time T % flag : choose the algrithom of time changing % 1: general geop model % 2: Age % 3: Degree ( changing N ) ( not available now % 4: Degree ( fix N ) % 5: Age Inverse % 6: Degree ( random rank & Tension Parameter ) % 7: GEOP - Tension Parameter % 8: GEOP - Pr ( radius )

96

1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722

% 9: GEOP - Pr ( distance & radius ) % 10: GEOP - Pr ( distance & radius Pr ( distance ) + Pr ( radius ) ) % modelT0 : the model to determine edges at time 0 % 1: geop model % 2: GNP model % h : Tension Parameter %------------------------------------------% generate geo model cordinates and influcial area of N nodes % G : initial cordinates matrix of time 0 % G (i ,1: m ) : cordinators % G (i , m +1) : rank % G (i , m +2) : influcial area % G (i , m +3) : time T of birth % G (i , m +4) : degree at time T % G (i , m +5) : rank at time T -1 % G (i , m +6) : if node ' s influcial area need to be re - evaluated % 1: yes , rank changed , need to be evaluated % 0: no , no changes of rank , not need to be evalueated [ G ] = FUNgeo (N ,a ,b , m ) ; % calculate u vector of m dimension { -1 ,0 ,1} [ u ] = FUNgeoU ( m ) ; % generage adjency matrix for geo model based on G A = zeros (N , N ) ; if flag ==4 || flag ==6 if modelT0 == 1 % GEOP [ AT , GT ] = FUNgeoedgeDeg (G ,u ,m , A ) ; elseif modelT0 == 2 % GNP [ AT , GT ] = FUNgnp (N ,0.5 , G ,a ,b , m ) ; else display ( ' undefined model at time 0 ') ; return ; end else GT = G ; end for t = 1: T if flag ==1 || flag ==7 || flag ==8 || flag ==9 || flag ==10 [ GT ] = FUNgeoTime ( GT ,m ,a , b ) ; elseif flag ==2 || flag ==5 [ GT ] = FUNgeoTimeAge ( GT ,m ,a ,b ,t , flag ) ; elseif flag ==4 || flag == 6 [ AT , GT ] = F U N g e o T i m e D e g F i x N ( GT ,m ,a ,b ,t ,u , AT , flag ) ; else display ( ' undefined algrithom of time ') ; end display ([ ' time : ' num2str ( t ) ]) ; end % for modles rather than DegFixN , will determine edges at final time

97

1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774

if flag ~=4 && flag ~= 6 if flag == 7 % geop - random rank model , add tension parameter [ AT , GT ] = FUNgeoedge ( GT ,u ,m ,A , flag , h ) ; else [ AT , GT ] = FUNgeoedge ( GT ,u ,m ,A , flag ,0) ; end end degree = GT (: , m +4) ; % resort GEOP nodes degree / rank by degree algorithm GEOP adjency matrix at % time T with T +1 nodes ( by degree rank method ) with m dimension function [ AT ,G , degree ] = FUNgeoPDeg (a ,b ,m , T ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - % A : adjency matrix of GEO - P at time 0 % AT : adjency matrix of GEO - P at time T by Age algorithm % degree : degree of A %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % a , b : GEOP parameters % N : order of graph , N = T + 1 % m : dimention of graph % T : time T %-------------------------------------------

% initial G at time 0 with only G (1 ,1: m ) = rand (1 , m ) ; G (1 , m +1) =1; G (1 , m +2) =( G (1 , m +1) ^( - a ) ) /(2^ a ) ; G (1 , m +3) =0; G (1 , m +4) =0; A =[0];

one node % cordinators % rank % influcial area % time of birth % degree of node at time T

% calculate u vector of m dimension { -1 ,0 ,1} [ u ] = FUNgeoU ( m ) ; for t = 1: T G ( t +1 ,1: m ) = rand (1 , m ) ; G ( t +1 , m +1) = 0; G ( t +1 , m +2) = 0; G ( t +1 , m +3) = t ; G ( t +1 , m +4) = 0; [ NewA , NewG ]= FUNgeoDeg (A ,G ,u ,a , m ) ; A = NewA ; G = NewG ; end AT = A ; degree = G (: , m +4) ;

98

1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827

function [ GT ] = FUNgeoTime (G ,m ,a ,b , T ) % generate cordinators matrix by different time T % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - % GT : cordinate matrix of time T %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % G : initial cordinates matrix of time 0 % G (i ,1: m ) : cordinators % G (i , m +1) : rank % G (i , m +2) : influcial area % G (i , m +3) : time T of birth % G (i , m +4) : degree at time T % G (i , m +5) : rank at time T -1 % G (i , m +6) : if node ' s influcial area need to be re - evaluated % 1: yes , rank changed , need to be evaluated % 0: no , no changes of rank , not need to be evalueated % m : dimension % a , b : parameters of GEO - P model , used to calculate influcial area %-------------------------------------------

N = size (G ,1) ; % generate new cordinagtes NewCor = rand (1 , m ) ; % generate new rank NewRank = 1+ fix ( N * rand (1 ,1) ) ; % generate new row for GT New = [ NewCor , NewRank ,0 ,T ,0 ,0 ,1]; GT = [ G (: ,1: m +1) ; New ]; % re - order existing rank by adding a new node for i = 1: N if GT (i , m +1) >= NewRank GT (i , m +1) = GT (i , m +1) +1; end end % choose and delete a node from existing nodes DelRank = 1+ fix (( N +1) * rand (1 ,1) ) ; GT ( GT (: , m +1) == DelRank ,:) =[]; % re - order existing ran by deleting a node for i = 1: N if GT (i , m +1) >= DelRank GT (i , m +1) = GT (i , m +1) -1; end end % calculate influcial area

99

1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878

GT (: , m +2) = ( GT (: , m +1) .^( - a ) ) .*( N ^( - b ) ) ;

% generate adjency matrix for GEOP - DegFixN model , literated by degeree algrithom function [A , GT ] = F U N g e o T i m e D e g F i x N (G ,m ,a ,b ,T ,u ,A , flag ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - % GT : cordinate matrix of time T %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % G : initial cordinates matrix of time 0 % G (i ,1: m ) : cordinators % G (i , m +1) : rank % G (i , m +2) : influcial area % G (i , m +3) : time T of birth % G (i , m +4) : degree at time T % G (i , m +5) : rank at time T -1 % G (i , m +6) : if node ' s influcial area need to be re - evaluated % 1: yes , rank changed , need to be evaluated % 0: no , no changes of rank , not need to be evalueated % m : dimension % a , b : parameters of GEO - P model , used to calculate influcial area % T : time t % u : vectors of m - dimension ( -1 ,0 ,1) ^ m % A : adjency matrix % flag : model type % 1: GEOP % 2: Age % 3: Degree by changing N % 4: Degree by fix N % 5: Age Inverse % 6: Degree fix N by Radom Ranking % 7: GEOP - Random Rank % 8: GEOP - Pr %-------------------------------------------

N = size (G ,1) ; % choose and delete a node from first N existing nodes DelRow = 1+ fix (( N ) * rand (1 ,1) ) ; % if there was edge between this node , deleted node , then delete the edge for j =1: N if A ( DelRow , j ) ==1 G (j , m +4) = G (j , m +4) -1; end end G ( DelRow ,:) =[]; A ( DelRow ,:) =[]; A (: , DelRow ) =[];

100

1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929

% generate new cordinagtes NewCor = rand (1 , m ) ; % generate new row for GT New = [ NewCor , 0 ,0 ,T ,0 ,0 ,1]; G = [ G ; New ]; A (N ,:) =0; A (: , N ) =0; % set value of rank at time T -1; G (: , m +5) = G (: , m +1) ; if flag ==6 % random rank

e1 =0.1; e2 = -0.1; [A , G ] = FUNgeoedge (G ,u ,m ,A , flag ,0) ; % sort nodes ' rank by degree E = sum ( G (: , m +4) ) /2; MaxDeg = max ( G (: , m +4) ) ; % ExtP = ( log ( E ) / log ( MaxDeg ) ) *0.9; ExtP = ( log ( E ) / log ( MaxDeg ) ) ^ e1 ; G (: , m +1) = min ((( G (: , m +4) .^ ExtP ) ./ E ) .^ e2 ,10* N ) ; else % consecutive rank [A , G ] = FUNgeoedgeDeg (G ,u ,m , A ) ; % sort nodes ' rank by degree for i = 1: N BigerDeg = length ( find ( G (: , m +4) >G (i , m +4) ) ) ; OlderAge = length ( find ( G (: , m +4) == G (i , m +4) & G (: , m +3) < G (i , m +3) ) ) ; G (i , m +1) = BigerDeg + OlderAge +1; end end % calculate influcial area G (: , m +2) = ( G (: , m +1) .^( - a ) ) .*( N ^( - b ) ) ; % rank changed , set the flat to be 1 ( need to be evaluated next time ) G ( find ( G (: , m +1) ~= G (: , m +5) ) ,m +6) =1; % rank stays the same , set the flat to be 0 ( no need to be evaluated next time ) G ( find ( G (: , m +1) == G (: , m +5) ) ,m +6) =0; GT = G ;

% gegerate cordinate for GEOP - Age model by time T function [ GT ] = FUNgeoTimeAge (G ,m ,a ,b ,T , flag ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - % GT : cordinate matrix of time T %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - -

101

1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982

% G : cordinators of random nodes . % G (i ,1: m ) : cordinators % G (i , m +1) : rank % G (i , m +2) : influcial area % G (i , m +3) : time T of birth % G (i , m +4) : degree at time T % G (i , m +5) : rank at time T -1 % G (i , m +6) : if node ' s influcial area need to be re - evaluated % 1: yes , rank changed , need to be evaluated % 0: no , no changes of rank , not need to be evalueated % m : dimension % a , b : parameters of GEO - P model , used to calculate influcial area % T : time t % flag : indicate the model type % 2. Age % 5. Age - Inverse %-------------------------------------------

N = size (G ,1) ; % generate new cordinagtes NewCor = rand (1 , m ) ; % generate new rank , the smallest rank if flag == 2 % by age NewRank = N +1; elseif flag == 5 % by age - inverse model NewRank = 1; else display ( ' undefined modle type for age ') ; return ; end % generate new row for GT New = [ NewCor , NewRank ,0 ,T ,0 ,0 ,0]; GT = [ G ; New ]; % choose and delete a node from existing nodes DelRow = 1+ fix ( N * rand (1 ,1) ) ; DelRank = GT ( DelRow , m +1) ; GT ( DelRow ,:) =[]; % set value of rank at time T -1; G (: , m +5) = G (: , m +1) ; % re - order existing rank by deleting a node for i = 1: N if flag == 2 % by age model if GT (i , m +1) >= DelRank GT (i , m +1) = GT (i , m +1) -1; end elseif flag == 5 % by age - inverse model if i < N if GT (i , m +1) < DelRank

102

1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035

GT (i , m +1) = GT (i , m +1) +1; end end end end % calculate influcial area GT (: , m +2) = ( GT (: , m +1) .^( - a ) ) .*( N ^( - b ) ) ;

function [ u ] = FUNgeoU ( m ) % generate u vectors in R ^ m by { -1 ,0 ,1} , used to calculate distance of % veritices % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - % u : vectors of m - spare , generated by { -1 ,0 ,1} %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % m : dimenstion %-------------------------------------------

Str1 = '[ '; Str2 = ']= ndgrid ( '; Str3 = 'u =[ '; for i = 1: m Str1 = [ Str1 , 'v ' , num2str ( i ) , ' , ']; Str2 = [ Str2 , ' -1:1 , ']; Str3 = [ Str3 , 'v ' , num2str ( i ) , '(:) , ']; end Str1 = Str1 (1: length ( Str1 ) -1) ; Str2 = Str2 (1: length ( Str2 ) -1) ; Str2 = [ Str2 , ') ']; Str1 = [ Str1 , Str2 , '; ']; Str3 = Str3 (1: length ( Str3 ) -1) ; Str3 = [ Str3 , ']; ']; eval ( Str1 ) ; eval ( Str3 ) ;

% generate G (K ,1/2) adjency matrix function [A , GT ] = FUNgnp (N ,P ,G ,a ,b , m ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - % A : Adjency Matrix of order K %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - -

103

2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087

% K : order of graph % P : probability of edge between any pair of nodes % G : cordinators of random nodes . % G (i ,1: m ) : cordinators % G (i , m +1) : rank % G (i , m +2) : influcial area % G (i , m +3) : time T of birth % G (i , m +4) : degree at time T % G (i , m +5) : rank at time T -1 % G (i , m +6) : if node ' s influcial area need to be re - evaluated % 1: yes , rank changed , need to be evaluated % 0: no , no changes of rank , not need to be evalueated %------------------------------------------A =[]; A = rand (N , N ) ; for i =1: N A (i , i ) =0; for j = i +1: N if A (i , j ) >= P A (i , j ) =1; else A (i , j ) =0; end A (j , i ) = A (i , j ) ; end Degree = sum ( A (i ,:) ) ; G (i , m +4) = Degree ; end

% sort nodes ' rank by degree for i = 1: N BigerDeg = length ( find ( G (: , m +4) >G (i , m +4) ) ) ; OlderAge = length ( find ( G (: , m +4) == G (i , m +4) & G (: , m +3) < G (i , m +3) ) ) ; G (i , m +1) = BigerDeg + OlderAge +1; end % calculate influcial area G (: , m +2) = ( G (: , m +1) .^( - a ) ) .*( N ^( - b ) ) ; GT = G ;

% generate Normalized Loplacion matrix and calculate spectual gap function [ inL , outL , indegree , outdegree , inLambda_N , inLambda_2 , outLambda_N , outLambda_2 , inGap , outGap ] = FUNLPgap ( A ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - % A : adjency matrix %-------------------------------------------

104

2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140

% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % L : Nomalized Loplcion matrix % indegree : indegree % outdegree : outdegree % Lambda_N : biggest eigenvalue % Lambda_2 : 2 nd smalled eigenvalue % gap : max { abs ( Lambda_N - 1) , abs ( Lambda_2 - 1) } %------------------------------------------N = length ( A ) ; % calculate indegree and out degree indegree = []; outdegree = []; indegree_D = []; outdegree_D = []; for i = 1: N outdegree (i ,1) = sum ( A (i ,:) ) ; indegree (i ,1) = sum ( A (: , i ) ) ; if outdegree (i ,1) == 0 outdegree_D (i ,1) = 0; else outdegree_D (i ,1) = outdegree (i ,1) ^( -0.5) ; end if indegree (i ,1) == 0 indegree_D (i ,1) = 0; else indegree_D (i ,1) = indegree (i ,1) ^( -0.5) ; end end % generate D matrix with diagonal elements as degree inD = diag ( indegree_D ) ; outD = diag ( outdegree_D ) ; I = eye ( N ) ; inL = I - inD * A * inD ; outL = I - outD * A * outD ; [ inV , inLambda ] = eig ( inL ) ; [ outV , outLambda ] = eig ( outL ) ; inLambda = sort ( diag ( inLambda ) ) ; outLambda = sort ( diag ( outLambda ) ) ; inLambda_N = inLambda ( N ) ; inLambda_2 = inLambda (2) ; outLambda_N = outLambda ( N ) ; outLambda_2 = outLambda (2) ;

105

2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193

inGap = max ( abs ( inLambda ( N ) -1) , abs ( inLambda (2) -1) ) ; outGap = max ( abs ( outLambda ( N ) -1) , abs ( outLambda (2) -1) ) ;

% calculate dominent eigenvalue and eigenvector by powermethod function [ Lambda , V , count ] = FUN powermet hod (A , itermax , errmax ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - % Lambda : dominant eigenvalue % V : dominant eigenvector % count : for test %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % Lambda : dominant eigenvalue % Evector : dominant eigenvector %------------------------------------------% itermax =10; % errmax = 0.001; % A =[1 ,2 ,3;4 ,1 ,3;0 ,3 ,4]; N = size (A , 1) ; Lambda = 0 ; V = ones (N , 1) ; % calculator dominant eigenvector V for num = 1 : itermax Lambdaold = Lambda ; V = A * V ; [ Lambda , i ] = max ( abs ( V ) ) ; V = V ./ norm ( V ) ; % normlize errtemp = abs (( Lambda - Lambdaold ) / Lambda ) ; % calculate the error if ( errtemp < errmax ) break ; end end P = A*V; Lambda =0; count =0; % for i = 1: N % if V ( i ) ~= 0 % Lambda = Lambda + abs ( P ( i ) / V ( i ) ) ; % count = count +1; % end % % end % Lambda = Lambda / count ; for i = 1: N if V ( i ) ~= 0 Lambda = abs ( P ( i ) / V ( i ) ) ; break ;

106

2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244

end end

% alculate adjency matrix of GEOP and changing by time T by different % algorithm , save edges into file and data into database function [] = GEOP_dbinsert (N , T , a , b , Seq , dimensionS , dimensionE , flag , modelT0 , h ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % N : Order of Graph % T : time T for GT % a , b : parameters of GEOP model % Seq : sequence num of samples with same parameters (N ,a ,b , dim , T ) % dimensionS : dimension start num for loop % dimensionE : dimension end num for loop % flag : model type % 1: GEOP % 2: Age % 3: Degree by changing N % 4: Degree by fix N % 5: Age Inverse % 6: Degree fix N by Radom Ranking & Tension Parameter % 7: GEOP - Tension Parameter % 8: GEOP - Pr ( radius ) % 9: GEOP - Pr ( distance & radius ) % 10: GEOP - Pr ( distance & radius Pr ( distance ) + Pr ( radius ) ) % modelT0 : the model to determine edges at time 0 % 1: geop model % 2: GNP model % h : Tension Parameter , can input 0 if do not need this parameter %------------------------------------------format short e % N = 7115; % T = 1; % a = 0.7; % b = 0.15; % Seq = 1; tbl = ' geopsample_links '; Col = { ' userid ' , ' friendid ' , ' userlabel ' , ' friendlabel ' , ' seq ' , ' dim ' , 'N ' , ' a ' , 'b ' , 'T ' };

for i = dimensionS : dimensionE DA = []; A =[]; AT =[];

% dimension

107

2245 2246 2247 2248 2249 2250 2251 2252 2253

if flag ==3 [ AT ,G , degree ]= FUNgeoPDeg (a ,b ,i , T ) ; N = T +1; else [A , AT , degree ]= FUNgeoP (a ,b ,N ,i ,T , flag , modelT0 , h ) ; end display ( ' FUNgeoP done ') ; Del = sprintf ( ' delete from g e o p s a m p l e _ l i n k s where seq = % d and dim = % d and N = % d and a = % d and b = % d and T =% d ' , Seq , i , N , a , b, T); Data = zeros ( N ^2 ,10) ; Edge = zeros ( N ^2 ,2) ; count = 1; for m = 1: N for n = 1: N if AT (m , n ) == 1 Data ( count ,:) = [m ,n ,m ,n , Seq ,i ,N ,a ,b , T ]; Edge ( count ,:) = [m , n ]; count = count +1; end end % display ([ ' m = ' num2str ( m ) ]) ; end Data = Data (1: count -1 ,:) ; Edge = Edge (1: count -1 ,:) ; display ( ' DataEdge done ') ; FileName = [ ' GEOP_dbinsert_ ' num2str ( N ) '_ ' num2str ( T ) '_ ' num2str ( Seq ) '_ ' num2str (100* a ) '_ ' num2str (100* b ) '_ ' num2str ( i ) '. txt ']; [ Flag ] = FUNfileA ( Edge , FileName , ' int ') ; StrDis = sprintf ( '% d th dimension edge data is saved to file ' , i ) ; display ( StrDis ) ; FileNameTB = [ ' GEOP_dbinsert_ ' num2str ( N ) '_ ' num2str ( T ) '_ ' num2str ( Seq ) '_ ' num2str (100* a ) '_ ' num2str (100* b ) '_ ' num2str ( i ) ' _tbl . txt ']; [ Flag ] = FUNfileA ( Data , FileNameTB , ' int ') ; StrDis = sprintf ( '% d th dimension edge data is saved to table file ', i); display ( StrDis ) ;

2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270

2271 2272 2273 2274 2275

2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289

%[ Flag ] = FUNdbInsert ( ' OSN ' , ' root ' , ' mysql_root ' , tbl , Col , Data , Del ) ; % StrDis = sprintf ( '% d th dimension is inserted to db ' , i ) ; % display ( StrDis ) ; end

% calculate and save degree distribution list to file function [] = G EO P_ D eg Di st _ db (N , T , a , b , Seq , dimensionS , dimensionE )

108

2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331

% - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % N : Order of Graph % T : time T for GT % a , b : parameters of GEOP model % Seq : sequence num of samples with same parameters (N ,a ,b , dim , T ) % dimensionS : dimension start num for loop % dimensionE : dimension end num for loop %------------------------------------------dbo = 'OSN '; account = ' root '; pswd = ' mysql_root '; % % % % % % % Seq = 1; T = 0; N = 1000; a = 0.7; b = 0.15; DimensionS = 6; DimensionE = 6;

Data = []; DataA = []; Degree = [];

OS = isunix ; % connect to specified database , specifying username and password if OS == 1 % unix operation system connection = database ( dbo , account , pswd , ' com . mysql . jdbc . Driver ' , ' jdbc : mysql : / / 1 2 7 . 0 . 0 . 1 : 3 3 0 6 / OSN ') ; else % windows operation system connection = database ( dbo , account , pswd ) ; end % generate GEOP matrix and calculate degree for every node of GEOP for i = dimensionS : dimensionE % dimension DegDist = []; Str = sprintf ( ' select degree , dist from geopdegdist where seq =% d and N = % d and dim =% d and a = % d and b = % d and T =% d ' , Seq ,N , i ,a ,b , T ) ; cursor = exec ( connection , Str ) ; % set the reture data format as int / numeric setdbprefs ( ' DataReturnFormat ' , ' numeric ') ; % retrieve indegree distribution cursor = fetch ( cursor ) ; DegDist (: ,1) = cursor . data (: ,1) ;

2332 2333 2334 2335 2336 2337 2338 2339

109

2340 2341 2342

DegDist (: ,2) = cursor . data (: ,2) ; FileName = [ ' GEOP_DegDist_ ' , num2str ( N ) '_ ' num2str ( T ) '_ ' num2str ( Seq ) '_ ' num2str ( a *100) '_ ' num2str ( b *100) '_ ' num2str ( i ) '. txt ']; [ Flag ] = FUNfileA ( DegDist , FileName , ' int ') ; end

2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387

% read degree distribution file and plot different dim in one graph function [ LegendStr , TitleStr ] = G E O P _ D e g D i s t _ p l o t (N , T , a , b , Seq , dimensionS , dimensionE , FilePath , Flag ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % N : Order of Graph % T : time T for GT % a , b : parameters of GEOP model % Seq : sequence num of samples with same parameters (N ,a ,b , dim , T ) % dimensionS : dimension start num for loop % dimensionE : dimension end num for loop % FilePath : the degree distribution list file path , if it is null then take % the default value % flag : model type % 1: GEOP % 2: Age % 3: Degree by changing N % 4: Degree by fix N % 5: Age Inverse % 6: Degree fix N by Radom Ranking & Tension Parameter % 7: GEOP - Tension Parameter % 8: GEOP - Pr ( radius ) % 9: GEOP - Pr ( distance & radius ) % 10: GEOP - Pr ( distance & radius Pr ( distance ) + Pr ( radius ) ) %------------------------------------------% % % % % % N =1000; T =0; a = 0.7; b = 0.15; DimensionS =1; DimensionE =6;

hold on ; % Open GEOP_DegDist_ %. txt file to plot degree distribution if isempty ( FilePath ) FilePath = 'C :\ Amanda \ Ryerson \ thesis \ mfile \ main \ output \ GEOP_DegDist \ '; end

110

2388 2389 2390

2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430

% open different dimension file and read the data into vectors for i = dimensionS : dimensionE FileName = [ ' GEOP_DegDist_ ' num2str ( N ) '_ ' num2str ( T ) '_ ' num2str ( Seq ) '_ ' num2str ( a *100) '_ ' num2str ( b *100) '_ ' num2str ( i ) '. txt ']; File = [ FilePath FileName ]; fid = fopen ( File , 'r ') ; if fid == -1 display ([ ' Error opening the ' File ]) ; end Num =0; s = sprintf ( ' DegDist % d =[]; ' , i ) ; eval ( s ) ; s = sprintf ( ' DegDist % d ( Num ,:) = Line ' '; ' , i ) ; while feof ( fid ) == false Num = Num +1; Line = fgetl ( fid ) ; Line = sscanf ( Line , ' % f % f ') ; eval ( s ) ; end end

% plot degree distribution for every dimension % y : yellow , m : pink , c : light blue , r : red , g : green , b : blue , k : black Color =[ ' m ' , 'r ' , 'k ' , 'b ' , 'g ' , 'y ' , 'c ']; Line = { ' - ' , '--', ': ' , ' -. ' , ' -+ ' , ' -h '}; LegendStr = [ ' ']; for i = dimensionS : dimensionE Linestyle = Line { i }; Str = [ ' plot ( log ( DegDist % d (: ,1) ) , log ( DegDist % d (: ,2) ) , ', ' ' ' ' , Linestyle , Color ( i ) , ' ' ') ']; s = sprintf ( Str ,i , i ) ; eval ( s ) ; xlabel ( ' log ( Degree ) ') ; ylabel ( ' log ( Degree Distribution ) ') ; LegendStr = [ LegendStr ','' GEO - P ' num2str ( i ) ' dimension ' ' ']; end % list models to display on graphs Model = { ' GEO -P ' , ' GEO - P ( Age ) ',' GEO - P ( Deg ) ',' GEO - P ( GnpDeg ) ',' GEO - P ( Ten ) ',' GEO - P ( DegRdmRk ) '}; LegendStr = substring ( LegendStr , 1 , length ( LegendStr ) -1) ; LegendStr = [ ' legend ( ' , LegendStr , ') ']; eval ( LegendStr ) ; TitleStr = [ ' model : ' Model { Flag } ' Seq : ' num2str ( Seq ) ' N:' num2str ( N ) ' T : ' num2str ( T ) ' a : ' num2str ( a ) ' b : ' num2str ( b ) ' p :1 ']; title ( TitleStr ) ;

2431 2432

111

2433

2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465

fileNM = [ ' GEOP_DegDist_ ' num2str ( N ) '_ ' num2str ( T ) '_ ' num2str ( Seq ) ' _ ' num2str ( a *100) '_ ' num2str ( b *100) '_ ' num2str ( dimensionS ) '_ ' num2str ( dimensionE ) ]; saveas ( gcf , fileNM ) ;

% alculate spectral gap of GEOP and compare with GNP ( random graph ) function [] = GEOP_gap_db (N , T , a , b , Seq , dimensionS , dimensionE , flag ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % N : Order of Graph % T : time T for GT % a , b : parameters of GEOP model % Seq : sequence num of samples with same parameters (N ,a ,b , dim , T ) % dimensionS : dimension start num for loop % dimensionE : dimension end num for loop % flag : compare with GNP ? % 0: no % 1: yes %------------------------------------------% Seq = 1; % N = 7115; % T = 0; % a = 0.7; % b = 0.15; DataA = []; Data = []; for i = dimensionS : dimensionE % dimension A = []; DA = []; sql1 = sprintf ( ' select u , outdegree , indegree from geopsample where seq = % d and N = % d and dim = % d and a = % d and b = % d and T =% d order by userlabel ' , Seq ,N ,i ,a ,b , T ) ; sql2 = sprintf ( ' select userlabel , friendlabel from g e o p s a m p l e _ l i n k s where seq = % d and N = % d and dim = % d and a = % d and b = % d and T =% d order by userlabel ' , Seq ,N ,i ,a ,b , T ) ; sql ={ sql1 ; sql2 }; [K , A ] = FUNdbA ( ' OSN ' , ' root ' , ' mysql_root ' , ' geopsample ' , '1 ' , sql ) ; N = length ( A ) ; % calculate 1 st largest eigenvalue [ Lambda , Evector ]= FUNpowe rmethod (A ,20 ,0.001) ; % calculate 2 nd largest eigenvalue A1 =A - Lambda * Evector * Evector '; [ Lambda2 , Evector2 ]= FUN powermet hod ( A1 ,20 ,0.001) ; Gap = Lambda - Lambda2 ;

2466

2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478

112

2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526

D = { ' GEOP ' , num2str ( N ) , num2str ( Seq ) , num2str ( i ) , num2str ( Lambda ) , num2str ( Lambda2 ) , num2str ( Gap ) }; Data = [ Data ; D ]; DA = [0 ,N , Seq ,i , Lambda , Lambda2 , Gap ]; DataA = [ DataA ; DA ];

end % GNP if flag ==1 [ G ]= FUNgnp (N ,1/2) ; [ GNPLambda , GNPEvector ]= FUNp owermeth od (G ,200 ,0.001) ; % calculate 2 nd largest eigenvalue G1 =G - GNPLambda * GNPEvector * GNPEvector '; [ GNPLambda2 , GNPEvector2 ]= F UNpowerm ethod ( G1 ,200 ,0.001) ; GNPGap = GNPLambda - GNPLambda2 ; GNPD = { ' GNP ' , num2str ( N ) , '1 ' , '1 ' , num2str ( GNPLambda ) , num2str ( GNPLambda2 ) , num2str ( GNPGap ) }; Data = [ Data ; GNPD ]; DataA = [ DataA ;1 ,N ,1 ,1 , GNPLambda , GNPLambda2 , GNPGap ]; end filename = [ ' GEOP_gap_ ' num2str ( N ) '_ ' num2str ( T ) '_ ' num2str ( Seq ) '_ ' num2str (100* a ) '_ ' num2str (100* b ) ]; filenametxt = [ filename '. txt ']; [ Flag ] = FUNfileA ( DataA , filenametxt , 'dec ') ;

f = figure ( ' Position ' ,[10 10 700 700]) ; cnames = { ' model ' , ' nodes ' , ' Seq ' , 'm - dimension ' , ' Lambda_1 ' , ' Lambda_2 ' , ' Gap ' ,}; t = uitable ( ' Data ' , Data , ' ColumnName ' , cnames , ' parent ' ,f , ' Position ' ,[1 1 700 700]) ; saveas ( gcf , filename ) ; % plot the graph simulate by GEO - P model function [G , AT ] = GEOP_sim (N ,m ,a ,b , File , WF , circle , edge ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % N : Order of Graph % m : dimension % a , b : GEOP model parameters % File : file name of vertices information , format is same to G % Wf : if write the G to file % 1: yes % 0: no % circle : which vertices will be plot influence region

113

2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578

% edge : if plot edges between vertices % 1: yes % 0: no %------------------------------------------% - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - % G : cordinators of random nodes . % G (i ,1: m ) : cordinators % G (i , m +1) : rank % G (i , m +2) : influcial area % G (i , m +3) : time T of birth % G (i , m +4) : degree at time T % G (i , m +5) : rank at time T -1 % G (i , m +6) : if node ' s influcial area need to be re - evaluated % 1: yes , rank changed , need to be evaluated % 0: no , no changes of rank , not need to be evalueated %------------------------------------------if isempty ( File ) [ G ] = FUNgeo (N ,a ,b , m ) ; else fid = fopen ( File , 'r ') ; if fid == -1 display ([ ' Error opening the ' File ]) ; end row =0; G = zeros (N , m +6) ; while feof ( fid ) == false row = row +1; Line = fgetl ( fid ) ; Line = sscanf ( Line , ' % f % f % f % f % f % f % f % f ') ; G ( row ,:) = Line ; end end [ u ] = FUNgeoU ( m ) ; A = zeros (N , N ) ; [ AT , GT ] = FUNgeoedge (G ,u ,m ,A ,1 ,0) ; if m == 2 Cn = pi ; else if mod (m ,2) ==1 % odd n = ( m +1) /2; Cn = (2^(( m +1) /2) ) *( pi ^(( m -1) /2) ) /(( factorial (2* n ) ) /( factorial ( n ) *2^ n ) ) ; else % even Cn = ( pi ^( m /2) ) /( factorial ( m /2) ) ; end end hold on ; axis ([0 1 0 1]) ; axis square ; seta =0:0.001:2* pi ;

114

2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630

Data = zeros (N , m +3) ; for i = 1: N plot ( G (i ,1) ,G (i ,2) , '.r ' , ' Markersize ' ,15) ; rank = G (i , m +1) ; text ( G (i ,1) ,G (i ,2) -0.03 , num2str ( rank ) ,' FontSize ' ,8) ; end % plot circle for i = 1: length ( circle ) v = circle ( i ) ; % calculate max and min influcial radius of two nodes I = G ( G (: , m +1) == v , m +2) ; r = ( I / Cn ) ^(1/ m ) ; % give smaller radius for plot effections only % if v ==7 % r = 0.19; % elseif v ==16 % r =0.13; % end x = G ( G (: , m +1) == v ,1) + r * cos ( seta ) ; y = G ( G (: , m +1) == v ,2) + r * sin ( seta ) ; plot (x , y ) ; end if edge == 1 for i = 1: N for j = i +1: N if AT (i , j ) == 1 irank = G (i , m +1) ; jrank = G (j , m +1) ; plot ([ G (i ,1) G (j ,1) ] ,[ G (i ,2) G (j ,2) ]) ; end end end end

hold off ; if WF == 1 FileName = [ ' GEOP_sim_ ' num2str ( N ) '_ ' num2str ( m ) '_ ' num2str (100* a ) '_ ' num2str (100* b ) '. txt ']; [ Flag ] = FUNfileA (G , FileName , ' dec ') ; end

% generate G (n , p ) edges file function [] = GNP_edge (N , P ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - -

115

2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683

%------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % N : Order of Graph % P : probability of edeges %------------------------------------------[A , GT ]= FUNgnp (N ,P ,0 ,0 ,0 ,0) ; Data = zeros (N ,2) ; count = 0; for i =1: N for j = i +1: N if A (i , j ) ==1 count = count + 1; A (i , j ) =1; Data ( count ,1) = i ; Data ( count ,2) = j ; end end end FileName = [ ' GNP_ ' num2str ( N ) '_ ' num2str ( P *100) ' _edge . txt ']; [ Flag ] = FUNfileA ( Data , FileName , ' int ') ;

% generate G (n , p ) model and calculate the spetural gap function [] = Gnp_gap (N , P ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % N : Order of Graph % P : probability of edeges %------------------------------------------[A , GT ]= FUNgnp (N ,P ,0 ,0 ,0 ,0) ; [ Lambda , Evector ]= FUNpowe rmethod (A ,200 ,0.00001) ; % calculate 2 nd largest eigenvalue A1 =A - Lambda * Evector * Evector '; [ Lambda2 , Evector2 ]= FUNp owermet hod ( A1 ,200 ,0.00001) ; %[ Lambda , Lambda2 , Evector ] = eigen ( G ) ; Gap = Lambda - Lambda2 ; Data = [ Lambda , Lambda2 , Gap ]; FileName = [ ' GNP_ ' num2str ( N ) '_ ' num2str ( P *100) '. txt ']; [ Flag ] = FUNfileA ( Data , FileName , ' dec ') ;

116

2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732

% calculate spectral gap for wiki , and verify if it satisfy gen graph function [] = wiki_gap_gen () % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - %------------------------------------------Data = []; [K , A ] = FUNdbA ( ' OSN ' , ' root ' , ' mysql_root ' , ' wikisample ' , '0 ' ,[]) ; N = length ( A ) ; % calculate dominent eigenvector by power method [ Lambda , Evector ]= FUNpowe rmethod (A ,50 ,0.000001) ; % calculate 2 nd largest eigenvalue A1 =A - Lambda * Evector * Evector '; [ Lambda2 , Evector2 ]= FUNp owermet hod ( A1 ,51 ,0.00001) ; %[ Lambda , Lambda2 , Evector ] = eigen ( A ) ; % plot and save gap Gap = Lambda - Lambda2 ; Data = { ' wiki ' , '0 ' , num2str ( N ) , num2str ( Lambda ) , num2str ( Lambda2 ) , num2str ( Gap ) }; % GNP [ G ]= FUNgnp (N ,1/2) ; [ GNPLambda , GNPEvector ]= FUNpo wermeth od (G ,200 ,0.001) ; % calculate 2 nd largest eigenvalue G1 =G - GNPLambda * GNPEvector * GNPEvector '; [ GNPLambda2 , GNPEvector2 ]= F UNpowerm ethod ( G1 ,200 ,0.001) ; GNPGap = GNPLambda - GNPLambda2 ; GNPD = { ' GNP ' , '0 ' , num2str ( N ) , num2str ( GNPLambda ) , num2str ( GNPLambda2 ) , num2str ( GNPGap ) }; Data = [ Data ; GNPD ];

f = figure ( ' Position ' ,[10 10 500 700]) ; cnames = { ' networkname ' , ' Sample # ' , ' Sample Size ' , ' Lambda_1 ' , ' Lambda_2 ' , ' Gap ' ,}; t = uitable ( ' Data ' , Data , ' ColumnName ' , cnames , ' parent ' ,f , ' Position ' ,[1 1 500 700]) ; filename = [ ' wiki_gap_vs_GNP ']; saveas ( gcf , filename ) ; close all ; % verify if it is a gen [ LogA , SCodd ] = FUNgen ( Lambda , Evector ) ;

117

2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781

fileNM = [ ' wiki_gen ']; saveas ( gcf , fileNM ) ;

% calculate and plot wiki degree distribution and compare with GEOP function [] = w i k i _ v s _ G E O P _ D e g D i s t (N , T , a , b , Seq , CompFlag , dimensionS , dimensionE , FilePath ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % N : Order of Graph % T : time T for GT % a , b : parameters of GEOP model % Seq : sequence num of samples with same parameters (N ,a ,b , dim , T ) % CompFlag : if compare with GEOP model degdist % 1: yes % 0: no % dimensionS : dimension start num for loop % dimensionE : dimension end num for loop % FilePath : the degree distribution list file path , if it is null then take % the default value %------------------------------------------%//////////////////////////////////////////////////////////////////// % connect to specified database , specifying username and password connection = database ( ' OSN ' , ' root ' , ' mysql_root ') ; % found how many users are there in samples Str1 = [ ' select degree , dist from wiki_degdist where seq =0 and flag = ''in ' ' ' ]; cursor1 = exec ( connection , Str1 ) ; % set the reture data format as int / numeric setdbprefs ( ' DataReturnFormat ' , ' numeric ') ; % retrieve indegree distribution cursor1 = fetch ( cursor1 ) ; InDegree = cursor1 . data (: ,1) ; InDist = cursor1 . data (: ,2) ; Str2 = [ ' select degree , dist from wiki_degdist where seq =0 and flag = '' out ' ' ' ]; cursor2 = exec ( connection , Str2 ) ; % set the reture data format as int / numeric setdbprefs ( ' DataReturnFormat ' , ' numeric ') ; % retrieve outdegree distribution

118

2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804

cursor2 = fetch ( cursor2 ) ; OutDegree = cursor2 . data (: ,1) ; OutDist = cursor2 . data (: ,2) ; Str3 = [ ' select degree , dist from wiki_degdist where seq =0 and flag = '' all ' ' ' ]; cursor3 = exec ( connection , Str3 ) ; % set the reture data format as int / numeric setdbprefs ( ' DataReturnFormat ' , ' numeric ') ; % retrieve all degree distribution cursor3 = fetch ( cursor3 ) ; AllDegree = cursor3 . data (: ,1) ; AllDist = cursor3 . data (: ,2) ; hold on ; % plot ( log ( InDegree ) , log ( InDist ) , ': ' , log ( OutDegree ) , log ( OutDist ) , '-', log ( AllDegree ) , log ( AllDist ) , ' -. ') ; plot ( log ( InDegree ) , log ( InDist ) , ': ' , log ( OutDegree ) , log ( OutDist ) , ' - ') ; if CompFlag == 1 [ LStr , TStr ]= G E O P _ D e g D i s t _ p l o t (N , T , a , b , Seq , dimensionS , dimensionE , FilePath ) ; LegendStr = [ substring ( LStr ,0 ,6) ,''' wiki indegree ' ' , ' ' wiki outdegree ' ' , ' ' wiki alldegree ' ' , ' , substring ( LStr ,7 , length ( LStr ) -1) ]; eval ( LegendStr ) ; titleStr = [ ' wiki vs ', TStr ]; fileNM = [ ' wiki_vs_GEOP_DegDist_ ' num2str ( N ) '_ ' num2str ( T ) '_ ' num2str ( Seq ) '_ ' num2str ( a *100) '_ ' num2str ( b *100) '_ ' num2str ( dimensionS ) '_ ' num2str ( dimensionE ) ]; else legend ( ' wiki indegree ' , ' wiki outdegree ' , ' wiki all degree ') ; titleStr = [ ' wiki log - log plot ']; fileNM = [ ' wiki - degdist ' ]; end title ( titleStr ) ; hold off ; saveas ( gcf , fileNM ) ; % calculate and plot wiki degree distribution and compare with GEOP function [] = w i k i _ v s _ G E O P _ D e g D i s t (N , T , a , b , Seq , CompFlag , dimensionS , dimensionE , FilePath ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - -

2805 2806 2807

2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825

119

2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874

% % % % % % % % % %

N : Order of Graph T : time T for GT a , b : parameters of GEOP model Seq : sequence num of samples with same parameters (N ,a ,b , dim , T ) CompFlag : if compare with GEOP model degdist 1: yes 0: no dimensionS : dimension start num for loop dimensionE : dimension end num for loop FilePath : the degree distribution list file path , if it is null then take % the default value %------------------------------------------%//////////////////////////////////////////////////////////////////// % connect to specified database , specifying username and password connection = database ( ' OSN ' , ' root ' , ' mysql_root ') ; % found how many users are there in samples Str1 = [ ' select degree , dist from wiki_degdist where seq =0 and flag = ''in ' ' ' ]; cursor1 = exec ( connection , Str1 ) ; % set the reture data format as int / numeric setdbprefs ( ' DataReturnFormat ' , ' numeric ') ; % retrieve indegree distribution cursor1 = fetch ( cursor1 ) ; InDegree = cursor1 . data (: ,1) ; InDist = cursor1 . data (: ,2) ; Str2 = [ ' select degree , dist from wiki_degdist where seq =0 and flag = '' out ' ' ' ]; cursor2 = exec ( connection , Str2 ) ; % set the reture data format as int / numeric setdbprefs ( ' DataReturnFormat ' , ' numeric ') ; % retrieve outdegree distribution cursor2 = fetch ( cursor2 ) ; OutDegree = cursor2 . data (: ,1) ; OutDist = cursor2 . data (: ,2) ; Str3 = [ ' select degree , dist from wiki_degdist where seq =0 and flag = '' all ' ' ' ]; cursor3 = exec ( connection , Str3 ) ; % set the reture data format as int / numeric setdbprefs ( ' DataReturnFormat ' , ' numeric ') ; % retrieve all degree distribution

120

2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886

cursor3 = fetch ( cursor3 ) ; AllDegree = cursor3 . data (: ,1) ; AllDist = cursor3 . data (: ,2) ; hold on ; % plot ( log ( InDegree ) , log ( InDist ) , ': ' , log ( OutDegree ) , log ( OutDist ) , '-', log ( AllDegree ) , log ( AllDist ) , ' -. ') ; plot ( log ( InDegree ) , log ( InDist ) , ': ' , log ( OutDegree ) , log ( OutDist ) , ' - ') ; if CompFlag == 1 [ LStr , TStr ]= G E O P _ D e g D i s t _ p l o t (N , T , a , b , Seq , dimensionS , dimensionE , FilePath ) ; LegendStr = [ substring ( LStr ,0 ,6) ,''' wiki indegree ' ' , ' ' wiki outdegree ' ' , ' ' wiki alldegree ' ' , ' , substring ( LStr ,7 , length ( LStr ) -1) ]; eval ( LegendStr ) ; titleStr = [ ' wiki vs ', TStr ]; fileNM = [ ' wiki_vs_GEOP_DegDist_ ' num2str ( N ) '_ ' num2str ( T ) '_ ' num2str ( Seq ) '_ ' num2str ( a *100) '_ ' num2str ( b *100) '_ ' num2str ( dimensionS ) '_ ' num2str ( dimensionE ) ]; else legend ( ' wiki indegree ' , ' wiki outdegree ' , ' wiki all degree ') ; titleStr = [ ' wiki log - log plot ']; fileNM = [ ' wiki - degdist ' ]; end title ( titleStr ) ; hold off ; saveas ( gcf , fileNM ) ;

2887 2888 2889

2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920

% calculate wiki NL gap vs GEOP NL gap function [] = w ik i_ v s_ ge op _ NL (N , T , a , b , Seq , dimensionS , dimensionE ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % N : Order of Graph % T : time T for GT % a , b : parameters of GEOP model % Seq : sequence num of samples with same parameters (N ,a ,b , dim , T ) % dimensionS : dimension start num for loop % dimensionE : dimension end num for loop %-------------------------------------------

Data = []; Datatxt = [];

121

2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946

Start = 1; End = 1; sampleStr = ' wikisample '; % % % % % % % initial GEOP parameters T = 0; a = 0.7; b = 0.15; Seq = 1; dimensionS = 1; dimensionE = 4;

geopN = N ; % check OS OS = isunix ; sql = {}; for i = Start : End % generate wiki adjency matrix [K ,A ,u , outdegree , indegree , P ] = FUNdbA ( ' OSN ' , ' root ' , ' mysql_root ' , sampleStr , '0 ' , sql ) ; wikiN = length ( A ) ; [ inL , outL , indegree , outdegree , inLambda_N , inLambda_2 , outLambda_N , outLambda_2 , inGap , outGap ] = FUNLPgap ( A ) ; D = { sampleStr , num2str ( wikiN ) , num2str ( i ) , num2str ( inLambda_N ) , num2str ( inLambda_2 ) , num2str ( inGap ) , num2str ( outLambda_N ) , num2str ( outLambda_2 ) , num2str ( outGap ) }; Data = [ Data ; D ]; Datatxt = [ Datatxt ;0 , wikiN ,i , inLambda_N , inLambda_2 , inGap , outLambda_N , outLambda_2 , outGap ]; display ( ' wiki is done ') ; % calculate geop LP gap for j = dimensionS : dimensionE % dimension GEOPsql1 = sprintf ( ' select u , outdegree , indegree from geopsample where seq = % d and N = % d and dim = % d and a = % d and b = % d and T =% d order by userlabel ' , Seq , geopN ,j ,a ,b ,T); GEOPsql2 = sprintf ( ' select userlabel , friendlabel from g e o p s a m p l e _ l i n k s where seq = % d and N = % d and dim = % d and a = % d and b = % d and T =% d order by userlabel ' , Seq , geopN ,j ,a ,b , T ) ; GEOPsql ={ GEOPsql1 ; GEOPsql2 }; % generate GEOP matrix according to N , a , b , dim , seq [ K1 , G ] = FUNdbA ( ' OSN ' , ' root ' , ' mysql_root ' , ' geopsample ' , '1 ' , GEOPsql ) ; [ inL , outL , indegree , outdegree , inLambda_N , inLambda_2 , outLambda_N , outLambda_2 , inGap , outGap ] = FUNLPgap ( G ) ;

2947 2948 2949 2950 2951 2952 2953 2954

2955

2956 2957 2958 2959 2960

122

2961

2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972

GEOPD = { ' GEOP ' , num2str ( geopN ) , num2str ( j ) , num2str ( inLambda_N ) , num2str ( inLambda_2 ) , num2str ( inGap ) , num2str ( outLambda_N ) , num2str ( outLambda_2 ) , num2str ( outGap ) }; Data = [ Data ; GEOPD ]; Datatxt = [ Datatxt ;1 , geopN ,j , inLambda_N , inLambda_2 , inGap , outLambda_N , outLambda_2 , outGap ]; str = sprintf ( '% dth GEOP is done ' , j ) ; display ( str ) ; end end filename = [ sampleStr ' _vs_GEOP_NL_gap_ ' num2str ( geopN ) '_ ' num2str ( T ) '_ ' num2str ( Seq ) '_ ' num2str (100* a ) '_ ' num2str (100* b ) '_ ' num2str ( dimensionS ) '_ ' num2str ( dimensionE ) ]; filenametxt = [ filename '. txt ']; [ Flag ] = FUNfileA ( Datatxt , filenametxt ) ; if OS == 0 % windows ( not unix ) f = figure ( ' Position ' ,[10 10 700 700]) ; cnames = { ' networkname ' , ' Sample Size ' , ' Sample #/ dimension ' , ' inLambda_N ' , ' inLambda_2 ' , ' inGap ' , ' outLambda_N ' , ' outLambda_2 ' , ' outGap '}; t = uitable ( ' Data ' , Data , ' ColumnName ' , cnames , ' parent ' ,f , ' Position ' ,[1 1 500 700]) ; saveas ( gcf , filename ) ; end

2973 2974 2975 2976 2977 2978

2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004

% calculate and plot youtube degree distribution function [] = y ou tu b e_ De gD i st ( flag ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % frag : plot type % 0. 1 + 2 % 1. degree distribution % 2. log - log %------------------------------------------% connect to specified database , specifying username and password connection = database ( ' OSN ' , ' amandatian ' , '1 z3456 ') ; % open cursor and issue SQL statement to select data cursor = exec ( connection , ' select degree , dist from y o u t u b e d e g r e e _ d i s t order by degree ') ; % set the reture data format as int / numeric setdbprefs ( ' DataReturnFormat ' , ' numeric ') ;

123

3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056

% retrieve R rows of data cursor = fetch ( cursor ) ; Data = cursor . data ; Degree = Data (: ,1) ; Dist = Data (: ,2) ; % plot if flag == 0 subplot (1 ,2 ,1) ; plot ( Degree , Dist ) ; xlabel ( 'k ') ; ylabel ( ' N ( k ) ') ; title ( ' Youtube - Degree Distribution ') ; subplot (1 ,2 ,2) ; plot ( log ( Degree ) , log ( Dist ) ) ; xlabel ( ' log ( k ) ') ; ylabel ( ' log ( N ( k ) ) ') ; title ( ' Youtube - Degree Distribution log - log plot ') ; elseif flag == 1 plot ( Degree , Dist ) ; xlabel ( 'k ') ; ylabel ( ' N ( k ) ') ; title ( ' Youtube - Degree Distribution ') ; elseif flag == 2 plot ( log ( Degree ) , log ( Dist ) ) ; xlabel ( ' log ( k ) ') ; ylabel ( ' log ( N ( k ) ) ') ; title ( ' Youtube - Degree Distribution log - log plot ') ; end

function [] = y ou tu b e_ ga p_ g en ( Start , End ) % calculate youtube samples spectral gap , and verify if it follows gen % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % Start , End : loop of seq of samples %------------------------------------------Data = []; Datatxt = []; % check OS OS = isunix ; for i = Start : End % generate adjency matrix [K , A ] = FUNdbA ( ' OSN ' , ' root ' , ' mysql_root ' , ' youtubesample ' , num2str ( i ) ,[]) ;

124

3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105

N = length ( A ) ; % calculate dominent eigenvector by power method [ Lambda , Evector , count ]= FUNpower method (A ,50 ,0.001) ; % calculate 2 nd largest eigenvalue A1 =A - Lambda * Evector * Evector '; [ Lambda2 , Evector2 , count2 ]= FUNpowe rmethod ( A1 ,50 ,0.001) ; %[ Lambda , Lambda2 , Evector ] = eigen ( A ) ; Gap = Lambda - Lambda2 ; D = { ' youtubesample ' , num2str ( i ) , num2str ( N ) , num2str ( Lambda ) , num2str ( Lambda2 ) , num2str ( Gap ) }; Data = [ Data ; D ]; Datatxt = [ Datatxt ;0 , i ,N , Lambda , Lambda2 , Gap ]; % GNP [ G ]= FUNgnp (N ,1/2) ; [ GNPLambda , GNPEvector ]= FUNp owermeth od (G ,200 ,0.001) ; % calculate 2 nd largest eigenvalue G1 =G - GNPLambda * GNPEvector * GNPEvector '; [ GNPLambda2 , GNPEvector2 ]= F UNpowerm ethod ( G1 ,200 ,0.001) ; GNPGap = GNPLambda - GNPLambda2 ; GNPD = { ' GNP ' , num2str ( i ) , num2str ( N ) , num2str ( GNPLambda ) , num2str ( GNPLambda2 ) , num2str ( GNPGap ) }; Data = [ Data ; GNPD ]; Datatxt = [ Datatxt ;1 , i ,N , GNPLambda , GNPLambda2 , GNPGap ];

if OS == 0 % windows / not unix operation system % verify if it is a gen [ LogA , SCodd ] = FUNgen ( Lambda , Evector ) ; fileNM = [ ' youtube_gen_ ' num2str ( i ) ]; saveas ( gcf , fileNM ) ; end end filename = [ ' youtube_gap_ ' num2str ( Start ) '_ ' num2str ( End ) ]; filenametxt = [ filename '. txt ']; [ Flag ] = FUNfileA ( Datatxt , filenametxt , ' dec ') ; if OS == 0 % windows ( not unix ) f = figure ( ' Position ' ,[10 10 500 700]) ; cnames = { ' networkname ' , ' Sample # ' , ' Sample Size ' , ' Lambda_1 ' , ' Lambda_2 ' , ' Gap ' ,}; t = uitable ( ' Data ' , Data , ' ColumnName ' , cnames , ' parent ' ,f , ' Position ' ,[1 1 500 700]) ; saveas ( gcf , filename ) ; end

125

3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143

% choose a youtubesampe and calculate NL gap compare with GEOP NL gap function [] = y o u t u b e _ v s _ g e o p _ N L (T , a , b , dimensionS , dimensionE , sampleSeqS , sampleSeqE , flag ) % - - - - - - - - - - - - - - - - - output - - - - - - - - - - - - - - - - - - - %------------------------------------------% - - - - - - - - - - - - - - - - - input - - - - - - - - - - - - - - - - - - - - % T : time T for GT % a , b : parameters of GEOP model % dimensionS : dimension start num for loop % dimensionE : dimension end num for loop % sampleSeqS , sampleSeqE : choose youtube sample seq ( for loop ) % flag : type of algorithm about T % 1: GEOP % 2: Age % 3: degree %------------------------------------------Data = []; Datatxt = []; sampleStr = ' youtubesample '; % % % % % T = 1; a = 0.7; b = 0.15; dimensionS = 1; dimensionE = 4;

% check OS OS = isunix ; sql = {}; for i = sampleSeqS : sampleSeqE % generate adjency matrix [K ,A ,u , outdegree , indegree , P ] = FUNdbA ( ' OSN ' , ' root ' , ' mysql_root ' , sampleStr , num2str ( i ) , sql ) ; N = length ( A ) ; [ inL , outL , indegree , outdegree , inLambda_N , inLambda_2 , outLambda_N , outLambda_2 , inGap , outGap ] = FUNLPgap ( A ) ; D = { sampleStr , num2str ( N ) , num2str ( i ) , num2str ( inLambda_N ) , num2str ( inLambda_2 ) , num2str ( inGap ) , num2str ( outLambda_N ) , num2str ( outLambda_2 ) , num2str ( outGap ) }; Data = [ Data ; D ]; Datatxt = [ Datatxt ;0 , N ,i , inLambda_N , inLambda_2 , inGap , outLambda_N , outLambda_2 , outGap ]; for j = dimensionS : dimensionE G =[]; GT =[]; % dimension

3144 3145 3146 3147 3148 3149 3150 3151 3152

%[ G , GT , degree ] = FUNgeoP (a ,b ,N ,j , T ) ; if flag ==1

126

3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163

[G , GT ] = FUNgeoP (a ,b ,N ,j , T ) ; elseif flag ==2 [G , GT ] = FUNgeoPAge (a ,b ,N ,j , T ) ; elseif flag ==3 display ( ' not defined algorithm for T ') ; else display ( ' not defined algorithm for T ') ; end [ inL , outL , indegree , outdegree , inLambda_N , inLambda_2 , outLambda_N , outLambda_2 , inGap , outGap ] = FUNLPgap ( GT ) ; GEOPD = { ' GEOP ' , num2str ( N ) , num2str ( j ) , num2str ( inLambda_N ) , num2str ( inLambda_2 ) , num2str ( inGap ) , num2str ( outLambda_N ) , num2str ( outLambda_2 ) , num2str ( outGap ) }; Data = [ Data ; GEOPD ]; Datatxt = [ Datatxt ;1 , N ,j , inLambda_N , inLambda_2 , inGap , outLambda_N , outLambda_2 , outGap ]; end end filename = [ sampleStr ' _vs_GEOP_NL_gap_ ' num2str ( N ) '_ ' num2str ( T ) '_ ' num2str (100* a ) '_ ' num2str (100* b ) '_ ' num2str ( dimensionS ) '-' num2str ( dimensionE ) ]; filenametxt = [ filename '. txt ']; [ Flag ] = FUNfileA ( Datatxt , filenametxt ) ; if OS == 0 % windows ( not unix ) f = figure ( ' Position ' ,[10 10 700 700]) ; cnames = { ' networkname ' , ' Sample Size ' , ' Sample #/ dimension ' , ' inLambda_N ' , ' inLambda_2 ' , ' inGap ' , ' outLambda_N ' , ' outLambda_2 ' , ' outGap '}; t = uitable ( ' Data ' , Data , ' ColumnName ' , cnames , ' parent ' ,f , ' Position ' ,[1 1 500 700]) ; saveas ( gcf , filename ) ; end -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -- code to call SNAP methods to calculate diameter -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - # include " stdafx . h " int main ( int argc , char * argv [] ) { // get parameters Env = TEnv ( argc , argv , TNotify :: StdNotify ) ; const TStr InFNm = Env . G e t I f A r g P r e f i x S t r (" - i :" , " graph . txt " , " Input file ") ; const TStr OutFNm = Env . G e t I f A r g P r e f i x S t r (" - o :" , " output . txt " , " Output file ") ; const int MaxNode = Env . G e t I f A r g P r e f i x I n t (" - m :" , 1000000 , " Maximum Node Count ") ;

3164 3165 3166 3167 3168 3169 3170

3171 3172 3173 3174 3175 3176

3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193

127

3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242

// generate graph by input txt file with edge links PNGraph Graph = TSnap :: LoadEdgeList < PNGraph >( InFNm , 0 , 1) ; int A ; int B ; B = Graph - > GetNodes () ; // get diameter of G A = TSnap :: GetB fsFullDi am ( Graph , MaxNode , true ) ; // write diameter to file char s [] = " the diameter of graph is "; char c = '\n '; FILE * stream ; stream = fopen ( OutFNm . GetCStr () , " w " ) ; fprintf ( stream , "% s % c " , s , c ) ; fprintf ( stream , "% d \ n " , A ) ; fprintf ( stream , "% d \ n " , B ) ; fclose ( stream ) ; } -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -- code to call SNAP methods to calculate eigenvalues -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - # include " stdafx . h " int main ( int argc , char * argv []) {

// get parameters Env = TEnv ( argc , argv , TNotify :: StdNotify ) ; const TStr OutFNm = Env . G e t I f A r g P r e f i x S t r (" - o :" , " output . txt " , " Output file ") ; const int Order = Env . G e t I f A r g P r e f i x I n t (" - N :" , 100 , " Graph Order ") ; const int Edge = Env . G e t I f A r g P r e f i x I n t (" - E :" , 1000 , " Graph Edge ") ; // create a graph PNGraph Graph = TSnap :: GenRndGnm < PNGraph >( Order , Edge ) ; // convert to undirected graph TUNGraph PUNGraph UGraph = TSnap :: ConvertGraph < PUNGraph >( Graph ) ;

int Norder ; Norder = UGraph - > GetNodes () ; // calculate eigenvalue , fist two largest and first two smallesa TFltV EigValV ; TVec < TFltV > EigV ;

128

3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257

TSnap :: GetEigVec ( UGraph , 4 , EigValV , EigV ) ; // write data into file FILE * stream ; stream = fopen ( OutFNm . GetCStr () , " w " ) ; fprintf ( stream ," Eigen Values :\ n ") ; for ( int i =0; i < EigValV . Len () ; i ++) { fprintf ( stream , "% d \ t % f \ n " , i , EigValV [ i ]() ) ; } fclose ( stream ) ; }

129

Bibliography
[1] L.A. Adamic, O. Buyukkokten, E. Adar, A social network caught in the Web, First Monday 8 (2003) 440-442. [2] Y. Ahn, S. Han, H. Jeong, H. Kwak, S. Moon, Analysis of topological characteristics of huge on-line social networking services, In: Proceedings of the 16th International Conference on World Wide Web, 2007. [3] A. Bonato, A Course on the Web Graph, American Mathematical Society Graduate Studies Series in Mathematics, Providence, Rhode Island, 2008. [4] R. Babu, Numerical Methods, Dorling Kindersley (India) Pvt. Ltd., 2010. [5] A. BarabÂ´ asi, R. Albert, Emergence of scaling in random networks, Science 286 (1999) 509-512. [6] B. Bhattacharjee, P. Druschel, M. Marcon, A. Mislove, Measurement and analysis of on-line social networks, In: Proceedings of the 7th ACM SIGCOMM Conference on Internet Measurement, 2007. [7] A. Bonato, J. Janssen, P. Pralat, A geometric model for on-line social networks, In: Proceedings of 3rd Workshop on Online Social Networks, 2010. [8] F.R.K. Chung, Spectral Graph Theory, American Mathematical Society 1997. [9] F.R.K. Chung, L. Lu, Complex Graphs and Networks, American Mathematical Society 2004. [10] E. Estrada, Spectral scaling and good expansion properties in complex networks, Europhys. Lett. 73 (2006) 649-655.
131

[11] B. Huberman, S. Golder, D. Wilkinson, Rhythms of social interaction: messaging within a massive on-line network, In: 3rd International Conference on Communities and Technologies, 2007. [12] R. Kumar, J. Novak, A. Tomkins, Structure and evolution of online social networks, In: Proceedings of the 12th ACM SIGKDD international conference on Knowledge discovery and data mining, 2006. [13] D. Liben-Nowel, An algorithmic approach to social networks, Ph.D. Dissertation, Massachusetts Institute of Technology, 2005. [14] List of social networking websites, Wikipedia. Accessed July 1, 2011. http: //en.wikipedia.org/wiki/List_of_social_networking_websites. [15] S. Milgram, The small world problem, Psychology Today 2 (1967) 60-67. [16] Online Social Network Research@The Max Planck Institute for Software Systems. Accessed May 10, 2010. http://socialnetworks.mpi-sws.org/ data-imc2007.html. [17] Press Room, Facebook. Accessed July 1, 2011. http://www.facebook.com/ press/info.php?statistics. [18] Stanford large network dataset collection. Accessed July 5, 2010. http: //snap.stanford.edu/data/index.html. [19] The History of Usenet, Usenet.com. Accessed July 1, 2011. http://www. usenet.com/usenet_history.html. [20] Usenet, Wikipedia. Accessed July 1, 2011. http://en.wikipedia.org/wiki/ Usenet. [21] D. J. Watts, S. H. Strogatz, Collective dynamics of "small-world" networks, Nature 393 (1998) 440-442.

132

