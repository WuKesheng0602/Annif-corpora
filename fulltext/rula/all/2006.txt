NOTE TO USERS

This reproduction is the best copy available.

®

UMI
R e p r o d u c e d with perm issio n of th e copyright ow ner. Further reproduction prohibited without perm ission.

R e p ro d u c e d with p erm ission of the copyright ow ner. Further reproduction prohibited without permission.

HETEROGENEOUS HYPERCUBE ARCHITECTURES FOR FAULT TOLERANT EMBEDDED SYSTEMS

by

Jacob Levman, BASc, Toronto, September 17*' ' 2004

A thesis presented to Ryerson University in partial fulfillment of the requirement for the degree of Master of Applied Science in the program of Electrical and Computer Engineering

Toronto, Ontario, Canada, 2004 © Jacob Levman 2004

Î.V--

If

L ld iiA R Y

R eproduced with perm ission of th e copyright owner. Further reproduction prohibited without permission.

UMI Number: EC52963

INFORMATION TO USERS

The quality of this reproduction is dependent upon the quality of the copy submitted. Broken or indistinct print, colored or poor quality illustrations and photographs, print bleed-through, substandard margins, and improper alignm ent can adversely affect reproduction. In the unlikely event that the author did not send a complete manuscript and there are missing pages, these will be noted. Also, if unauthorized copyright material had to be removed, a note will indicate the deletion.

UMI
UMI Microform EC52963 Copyright 2008 by ProQuest LLC. All rights reserved. This microform edition is protected against unauthorized copying under Title 17, United States Code. ProQuest LLC 789 E. Eisenhower Parkway PO Box 1346 Ann Arbor, Ml 48106-1346

R epro duced with permission of th e copyright owner. Further reproduction prohibited without permission.

R yerson U niversity requires the signatures o f all persons using or photocopying this thesis. Please sign below , and give address and date.

in

R eprod uced with perm ission of th e copyright owner. Further reproduction prohibited without permission.

Hardware Software Co-Synthesis of HetervKu:rieous Hyperciibe Architectures for Fault Tolerant Embedded Systems

Jacob Levm an, M asters o f A pplied Science, 2004. Electrical and C om puter E ngineering. R yerson U niversity

A bstract

The hardware-softw are co-synthesis o j an em bedded sy ste m ' s architecture involves the partitioning o f a system specification into hardware and software modules so as to meet various non-functional requirements. 4 designer can specify many non-functional requirements including cost, performance,

reliability etc. In this thesis, we present an approach to the hardware-sofhvare co-synthesis o f em bedded system s targeting hypercube topologies. Hypercuhe topologies pro vid e a flexible and reliable architecture f o r an em bedded device with multiple processing elements. To the best o f our knowledge, this is the f u s t The co-.synlhesis

time that hypercube topologies have been su pported in a co-synthesis algorithm.

approach presen ted here .supports the follow in g features: I) input in the form o f an acn-'clic perio d ic task graph with real-tim e constraints. 2) the pipelining o f task graphs. 3) the use o f a heterogeneous set o f processing elements. 4) Support f o r fa u lt tolerance through our newly developed group based fau lt tolerance technique. efficacy. The co-synthesis algorithm has been applied to two case studies to dem onstrate its

IV

R e p ro d u c e d with perm ission of th e copyright owner. Further reproduction prohibited without permission.

A ck n o w le d g em e n ts
th e author w ould like to thank his two supervising pro lessors. D r. Gui K han and Dr. .lavad A lirezaic. for providing their guidance, know ledge and support. The author w ould also like to thank the m em bers o f the review com m ittee for their participation. The a u th o r w ould like to thank the N ational Science and E ngineering R esearch C ouncil o f C an ad a (N SE R C ) for providing funding support for th is research project in the form o f m ultiple grants to my supervising professors. T he author w ould like to thank O ntario G raduate Scholarships (O G S ) for funding this research through a scholarship. T he author w ould also like to thank C anadian M icroelectronics C orporation (C M C ) for providing the A R M rapid prototyping platform that w as used in the case studies o f this thesis.

R e p ro du c ed with perm ission of th e copyright owner. Further reproduction prohibited without permission.

Dedication

1 w ould like to dedicate this thesis to m y w ife w hose drive to accom plish is inspiring. W ithout her love and support 1 w ould not be w here 1 am today.

VI

R e p ro d u c e d with perm ission of th e copyright owner. Further reproduction prohibited without permission.

T a b le o f C ontents

!. IN T R O D U C T IO N I . I O verview 1.2 O riginal C ontributions 1.3 T h esis O rganization I

I

3 4

2. D E SIG N O F E M B E D D E D SY ST E M S 2.1 Introduction to Flardw are-Softw are C o-D esign 2.2 H ardw are-S oftw are P artitioning
2.2.1 Standard Approach 2.2.2 Partitioning Granularity 2.2.3 Dynamic Programming 2.2.4 Fault Tolerance

6 6 16
17 18 21 22

2.3 H ardw are-S oftw are C o-S ynthesis 2.4 H ypercube A rchitectures

25 28

3. C O -S Y N T H E S IS FO R H Y PE R C U B E SY ST E M S 3.1 Introduction 3.2 F ault T olerance at the T ask G raph Level
3.2.1 Overview 3.2.2 Task Based Fault Tolerance 3.2.3 Cluster Based Fault Tolerance 3.2.4 Group Based Fault Tolerance 3.2.5 Task Graph Based Fault Tolerance Comparison

33 33 38 38
39

40 44 49 51 57 62

3.3 P ip elin ed Scheduler 3.4 D evice E xpansion 3.5 C o m m u n icatio n Link Integration

4. IM P L E M E N T A T IO N A N D E X P E R IM E N T A L R E SU L T S 4.1 Parallel M PE G -2 D ecoding

68 68

VII

R e p ro d u c e d with perm ission of th e copyright owner. Further reproduction prohibited without permission.

4 .2 I'arallel B lock M a tc h in g

7.^

4.3 D iscussion o f E xperim ental R esults

93

5. CONCLUSIONS AND FUTURE WORK

98

REFERENCES

A ppendix A - Prototype D evice C ode L isting

105

VI I I

R e p ro d u c e d with perm ission of th e copyright owner. Further reproduction prohibited without perm ission.

List o f Tables
I'a b lc 3.1 : F au lt I'olcrance C om parison D ata T a b le 4.1 : P ro cessin g E lem ent U tilization o f D esign Space for 50 M P E G D ecoding 72 86 92

fa b le 4.2; P ro cessin g E lem ent U tilization o f D esign Space for B lock M a tc h in g T a b le 4.3: G en erated M otion V ectors

IX

R e p ro d u c e d with p erm ission of th e copyright ow ner. Further reproduction prohibited without perm ission.

List o f Figures
i-'igure 2.1 : T rad itio n al D esign F igure 2.2: M ardw are-SoFtw are C o -D esig n F igure 2.3: lia rd w a re -S o flw a re C o -S y n th e sis F igure 2.4: A 4 D H ypercube F igure 2.5: E x a m p ,e H y p ercu b e A rc h ite ctu re F ig u re 2.6: E x am p le H ierarchical A rch itectu re F ig u re 3.1 : H y p ercu b e C o -S y n th e sis A lg o rith m F lo w F igure 3.2: T a sk B ased F a u lt T o le ra n c e E xam p le F igure 3.3: C lu ste r B ased Fault T o leran ce --In p u t & 1 Iteration F ig u re 3.4: C lu ste r B ased Fault T o le ra n c e - 2 & 3 Iterations F ig u re 3.5: C lu ste r B ased Fault T o leran ce --F in al C lu sterin g F ig u re 3.6: F inal A dded A ssertio n T asks A fte r C lu ste rin g F ig u re 3.7; G ro u p B ased F ault T o leran ce - In p u t & 1 Iteration F ig u re 3.8: G ro u p B ased F ault T o le ra n c e - 2 & 3 Iteratio n s F ig u re 3.9: G ro u p B ased F a u lt T o le ra n c e - Final G ro u p in g F ig u re 3.10: Final A d d ed A ssertio n T ask s A fte r G ro u p in g F ig u re 3 .11: R a n d o m ly G e n e rate d T ask G rap h (G rap h #1) F ig u re 3 .12: H y p ercu b e C o -S y n th e sis S ch ed u ler F igure 3.13: B in ary N a m in g for H y p ercu b e N o d e s F ig u re 3.14: N o n -S y m m e tric ai 3-D H y p ercu b e F ig u re 4.1: P arallel M P E G D ecoding: F u n ctio n al T a sk G raph F ig u re 4.2: D esign Space E x p lo ratio n o f P arallel M P E G D ecoding 8 10 12 29 32 32 37 40 42 43 43 44 47 47 48 48 51 54 63 66 69 71 73 74 75 77 78 79 80

F ig u re 4.3: P arallel M P E G D ecoding: A rc h ite ctu re fo r L ` T est C ase F ig u re 4.4 : P arallel M P E G D ecoding: A rc h ite ctu re fo r 2 " `^ T e st C ase F igure 4.5: P arallel M P E G D ecoding: A rc h ite ctu re for s " ' T est C ase F ig u re 4.6: B lock M atching: Functional T ask G ra p h Figure 4.7: B lock M atch in g T ask G raph: G B F T G ro u p in g Figure 4 .8 : B lock M atch in g T ask G rap h w ith A d d e d A ssertio n T asks Figure 4.9: B lock M atching: Final R esu ltan t T ask G rap h

x

R e p r o d u c e d with p e rm issio n of th e copyright o w ner. F urther reproduction prohibited without perm ission.

F igure 4.10; B lock M atch C ircuit D esign Figure 4.11 : B lock M atch State M achine i'igure 4.12: D esign S p ace E xploration o f Parallel B lock M atchini Figure 4.13: Final P rototype D evice A rchitecture F igure 4.14: R eference Im age Figure 4.15: Input Im age F igure 4.16: M acroblock Identification

81 83 85

89 90
91 91

XI

R e p ro d u c e d with perm ission of th e copyright ow ner. Further reproduction prohibited without perm ission.

G lo s s a ry o f A c r o n y m s

C A D - C o m p u ter A ided D esign G B F T - G roup Based F ault T olerance C B F T - C lu ster Based Fault T olerance T B F T - I'a s k B ased Fault T olerance C PU -- C entral P rocessing U nit A S IC - A p p licatio n S pecific Integrated C ircu it FPG A - Field P ro g ram m ab le G ate A rray M PE G - M otion Picture E xperts G roup PE - P ro cessin g E lem ent IP - In tellectual P roperty SW -- S oftw are H W - Flardw are VI ID E - V ery high speed integrated circu it H a rd w a re D escription L anguage

XII

R e p ro d u c e d with perm issio n of th e copyright owner. Further reproduction prohibited without perm ission.

CHAPTER I IN T R O D U C T IO N

1.1 O verview

T h e av erag e C an ad ian equates the idea o f a c o m p u ter w ith a d esk to p o r laptop. a c tu a lity , th e d e fin itio n o f a co m p u te r is m uch broader.

In

It is e stim a ted th at in the T e lev isio n , audio

a v e ra g e C a n a d ia n 's ho m e there are 30 to 40 em b ed d ed system s.

sy ste m s, refrig erato rs, telep h o n es, tem p eratu re c o n tro ls and sto v es all use em b ed d ed c o m p u te rs. E m b ed d ed co m p u ters also play an integral role in m any o f th e assisted

d e v ic e s th a t a id d isabled in d iv id u als in p erfo rm in g daily a c tiv ities, e.g. p o w e r w h e e lch a irs a n d co m m u n icatio n devices. A d d itionally, m any e m b ed d ed d ev ices are resp o n sib le fo r p ro tectin g h u m an life; em b ed d ed co m p u ters control m o d e m m edical in stru m e n ta tio n , airplanes, a ir traffic control sy stem s, an ti-lo ck b re a k in g sy stem s (A B S ) and ev en the " fasten y o u r seatb elt" light on the d a sh b o ard o f y o u r car. By

m an y e stim a tes, em bedded devices account for 99% o f w o rld w id e co m p u ters w h ile d e sk to p s a n d laptops account for ju s t 1%. a p p lic a tio n -sp e c ific c o m p u tin g devices. E m b ed d ed c o m p u te rs are sm all-scale

E m bedded co m p u ters alread y p e m ie a te our

so c ie ty and th e ir grov/th is ex p ected to c o n tin u e indefinitely.

It is c o m m o n kno w led g e th at tech n o lo g ical d e v elo p m en ts are p rp d u cin g in creasin g ly e ffic ie n t a n d co m p act co m p u ters. T his applies to em bedded c o m p u te rs as w ell. T he

1

R e p ro d u c e d with pe rm issio n of th e copyright ow ner. Further reproduction prohibited without perm ission.

m ore pow erful and co m plicated the eomponenLs o f an em bedded device, the m ore d ifllcu lt it is for a c o m p u ter engineer to produce a product that m eets safety, perform ance, cost and pow er consum ption requirem ents w ithin a reasonable am ount o f tim e. T he production o f the high perform ance em bedded devices o f the future will require tools and form al m ethods to aid engineers in system design and developm ent.

The research p resen ted in th is thesis is centred around the dev elo p m en t o f com puter aided d esign (C A D ) softw are tools that will , be used to aid in the design and d ev elo p m en t o f future em b ed d ed devices. E ssentially, an engineer w ill tell the C A D tool w h a t the d esired d evice should be capable o f doing; the tool w ill analyze the given in fo rm atio n and reco m m en d a reliable and efficient design. T his can aid a

p ro d u ct en g in e e r in d e v elo p in g system s th at are far m ore reliable, cost, tim e and pow er efficient. R eliability is key for the developm ent o f safety-oriented devices that are re sp o n sib le fo r p ro tectin g hum an life. M inim al production cost is im portant for en su rin g the final p roducts are accessible to all people regardless o f socio-econom ic status. S im ilarly, decreased labour costs as a resu lt o f m ore exp ed ien t design, results in a c h e ap e r product. F inally, m inim izing a d e v ic e 's pow er co n su m p tio n is essential to red u cin g en erg y costs, b o th financial and environm ental. T hese C A D tools will aid in the d e v e lo p m en t o f n ew devices that will continue to play a central role in our lives.

W ithin electrical and co m p u ter engineering, em bedded system s research is in its infancy. T h is m akes it an exciting field to w ork in as it provides unique and novel

R e p ro d u c e d with p erm ission of the copyright ow ner. Further reproduction prohibited without oerm ission.

opportunities. autom otive,

It is also attractive due to its broad range o f applications (aerospace, com m unications etc.). D eveloping these softw are tools can be

technically challenging and thus intellectually rew arding.

1.2 O riginal C ontributions

T h is thesis presents a new hardw are-softw are co-synthesis tool to aid in the design and developm ent o f high perform ance em bedded devices. The proposed approach

focuses prim arily on com putationally intensive com puting system s requiring high levels o f fault tolerance. A full hardw are-softw are co-synthesis approach is presented w ith com parisons to a fully exhaustive technique. Im plem entation results are also

p rovided in order to further dem onstrate the algorithm 's efficacy.

T h e m ajor contributions o f this thesis are as follow s; · D evelopm ent o f a hardw are-softw are co-synthesis algorithm capable o f generating hypercube architecture based em bedded devices · D evelopm ent o f group based fault tolerance (G B FT), a technique designed to effiCi^.itly add support for fault tolerance in em bedded system s at the task graph level · C om parative analysis betw een the new ly developed G B FT algorithm and other existing m ethods · C om parative analysis betw een the co-synthesis algorithm presented here and

R eproduced with perm ission of th e copyright owner. Further reproduction prohibited without permission.

the optim al case im plem entation o f a security/navigation device in sim ulation in order to dem onstrate the efficacy o f the co-synthesis algorithm Im plem entation o f a parallel block m atching device in order to dem onstrate the efficacy o f the co-synthesis algorithm P rototype construction o f the block m atching case study

1.3 T h esis O rganization

T his thesis consists o f five chapters. The second chapter encom passes a survey o f hardw are-softw are co-design, and a thorough survey of hardw are-softw are

p a rtitio n in g and co-synthesis.

C hapter 2 also includes background on hypercube

architectures. These tw o chapters are intended to provide the basic understanding o f the d esig n issues o f hardw are-softw are em bedded system s and to survey the existing research in this field.

T he third chapter is the m ain com ponent o f this thesis. It consists o f a full description o f all o f the com ponents o f the co-synthesis algorithm . These include group based

fault tolerance, a pipelined scheduling technique, a m ethod for adding processing elem en ts to the current system design, placing existing processing elem ents w ithin a hypercube topology and synthesizing all required com m unication links.

R e p ro du c ed with perm ission of th e copyright owner. Further reproduction prohibited without p en n iss'c n .

The

fourth

chapter describes the two

case studies im plem ented

in order to

dem onstrate th e alg o rith m 's efficacy. T he first case study perform s the decoding o f parallel M PE G -2 video stream s and com pares the a lg o rith m 's results w ith that o f an exhaustive technique. The second case study perform s parallel block m atching and a final prototype device is constructed. T he fourth chapter also includes a discussion o f th e experim ental results obtained from both o f the case studies. concludes th is thesis. T he fifth chapter

1
R eo rod uced with oerm ission of the coovriaht owner. F u rth e r re o ro d u c tio n o ro h ib ite d w ith o u t o e rm is s io n .

CHAPTER 2 DESIGN OF EMBEDDED SYSTEMS

2.1 Introduction to H ardw are-Softw are Co-Design

T his section surveys hardw are softw are co-design.

H ardw are-softw are co-design is

an active area o f research that involves the developm ent o f tools and m ethodologies to aid in the design o f em bedded com puter system s. Em bedded com puters are

processing devices used in areas as diverse as w ireless com m unications, m edical instrum entation, transportation and food preparation. A lthough these fields are

w id ely different, the em bedded device com ponents o f the products share com m on design techniques. T his is an outline o f hardw are-softw are co-design: a m ethod for designing and developing an em bedded com puter device. The m otivation behind co design is that both hardw are and softw are com ponents should be addressed

sim ultaneously in order to ensure that the final device m eets cost, perform ance, reliability and pow er consum ption goals.

Separate softw are and hardw are design m ethods have been the subject o f a great deal o f research over the years [21, 41]. H ow ever, the design o f both hardw are and

softw are as a jo in t venture rem ains an area o f rapidly grow ing research. M ost o f the em bedded system s research has been stim ulated by the developm ent o f fairly inexpensive high perform ance m icroprocessors [8]. W hen em bedded processors w ere

R epro duced with perm ission of th e copyright owner. Further reproduction prohibited without permission.

s:

exclusively sm all and responsible for the execution o f m inim al am ounts o f softw are, sim ple techniques w ere m ore than sufficient to create devices that satisfied W ith the

p erform ance and functional goals w ithin a reasonable tim e to m arket.

n u m b er o f transistors on a chip increasing exponentially, em bedded devices have the potential to utilize far m ore sophisticated circuits and architectures [48]. The

em bedded engineer requires C A D tools to aid in the design and d evelopm ent o f em bedded com puters and to predict im plem entation costs.

T h e rest o f the subsection introduces the m otivation behind hardw are-softw are co d e sig n o f em bedded system s. A dditionally, it intends to introduce the various

com ponents o f the hardw are-softw are co-design process.

Co-Design Overview

T h e em bedded system design process w ill vary considerably w ith respect to the type o f p ro d u ct under developm ent. H ow ever, com m onalities can be identified and the

ab ility to abstract hardw are and softw are com ponents to the sam e level is greatly ex p lo ited in hardw are-softw are co-design. The traditional approach to the design o f an em bedded com puter system is to enforce hardw are-softw are partitioning a t an early stage. T his results in w ell-defined design tracks for both the hardw are and

so ftw are com ponents. The m ajor w eakness in traditional em bedded system s design

R e o ro du ce d with oerm ission of th e coovriaht owner. Further reoroduction orohibited without oermission.

lies in the early partitioning process. A graphical overview o f the traditional design approach is provided in Figure 2.1 below .

R equirem ents And Specification

Partitioning

Hardware Design

Software Design

Integration

Com pleted Design

Figure 2,1: Traditional Design

O ne o f the m ajor flaw s o f such an approach is the inability o f the design and developm ent flow to correct m istakes m ade in the partitioning phase. I f during

integration, an em bedded system s engineer discovers that the product w ill not m eet

R e p ro d u c e d with perm ission of th e copyright owner. Further reproduction prohibited without permission.

various non-functional requirem ents (perform ance, pow er consum ption, etc.), the cost im posed on re-evaluation o f the design will be extrem ely high.

T he

hardw are-softw are co-design

process begins w ith the creation o f device B oth functional and n o n 

requirem ents, w hich leads to a form al specification.

functional requirem ents such as perform ance, cost and pow er co nsum ption are specified. T h is can then be converted into a standardized system description or

specification. E m bedded system specification requires detailed m odels to aid in the a b stract description o f co m ponent functionality. A bstract m odeling that does not F urther

differen tiate betw een hardw are an d softw are is know n as co-specification.

research into the high level m o d elin g o f em bedded devices w ould be greatly beneficial.

It is com m on for this standardized description to be converted into a task graph form at. H ardw are-softw are p artitioning is perform ed on this task graph. P artitioning is concerned w ith assigning an execution location (softw are or h ardw are) to each task. A fter partitioning, co-synthesis is perfo m ied and typically, the co-synthesis and partitioning phases are closely knit. C o-synthesis is broken dow n into the

assignm ent, allocation and scheduling phases.

Finally, the generated softw are,

hardw are and interface m odules are integrated. F eedback in the design process can oc c u r at system integration by return ing to the partitioning phase, thus allo w in g the d esig n er to refine the given solution. A t integration, the overall system can be

ev aluated for functional and non-functional requirem ents by using hardw are softw are

R e o ro d u c e d with oerm ission of th e coovriaht owner. Further reoroduction orohibited without oermission.

co-sim ulation. C o-sim ulation allow s for both hardw are and softw are com ponents to be tested congruently. Figure 2.2. A visual overview o f the co-design process is provided in

R equirem ents and Specification

C o n v ersio n to T ask G raph

H ardw are-S oftw are Partitioning and CoS y n th e sis

S o ftw are

Interface

H ardw are

Integration Prototyping

C om pleted D esign

Figure 2.2: Hardware-Software Co-Design

10

R e o ro d u c e d w ith o e rm is s io n o f th e c o o v ria h t o w n e r. F u rth e r re o ro d u c tio n o ro h ib ite d w ith o u t o e rm is s io n .

H W /SW Partitioning

T h e p a rtitio n in g process is concerned w ith d e c id in g w h at system fu n ctio n ality w ill be im p lem en ted as hard w are and w hat w ill be im p lem ented as softw are. T y p ic ally , an e m b ed d ed d e v ic e w ill need to m eet a n u m b er o f non-functional req u irem en ts. T h ese w o u ld often include p erform ance, price, reliab ility an d p o w e r co n sum ption. W ith

m o re co m p o n en ts im p lem ented in h ardw are, system price and pow er c o n su m p tio n w ill increase. H ow ever, w ith a large n u m b er o f com ponents im p lem e n te d in

softw are, sy stem perfo rm an ce a n d reliab ility can degrade. It is im p o rtan t to balan ce th e selectio n o f hardw are and so ftw are com p o n en ts to ensure th at all sy stem req u irem en ts are m et. S ignificant research h as been conducted w ith resp e c t to

p a rtitio n in g alg o rith m s in ord er to au to m ate the process o f o btaining a n e fficien t h a rd w a re -so ftw a re lay o u t fo r a n em b e d d e d device.

HW /SW Co-Synthesis

H a rd w are-so ftw are co -sy n th esis o f an em b e d d e d d evice is the process by w h ich the h a rd w a re -so ftw a re arch itectu re o f the sy stem is autom atically deriv ed to satisfy m u ltip le goals. T hese goals can include facto rs such as cost, perform ance and p o w e r co n su m p tio n . H ardw are-softw are c o -sy n th esis is inseparable from th e p ro cess o f

11

R p .n rn rli i n e d w ith n p rm L Q p in n n f t h p r .n n w r in h t n w n p r

F u r t h e r m n m r l i irttin n n m h ih itp H w ith n i it n p r m i s c i n n

p artitio n in g . T h e h a rd w are-so ftw are c o -sy n th e sis d esign flow c o n sists o f three m ain c o m p o n e n ts: allo catio n , assig n m en t and scheduling. A llocation is concerned w ith

se le c tin g the n u m b er and type o f c o m m u n ic a tio n links and p ro cessin g elem en ts in the system . T he assig n m en t c o m p o n e n t is con cern ed w ith the m ap p in g o f tasks to

*

p ro c e ssin g elem en ts. T he sc h ed u lin g c o m p o n e n t is co n cern ed w ith the tim ing o f task e x e c u tio n and c o m m u n icatio n s. T y p ically , th e p a rtitio n er w ill iteratively adapt its T he scheduler is

Î

h a rd w a re m ap p in g s based larg ely on tlte resu lts o f the scheduler.

ty p ic a lly th e final p h a se o f co -sy n th esis. A v isu al o v erv iew o f a c o m m o n approach to c o -sy n th e sis is pro v id ed in F igure 2.3.

I
I
I
I

A llocation

Assignment

I
Scheduling

Figure 2.3: HW /SW Co-Synthesis

12

*

R e p r o d u c e d with p e rm iss io n of th e copyright o w ner. F urther repro du ction prohibited without p erm issio n.

H W /SW Co-Simui'ation

H igh perfo rm an ce em bedded system co m p o n en ts can be ex trem ely co m p lex .

It Is

d iffic u lt to d ev elo p co m prehensive an aly tic system s to m odel th e p erfo rm an ce o f an e m b ed d ed d ev ice th at consists o f com plicated com ponents. C o n cu rren tly sim u latin g co m p o n en ts w ith d iffering behavioural m odels is referred to as co-sim u latio n . T y p ically , a co-sim u latio n en v iro n m en t w ill m odel m u ltip le co m p o n en ts, both so ftw are and hardw are. T his can be a d ifficu lt task as softw are sim u latio n c o n sists o f m o d elin g a p ro cesso r ex ecu tin g a series o f instructions. H ow ever, h ard w are

sim u latio n can consist o f m o d elin g som ething co m pletely differen t, such as an analog o r d igital circu it. In an em bedded device it is co m m o n fo r th e ex ecu tio n o f

a p p lic atio n specific integrated circuits to d ep en d on co m m an d s issued b y one o f the sy ste m 's p rocessors. O ne should no te that co-sim u latio n req u ires th e h ard w are

sim u lato r to rea c t to in p u t from th e softw are sim u lato r and v ice versa.

A n u m b er o f co -sim u latio n to o ls have been developed. O ne o f the m o st w ell-k n o w n c o -sim u la tio n to o ls is S eam less from M en to r G raphics. S eam less allow s the u se r to tie in v ario u s hardw are and softw are sim ulators. S eam less c o o rd in ates the

c o m m u n ic a tio n s b etw een sim ulators to ensure th a t the overall b eh av io u r reflects th at o f an em b ed d ed device. A lthough S eam less p erfo rm s as an effectiv e co -sim u latio n to o l, it can also be applied for h a rd w are-so ftw are co -v erificatio n [44].

13

R e p ro d u c e d with perm ission of th e copyright owner. Further reproduction prohibited without perm ission.

H W /SW C o-V erification

T he c o m p le x ity o f em bedded system s prevents the d esigner from

rely in g on

#

i
#

trad itio n al v a lid a tio n tech n iq u es such as sim ulation and testing. T h ese tec h n iq u es are in su fficien t to p ro p erly v erify th e correctness o f such a system . To ad d ress this

* f
% f

pro b lem , n ew form al v e rificatio n m ethods are needed to overcom e the lim itatio n s o f trad itio n al valid atio n techniques.

M u ltip le m eth o d s have been developed for p erform ing h ard w a re -so ftw a re cov erification. A c o m m o n ap p ro ach involves the use o f a P etri-n et b ased rep re sen ta tio n o f e m b e d d e d sy stem s, as in the system nam ed PR E S [9, 10]. proves the co rrectn ess o f an em b ed d ed system T he P R E S m odel the tru th o f

| E

fay d eterm in in g

| || $ |

c o m p u ta tio n tree lo g ic and tim ed com putation tree logic.

T hese rese a rc h p ro jects

m ake u se o f m odel c h e ck in g to p ro v e the correctness o f em bedded sy stem s a n d h av e used an au to m atic teller m achine serv er to dem onstrate th e feasib ility o f th e ir approach. A n o th e r ap p ro ach dev elo p ed by H siung involves the use of lin ear h y brid a u to m a ta and em p lo y s a sim p lificatio n strategy to address the state-sp ace e x p lo sio n that o c c u rs in the form al v erificatio n o f com plex system s [26].

I
|

I
|

I
|

P resently, o u r k n o w led g e o f the jo in t hardw are-softw are d esign p ro cess is far m ore lim ited than that o f e ith e r o f the tw o separately. W hile em b ed d ed system s

d ev elo p m en t can be perform ed as separate processes o f h ard w are and so ftw are

14

R e p r o d u c e d with perm issio n of th e copyright ow ner. Further reproduction prohibited without perm ission.

d e sig n , this route can be far m ore c h allen g in g w hen attem p tin g to m eet vario u s price a n d p e rfo rm a n c e re<in m o re e rro r prone ic n ts. A d d itionally, this d esig n path has a ten d en cy to result ucts due to difficu lties in em bedded system v erification.

R e se a rc h in to system m o d elin g is a key elem en t to our u n d erstan d in g o f h ardw areso ftw a re co -d esig n . W hile m an y ab stract m o d els for em bedded system co m p o n en ts

e x ist, there is a lack o f accurate m odels to address th e detailed ch a ra c te ristic s o f these co m p o n e n ts. E m bedded system s are alw ay s being d e v elo p ed w ith various

p e rfo rm a n c e and c o st m etrics in m ind. In o rd er to properly m e e t th o se req u irem en ts, it is essen tial to develop a th o ro u g h u n d erstan d in g o f m o d elin g th at in clu d es both the in tric a c ie s o f a co m p o n e n t as w ell as its h ig h level properties.

In th e c u rre n t em b ed d ed sy stem s m ark e t, d e sig n e rs and d e v e lo p e rs c a n m ostly p ro d u c e d e v ic e s th at m eet req u irem en ts w ith in a reaso n ab le a m o u n t o f tim e. H o w e v er, so o n th e u tiliz a tio n of so p h isticated hard w are-so ftw are co-d esig n

tec h n iq u es w ill be req u ired in o rd er to m ee t future device dem ands.

A s adv an ced

p ro ce sso rs a n d A S IC s b ecom e less ex p en siv e, the n eed for to o ls to aid the d esig n and d e v e lo p m e n t process w ill increase dram atically in o rd er to ensure the d e v e lo p m e n t o f h ig h qu ality dev ices w ith a m in im u m tim e to m arket.

15

R e p r o d u c e d with p e rm issio n of th e copyright ow ner. Further reproduction prohibited without perm issio n.

2.2 H ard w are-S oftw are Partitioning

H ard w are-so ftw are partitioning is the process by w hich the various co m p o n en ts o f an e m bedded c o m p u te r's functionality are placed in eith er hardw are o r softw are. The

m o tiv atio n behind the p artitioning process is to produce a reliable em bedded device that m eets p erfo rm an ce, cost and pow er consum ption requirem ents.

T he p artitio n in g process is a subset o f hardw are-softw are co-design.

C om puter

co m p o n en ts suitable fo r use in em bedded devices have in creased in ab ility and com p lex ity dram atically in recent years. T he jo b o f an em b ed d ed system s engineer in v o lv es selectin g appropriate com ponents and integrating them to produce an em b ed d ed device. T he rapid increase in both com plexity an d p erfo rm an ce o f these co m p o n en ts has resulted in an increase in the difficulty o f c o m p o n en t selection and integration. T hese d ifficulties have fuelled dem and fo r to o ls and design

m eth o d o lo g ies to aid in th e creation o f em bedded devices th a t are c o m p rise d o f both hardw are and softw are com ponents.

T he ty p ical em b ed d ed system design approach is significantly restrictive. T he m ain flaw revolves around the lack o f design flow after system in tegration and prototyping. If th e system is integrated and an expensive prototype is p roduced, further design c h an g es can be extrem ely costly. T hese further design ch an g es m ay have to o ccu r if

16

R e o ro d u c e d with oerm isslon of th e coDvrlaht ow ner. F u rth e r re n ro d u c tio n o ro h lh ite d w ith o u t n e rm lcR in n

prototyping reveals that the system will not m eet non-functional requirem ents (such as perform ance).

T his su b sec tio n 's goal is to introduce the reader to the m otivation behind hardw aresoftw are partitioning for em bedded devices. A dditionally, this subsection intends to introduce the reader to the existing research in hardw are-softw are partitioning.

2.2.1 Standard Approach

T he partitioning process is concerned w ith deciding w hich system functionality w ill be im plem ented as hardw are and w h ich will be im plem ented as softw are. It is

im portant to balance th e selection o f hardw are and softw are com ponents to ensure that all system requirem ents are m et. S ignificant research has been co nducted w ith respect to partitioning algorithm s in order to autom ate the process o f obtaining an efficient hardw are-softw are layout fo r an em bedded device.

The standard approach to hardw are-softw are partitioning involves the use o f a heuristic to prioritize a task set. T his prioritization aids in the determ ination o f task m ap p in g (to hardw are or softw are). O ften m uch o f the jo b o f the partitioning

algorithm researcher is sim ply to develop an effective heuristic that w ill result in an optim al partitioning algorithm .

17

Reproduced with perm ission of th e copyright owner. Further reproduction prohibited without permission.

T h e earliest partitioning algorithm s proposed, began by im plem enting all com ponents in softw are and proceeded to m ove com ponents to hardw are im plem entations until various system requirem ents w ere optim ized [18]. O ther early approaches proposed to im plem ent all com ponents in hardw are and to proceed to m ove com ponents to softw are until system requirem ents w ere met [22]. A m ore recent approach involves m aking an educated guess w ith reference to w hether a given task should first be m apped to softw are or to hardw are [6]. A fterw ards, the algorithm w ould iteratively attem pt re-m apping tasks from their original locations until requirem ents are satisfied. T hese techniques a n d versions th ere o f are still in use. In all cases the approach is

sim ilar, th e algorithm attem pts a default o r initial configuration, analyzes its effectiveness and iteratively alters the current layout i f non-functional requirem ents are not m et. O ther techniques to aid in the heuristics for partitioning decisions

include linear integer program m ing [38], sim ulated annealing [40] and petri-nets [19].

2.2.2 Partitioning Granularity

G ranularity defines the size o f system com ponents that can be im plem ented in either hardw are or softw are. A partitioning algorithm that operates a t a high level o f

granularity (also referred to as coarse-grained) uses only large blocks o f system functionality to be im plem ented on any given processing elem ent (PE). It can be

beneficial fo r a large segm ent o f functionality to be im plem ented on the sam e PE. T his is particularly evident in larger scale distributed em bedded devices, w here

I
18

R e o ro d u ce d w ith o e rm is s lo n o f th e c n n u r i o h t o w n e r

F u r t h e r r e n r n d i l o ti n n n r n h i h i t e H w i t h m it n o r m i o o i o n

dividing a high grained system into sm aller com ponents and then m apping them across the system can yield an unnecessarily high com m unication overhead. This

occurs w hen tightly coupled com ponents arc " spread out" throughout the system . U sing the granularity that is specified by the program m er o f an application is often referred to as a high level o f granularity. G upta and D eM icheli developed an They

approach to th e coarse grained hardw are-softw are partitioning problem [23]. present a partitioning procedure to identify potential hardw are and

softw are

com ponents o f a system . T heir technique also utilizes the O lym pus S ynthesis System for digital design [39] for the synthesis o f dedicated hardw are w ithin their system . Y en and W o lf have also developed an approach to the coarse grained partitioning problem [52]. sim u ltan eo u sly tradeoffs. They present an autom atic iterative im provem ent technique for perform ing concurrency optim ization and hardw are-softw are

B y considering both concurrency and hardw are-softw are tradeoffs, their

approach is ab le to identify cost/perform ance points that m ay n o t have been identified otherw ise.

A partitioning algorithm that operates at a low level o f granularity (also referred to as fine-grained) w ill often divide an em bedded sy stem 's functionality into extrem ely sm all com ponents. Fine-grained partitioning algorithm s have the disadvantage that

separating system functionality on such a sm all scale can dram atically increase co m m unication overheads, w hich has the effect o f decreasing system perform ance. Som e system s use this approach w hen they are dealing w ith partially re-configurable processors (processors w hose IP cores can be m odified during the design process).

19

R e o ra d u c s d w ith n e rm is s io n o f t h e o o n u rln h t o w n e r

F u r t h e r r e n r n r l n o t i n n n r n h i h i t e H w i t h n i it n e r m i c c i n n

Fine-grained system s can provide a better solution than coarse-grained algorithm s because they are m ore llexible in ten n s o f m apping the correct com putationally intensive com ponents to the appropriate processing elem ents. Fine-grained system s §

reduce the potential negative effect o f having to deal w ith a poorly defined system functional specification. A fine-grained system can refine the design on such a sm all scale th at som e will take one single com putationally intensive CPU instruction and treat it as a separate task [1]. It is com m on for tasks (individual com ponents that can be m apped to hardw are) to be called base blocks w hen dealing w ith fine grained partitioning. E rnst et al. have developed a heuristic approach to the fine grained They have developed a n iterative

|

i
^

1
ft É § | | I

hardw are-softw are partitioning problem [18].

partitioning process w hich is based on hardw are extraction and is controlled by a cost function. T his technique is in use in the C O SY M A system [40]. K nudsen and

M ad sen have also presented an approach to the fine grained partitioning problem [30]. T his approach uses dynam ic program m ing to solve both tlie problem s o f system execution tim e and hardw are area constraints. T his technique is in use in the L Y C O S system [38].

;
I
i

I
s

Finally, there is one research project know n that involves m erging these tw o ideas o f varying granularity [24]. This concept is know n as flexible granularity. D epending on the characteristics o f the specific application and the sy stem 's non-functional requirem ents, the selected granularity can span from a low level o f base blocks all the way to the user-defined functions. This approach is intended to overcom e the

shortcom ings o f both o f the previous approaches. T his w ork also includes estim ation

20

m ethodologies adapted to different levels o f granularity, w hich help to determ ine the final system granularity.

2.2.3 Dynamic Programming

D ynam ic program m ing is a technique ideal for problem s w here calculating all p o ssib le outcom es is not com putationally feasible. T his m akes dynam ic

program m ing w ell suited to the p artitioning problem , w hich can be extrem ely co m p utationally intensive. T ypically, a dynam ic solution is recursive and iterative in nature.

D y nam ic program m ing problem s can alw ays be divided into stages w here a decision w ill be required at each stage. T ypically there are a num ber o f states associated w ith each stage. D ecisions m ade at one stage w ill alter the current state into a new state in the n e x t stage. The decision m ade a t a given state does not depend on the decisions m ade in the previous state. It can be seen th at dynam ic program m ing extends itse lf easily to hardw are-softw are partitioning w h ich can be approached as a recursive, iterative, state based problem . O ften a dynam ic program m ing solution will

effectively process a task graph and im prove algorithm execution speed by avoiding testin g infeasible com binations.

21

R e o ro d u ce d w ith o e rm is s lo n o f th e c o o v rio h t o w n e r. F u rth e r re n ro d u c tio n o ro h ih ite d w ith o u t o e rm is s lo n .

Shrivastava et al. [45] have used dynam ic program m ing to develop an algorithm that can effectively solve the partitioning problem with extrem ely fast execution tim es. C hang and Pedram [5] have also used dynam ic program m ing to determ ine the solution to the coarse-grained partitioning problem o f a generic task graph. K nudsen and M adsen [31] have used dynam ic program m ing to determ ine the solution to the fine-grained partitioning problem . |

I
|

#

2.2.4 Fault Tolerance

|

I

F au lt tolerance is a large area o f com puting, w hereby com putational devices are developed w hich m ust m eet various m ission critical and safety critical requirem ents. T hese ty p es o f system s are com m on in aerospace and biom edical applications. Fault tolerant com puting has been a large a re a o f study [46], how ever, incorporating som e o f these ideas into hardw are-softw are partitioning is an extrem ely young discipline.

Î

I I

It is com m on in the developm ent o f fault tolerant devices to incorporate a sy ste m 's fault tolerant com ponents late in the design process. This often creates a significant overhead in term s o f im plem entation cost. Incorporating fault tolerance at an earlier stage o f design is likely to be very beneficial in reducing th is overhead. T his line o f reasoning has sparked research in incorporating fault tolerance into earlier phases in the design process, such as hardw are-softw are partitioning.

% |

$ |

I
I

22

p A n r n t r l i ir iA fl w i t h n A r m i c i s i n n n f t h A r t n n v / r i n h t n u / n A r

P i i r t h A r r A n r n r l i i r i i n n n r n h i h i t A r l \A /i th r ti it n A r m l c c l r v n

F ault

tolerant

hardw are-softw are

partitioning

generally

involves

adapting

the

p artitioning process to autom atically accom m odate system s requiring fault tolerance. T h e m ost predom inant w ork in this field is that o f D ave and .Iha [13]. researchers have developed a system These

that w ill input a functional task graph T heir system will

sp ecificatio n and perform task clu sterin g for fault tolerance.

ch o o se an erro r recovery topology th a t is optim ized to use a sm all n um ber o f extra p ro cessin g elem ents. A dditionally, B olchini e t al. [4] have developed a partitioning algorithm th at incorporates fault detection capabilities. T his m ay not be as robust as full fault tolerance, how ever fault detection is relevant as it is a subset o f fault tolerance.

Presently, o u r know ledge o f the jo in t hardw are-softw are design process is far m ore lim ited th an that o f either o f th e tw o separately. W hile em bedded system

d e v e lo p m en t can be perform ed as a separate process o f hardw are and softw are design, this route can be far m ore ch allen g in g w hen attem pting to m eet various price a n d perform ance requirem ents. A dditionally, this design path has a tendency to result in m ore erro r prone products due to a lack o f form alism in design m ethods.

H ardw are-softw are co-design is a burgeoning field o f research and one o f its m ost activ e subsets is h ardw are-softw are partitioning. P artitioning is the process o f

d ecid in g w h at functional system com ponents w ill be im plem ented as hardw are and w h at will be im plem ented as softw are. E ffective hardw are-softw are p a rtitio n in g is

23

R e o ro d u c e d with oerm isslon of th e coovrioht owner. Further reoroduction orohihited without oerm isslon.

essential for creatin g em bedded devices that m eet non-functional requirem ents such as perform ance, pow er consum ption and cost.

Since hardw are-softw are partitioning has begun to flourish as a field o f research, greatly vary in g approaches to the problem have been taken. R esearchers have

attem p ted to tack le m any issues and incorporate m any varying ideas. T he concept o f varying degrees o f granularity allow s an algorithm to separate a system 's

functionality into com ponents o f various size. D ynam ic p ro g ram m in g is an iterative, recursive technique that has been effectively incorporated into approaches to partitioning. F ault tolerance is an extrem ely im portant issue, especially in em bedded system s, and partitioning approaches have been developed to incorporate these abilities.

In the current em bedded system s m arket, designers and d ev elo p ers can m ostly p roduce devices that m eet requirem ents w ithin a reaso n ab le am ount o f tim e. H ow ever, soon the utilization of sophisticated h ardw are-softw are co-design

I
f

1
# I
S

techniques w ill be required in order to m eet future device dem ands.

A s advanced

processors and A S IC s becom e less expensive, the need fo r tools to aid the design and dev elo p m en t process will increase dram atically in order to ensure the dev elo p m en t o f high q u a lity devices w ith a m inim um tim e to m arket. H ardw are-softw are partitioning will be an integral com ponent o f these tools.

I I |
I

* |

24

R e o ro d u c e d with oerm isslon of the coovrioht ow ner. Further reoroduction orohihited without oerm isslon.

2.3 H ard w are-S oftw are C o-Syn thesis

A n em b ed d ed sy ste m 's architecture is ty p ically determ ined by the intuition o f a d e sig n eng in eer. T his process adds tim e to the developm ent cycle and som etim es It can also

resu lts in arc h ite c tu re s that do not m eet n o n-functional requirem ents.

resirit in an o v e r-d e sig n e d architecture w ith ex cessiv e hardw are that resu lts in overly e x p e n siv e d evices. C o n seq u en tly , in co rp o ratin g hardw are-softw are c o -sy n th esis in

d e sig n au to m atio n to o ls is essential for p ro d u cin g optim al devices w ith an accelerated tim e-to -m ark et. T he h ard w are-so ftw are c o -sy n th esis problem is con cern ed w ith

d eterm in in g o ptim al hard w are a n d softw are architectures. T his involves th e selection of p ro cesso rs (C P U s), a p p licatio n specific integrated circuits (A S IC s) and

co m m u n ic a tio n links in order to pro d u ce a device that m eets no n -fu n ctio n al req u irem en ts. T he c o -sy n th esis problem ty p ic a lly involves the selectio n o f the

qu an tity and ty p e o f p ro cessin g elem ents and co m m u n icatio n links (allo catio n ), task a ssig n m en t fro m a ta sk graph to processing elem en ts a n d confirm ation o f w h eth er the sy stem m eets req u irem en ts (usually th ro u g h scheduling). A task graph is a collection o f task s and co m m u n ic a tio n dep en d en cies that describe device functionality. The

a llo c atio n a n d scheduling phases are know n to be N P -com plete [20, 33], thus d eterm in in g an o ptim al solution in the co -synthesis phase can be extrem ely

co m p u ta tio n a lly intensive.

T h is w ork is m o tiv ated by the need to au to m ate the em bedded system d esig n process w h ile sim u ltan eo u sly p ro d u cin g high q uality devices. T he research p resen ted in this

25

R e o r o d u c e d w ith o e r m i s s l o n o f t h e c o o u r in h t o w n e r

F u r t h e r r e n r n d i i c t i n n o r o h i h i t e d w i t h n i it n e r m i s s i o n

th esis is fu rth er aim ed at p ro d u cin g h igh p erform ance fault to leran t em bedded system s. E m b ed d ed a p p lic atio n s that w ould particularly b en efit from high levels o f include aerospace, m ed ical in stru m en ts and high p erform ance

fault to le ran c e

tele co m m u n ic a tio n system s.

In fact, it is believed th a t w ithin the nex t tw o o r three

d e c ad e s p ro b es w ill be sent to o rb it n e a rb y stars [34]. Such em bedded d ev ices w ould b e resp o n sib le fo r co n sid erab le sy stem control a n d m easu rem en t in stru m en tatio n in a d d itio n to u n p aralleled fault to leran ce req u irem en ts.

T h e p rim a ry focus o f m o st o f the c o -sy n th e sis research p roblem has co n cen trated on th e sim p listic sin g le p ro ce sso r and A S IC arch itectu re [3, 6, 18, 28]. S om e approaches a ssu m e m o re c o m p licated arch itectu res, such as tw o C P U s and hard w are-accelerated c irc u itry [37]. V ario u s ap p ro ach es h av e b een attem p ted that in v o lv e m o v in g tasks

from h a rd w a re to so ftw are o r vice v e rs a in o rd e r to m eet th e sy stem req u irem en ts. In th e co -sy n th e sis o f d istrib u ted sy stem s, targ e t arch itectu res can in co rp o rate m ultiple p ro ce sso rs, A S IC s o r F P G A s (field p ro g ra m m a b le gate arrays). T w o m ain tech n iq u es h a v e b e e n u tiliz e d to h a n d le th e co -sy n th e sis o f d istrib u ted system s: th e op tim al and h e u ristic app ro ach es.

T h e op tim al a p p ro ach can be d iv id ed in to th re e sections: ex h au stiv e, m ix ed integer lin e a r p ro g ra m m in g , and c o n stra in t solving. T he ex h au stiv e a p p ro ach is

c h a ra c te riz e d by attem p tin g all p o ssib le m ap p in g s to pro v id e an op tim al solution. It can be v ery c o m p u tatio n ally in ten siv e and is only su itab le for sm a lle r system s. D 'A m b ro sio and H u have presented an ex h au stiv e tech n iq u e fo r h a rd w are-so ftw are

I

26

R o n r n r l i icieri w i t h r\<=»rmi.o.c.inn n f t h o n n n v / r i n h t n w n o r

P i i r t h o r I 'o n r n r li m t i n n n r n h i h i t o r i w i t h n i it n o r m i c c i n n

p artitioning [11]. H ow ever, th eir approach is lim ited to single processor architectures and ignores the co m m u n icatio n overhead. A h ardw are-softw are p artitioning

technique using m ixed integer linear pro g ram m in g is presented by Prakash and P ark er [42]. T h e ex ecution tim e o f th is technique is prohibitive for large task graphs. M oreover, this ap proach is lim ited to bus based architectures o r pre-d eterm in ed pointto -p o in t in terconnection topologies. A co n strain t solving approach has been

p resen ted by K uchcinski in the JaC o P system th a t co n centrates on sch ed u lin g and reso u rce assig n m en t [32].

T he heu ristic-b ased c o -sy n th esis a p p ro ach can be div id ed into tw o

m ethods:

co n stru ctiv e an d iterative. T he iterative schem e is characterized by h av in g an initial so lution, w h ic h is iteratively im proved. K iro v sk i and P otkonjak presented an

iterative algorithm th a t includes pow er as a cost function but th eir approach ignored the in ter-task co m m u n icatio n tim e [30]. O th er iterative tech n iq u es have been

dev elo p ed [25] but they are lim ited in that th ey allo w for only o n e type o f c o m m u n ic a tio n link. Li and W o lf have p resented an iterative co-sy n th esis algorithm c ap ab le o f sy n th esizin g m em ory h ierarchies for b u s architecture to p o lo g ies [36]. M O G A C is an iterative ap proach to the co-sy n th esis pro b lem that uses genetic alg o rith m s [16]. E xperim ental results sh o w that fo r large sy stem s M O G A C suffers

due to large ex ecu tio n tim es. W o lf has also presented an iterative ap proach to the c o  synthesis p roblem p ro d u cin g generic device arch itectu res [47]. G eneric device

a rch itectu res can be tuned to a particu lar ap p licatio n , but it can also result in d iso rg an ized and d iffic u lt to u n derstand designs as the interconnection to p o lo g y m ay

27

R e p ro d u c e d with p erm ission of th e copyright ow ner. Further reproduction prohibited without perm ission.

n o t c o n fo n n to an established architecture.

The constructive h euristic m eth o d is

c h a ra c te riz e d by building the solution step by step, w here the final o u tp u t is not availab le until the algorithm term in ates. C onstructive co-sy n th esis alg o rith m s are B akshi and G ajski have

p resen ted in the C O SY N [15J and C O F T A [13] system s.

a lso p resented a constructive p a rtitio n in g approach th at supports p ip elin in g at v ary in g d eg rees o f granularity [2]. A lth o u g h th eir approach allow s the a d d itio n o f m u ltip le softw are p ro cesso rs, it does n o t account fo r the hardw are cost o f ad d in g each C P U . A ll o f the above co -synthesis alg o rith m s support distrib u ted em b ed d ed sy ste m s but n o n e h av e u tilized hypercube to p o lo g ies as a targ et architecture.

2.4 H yp ercu b e A rch itectu res

H y p e rc u b e to p ologies are useful for h ig h perform ance em b ed d ed sy stem s an d h a v e a n u m b e r o f adv an tag es o v er o th e r arch itectu res [12, 27, 35, 43]. rep resen t p ro cessin g elem en ts (PE ) an d a link betw een H y p ercu b e nodes rep re sen ts a

n odes

c o m m u n ic a tio n interface (serial, p arallel, E thernet link, etc.). H y p ercu b e to p o lo g ies a re v ery flexible, versatile and generic. d eg ree fo u r, co n stru cted fro m tw o Figure 2.4 show s a h y p ercu b e n e tw o rk o f 3D hypercubes. The high level of

in terco n n ectiv ity in a hypercube arch itectu re results in a system th a t is su ite d to fault tolerance. A dditionally, h y p ercube sy stem s support high p e rfo rm an ce c o m p u tatio n

w h ile lim itin g the co m m u n icatio n o v erh ead s and/or bottlenecks asso ciated w ith largescale sy ste m s co n sistin g o f m an y PEs. T h ese features m ake h y p e rc u b e arc h ite c tu re s

28

R e p r o d u c e d with perm ission of th e copyright ow ner. Further reproduction prohibited without perm ission.

an e x c e lle n t c h o ice for m u ltip le PE em bedded system s th at need to co u p le faultto le ran c e w ith com plex co m p u tatio n . A dditional advantages of h y p ercube

arc h ite c tu re s include to p o lo g ies w ith sm all d iam eters and high levels o f sym m etry. F in a lly , ro u tin g in h y p ercu b e n etw o rk s is w ell researched and efficie n t routing a lg o rith m s are availab le [29].

Figure 2.4: A 4D Hypercube

T he m a in d isad v an tag e o f h y p ercu b e to p o lo g ies is th eir poor u p w ard scalab ility .

It

can b e a d iffic u lt and co m p le x p ro cess to add nodes to a hypercube n etw o rk . T his c ritic ism ap p lie s m ore d ire c tly to h y p ercube co m p u te r system s, w h ich are likely to be re c o n fig u re d a n d ex p an d ed reg u larly . It is unco m m o n for a d istrib u ted em b ed d ed

d e v ic e th at h a s already been m an u fa ctu red to require any ad d itio n al p ro cessin g

29

R e p r o d u c e d with p e rm issio n of th e copyright ow ner. Further reproduction prohibited without perm ission.

elem ents.

Such a circum stance could be used in reconfigurable space system s.

A nother d isad v an tag e o f hypercube system s is the large num ber o f com m unication links, b u t additional links sup p o rt fault tolerance. T hese com m unication links and

their interfaces to the processing elem ents result in a significant cost overhead. H ow ever, it should be noted that this research targets h igh perform ance fault-tolerant em b ed d ed devices. A s a result, the associated c o st to produce system s that m eet the flexibility, reliab ility and perform ance requirem ents o f dem anding applications is know in g ly accepted.

M any co -sy n th e sis architectures.

m ethods

for distributed

em b ed d ed system s target v arying

H y p ercu b e topologies can be considered a superset o f a n u m b er o f T opologies such as m esh, torus, binary and quad B inary

other h ierarch ical architectures.

trees can be p a rtially represented by suitable sized hypercube topologies.

trees h av e ev en b een em b ed d ed in incom plete hypercube system s [51]. A hierarchical arch itectu re (e.g. tree to pology) is one o f the m ost p rev alen t system targets in the high perfo rm an ce d istrib u ted co-synthesis research projects [13, 14]. |

M uch o f th e w o rk o n autom atic architecture generation in co-synthesis alg o rith m s for d istrib u ted em b ed d ed system s has concentrated on hierarchical topologies [14]. A lth o u g h hierarch ical system s can be adapted to enhance th eir fau lt tolerant cap ab ilities [13], a com parison o f the tw o architectures is p rovided to illustrate the cap ab ilities o f h y p ercu b e topologies. C onsider a 3D hypercube w ith eight processing elem ents p resen ted in Figure 2.5. I f the com m unication link betw een PE° and PE '
t

;

I

30

R e p ro d u c e d with p erm ission of th e copyright ow ner. Further reproduction prohibited without perm ission.

fails, the device could still operate correctly by routing m essages along alternate channels (e.g. PE" PE"* PE^ --> P E '). System perform ance w ould decrease as

com m unication betw een nodes connected by a faulty link (e.g. PE" - P E ') w ould take longer (three transfers instead o f one). Elowever, m ost im portantly, the system will continue to function. N ow consider a possible hierarchical architecture

im plem entation o f the sam e em bedded device show n in Figure 2.6. If the equivalent com m unication link (connecting PE° and P E ') fails, P E ', PE^, and PE^ o f the em bedded device w ould cease to function as they cannot com m unicate w ith any o f the other PEs. This w ould result in a catastrophic system failure. T he benefits over alternative architectures w ere a m ajor m otivation for developing the first hardw aresoftw are co-synthesis algorithm targeting hypercube topologies.

31

R eoroduced with oermission of the coovrioht o w n e r. F u rth e r re o ro d u c tio n o ro h ih ite d w ith o u t o e rm ise io n .

PE'

I i

Broken Link
Figure 2.5: Example Hypercube Architecture

a
Broken

Link

PE°

«

PE

PE

Figure 2.6: Example Hierarchical Architecture

32

Ronrrvrll iP.oH \A/ith n o r m i c o i n n n f f h o n n n v / r ln h f nvA/nnr

P i i r f h n r m n r n H i m t i n n n r nhiK ifnX vA/liKm if

CHAPTER 3 CO-SYNTHESIS FOR HYPERCUBE SYSTEMS

3.1 Introduction

A co n stru ctiv e co-synthesis approach that targets a hypercube topology as the final system architecture is presented. The algorithm uses a library o f processing elem ents (P E s) including processor cores (C PU s) and application specific integrated circuits (A S IC s), w hich provides relevant data such as hardw are a re a requirem ents and p erform ance inform ation. The library can consist o f m any C P U types and A SIC s.

T he library also provides inform ation related to various types o f com m unication links available w ith their interconnectivity costs. representing the functionality o f the device. The algorithm takes in a task graph T he com m unication links are generic

and the co-synthesis algorithm supports all types o f com m unication links including serial, parallel, etc. T he algorithm assum es that each PE in th e hypercube system

consists o f eith er a C PU or an A SIC . In addition to this, each PE consists o f som e local m em ory for com putational purposes and interface circuitry for com m unication links.

T he constructive co-synthesis approach presented in this thesis is provided in Figure 3.1 and consists o f six m ain steps:

33

R eoroduced with oermission of th e coovrioht owner. Further reoroduction orohihited without oermission.

1) Specification; D efining the required device functionality and perform ance and area requirem ents. 2) Profiling; E valuating each functional unit in the specification for perform ance and area utilization data. 3) Group Based Fault Tolerance (GBFT); A heuristic technique for adding fault tolerance to an em bedded device at the task graph level.
Î

4) Scheduling; perform ance.

A technique for evaluating the current device architecture for

5) Add Processing Element;

A heuristic technique for adding an additional

processing elem ent (CPU or A S IC ) to the current device architecture. 6) Synthesize Communication Links; A technique for arranging the sy stem 's processing elem ents into a hypercube topology and synthesizing all

connecting com m unication links.

The first phase o f the approach is concerned w ith defining the device requirem ents. A lthough any specification language can be used, the experim entation presented in this thesis has been specified in C language. The second phase or the algorithm T he specification is m anually

involves the profiling o f the device specification.

converted into task graph form . Each task in the task graph represents a functional section o f the overall device. Each o f these functional sections are tim ed for

execution on each type o f processor available in the library. A dditionally hardw are alternatives to the softw are im plem entation are developed and are profiled for both perform ance and area utilization. T he profiling stage is com plete once the softw are

34

R e n r n d u c .e d w ith n e r m i s s i n n nf t h n n n n u rln h t n w n n r

F i i r t h n r r n n r n r l i i n tin n n r n h l h i t o r l w i t h n i it n o r m i c t i n n

and hardw are tim ing data and the hardw are area data have been collected for each task in the task graph.

T h e third phase is the group based fault tolerance (G B FT ) m ethod w hich is applied to the input task graph. T his heuristic w as developed to add a m inim al fault detection m echanism to the system and to sim plify fault recovery. The algorithm adds

additional assertion and duplicate/com pare tasks to the task graph. It m inim izes the fault detection overhead by exploiting a ta sk 's error transparency and com bining tasks into groups. The quantity and type o f spare PEs in the final device is set by the user. If a fault is detected by one o f the added tasks, an additional processing elem ent is signaled to com m ence execution o f the failed task group. This sim ple heuristic

provides a lo w overhead m ethod for perform ing node-fault detection and recovery.

T h e fourth phase is the scheduling te c 'in iq u e (see the " Scheduling" block in Figure 3.1). This heuristic m ethod w as developed to efficiently evaluate the current device architecture to determ ine if it m eets perform ance requirem ents. In order to im prove d ev ice throughput, the scheduling technique utilizes the established R E C O D retim ing h euristic to support pipelining o f the task graph [7]. The scheduler accurately

predicts overall device perform ance by scheduling tasks based on data dependencies. If th e scheduler finds a task execution configuration that allow s the current device architecture to m eet perfom iance requirem ents then the co-synthesis algorithm term inates successfully. If the scheduler is unable to schedule the task graph w ithin d evice perform ance constraints th e co-synthesis algorithm proceeds to the fifth phase.

35

R eo rod uced with oermission of the coovrioht owner. Further reoroduction orohihited without oermission.

T he fifth phase is concerned with the addition o l'a n o th e r processing elem ent to the system (see the "A dd Processing E lem ent" block in Figure 3.1). T his section o f the co-synthesis algorithm analyzes the current device architecture, the cu rren t task m appings, each ta s k 's hardw are/softw are perfom iance data and each task 's hardw are area data to determ ine the ideal type o f processing elem ent to add to the current system . I f this phase is successful in adding a processing elem ent to the system , the co-synthesis algorithm proceeds to phase six. If this phase is unsuccessful in adding another processing elem ent (unable to add m ore hardw are w hile still m eeting the device hardw are a re a constraint) the co-synthesis algorithm term inates unsuccessfully and provides the user w ith the partial solution generated.

I
T he sixth phase is concerned w ith arranging the system 's processing elem ents w ithin a hypercube configuration and synthesizing all o f the com m unication links (see the " S ynthesize C om m unication L inks" block in Figure 3.1). T his phase arranges all o f the processing elem ents w ithin a hypercube topology w hile attem pting to keep PEs w ith high levels o f intercom m unication w ithin close proxim ity o f each other. O nce all o f the system 's PEs have been arranged, com m unication links connecting the PEs are synthesized. O nce this phase has com pleted, the co-synthesis algorithm proceeds to the scheduling phase.

36

R e n m d u c e d w ith D s r m is g lo n o f t h e c o o v r io h t o w n e r .

F u r th e r r e n ro d u c tio n nrnh ih iteri w ith o u t n e r m is s io n

Specification

Profiling

GBFT

Scheduling

Constraints Satisfied?

Y es

Finish - Successful

No

Add Processing E le m e n t

No Successful ?

Finish - Unsuccessful

Y es

Synthesize Communication Links

Figure 3.1: Hypercubc Co-Synthesis Algorithm Flow

37

R o n m r l i i P - f a r l VA/ith n c a r m l c c i n n r \ f t h o r t n n v / r i n h t n v A /n o r

P i i r t h o r ro n rrv H i i/^ tin n n r n h i h i t c i H

iA /lthrvii+

n c s rm iG c lrv n

3.2 F a u lt T o le ra n ce a t the T a sk G ra p h L evel

3.2,1 Overview

T his subsection discusses the tw o m ain preexisting techniques for adding fault d etection/tolerance at the task graph level. A dditionally, section 3.2.4 presents an

original co ntribution to task graph based fault tolerance techniques. In all cases fault d etection is accom plished through the addition o f fault detection tasks to the task graph. T here are three types o f tasks that any o f the approaches presented m ay add to a task graph: assertion tasks, d u p licate tasks and com pare tasks. A n assertion task

w ill analyze another task 's output in order to determ ine w hether the generated results are erroneous. g rap h . A duplicate task reproduces the sam e w ork as an o th er task in the

T ypically a duplicate task w ill utilize an alternative im plem entation to that A com pare task w ill exam ine th e results o f tw o The addition o f an assertion task typically

used b y the task it is duplicating.

tasks to d etect any inconsistencies.

requires considerably less com putational overhead than the addition o f a duplicate and co m p are set. H ow ever, assertion tasks are n ot alw ays feasible. For an assertion task to be used, error states m ust be able to be detected by an alyzing the results. A n ex am p le assertion task could be the analysis o f a checksum or checking that the generated results lie w ithin an expected range. D uplicate and com pare tasks tend to require a m uch higher com putational overhead. First the entire ta s k 's functionality

needs to be duplicated and then both generated results need to be com pared.

38

R e o ro d u c e d with oerm ission of th e coDvriaht owner. Further reoroduction orohibited without oerm ission.

3.2.2 T ask Based Fault T olerance

T ask based fa u lt to leran ce (T B F T ) w as d eveloped by Y ajnik et al. [49]. T ask based fault to leran ce is a tech n iq u e desig n ed to add fault detection c ap ab ilities at the task g rap h level, in task based fault tolerance, som e form o f erro r d etectio n m ust be D ue to the

perfo rm ed fo r the resu lts gen erated by each node in the task graph.

sig n ific a n t d iffe re n c e in fault to le ran t o v erh ead , assertion tasks are fav o u red in the task based fau lt to leran ce algorithm . If a given task is capable o f su p p o rtin g D uplicate and com pare task s are only

assertio n s th e n an assertio n task is added.

ad d ed i f assertio n s are unav ailab le for the given task. To dem onstrate these concepts F ig u re 3.2 p ro v id e s an exam ple input task graph. Figure 3.2 also illu strates the

resu lta n t task g rap h a fte r pro cessin g by the task based fault to lerance alg o rith m . H ere all o f the task s in the g ra p h su p p o rt the use o f assertion tasks fo r erro r d etectio n w ith the e x c ep tio n o f task T3. T ask T3 has had duplicate and com pare task s added to

provide su p p o rt for fault detection.

39

R e o ro d u c e d w ith o e rm is s io n o f th e c o o v rio h t o w n e r. F u rth e r re o ro d u c tio n o ro h ib ite d w ith o u t o e rm is s io n .

TO

Assert TO T1 T1

T2

T3

T2

T3

Dupi. T3

Input

Assert T1 A ssert T2
Output

C om p. T3
Figure 3.2: Task Based Fault Tolerance Example

I

3.2.3 Cluster Based Fault Tolerance

C lu ste r based fau lt to lerance w as d e v e lo p e d b y D ave and Jh a [13].

T h is technique

w a s d e v e lo p e d as an e x ten sio n o f th e ideas p resen ted in the task b ased fau lt tolerance alg o rith m . M o d ificatio n s w ere m ad e to th e ap p ro ach in o rd e r to red u ce the In clu ster

su b stan tial fault to leran t o v erhead p rev a len t in task based fau lt tolerance.

40

R p -n m rli ir.e ri w ith n o r m k c i n n n f t h e c n n u r i n h t n u u n e r

F u r t h e r re n ro H i l e t i n n n r e h i h i t e r l vA/ithei it n o t ' m i e c . i n n

based fault tolerance, D ave and Jh a have introduced the concept o f erro r transparency [13]. If a task provided w ith an erroneous input alw ays produces an erro n eo u s output then that task is said to be error transparent. T his effect is exploited in th eir algorithm by g ro u p in g erro r transparent tasks into clusters w hich only require one assertion or d u p lic a te /co m p a re task. Figure 3.3 show s an exam ple task graph input and the results gen erated by one iteration o f the cluster based fault tolerance algorithm . Figure 3.4

sh o w s the resu lts after both 2 and 3 iterations o f the algorithm . Figure 3.5 show s the final c lu sters for the given input task graph. A fter all o f the tasks have been grouped into clu sters, each clu ster is given an assertion o r d u plicate/com pare task to perform e rro r d etectio n . F igure 3.6 sh o w s the final clustered task graph w ith the add itio n o f e rro r d e te c tin g assertion tasks. E ach cluster is n o w treated as a single task in o rd er to e n su re that all tasks w ithin a cluster are executed on the sam e processing elem ent. In th e e x am p le graph provided, all o f the tasks are assum ed to be error transparent.

T h e C B F T algorithm traverses a task graph based on task p rio rity levels th a t favour tasks th at are h ig h er in the graph. T he algorithm only allow s one o f a given ta s k 's ch ild ren to be added to th at ta s k 's cluster. C lu ster based fault to lerance also If a large

introduces the co ncept o f a m axim um tolerated error detection tim e.

n u m b er o f task s w ere grouped into one cluster and an erro r occurs in the u p p erm o st task, the e rro r state w ould not be detected until all task s in that clu ster have com p leted ex ecu tio n . T h is m ay be undesirable as it will ad versely affect perform ance. To avoid th is p ro b lem , D ave and Jh a have incorporated a user specified m axim um tolerated e rro r d etectio n tim e into the cluster based fault tolerance algorithm [13]. The

41

algorithm will not group m ore tasks into one cluster if the sum o f the softw are execution tim es o f those tasks exceeds the user specified m axim um erro r detection tim e. In the clu ster based fault tolerance algorithm , if an erro r is detected on a given cluster, th e entire fu nctionality o f that clu ster is m oved to a spare p ro cessin g elem en t and signaled to reco m m en ce execution.

TO

Cluster 1 / /

TO

T1

T2

T1

T2

T3
Input

T3
After 1 Iteration
:;

Figure 3.3: Cluster Based Fault Tolerance --Input & 1 Iteration

42

R e n ro d u c e d w ith o e rm is s io n o f th e c o o v rio h t o w n e r. F u rth e r re o ro d u c tio n o ro h ib ite d w ith o u t o e rm is s io n

C lu ste r 1 C lu ste r 1.

TO
C lu ste r 2

T1

T2

T1

T3
After 2 iterations

T3
After 3 Iterations

Figure 3.4: Cluster Based Fault Tolerance --2 and 3 Iterations
Cluster 1

TO
Cluster 2

T1

T2

T3

After 4
Iterations

Figure 3.5; Cluster Based Fault Tolerance - Final Clustering

43

R e p r o d u c e d with p e rm issio n of th e copyright ow ner. Further reproduction prohibited without perm ission.

C lu ste r 1

TO
C lu ster 2

T2

T3

T5
Assertion Tasks

T4
Figure 3.6: Final Added Assertion Tasks After Clustering

3.2.4 Group Based Fault Tolerance

T h is section presents a new and original technique for adding fault detection and to leran ce at th e task, graph level nam ed group based fault tolerance (G B F T ). T his

tech n iq u e w as developed as an extension o f the ideas presented in both the task based fa u lt to leran ce [49] and cluster based fault tolerance algorithm s [13]. M odifications w ere m ade to the ap p ro ach es in o rd er to reduce the fault to leran t o v erhead prevalent. T h is alg o rith m utilizes th e co ncept o f error transparency. G ro u p based fault tolerance a lso uses the co ncept o f a user specified m axim um tolerated erro r detection tim e.

44

I

R e p ro d u c e d with perm ission of the copyright ow ner. Further reproduction prohibited without perm ission.

In group based fault tolerance, the task graph is traversed from the low est nodes to the highest nodes. Each le a f node (bottom level node) is assigned to its ow n group. Each o f the l e a f s parents are analyzed to determ ine w hether they can potentially be added to the given l e a f s group. A parent is considered a possibility for grouping in its

c h ild 's group i f it is not already grouped and if adding it to its c h ild 's group will not violate the user im posed erro r detection tim ing constraint. O nce the set o f parents

eligible for grouping have b een assem bled for a given task, the parents are iteratively added to the group in ord er o f decreasing fault tolerant overhead. T his process is

ended if the addition o f an o th er parent task to the group will violate the user defined error detection constraint. I f a task has no children, its fault tolerant overhead is set to its assertion overhead. calculated to be:
m a x [ a s s e r tio n _ o v e r h e a d { c h ild r e n { i)) + C o m { i,c h ild r e n { i))] + a s s e r tio n _ o v e r h e a d (/)

If a task i does have children, its fault tolerant overhead is

w here, assertion_overhead(/) = the assertion overhead o f task / children(t) = set o f the child tasks o f i Com(z/, v) = com m unication tim e from task u to v across a com m unication link

Figure 3.7 show s an exam ple task graph input and the results generated by one iteration o f the group based fault tolerance algoritlim . Figure 3.8 show s the results after both 2 and 3 iterations o f the algorithm . Figure 3.9 show s the final groupings for the given input task graph. Finally, Figure 3.10 show s the final clustered task

45

Renroduced with nerm ission of the coovriaht owner. Further reoroduction orohibited without oermission.

graph w ith the addition o f error detecting assertion tasks. A m ore com plex exam ple o f G B FT based task groupings is provided in Figures 4.6, 4.7, 4.8 and 4.9 in section 4.2. A fter all o f the tasks have been grouped, each group is given an assertion or Each group is now treated as a

duplicate/com pare task to perfonn error detection.

single task in order to ensure that all tasks w ithin a group are executed on the sam e processing elem ent. In the exam ple graph provided, all o f the tasks are assum ed to be erro r transparent. In the group based fault tolerance algorithm , if an erro r is detected

on a given cluster, the entire functionality o f that cluster is m oved to a spare processing elem ent and signaled to recom m ence execution.

T he group based fault tolerance algorithm adds assertion and duplicate/com pare tasks to a task graph. It does not add assertion or duplicate/com pare tasks to perform

checks on the fault detection tasks that it adds. I f fault detection o f faults occurring in the G B F T added tasks is w anted, then it m ust be added m anually after the G B FT algorithm has com pleted execution.

46

R e n m d u c e d w i t h n A rm iR R in n n f t h n n n n v / r in h t n w n n r

F i i r t h p r r n n r n d n n t i n n n r n h i h i t o H vA/ithniit n o r m i c e i n n

TO

TO

T2

T1
Group 1

T3
Input
After 1 Iteration

T3

Figure 3.7: Group Based Fault Tolerance --Input & I Iteration

TO
Group 1 Group 1

TO

T1
After 2 Iterations/

T2

T2

T3

T3
After 3

Iterations
Figure 3.8: Group Based Fault Tolerance - 2 & 3 Iterations

47

R epro duced with permission of th e copyright owner. Further reproduction prohibited without permission.

' TO
/G roup 1

/ .V
1

T3

After 4 Iterations
Figure 3.9: Group Based Fault Tolerance - Final Grouping

TO
'Group 1

T2

T3

Assertion Task

T4

Figure 3.10: Final Added Assertion Task After Grouping

48

R e prod uc e d with perm ission of th e copvriaht owner. Further reproduction prohibited without permission.

3.2.5 Task Graph Based Fault Tolerance Comparison

A com parison o f the results o f th e group based fault tolerance algorithm w ith both the clu ster based and task based techniques is provided in order to evaluate the new ly developed G B FT technique. T hirteen random test cases were generated and the

o u tp u t o f all three algorithm s is com pared. T he test cases have varying task graph co n fig u ratio n s and varying user defined tolerated error detection tim es. o u tputted erro r detection inform ation from each algorithm is com pared. The

T he data

collected h a s been assem bled in T able 3.1. H ere the values under the G B FT , C B FT and T B FT colum ns are the counts o f erro r detection tasks added to the task graph. T h e few er num ber o f error detection tasks added to a task graph results in a sm aller fault tolerance overhead. A sm aller fault tolerance overhead is desirable as it will

y ield a fault tolerant device that utilizes less hardw are and/or less com putation tim e.

T he first random ly generated task graph has been provided in Figure 3.11.

Task

graph 4 corresponds to the task graph from the M PEG decoding case study. T he task graph can be found in Figure 4.1. T ask graph 5 corresponds to the task graph from the block m atching case study and can be found in Figure 4.6.

T h e infoim ation gathered in the table reveals that the group based fault tolerance technique yields a 18.75% im provem ent in fault tolerance overhead o v er the cluster

49

R eoro duced with oerm ission of the coovrioht owner. Further reoroduction orohibited without oermission.

based (dull tolerance technique and a 45.83% im provem ent over the task based (ault tolerance technique.

Table 3 .Ï: Fault Tolerance Comparison Data Task Graph # 1 1 1 2 2 3 3 3 3 3 3 3 3 4 4 4 4 4 4 5 5 5 5 5 Tolerated Error Detection Time (msec) 4 3 2 3 2 9 8 7 6 5 4 3 2
800 300 120 80 40

GBFT 2 3 4 7 7 1 2 2 3 3 3 4 5 1 15 14 17 21
22

CBFT 3 3 4 7 8 3 3 3 3 3 3 3 5 16 16 17 17 21  22 16 16 16 16 16

TBFT 8 8 8 11 11 9 9 9 9 9 9 9 9 22 22 22 22
22

34 150 000 40 000 30 000
20 000

22
22

1 13 14 15 16

22 22 22 22

15 000

50

R e p ro d u c e d with perm ission of th e copyright owner. Further reproduction prohibited without permission.

Figure 3.11: Randomly Generated Task Graph (Graph #1)

3.3 Pipelined S chedu ler

T h e functionality described in this sub-section occurs in the `"Scheduling'' block in F igure 3.1. T h e effectiveness o f a given architecture alternative is ev aluated by

o b tain in g a pip elin ed schedule that is executed in the algorithm 's sch ed u lin g phase. A pip elin ed sch ed u le w ith a m inim um period P is an assignm ent o f co m p letio n tim es o f all tasks, F (v)^ such that for all tasks v in the system 0 < = F (v) < - P . For a task v

51

R e o ro d u ce d with oerm ission of th e coovriaht owner. Further reoroduction orohibited without oermission.

w ith a data dependence e = (u. v j. w here u is a parent o f v, the schedule tim e o f v m ust h onour the follow ing equation; /· (V ) > /· (II) + V ,,,, +C{IKV) A -( w here,
Vexec ~ execution tim e o f task v C(xi, v) - the overall com m unication tim e betw een m apped tasks u and

if P S M a tc h (u, v) otherw ise

V (0 i f no com m unication)
P S M a tc h (u , v) = true if tasks u and v are located on the sam e pipelined

stage, false otherw ise

T his definition requires that a task will not com m ence execution before receiving the required data from all parent resource usage into account tasks. The scheduler takes com m unication delays and w hen assigning tasks to p ro cessin g elem ents. T he

algoritlim utilizes the established R E C O D retim ing tran sfo rm atio n to divide the task graph into m ultiple pipelined stages [6, 7].

T he R E C O D retim ing transform ation divides a task graph into m ultiple pipelined stages by inserting a cut-line w hich separates tw o tasks (parent and child) and defines the separation betw een two pipelined stages. The location o f this cut-line is

dep en d en t on the parent and c h ild 's cu iren t pipeline stage, the parent and c h ild 's m apping, the length o f the constraining path o f the parent and the am oun t o f inform ation passed betw een the parent and child.

52

R e o r o d u c e d w ith o e r m i s s i o n of t h e c o o u r in h t o w n e r

F u rth e r re n ro rin n tin n n rn h ih ite d w ith o u t o e r m is s io n

Initially, the R E C O D tran sfo rm atio n is repeatedly used to divide the task graph into a m axim um n u m b e r o f pip elin ed stages. A fter perform ing th e R E C O D retim ing

tra n sfo rm atio n , the sch ed u ler attem p ts to assign com pletion tim es to all tasks to satisfy d e v ic e p e rfo rm a n c e requirem ents. If unsuccessful, the algorithm attem p ts to

im prove the ta s k a llo c atio n s iteratively in order to m inim ize device co m m u n icatio n overhead. A flo w d iag ram o f th e sc h ed u le r's o peration is provided in F igure 3.12.

53

R ctn rn H l irtoH

\A /ith

n o r m ic .c in n o f r h o o o n v /r lo h f ovA/ncsr

P n i 't h o r rooroW i lo tlo n orohiK iFo/4

v A /iF h o i

iF r \ o

r m

1e e i / - \ r

Successful?

Schedule

Yes Consiraints Satisfied?

Finish - Constraints Satisfied

No

Improved ^ from P revious S c h e d u le ? ^

No

Remap Task Back

Y es

Finish - Constraints not Satisfied

iterative Improve

Figure 3.12: Hypercube Co-Synthesis Scheduler

F or th e p u rp o ses o f sc h ed u lin g (" S c h e d u lin g " b lo ck in F igure 3.1), each task from the input task graph is assig n e d to o n e o f th e three sets, m , n and p . In o rd e r to specify the llrs t set, p a l h L o a d C h i ld , p a l h L o a d P a r e n t and p a l h L o a d v a ria b le values arc assig n ed to each task v. T hese v alu es are defin ed as:

54

R e p r o d u c e d with p e rm issio n of th e copyright o w ner. F u rth e r reproduction prohibited without perm ission .

p a lliL o a d C h 'ld {v ) = p ath L o a d P a rent {v) =

+ max{PSMalc/i{v.chilcJrL>n(v))* pa(l}LouclCliild(chiUixni,\'))\ + m v i\{P S M a tc h {\\ p a re n ts {v)) * p a th L o a d P u r e n t{ p a r e n ts ( v ) )}

p a lh L o a d (v ) = p ath L o a d C h ild {v ) + path L oadP aren t{v) -

w here, PSM atch(w , v) = 1 i f tasks u and v are located on the sam e pipelined stage, 0 otherw ise children(v) = set o f the child tasks o f v parent(v) = set o f the p a re n t tasks o f v

A s a result, a task v 's p a l h L o a d is the value o f the heaviest loaded path co n tain in g task
V.

T h e first set o f tasks m is defined as; 3 m A T -->( p a lh L o a d ( m ) = = m a x { p a th L o a d ( A T ) J ) w here, 3, , and = rep resen t th e r e e x is ts , s u c h th a t and e q u iv a le n t

respectively A T is th e set o f all tasks

S et m is th e set o f tasks th at are located on the co nstraining path and are scheduled first. S et w consists o f all the task s having a path to m . T he second set as: /7 = M ' - m. S et n c o n sists o f task s that are an cesto rs o f all the tasks o f set m e x c lu d in g the m em bers o f set m . is defined

55

R e n r o d u c e d with nerm ission of t h e coovrioht ow ner. Further r e o r o d L i c t i n n n r n h i h i t e r l w i t h o u t n o r m i R s i n n

The final sel p . is defined as; p = A T - m - n . Set p consists o f the rem ain in g ungrouped tasks and will be scheduled last.

T hese sets are used to p rio ritize the tasks for scheduling. T he c o n strain in g path is th e longest path th rough the g rap h in te n u s o f the execution tim es o f its tasks. W hen

scheduling a task o f set m that has unscheduled parents, the p arents are sch ed u led first. D ividing tasks into th ese set configurations prioritizes task s located on the T he task s on the co n straining path are m ost likely to a d v e rse ly

constraining path.

affect the target device perfo rm an ce and so th e m o tivation is to sch ed u le them first. If a system sch ed u le is o b tain ed th at m eets th e perfo rm an ce req u irem e n ts, the schedule function exits successfully, otherv\'ise the scheduler attem p ts to im p ro v e iteratively. E xcessive co m m u n icatio n s is a potential problem in h y p ercu b e to p o lo g ies as th ey can slo w dow n overall system perfo rm an ce by cau sin g PE s to w ait fo r data. W hen tw o task s are lo cated far from each o th er in the arch itectu re, c o m m u n ic a tio n b etw een them m ay require m ultip le hops. In o rd er to alleviate this potential p ro b lem , the algorithm in clu d es an iterativ e im prover (as labeled in F igure 3.12) w h o se goal is to refin e the task m apping. T he value c o m m L e v e l for each task is defined as:
comm Level (v, PE) = ^ Com{v, x) * Nh{v, x) + ^ Com(ii, v) * Nh{u, v)

w here,
C o m (u , v) - co m m u n icatio n tim e from task « to v across a

co m m u n icatio n link
N (u , v) = n u m b er o f links (hops) that m ust be traversed to

co m m u n icate betw een tasks z/ and v

56

R e o ro d u c e d w ith o e rm is s io n o f t h e c o n v rio h t o w n e r. F u r t h e r r e n r n r i i i o t i n n n r n h i h i t e d w i t h n i i t n o r m i c e i n n

X = c h ild r e n ( v )
u = p a r e n ls ( v )

A task q is se le c te d fo r re-m ap p in g b ased on the follow ing equation:
execTime{v,execLoc(v)) + comm Level {v, exec Loc{v)) execTime{v, APE)

q = arg max

+ commLevel{v. APE)

w here,
e x e c L o c ( v ) = the ex ecu tio n location (PE) o f task v e x e c T im e (v , P E f) = the e x e cu tio n tim e o f task v on P E f A P E = th e set o f all p ro cessin g elem ents

T he ab o v e eq u a tio n se le c ts task q for m ap p in g based on total perfo rm an ce gain. T a sk
q is su b seq u e n tly rem a p p ed to a n e w pro cessin g elem en t to im prove th e overall

e x e cu tio n and c o m m u n ic a tio n tim es.

T his process is repeated as lo n g as th e

sc h e d u le r rev e a ls co n tin u e d im p ro v em en ts in th e overall solution. W hen th is iterativ e p ro cess does not p ro v id e any fu rth er im provem ents, the sc h ed u le r e x its

u n su ccessfu lly .

T h is tech n iq u e w as inco rp o rated in order to help m in im iz e any

u n n e c essa ry c o m m u n ic a tio n s.

3.4 D ev ice E xpansion

T he fu n ctio n ality d e sc rib e d here is execu ted as p art o f th e "A dd P ro c essin g E le m e n t'' block o f the d esig n flo w given in F igure 3.1. T h is co-synthesis section is resp o n sib le

57

R e p ro d u c e d with pe rm issio n of th e copyright ow ner. Further reproduction prohibited without p erm ission.

for expanding the cu rren t system architecture to include an additional processing e lem en t (PE). The PE type can be a CPU or an application specific integrated circuit (A S IC ). T h e prim ary focus o f th is function is to determ ine th e m ost effective type o f PE to be added. T he addition o f a PE should p rovide a m axim um perform ance I f the addition o f a PE

enhancem ent w ith a m inim um additional hardw are area.

causes a vio latio n o f the hardw are area constraint, the function ex its unsuccessfully. O therw ise, the function w ill add a new P E and exit successfully. In order to m ake a k no w led g eab le decision on w hich PE to add, th e algorithm estim ates th e ratio o f e xpected p erform ance im provem ent due to the increase in hardw are area fo r all the available options. F or these calculations the variable, s p e e d u p S W is included as a

p relim inary estim ate o f p erform ance im provem ent due to the addition o f a n o th e r CPU and defined as:

*(1- rp/(rp+1))
w here, TSWexec(v) = the total execution tim e o f all tasks m apped to SW from set V
T P = the count o f total C PU s in the current system architecture

T he v a ria b le r a t i o S W x s defined th at estim ates the perform ance to hardw are area ratio for a d d in g a C P U and is defined as:
ra/ioS W = ExL * speedupSW /PA C

w here,
P A C = the area cost for the addition o f another CPU

58

R e p ro d u c e d with perm ission of th e copyright o w ner. Further reproduction prohibited without permission.

I
E x L - the expected load o f the new processor

E x L is provided to w eight the decision o f adding a new processor based on the

expected load that processor w ould receive. E x L is defined as:
E xL = Q E x L = C S T /(k * T P ) E xL = 1 \ÏCST< ^TP

if OE T > r f and OE T <
otherw ise

w here,
C S T = the co u n t o f tasks currently m apped to softw are

As an estim ation, it is assum ed that if the current system architecture contains k tim es as m any tasks m apped to softw are as there are C PU s, then the new ly added processor w ill be provided w ith a full task load. The value k is user set. T hese equations w ere selected to quickly approxim ate the expected am ount o f speedup obtained by adding an additional C PU to the system .

W ith respect to the speedup and ratio factors for adding new A S IC s, a task set v is declared as the set o f all tasks currently m apped to softw are. The s p e e d u p H lV [ v ] and
r a tio H W [ v ] array variables are then calculated for the set o f tasks in v.

Each

individual r a t i o H W value represents an expected im provem ent factor for m oving the given task from its current location in softw are to an A SIC im plem entation. The

s p e e d u p H W [ v ] represents the difference betw een the execution tim e o f task v in

softw are and in hardw are.

In order to define r a tio H W the variables iC o u ld B e n and

59

R eproduced with permission of the copyright owner. Further reproduction prohibited without permission.

tW iU B e n are created.

T he tC o u ld B e n [ v ] variable is defined as the count o f tasks T he tlV illB e n [ v J

having an identical hardw are configuration pattern as task v.

variable is defined as the count o f tasks having an identical hardw are configuration pattern as task v and is currently m apped to softw are. The r a tio H W [ v ] is defined as;
speedupHlV[v] tWillBen{v] -1 tCouldBen[v'\

X(v)

w here,
A ( v ) = the area cost for the hardw are im plem entation o f task v

The above form ulation encourages the selection o f hardw are solutions that can be reused by m ultiple tasks. All o f the ratio values (both hardw are and softw are)

obtained are com pared and the m axim um value is used to decide the PE type to be em ployed in the expansion. W hen the PE being added is an A SIC
{P E a s ic )-,

the

function assigns a m axim um num ber o f tasks w ith m atching configuration patterns to the new ly added A SIC , given that the follow ing constraints are met: ^ tim C ons where,
tim C o n s = the user specified device tim ing constraint P T (P E ) = the set o f tasks allocated to processing elem ent PE THW exec(v) = the total execution tim e o f all tasks m apped to H W from

set V

60

R e p ro du ce d with permission of the copyright owner. Further reproduction prohibited without permission.

W hen the added PE is a C PU , the function m ust decide w hich tasks will be initially allocated to the new C PU . The task to be allocated to the new processor is

selected from the processor identified by the variable Pdonor in the follow ing equation;

w here,
A P is the set o f all processors

The above equation ensures that the donor processor w ould alw ays be the m ost heavily loaded. T he task w ith the low est com m unication overhead w ith respect to the other locally allocated tasks is selected for rem apping from the donor process. This is intended to m inim ize the com m unication overhead and sim plify the iterative process for the scheduler. A fter this task has been reallocated to the new PE, the selection o f a donor processor and a task is repeated until the new C PU load reaches the average processor load. To accom plish this, the variable loadAverage -

/TP is defined,

w here T P is the total n um ber o f processors. T his process is repeated until an allocation is obtained such that the difference betw een the load on the new processor and the average load is a m inim um .

W hile adding new hardw are, the algorithm tracks the overall area o f the device to ensure an accurate prediction o f the final system cost. The hardw are area overhead associated w ith each com m unication interface located at each PE node is recorded, in ad dition to the cost o f each com m unication link.

61

R e p ro d u c e d with permission of the copyright owner. Further reproduction prohibited without permission.

3.5 C om m unication Link Integration

The lunctionality described here is executed in the " Synthesize C om m unication L inks" block o f the design flow provided in Figure 3.1. This section o f the co 

synthesis algorithm is responsible for connecting all the system P Fs and assignm ent o f com m unication links to fomn a hypercube topology. To lim it the com m unication overhead, the processing elem ents w ith high levels o f inter-com m unication are placed as close as possible in a hypercube topology. A n array o f com m unication coefficients is defined, c o m C o e ff[ T P E ] (w here T P E = the count o f total processing elem ents), for each processing elem ent. The c o m m C o e ff for processing elem ent PEn w ith respect to PEn, is defined as:

w here,
P E T ( P E ) = the set o f tasks currently allocated to P E P E A r r a y - the array o f all processing elem ents

In o rd er to clarify the process o f assigning specific locations to each processing elem ent w ithin the fram ew ork o f a hypercube architecture, the established binary nam ing convention for labeling nodes is utilized [29]. T he binary nam ing convention in a 3D hypercube is show n in Figure 3.13. T his nam ing convention is convenient for m essage routing and the num ber o f com m unication hops betw een two nodes can be

62

R e p ro d u c e d with permission of the copyright owner. Further reproduction prohibited without permission.

quickly determ ined by the num ber o f bit-w ise m ism atches betw een the binary identifiers for each node.

110

010

O il

100

101

000

001

Figure 3.13: Binary Naming for Hypercube Nodes

Initially, the first C P U is placed at location 000. Subsequently, each location (hA^ is filled by the PE nam ed in the variable s e le c le d P E by the follow ing definitions: 3 p e in A P E ~ ^ h e ( h N , B L (p e ))
selectedPE = arg inax( ^ PEArray[n].comCoeff\LJPE])

w here.

63

R e o ro d u c e d with Dermission of th e coDvriaht owner. Further reoroduction orohibited without oermission.

A P E = Ihc set, o f all processing elem ents currently assigned to a

specil'ic hypcrcube location
B L (p e ) = the binary num ber that processing elem ent p e is assigned to h e (h N , h M ) = the hypercube edge connecting binary location h N to

binary location h M
L IF E = the set o f all processing elem ents currently unassigned to a

specific hypercube location

The next PE to place in the hypercube is selected from the set o f unassigned PEs. The P E is selected such that it has the largest com m unication coefficient w ith respect to the already assigned PEs that w ill be its neighbour. T his process is repeated until all the PEs arc allocated to hypercube nodes. T his heuristic w as selected to m inim ize the occurrence o f long com m unication delays.

The co-synthesis algorithm does not require the hypercube architecture to be perfectly sym m etrical. I f all the processing elem ents are not a pow er o f tw o, som e o f the PEs will have few er com m unication links than the others. T his is generally considered

undesirable as one o f the advantages o f hypercube architectures lies in its innately fault-tolerant topology. C onsequently, if the total num ber o f processing elem ents is not a pow er o f tw o, an additional com m unication link to com pensate fo r the shortage in the m ost recently added PE is introduced. T his com m unication link connects the PE in the highest binary location ( fin a lP E ), with a d e s lin a lio n P E . In order to

determ ine the d e s lin a lio n P E , the set o f processing elem ents, n e ig h is defined as the

64

R e p ro d u ce d with permission of the copyright owner. Further reproduction prohibited without permission.

se t o f PE s that share a neig h b o u r w ith the f m a l P E .
d e s lin a lio n P E , is selected to be the task identified by:

T he processing cicm cnl

ma.x{PEArra]{ finalPE]£omCoqfj\n])

w hile n e n e ig h

T he above equation w as selected to connect the final PE with the com patible PE with w hich it com m unicates m ost often. To illustrate this exam ple consider Figure 3.14, w here a 5-node hypercube is provided and the final com m unication link will connect the PE at node (100) to the shaded PE w ith which it com m unicates m ost. As

previously m entioned, one o f the advantages o f hypercube topologies is its inherent fault tolerant capabilities. T he m otivation for the above heuristic is to elim in ate the potential catastrophic failure th at could occur if the com m unication link connecting node (000) and (100) fails. sym m etrical hypercuhe system s. T his heuristic preserves fault tolerance in non-

65

R e p ro d u ce d with perm ission of th e copyright owner. Further reproduction prohibited without permission.

011

100

000
Figure 3.14: Non-Symmetrical 3-D Hypcrcube

In sum m ary the approach consists o f six phases. T he first three are perform ed once, and th e final tliree are repeatedly executed until a final device arch itectu re has been generated. T he first phase is responsible for clearly defining the d e v ic e 's functional and non-functional requirem ents. T h e second phase is concerned w ith co n v ertin g the functional requirem ents into task graph form and gathering all o f the relevant data needed in the later phases. The th ird phase adds fault detection tasks to the task The fourth phase involves

graph, thus facilitating lo w overhead fault tolerance.

ev aluating the d ev ice's p erform ance and determ ining if it m eets non-functional perform ance requirem ents. The fifth phase is concerned w ith ad d in g a processing

66

R e p ro d u c e d with permission of the copyright ow ner. Further reproduction prohibited without perm ission.

elem ent to the system .

F inally, the sixth phase is responsible ib r sy n th esizin g all o f

the d e v ic e 's c o m m u n ic a tio n links.

67

R e p ro d u c e d with p erm ission of the copyright ow ner. Further reproduction prohibited without perm ission.

CHAPTER 4 IM P L E M E N T A T IO N A N D E X P E R IM E N T A L R ESU LTS

4.1 P arallel M P E G -2 D ecod in g

A n effe c tiv e d em o n stratio n o f the c ap ab ilities o f the c o -sy n th esis algorithm w ould h a v e to involve an a p p lic atio n that is c o m p u tatio n ally intensive. d e m o n stra tiv e p u rp o ses it is beneficial to A d d itio n ally , for

im p lem en t a d ev ice th at is easily

u n d e rsto o d . A m u ltip le PE em b e d d e d d ev ice w as im plem ented, w h ich is resp o n sib le for d e c o d in g 16 M P E G -2 video stream s and sim u ltan eo u sly co m p arin g th e ir decoded im ag es to p red efin ed data. S uch a d ev ice co u ld be used in a u to n o m o u s n a v ig a tio n or se cu rity system s. T h e d evice w as fully sp ecified in C language en c o m p a ssin g 9500 lin es o f code. A task g rap h re p re se n ta tio n w as o b tain ed by an alysis o f the T he fu n ctio n ality o f the system is

sp e c ific a tio n and is pro v id ed in F ig u re 4.1.

e x p re sse d as a g rap h o f 22 tasks. T h e d esig n space o f the a p p licatio n has been tested in term s o f d evice a re a an d tim in g co n strain ts in ord er to ev aluate the p erfo rm an ce o f the p resen ted approach. T h e te st and e x p erim en tal resu lts are p ro v id ed in F igure 4.2. The results o f an optim al tec h n iq u e th a t ex h au stiv ely attem p ts each p o ssib le T his is useful fo r d em o n stratin g the q u a lity o f the

c o m b in a tio n is also included.

a lg o rith m and its resu lts as co m p ared to th e op tim al solution.

68
R e o ro d u c e d with o e rm issio n of th e coo vriah t o w n e r. F u rth e r re o ro d u c tio n o ro h ib ite d w ith o u t o e rm is s io n .

Initialization

16
MPEG D ecoders

P a s s e s One Frame

20

R eg io n a l Comparison

P asses H ig h e st Correlation Frame X Final

22

/ Comparison J S tage

Figure 4.1: Parallel MPEG Decoding: Functional Task Graph

A se t o f h a rd w are and softw are im p lem en tatio n data is provided to th e alg o rith m . In ord er to estab lish the softw are execution tim es for each task, the C language based sp ecificatio n w as profiled on a P entium II 4 5 0 M H z C P U . T h e a lg o rith m library can co n sist o f m an y C PU types how ever, for sim p licity and practicality only th e Intel P entium II 4 5 0 M H z C PU w as included for this case study. E ach o f the tasks w ere

fully im p lem en ted in h ard w are and profiled for perfo rm an ce and h a rd w a re area req u irem en ts on an A ltera F L E X IO K E FPG A . T he only exception is the M P E G -2

69

R e p r o d u c e d with perm ission of the copyright ow ner. Further reproduction prohibited without perm ission.

d e c o d in g tasks, w here the p re-ex istin g IP core from A m phion S e m ic o n d u c to r w as utilized for the hardw are im plem entation. T ab le 4.1 provides info rm atio n reg a rd in g the quan tity o f each type o f PE used for each o f the design co n strain ts studied.

T he c o -sy n th e sis algorithm provides support for fault to leran t co m m u n ic a tio n s by g en eratin g th e targ e t d ev ice into a hypercube architecture. By u sin g th e g ro u p -b ased fault to leran ce tech n iq u es (G B F T ) p reviously outlined, a fault to leran t em b e d d e d d ev ice has been synthesized. The G BFT algorithm adds a sse rtio n and

d u p licate/co m p are tasks to the task graph.

U pon d etection o f a failu re, the

a sse rtio n /co m p a re task signals one o f the spare PE s to c o m m en ce e x e cu tio n o f th e failed task. T h e type an d num ber o f spare PE s are defined by the user. It sh o u ld be noted that in o rd er to co m p are th e algorithm w ith the optim al case th e G B F T sectio n o f the algoritluu had to be disabled. T he G B F T algorithm w ould su b sta n tia lly T he o p tim al ap p ro ach is

in crease the total n u m b er o f tasks in the task graph.

ex trem ely c o m p u ta tio n a lly in tensive and unable to generate resu lts for larg er task g rap h s w ithin a reaso n ab le am o u n t o f tim e. A lth o u g h n o d e fault to le ran t v ersio n s o f this c a se study have b e e n sim u lated , the d ata presented illu strates resu lts o b tain ed w ith o u t the use o f the G B F T p o rtio n o f the algorithm . F u rth er an aly sis th a t includes the e rro r d etection tasks added by the G B F T portion o f the alg o rith m is p ro v id ed in section 4.2.

70

R e p r o d u c e d with pe rm ission of th e copyright o w ner. F urther reproduction prohibited without perm issio n.

15 ------ O-- Device Constraints ·   Device R esults - -A- - Optimal Device

I
(0

2
n

c
c

o E
3 < 0) Ü

I

30

40

50

60

90

120

130

600

770

Device P^iod (msec)

Figure 4.2: Design Space Exploration of Parallel MPEG Decoding

I
T h e resu lts p ro v id ed in F igure 4.2 d e m o n stra te the ab ility o f the m ethod to sy n th e size em b e d d e d dev ices w ith vary in g d esign co n strain ts. A c o m p ariso n o f h a rd w a re a re a to p erfo rm a n c e tra d e -o ffs can be very useful to an em bedded en g in e e r in o rd er to ex a m in e d ifferen ces betw een d esign altern ativ es. T he resu lts from using an

e x h a u stiv e (optim al) m ap p in g tech n iq u e is a lso provided. T h e ex h au stiv e a p p ro ach a tte m p ts all the p o ssib le co m b in atio n s an d is v ery c o m p u ta tio n a lly intensive. C o m p ariso n results from the c o -sy n th esis alg o rith m w ith th o se obtain ed by the optim al tech n iq u e rev ealed that the alg o rith m p ro d u ces em b ed d ed d e v ic e s w ith 9 6 .2 5 % o f the perfo rm an ce o b tain e d by the o ptim al tech n iq u e on average.

71

R e p ro d u c e d with p e rm issio n of th e copyright o w ner. F urther reproduction prohibited without perm ission .

A d d itio n ally , the em b ed d ed devices generated by th e algorithm o nly utilized 0.62 (average) m o re hard w are than the devices obtained by the optim al m ethod.

Table 4.1: Processing Element Utilization of Design Space for MPEG Decoding
Area Constraint (millions of transistors) 13.5 11.5 ]1 10.5 9.5 9 8.5 7.6 7.5 Timing Constraint (msec) 30 40 50 60 90 120 130 600 770 Initial HWTask 1 1 0 0 0 0 0 0 0 0 MPEG-2 Decoding Cores Tasks 2-17 6 4 3 3 2 1 1 0 0 HW --Reg. Comparison Tasks 18-21 1 1 1 1 1 1 I 1 0 HW - Final Comparison Task 22 1 1 1 1 ! 1 0 0 0 Total PEs Exec. Time (msec) 35.2 14.8 11.2

Qpiimsà

\

10 7 6 6 5 4 3 2 1

e s s e ' E x e e i S S s i rj 1 -2 4 j
!

1
13.5 7.9 4.2 3.4 1.6 0.8 -3 4 «rs -3 4 ^ 1 !

! !

IM h r s i m s

1

T ab le 4.1 p ro v id es d etailed inform ation regarding the configuration o f each solution that the co-synthesis algorithm produced. G iven the design constraints p ro v id ed in

the first tw o co lu m n s, the algorithm generated a device that could m eet specification^'. T he next fo u r colum ns (3-6) provide the count o f various A SIC circu its p rese n t in tk s final sy n th esized system . T he total PEs colum n pro v id es a co u n t o f the total nm nse? o f P E s present in the given device. The count o f C P U s in the table have not hcen T he execution tim e colum n sW % r

included as th ere is only one C PU for each case.

72

R e p ro d u c e d with perm ission of th e copyright o w ner. Further reproduction prohibited without perm ission.

th e length o f tim e the algorithm took to execute on a Pentium IV in order to synthesize the device. The final colum n provides the approxim ate execution tim es Figure 4.3 provides the final device

from perform ing exhaustive co-synthesis.

architecture fo r the first test case provided in table 4.1. Figure 4.4 provides the final d evice architecture fo r th e second test case. The architecture for th e fifth test case is provided in Figure 4.5.

I
MPEG D ec o d e

.0110
MPEG D ecode

Init

MPEG D ecode

001

001

MPEG D ecode
1100

MPEG D ecode
1101

CPU

Regional ' Comparison.

MPEG D eco d e

Final
Comparison

tooo

0001

1000

1001

Figure 4.3: Parallel MPEG Decodir g: Architecture for 1* Test Case

73

R eproduced with perm ission of th e copyright owner. Further reproduction prohibited without permission.

110

Final

\

Comparison

MPEG Decode

Regional 1 Comparisoni O il

010

MPEG Decode

MPEG Decode

100

101

C PU

MPEG Decode

000

001

Figure 4.4: Parallel MPEG Decoding: Architecture for 2" ** Test Case

74

R eprod uced with perm ission of the copyright owner. Further reproduction prohibited without permission.

I
010

MPEG Decode

Regional Comparisoi

011

I:
Final
Comparison

100

CPU

MPEG Decode

000

001

Figure 4.5: Parallel MPEG Decoding: Architecture for S"* Test Case
&

4.2 Parallel B lock M atching

A n effective dem onstration o f the capabilities o f the co-synthesis algorithm w ould have to involve an application that is com putationally intensive. A dditionally, for

dem onstrative purposes it is beneficial to im plem ent a device that is easily understood. In the previous case study a device has been im plem ented that utilizes 16 M PE G decoders. M PEG decoding is the process by w hich a com pressed video file is uncom pressed for the purpose o f view ing or accessing the raw image data. F or the second case study, the block m atching algorithm has been im plem ented. M PEG and o th er video com pression form ats are designed for fast transm ission / easy storage o f

75

R e prod uc e d with perm ission of the copyright owner. Further reproduction prohibited without permission.

video data.

In order for such a form at to be useful, the decoding process m u st be

relatively fast. In order to efficiently com press the video data for easy d ecoding, a com putationally intensive encoding algorithm m ust be run. Block m atching is the

m ost tim e consum ing com ponent o f M PEG encoding. B lock m atching analyzes the m acroblocks from the input im age and com pares them w ith the surrounding a re a on the reference im age. By analyzing all possible locations, an exhaustive block

m atching algorithm will generate m otion vector data indicating the m ovem ent o f a given m acroblock from one im age to the next.

A m ultiple PE em bedded device responsible for perform ing the block m atching algorithm has been im plem ented. Such a device could be used fo r any application

involving the acquisition o f video data. The device is fully specified in C language. A task graph representation is obtained by analysis o f the specification and is provided in Figure 4.6. The functionality o f the system is expressed as a graph o f 22 tasks. T he group based fault tolerance (G B FT) techniques previously o utlined have been used and the resultant task grouping is provided in Figure 4.7. T he G B FT

grouping results in the addition o f the assertion tasks show n in Figure 4.8. T he final resultant task graph after G B FT has been perform ed and each group has m erged to becom e a single task is provided in Figure 4.9. Further discussion o f how the G B FT algorithm groups tasks together is provided in section 3.2.4.

76

R e p ro du ce d with perm ission of the copyright owner. Further reproduction prohibited without permission.

Initialization

I Fram e Blocktnalching

P a s s e s One V ector

V ector Assembly

Final V ector Assembly

Figure 4.6: Block Matching: Functional Task Graph

77

R e p ro du ce d with permission of the copyright owner. Further reproduction prohibited without permission.

G roup

Group 3 G roup 4

G roup 15 G ro u p /G

G roup

F ig u re 4.7: B lo ck M a tc h in g T a s k G r a p h : G B F T G r o u p in g

78

R e p ro d u ce d with perm ission of th e copyright owner. Further reproduction prohibited without permission.

Group

Group 3 Group 4

Group 2 Assert Group 3 Assert

Assert
Group 16 Assert Group 15 Assert

g
Group 1

Assert

Figure 4.8: Block Matching Task Graph with Added Assertion Tasks

79

R e p ro d u c e d with perm ission of the copyright owner. Further reproduction prohibited without perm ission.

Inilializalion and 1 Blockmalching

Init Assert

j 4

1 BlockMalch

Group 3 Assert / BlockMalch Assert

1 Blockmalching and all Vector Assembly

Final Assert

Figure 4.9: Block Matching: Final Resultant Task Graph

The m ost com plex task in the device outlined is the block m atch task. In order to obtain pertinent hardw are perform ance and area inform ation for all tasks, the functionality needs to be im plem ented in hardw are. T his task has been im plem ented w ith the design provided in Figure 4.10. Y ang et al. have presented an entire m otion estim ation architecture w hich utilizes a sub-circuit responsible for error calculations that is sim ilar to the im plem entation in Figure 4.10 [50j. Dutta and W o lf have presented a flexible m otion estim ation architecture [17] based on the research o f Y ang ct al. In the design presented, the d iff circuit calculates the absolute difference betw een the two input values. 'I'he absolute d ifference betw een the corresponding

80
R e p ro d u c e d with perm ission of th e copyright owner. Further reproduction prohibited without perm ission.

pixel values o f the tw o input im ages is the error at the given point. T h e ad d er c irc u it ad d s the c u rre n t error to the p rev io u sly calculated errors to sum the overall e rro r for a given vector. T he co m p ariso n circuit com pares the tw o input values and if th e new v a lu e is low er than the old value, the c irc u it outputs the n ew value and latc h es the c u rren t 1 and J values into an internal register. T hese I and J values rep re sen t the cu rren t m o tio n vector. T he control unit track s the current state o f the circu it and sig n als all su b circuits, registers and outp u ts accordingly. A form al d e scrip tio n o f the functionality o f the d ev ice is pro v id ed in the V H D L code in A ppendix A.
Control

addByle

allDone

Start

tutienl rn B y le *
current J

OUll' outJ

g

Adder

Conrpare

I

I
Register Register

F ig u re 4 .10: B lo ck M a tc h C ir c u it D esign

81

R e p ro d u c e d with p erm ission of the copyright ow ner. Further reproduction prohibited without perm ission.

T his b lo ck m atch circu it op erates using a state m achine w hich is a d m in iste re d in the control unit and is p ro v id e d in F igure 4.1 1. State 0 is the initial state w hen the circuit is w a itin g for input. In state 1 the c irc u it h as ju s t received an ev en n u m b ered c o u n t o f in p u ts a n d as a result, th e ad d er reg iste r is signaled to load the ad d e r c irc u it g enerated value. In state 2 the c irc u it has ju s t received an u n ev en n u m b er o f inputs. I f the circ u it has receiv ed 512 in p u t v alu es, the c irc u it tran sitio n s to state 3 and signals the c o m p a re su b -c irc u it to beg in ex ecu tio n , o th erw ise the circuit retu rn s to state 1. In state 3 th e co m p a re re g iste r is signaled to load the com pare c irc u it g e n e ra te d error v alue. In state 4 the a d d e r reg ister is in itialized a n d the in co m in g d a ta is loaded into the in p u t register.

82
R e p r o d u c e d with p e rm iss io n of th e copyright o w ner. Fu rther reproduction prohibited w ithout perm issio n.

so
81
else

S2
If ad d C o u n lô î > th re sh o ld e lse

S3
If finished

S4
Figure 4.11: Block Match State Machine

T h e design space o f the application in term s o f d evice area and tim ing c o n stra in ts has been tested in order to evaluate the perform ance o f the approach. experim ental results are provided in Figure 4.12. T h e test and

A set o f h ard w are and softw are

im plem entation data w as provided to the algorithm . In ord er to estab lish the so ftw are execution tim es for each task, the C language based sp ecificatio n w as p ro file d on an A R M 7T D M I processor. T he algorithm library can co n sist o f m any C P U types.

83

R e p r o d u c e d with p erm ission of the copyright ow ner. Fu rth er reproduction prohibited without perm ission.

how ever, for sim p licity and practicality only the A R M 7T D M I has been in clu d e d for th is case study. E ach o f the tasks w ere fully im p lem ented in h ard w are an d pro filed for p erfo rm a n c e and hardw are area requirem ents on a X ilinx V irtex E X C V 2 0 0 0 E FPG A . T a b le 4.2 pro v id es inform ation regarding the quantity o f each type o f PE

used for e ach o f the d e sig n constraints studied.

T he

c o -sy n th e sis

algorithm

provides

su p p o rt

for

fault

to le ran t

inter-P E By

co m m u n ic a tio n s by gen eratin g the target d evice into a hypercube a rch itectu re.

u sin g the g ro u p -b ased fault tolerance (G B F T ) m ethod, fault to le ran t em b ed d ed devices have been synthesized. T he GBFT algorithm adds a sse rtio n and

d u p licate/co m p are task s to the task graph.

U pon detection o f a failu re, the

a sse rtio n /co m p a re task signals one o f the spare P E s to com m ence e x e cu tio n o f the failed task. T he type and num ber o f spare PE s are defined by the user.

In the p rev io u s case study the results w ere co m p ared w ith those o f an e x h a u stiv e technique. T he ex h au stiv e technique is very co m p u tatio n ally intensive. O n th e 22

node task graph pro v id ed in the previous case study, the ex h au stiv e tech n iq u e required a p p ro x im ate ly 24 hours o f execution tim e. T he parallel block m atc h in g case stu d y co n sists o f 32 n odes (after G B FT ) and as a result the ex h au stiv e tec h n iq u e is far too co m p u tatio n ally intensive to gather com p arativ e results w ithin a reaso n ab le am o u n t o f tim e. A s a result, in Figure 4.12 only the device co n strain ts have been

p rovided to o u r program and the resultant ou tp u t provided by the a lg o rith m have been included.

84
R e p ro d u c e d with perm ission of th e copyriglit o w ner. F urther reproduction prohibited without perm issio n.

200 180 %

- - -o- - - Device Results -- A-- Constraints

B
'</>

i2

160

1
*

C

z
< n 140 TO c

__ X.

V

1 0

JZ

o 120

100
80

Ej--

-- ^

I



s -t

--W-.
-m

50 15 17.5 18.5 25 30 32 35 150

D e v ice P eriod (se c ;

Figure 4.12: Design Space Exploration of Parallel Block M atching

T h e resu lts provided in F igure 4.12 d e m o n stra te the alg o rith m 's ab ility to sy n th esize e m b e d d e d dev ices w ith v arying d e sig n c o n strain ts. A co m p ariso n o f h ard w a re area to perfo rm an ce trade-offs can be v ery useful to an em b ed d ed e n g in e e r in o rd e r to exam ine differen ces b etw een design altern ativ es.

85

R e p r o d u c e d with p e rm issio n of th e copyright ow ner. Further reproduction prohibited without perm ission.

1
Table 4.2: Processing Element Utilization of Design Space for Block Matching

Area Constraint (thousands of transistors) 189 174 94 91 90 83

Timing Constraint (sec) 15 17.5 18.5 25 30 32 35 150

CPU cores 2 2 1 1 1 I 1 1

Block Matching Cores 3 2 2 2 2 1 1 0

Block match Assert Cores 1 1 1 1 1 1 1 0

Final Assert Cores 1 1 1 0 0 0 0 0

Total PEs 7 6 5 4 4 3 3 1

Exec. Time (msec) 342.4 233.7 144.0

112.5
153.7 100.3 112.5 2.4

82
74

T able 4.2 provides detailed info rm atio n regarding the configuration o f each solution that th e co-synthesis alg o rith m produced. G iven the design constraints p rovided in

the first tw o colum ns, the algorithm generated a device that could m eet specifications. The n e x t four colum ns (3-6) provide the count o f various A SIC circuits p resen t in the final sy nthesized system . T he total PE s colum n provides a count o f the total num ber o f P E s present in the given device. T he count o f initialization cores and final cores have not been included as there are none im plem ented in hardw are for each case. The final colum n provides the length o f tim e the algorithm took to execute in order to sy nthesize the device.

86
R e p ro d u c e d with pe rm ission of th e copyright ow ner. Further reproduction prohibited without perm ission.

In ord er to further dem onstrate the efficacy o f the approach a prototype device has been constructed based on the design generated by the hardw are-softw are co synthesis algorithm . A device based on the third set o f design constraints provided in table 4.2 has been constructed. T he algorithm w as provided w ith an area co n strain t o f 20000 gates in excess o f the area o f the initial C PU (74209 gates). T he algorithm w as also provided w ith a perform ance (period) constraint o f 18.5 seconds. A fter co 

synthesis, the algorithm generated a final device architecture as seen in Figure 4.13. T he design consists o f a single CPU , tw o block m atching PE circuits, one block m atch assert circuit and one final assert circuit. A dditionally, in order to support fault tolerance one additional spare block m atching circuit and tw o repeater circuits have been included in the design.

T he algorithm predicted a final device area o f 19683 gates in excess o f the initial C PU area (74209). O ne block m atching processing elem ent and tw o repeater

processing elem ents w ere added to support fault tolerance. A single block m atching circuit has been synthesized and determ ined to utilize 3451 gates. T he add itio n o f

three more processing elem ents also results in the addition o f six new com m unication links. Each additional link results in the addition o f tw o com m unication interfaces. Each additional com m unication interface has been synthesized and d eterm ined to utilize 354 gates. Finally, in order to support softw are to hardw are com m unications on the ARM rapid prototyping platform , additional interface circuitry is required. T h is circuitry was synthesized and d etennined to utilize 2866 gates. T he algorithm also predicted a device period o f 18.49 seconds.

87

Reproduced with perm ission of th e copyright owner. Further reproduction prohibited without permission.

The sum o f all o f the hardw are area predictions are as follows: 19863 G ate count o f initial hardw are in excess o f initial CPU G ate count o f initial CPU G ate count o f 1 additional block m atch circuit G ate count o f 12 additional interface circuits (12 * 354) Gate count o f A R M circuitr>' required for H W /SW com m . Total gate count

74209
3451 4248
+

2866 104637

The entire device represented by Figure 4.13 w as im plem ented in over 2500 lines o f V H D L and C code. A listing o f the code is provided in A ppendix A. Synthesis o f the final d e v ic e 's non CPU hardw are revealed an actual gate count o f 28368 transistors. A dding the total gate count o f the initial CPU (74209) yields a final device actual gate count o f 102577 transistors.

The com pleted hardw are-softw are device w as profiled for perform ance. determ ined to have a period o f 17.02 seconds.

It w as

88

R e p ro d u c e d with permission of th e copyright owner. Further reproduction prohibited without permission.

111
Repeater Repeater

Block Match

Block Match

Assert

010

Final A ssert

Block Match

Figure 4.13: Final Prototype Device Architecture

The group based fault tolerance m ethod developed allow s the u ser to m anually select the quantity and type o f spare processing elem ents. In order to support fault tolerance but to also lim it the fault tolerance overhead one spare block m atching processing elem ent has been included. A dditionally, in order to sim plify the hypercube topology and for ease o f link fault tolerance, tw o repeater processing elem ents have been included. T he repeater processing elem ents consist solely o f com m unication

89

R e prod uc e d with perm ission of th e copyright owner. Further reproduction prohibited without permission.

T
interface circuitry, and are only responsible for repealing incom ing data on the appropriate outgoing link.

In order to test the device's functionality, an input im age and a reference im age have been provided as input. T he device then calculated the m otion vectors for each o f the 16 m acroblocks in the images. The reference im age is provided in Figure 4.14. T he input im age is provided in Figure 4.15. T he m acroblock num bering convention used is provided in Figure 4.16. The generated vector data is provided in T able 4.3.

«'"""'I

< . \

·

- ./-w.-v

u r n s :

Figure 4.14: Reference Image

90
R e prod uc e d with perm ission of th e copyright owner. Further reproduction prohibited without permission.

VT| * " "

-- -r--;

·· ** ·

%L.. ; . ( 

,.

. - r  ..- , 'f '- ^ .

`I

Figure 4.15: Input Image

12

13

14

15

8

9

10

11

4

5

6

7

0

1

2

3

Figure 4.16: Macroblock Identification

91

R eprodu ced with perm ission of th e copyright owner. Further reproduction prohibited without permission.

Table 4.3: Generated Motion Vectors Macrobiock 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Row Shift 0 0 0 0 0 -1 0 0 0 0 0 0 0 -2 0 0 Column Shift 0 0 0 0 0 -1 0 0 0 0 0 0 0 0 0 0

In ord er to confirm that the device correctly supports fault tolerance error states w ere sim ulated. R andom error conditions in various block m atching subcom ponents w ere sim ulated by using a random num ber generator. A fter an error state has been

detected, all further com m unication to the block m atching PE w here the error w as detected is rerouted to one o f the spare block m atching PEs. A dditionally, the set o f tasks executed on the PE w here the error w as detected m ust be re-executed on the new ly activated spare PE. This results in a degradation o f overall system

perform ance for the period in w hich the error w as detected. The average m easured period o f the device w hen an error w as detected is 20.94 seconds. T he output results from the cases w here an error was detected is identical to those generated by the device w hen no error w as detected.

92
R e p ro d u c e d with perm ission of th e copyright owner. Further reproduction prohibited without permission.

4.3 D iscussion o f E xperim ental R esults

A design m ethodology For m edium to large-scale fault-tolerant em bedded system s has been presented. T he objective has been to introduce a tool to aid the em bedded

system s d eveloper to create hypercube devices m eeting p erform ance, cost and reliability constraints w ithin a reasonable am ount o f tim e. To achieve this goal

efficiently and effectively, a series o f equations w ere developed to g overn pipelined scheduling, task reallocation, addition o f processing elem ents, co n fig u ratio n o f processing elem ents w ithin a hypercube topology and synthesis o f inter-PE

com m unication links. O ne o f the p redom inant m otivations is to m inim ize undesirable m ulti-hop com m unications that can occu r in hypercube system s. A dditionally, the

innate link-fault tolerant nature o f hypercube architectures is preserved. S upport for fault tolerance has been developed through the use o f the group based fault tolerance technique.

In order to dem onstrate the efficacy o f the new group based fault to lerance technique, the algorithm was com pared to both cluster and task based fault tolerance. To the

best o f our know ledge cluster and task based fault toleranee are *the only other published m ethods governing the addition o f error detection functionality at the task graph level. T he experim ental results show ed that on average the group based fault tolerance m ethod yields a 9.8% im provem ent in fault tolerant overhead over the cluster based fault tolerance m ethod and a 61% im provem ent over the task based fault

93

R e p ro du c ed with perm ission of th e copyright owner. Further reproduction prohibited without permission.

tolerance m ethod. tolerance m ethod.

T hese results dem onstrate the efficacy o f the group based fault

In order to evaluate the efficacy o f the co-synthesis approach the results o f an optim al algorithm have been provided for the test cases o f the first case study. T h e exh au stiv e technique is a sim ple approach that attem pts all possible com binations and is extrem ely com putationally intensive. T his exhaustive technique w as im plem ented for the sole purpose o f evaluating the results o f the algorithm w ith the optim al solution. O n average the approach yielded devices that under-perform ed the optim al case by 3.75% . A dditionally, the algorithm resulted in designs that use 0.62% m ore h ard w are area th an that o f th e optim al approach. These results show only sm all dev iatio n s

betw een the alg o rith m 's solutions and the ideal ones, indicating that the p ro p o sed m ethod yields high quality solutions. To the best o f our know ledge, this approach is the first co-synthesis algorithm developed targeting em bedded hypercube system s. C om paring the results o f this approach w ith, for instance, a co-synthesis algorithm developed to target bus system s w ould be inconclusive due to the differences in the target architectures. optim al m ethod. C onsequently, the com parison has been lim ited to that o f the

A nother com m on approach for com paring various co-synthesis or partitioning techniques is to evaluate th eir respective execution tim es. Som e tim ing analysis o f

the algorithm has been perform ed w ith relation to the case studies presented in this paper (see Tables 4.1 & 4.2). It can be observed that as the hardw are constraint rises,

94

R e p ro d u c e d with perm ission of th e copyright owner. Further reproduction prohibited without perm ission.

1

so does th e execution tim e. A s m ore h a rd w are is added to th e system , m o re iteratio n s o f the algorithm m u st be ex ecuted. T h e av erage ex ecution tim e fo r th e a lg o rith m S y n thesizing the 22-task e m b ed d ed d ev ice

(across both case studies) is 84.92 m s.

(first case study) for the g iv en set o f in p u t requirem ents w ould take a p p ro x im ate ly 24 hours to com plete using th e o p tim al approach. T he ex ecution tim e o f su ch an

approach is im practical for the c o m p arab le task graphs o f the case stu d y d evices. A dditionally, it is expected th at the e x e cu tio n tim e w ould increase e x p o n e n tially if the n u m b er o f tasks in the d evice sp ecificatio n increases. T his w as v erified w hen

attem pting to use the o ptim al m eth o d on the 32-node task graph from the seco n d case study. T he optim al execution tim e w as observed to be pro h ib itiv e and as a resu lt no optim al cases w ere com pleted. In th e cases w h ere the optim al tec h n iq u e c o u ld be

used, it w as found to produce m arg in ally b e tte r designs b u t its ex ecu tio n tim e w as too large and im practical. B oth a lg o rith m s w ere executed on a P entium IV 2.8 G H z T h e ex ecu tio n tim ing results in d ic a te th a t the

system w ith 512M B o f m em ory.

approach is efficient a n d its e x e cu tio n tim e is not a serious im p e d im e n t to its perform ance. T he first case study p resen ted in this paper is fully im p lem en ted and executed in sim ulation.

In ord er to further confirm the effectiv en ess o f the devices that the alg o rith m produces, a prototype o f the second case study device has been b u ilt using a rapid p ro totyping platform based on the A R M C PU and X ilinx V irtexE FPG A .

95

R e p r o d u c e d with perm ission of th e copyright ow ner. Further reproduction prohibited without p erm ission.

n

T h e results sh o w a final d e v ic e gate co u n t o f 102577 tran sisto rs. A s d isc u sse d in the p revious section, th e alg o rith m p red icted a total d evice gate c o u n t o f 104637 tran sisto rs. T h ese p re d ic te d results y ield a 2 .0 % error. T h is e rro r has b een attrib u ted to the estim a tes on th e c o st o f the c o m m u n ic a tio n lin k interfaces. T h e in terface gate c o u n t w as e stim a ted by sy n th e sizin g a stan d ard co m m u n ic a tio n in terface. T h e largest source o f th e d isc re p an c y c o m e s fro m th e co m m u n ic a tio n lin k in terface circu itry that a cco m p an ies the C P U p ro cessin g elem en t. D ue to the co m p lex nature o f the C P U ,

th is in terface circ u itry dev iates c o n sid e rab ly fro m th at o f th e o th e r p ro cessin g elem ents. A d d itio n ally , th e V H D L c o m p ile r a ttem p ts to o p tim ize the d ev ice area

w h ich m ay reduce th e overall d ev ice gate count. T h e e x isten ce o f these d isc re p an c ies w as not realized u n til the final d e v ic e w as co m p leted , as a resu lt the m o d elin g o f th ese co sts into the actual system w a s n o t p o ssible.

T h e resu lts sh o w a final d ev ice p erfo rm an ce p erio d o f 17.02 seconds. T h e algorithm p red icted a final d ev ice p erio d o f 18.49 seconds. T h is is an 8.6% error. T his erro r h as been a ttrib u ted to the o b serv ed in co n siste n c y in the tim e m ea su rem e n t functions available fo r use w ith the A R M C P U . D uring p rofiling, the sam e fun ctio n ality w as

rep eated ly m easu red fo r tim in g . T he ex ecu tio n tim e o f the sam e so ftw a re functional b lo ck w as o b serv ed to ty p ically v a ry by ap p ro x im ately 10% and in so m e cases as m u ch as 40% . D ue to th is d iscrepancy, e stim a ted ex ecu tio n tim es based on the

m ax im u m m easured values w ere selected . T h is is b eliev ed to be the m ain source o f e rro r co ntributing to the overall d e v ic e p eriod e stim ate being 8.6% h ig h er than the final m easured value.

96
R e p r o d u c e d with p e rm ission of th e copyright o w ner. Further reproduction prohibited without perm ission.

It should be noted th at w ith a p eriod o f 17.02 seconds, the pro to ty p e d evice is slow . T h is is d u e to us using an A R M 7T D M I processor. T he A R M 7 is w idely used in

sm all scale e m b ed d ed system s and a t 74,209 transistors., it is an ex trem ely sm all pro cesso r. By com parison, an old desktop C P U such as the Intel P en tiu m II, e o n sists o f 7.5 m illio n transistors w hich is ap p ro x im ately 100 tim es larger. A d d itio n ally th e co m m u n icatio n bus on the rapid p ro to ty p in g platfo rm is also slow .

97

R e p ro d u c ed with perm ission of t h e copyright owner. Further reproduction prohibited without perm ission.

CHAPTER 5 C O N C L U SIO N S A N D FU T U R E W O R K

T h e h ard w a re -so ftw a re co-sy n th esis o f an em bedded system arch itectu re in v o lv es the p artitio n in g o f a sy stem specification o r functional description into h ard w are and so ftw are m odules so as to m ee t a series o f non-functional req u irem en ts such as cost and p erform ance. presen ted V ario u s distrib u ted em b ed d ed d evice arch itectu res have been bus, h ierarchical and hypercube. H ypercube

p rev io u sly , in clu d in g

arc h ite c tu re s are particu larly suitable fo r use in fault to leran t and high p erfo rm a n c e devices. T o the b e st o f ou r know ledge, the first co -synthesis a lg o rith m has been

p resented th a t w ill au to m atically g en erate fault to le ra n t hy p ercu b e arch itectu re based e m b ed d ed devices. T h e new ly dev elo p ed group b ased fault tolerance, a tec h n iq u e fo r ad d in g fault to lerance to an em bedded device at the task graph level has also been presented. T he c o -sy n th esis algorithm consists o f six m ain steps; sp ecificatio n -

d efin in g d evice functional and non-functional req u irem en ts, pro filin g - ev alu atin g the functional specification for perfo rm an ce and a re a utilization, group based fault tolerance - adding fault to lerance to the device at the task graph level, sch ed u lin g evalu atin g the p erform ance o f the cu rre n t device architecture, addition o f p ro cessin g elem en ts -- im proving device perform ance by adding m ore hardw are, and the synthesis o f co m m unication links - arranging all processing elem en ts w ithin a h y p ercube topology and sy n th esizin g all co m m u n icatio n links. attem p ts to m inim ize the occu rren ce of m ultiple hops T h e algorithm d u ring inter-task

98
R e p ro d u c e d with p e rm issio n of th e copyright ow ner. Further reproduction prohibited without perm ission.

co m m u n icatio n s.

T h is helps to red u ce the overall system co m m u n icatio n o v erh ead

an d thus increases d ev ice perform ance.

A secu rity /n av ig atio n device has b e e n im p lem en ted th a t is resp o n sib le fo r d ec o d in g 16 M P E G video stream s in parallel. T h e c o -sy n th esis alg o rith m 's final arc h ite c tu re results w e re co m p ared w ith that o f th e op tim al case. T his com parison rev e a le d only m in o r d e v ia tio n s b etw een th e c o -sy n th esis alg o rith m 's generated dev ices and th a t o f th e o p tim al tech n iq u e. T h ese m in o r d e v ia tio n s illu strate how th e c o -sy n th e sis

alg o rith m is capable o f g en erating h ig h qu ality solutions.

A second d evice has been im p lem en ted to illu strate the alg o rith m 's a b ility to g e n erate fau lt to le ra n t devices. T his d evice is re sp o n sib le fo r p erfo rm in g the b lo ck m atc h in g alg o rith m w h ich is a co m p u tatio n ally in ten siv e and an essen tial c o m p o n e n t o f M P E G en co d in g . A d d itionally, in o rd er to fu rth e r d em o n strate the efficacy o f th e a p p ro ach , a pro to ty p e device based on the a lg o rith m 's resu lts has been im plem ented. T h e final pro to ty p e d e v ic e 's area an d tim in g v a lu e s w ere co m p ared w ith th e a lg o rith m 's predicted v alues and revealed o nly m o d est d ev iatio n s from the a n ticip ated results. E rror c o n d itio n s w ere also sim ulated on the pro to ty p e d evice to confirm c o rre c t fau lt to le ran t d e v ic e functionality. T his d em o n strates the co -synthesis a lg o rith m 's ab ility to g en erate fault tolerant devices and to accurately p red ict d evice a re a and

p erfo rm an ce costs.

99
R e p r o d u c e d with pe rm ission of th e copyright ow ner. Further reproduction prohibited without perm ission.

D uring th e synthesis and d ev elo p m en t o f the block m atching case study, av ailable e q u ip m e n t w as lim ited to a sm all A R M 7T D M I C PU connected to a X ilinx F PG A via a slow co m m u n ic a tio n m ed iu m . T h is resu lted in a slow perfo rm in g b ut in ex p en siv e device. F uture w ork w ill entail the dev elo p m en t o f an additional p rototype based on a faster a n d larger C PU . A d d itio n ally , the system will have a faster F P G A for the
I:

ap p lication specific circu itry and h ig h e r speed hardw are-softw are com m unications. T his w ill further d em o n strate our co-synthesis alg o rith m 's cap ab ilities by

sy n th esizin g and building a pro to ty p e device w ith m ore practical p erfo rm an ce and area constraints.

T he co-sy n th esis algorithm presen ted , targets fault tolerant em bedded devices and takes as input functional and non-functional requirem ents. requirem ents include p erform ance and area. T he non-functional

In order to further enhance the

alg o rith m 's ability to synthesize fau lt tolerant devices, future w ork w ill entail adapting the algorithm to include reliab ility as a non-functional requirem ent. C P U s, A S IC s and com m unication links all have an inherent reliability factor and the overall device reliab ility w ill be a fu n ctio n o f th e selection o f differing p ro cessin g elem ents, links a n d how they are interconnected.

100

R e p ro d u c e d with perm issio n of th e copvriaht ow ner. Further reproduction prohibited without oerm ission.

REFERENCES
[1] P. A lhanas, H. F. Silverm an, " P rocessor reconfiguration through instruction-set m etam orphosis" , I E E E C o m p u te r , vol. 26, no. 3, pp. 11-18, M arch 1993. [2] S. B akshi and D. G ajski, "P artitioning and Pipelining for Perform anceC onstrained H ardw are/Softw are System s," I E E E T r a n s a c tio n s o n V e ry L a r g e S c a le I n te g r a tio n S y s te m s , vol. 7, no. 4, Dec. 1999. [3] E. B arros, W. R osenstiel, and X. X iong, "A m ethod for partitioning U N IT Y language to hardw are and softw are," P r o c e e d in g s E u r o p e a n D e s ig n A u to m a tio n C o n fe r e n c e , Sept 1994, pp. 220-225, G renoble, France. [4] C. B olchini, L. Pom ante, F. Salice, D. Sciuto, " O nline Fault D etection in a H ardw are/Softw are C o-D esign E nvironm ent; System Partitioning", P r o c e e d in g s I E E E I n te r n a tio n a l S y m p o s iu m o n S y s te m S y n th e s is , O ct. 2001, pp. 51-56, M ontreal, Canada. [5] Jui-M ing Chang, M assoud Pedram , " C odex-dp; Co-D esign o f C om m unicating System s U sing D ynam ic P rogram m ing", I E E E T r a n s a c tio n s o n C o m p u te r - A id e d D e s ig n o f I n te g r a te d C ir c u its a n d S y s te m s , vol. 19, no. 7, July 2000. [6] K. S. C hatha and R. V em uri, "H ardw are-Softw are Partitioning and P ipelined Scheduling o f T ransform ative A pplications," I E E E T r a n s a c tio n s o n V e r y L a r g e S c a le In te g r a tio n S y s te m s , vol. 10, no. 3, June 2002. [7] K. S. C hatha and R. V em uri, " R EC O D : a retim ing heuristic to optim ize resource and m em ory utilization in H W /SW codesigns," P r o c e e d in g s I n te r n a tio n a l W o r k s h o p o n H a r d w a r e /S o ftw a r e C o d e s ig n , M arch 1998, pp. 139-143, Seattle, U SA . [8] J. C hoquette, M. Gupta, D. M cC arthy, J. V eenstra, " H igh perform ance R ISC m icroprocessors". I E E E M ic r o , pp. 48-55, A ug 1999. [9] L.A. C ortes, P. Eles, Z. Peng, "Form al coverification o f em bedded system s using m odel checking" , P r o c e e d in g s E u r o m ic r o C o n fe r e n c e , Sept. 2000, vol. 1, pp. 106113, M aastricht, N etherlands. [10] L.A. Cortes, P. Eles, Z. Peng, " V erification o f em bedded system s using a Petri n et based representation" . P r o c e e d in g s I n te r n a tio n a l S y m p o s iu m o n S y s te m S y n th e s is , Sept. 2000, pp. 149-155, M adrid, Spain. [11] J. G. D 'A m brosio and X. H u, " C onfiguration-level h ardw are/softw are partitioning for real-tim e system s," P r o c e e d in g s In te r n a tio n a l W o r k s h o p H a r d w a r e S o ftw a r e C o -D e s ig n , Sept. 1994, pp. 34-41, G renoble, France. [12] S. K. Das, M. C. Pinotti and Sarkar, "O ptim al and load balanced m apping o f parallel priority queues in hypercubes," IE E E T r a n s a c tio n s o n P a r a lle l a n d D is tr ib u te d S y s te m s , vol. 7, issue 6, pp. 555-564, June 1996. [13] B. P. Dave and N. K. Jha, "C O FTA : H ardw are-softw are co-synthesis o f heterogeneous distributed em bedded system architectures for low overhead fault tolerance," I E E E T r a n s a c tio n s o n C o m p u te r s , vol. 48, no. 4, A pril 1999. [14] B. P. Dave and N. K. Jha, " C O H R A : H ardw are-Softw are C osynthesis o f H ierarchical H eterogeneous D istributed E m bedded System s," IE E E T r a n s a c tio n s o n C o m p u te r A id e d D e s ig n o f I n te g r a te d C ir c u its a n d S y s te m s , vol. 17, no. 10, Oct.

1998.

101

R e n rodu ce d w ith o e rm is s io n o f th e c o o v rio h t o w n e r. F u rth e r re o ro d u c tio n o ro h ib ite d w ith o u t o e rm is s io n .

[15] B. P. D ave, G. L akshm inarayana and N . K. Jha, "CO SY N ; H ardw are-softw are co-synthesis o f heterogeneous distributed em bedded system s," I E E E T r a m a c l i o n s o n V L S I S y s te m s , vol. 7, no. 1. M arch 1999. [16] R. D ick and N . K. Jha, "M O G A C : A M ultiobjective G enetic A lgorithm for H ardw are-S oftw are C osynthesis o f D istributed Em bedded S ystem s," IE E E T r a n s a c tio n s o n C o m p u te r - A id e d D e s ig n o f I n te g r a te d C ir c u its a n d S y s te m s , vol. 17. no. 10, pp. 920-935, O ct. 1998. [17] S. D utta and W . W o lf "A Flexible Parallel A rchitecture A dapted to B lockM atching M otion-E stim ation A lgorithm s" , I E E E T r a n s a c tio n s o n C ir c u its a n d S y s te m s f o r V id e o T e c h n o lo g y , Vol. 6, N o. 1, pp. 74-86, Feb. 1996. [18] R. Ernst, J. H enkel, and T. Benner, "H ardw are-softw are cosynthesis for m icrocontrollers," I E E E D e s ig n & T e st, vol. 10, pp. 64-75, Dec. 1993. [19] F. C. Filho, P. M aciel, E. B arros, " A Petri N e t Based A pproach For H ardw are/Softw are P artitioning", S y m p o s iu m o n I n te g r a te d C ir c u its a n d S y s te m s D e s ig n , Sept. 2001, pp. 72-77, Pirenopolis, Brazil. [20] M .R . G arey and D. S. Johnson, C o m p u te r s a n d I n te r a c ta b ility : A G u id e to th e T h e o r y o f N P - C o m p le te n e s s . San Francisco, CA: Freem an, 1979. [21] C. G hezzi, M . Jazayeri, D. M andrioli, F u n d a m e n ta ls o f So ftw 'a r e E n g in e e r in g , Prentice H all, U pper Saddle R iver, N J, 1991. [22] R. G upta and G. D eM icheli, "H ardw are/softw are cosynthesis for digital system s," I E E E D e s ig n & T e s t o f C o m p u te r s , pp. 29-41, Sept. 1993. [23] R. G upta and G. D eM icheli, " System -level synthesis using re-program m able com ponents". P r o c e e d in g s E u r o p e a n C o n fe r e n c e o n D e s ig n A u to m a tio n , M ar. 1992, pp. 2-7, B russels, B elgium . [24] J. H enkel, R. Ernst, "A n A pproach to A utom ated H ardw are/Softw are P artitioning U sing a Flexible G ranularity that is D riven by H igh-Level E stim ation T echniques" , I E E E T r a n s a c tio n s o n V e ry L a r g e S c a le I n te g r a tio n S y s te m s , vol. 9, no. 2, A pril 2001. [25] J. H ou and W . W olf, "Process partitioning for distributed em bedded system s," P r o c e e d in g s In te ? 'n a tio n a l W o r k s h o p o n H a r d w a r e /S o ftw a r e C o d e s ig n , Sept. 1996. pp. 70-76, Pittsburgh, U SA . [26] P.-A . H siung, " H ardw are-softw are tim ing coverification o f concurrent em bedded real-tim e system s" , l E E P r o c e e d in g s C o m p u te r s a n d D ig ita l T e c h n iq u e s , pp. 83-92, M arch 2000. [27] B. A. Izadi, F. O zguner, "R eal-tim e fault-tolerant hypercube m ulticom puter," l E E P r o c e e d in g s C o m p u te r s a n d D ig ita l T e c h n iq u e s , vol. 149, no. 5, pp. 197-202,

Sep. 2002.
[28] A. K alavade and E. A. Lee, " A hardw are-softw are codesign m ethodology for DSP applications," I E E E D e s ig n & T e st, vol. 10, pp. 16-28. Sept. 1993. [29] G. N. K han, G. S. H ura, G. W ei, "D istributed R ecovery B lock Based Faulttolerant R outing in H ypercube N etw orks," P r o c e e d in g s I E E E C a n a d ia n C o n fe r e n c e o n E le c tr ic a l a n d C o m p u te r E n g in e e r in g , M ay 2002, pp. 603-608, W innipeg, Canada. [30] D. K irovski and M . Potkonjak, "System -level synthesis o f low -pow er real-tim e system s," P r o c e e d in g s D e s ig n A u to m a tio n C o n fe r e n c e , June 1997, pp. 697-702, A naheim , USA.

102
R e n r o d u c e r i w ith n e r m i s s in n nf t h p r.n n u rln h t n w n e r F u r t h e r r f ? n r o d i i c i i n n n r n h i h i f p d vuith niit n e r m i s c i n n

[31] P. V. K nudsen, J. M adsen, " PA CE; A dynam ic program m ing algorithm for hardw are/softw are partitioning" . P r o c e e d in g s 4 `^ In te r n a tio n a l W o r k s h o p o n H a r d w a r e /S o ftw a r e C o d e s ig n , pp. 85-92, 1996, Pittsburgh, USA. [32] K. K uchcinski, " C onstraints-driven scheduling and resource assignm ent," A C M T r a n s a c tio n s o n D e s ig n A u to m a tio n o f E le c tr o n ic S y s te m s , vol. 8, no. 3, pp. 355-383, Ju ly 2003. [33] Y u-K w ong K w ok and I. A hm ad, " D ynam ic critical-path scheduling: An effective technique for allocating task graphs to m ultiprocessors," I E E E T r a n s a c tio n s o n P a r a lle l D is tr ib u te d S y s te m s , vol. 7, pp. 506-521, M ay 1996. [34] L. E. LaForge, " Self-H ealing A vionics for Starships," P r o c e e d in g s I E E E A e r o s p a c e C o n fe r e n c e , M arch 2000, vol. 5, pp. 499-519, B ig Sky, USA. [35] L. E. LaForge, K. F. K orver and M. S. Fadali, " W hat D esigners o f B us and N etw ork A rchitectures Should K now about H ypercubes," I E E E T r a n s a c tio n s o n C o m p u te r s , vol. 52, no. 4, A pril 2003. [36] Y. Li and W . W olf, " H ardw are/Softw are C o-Synthesis w ith M em ory H ierarchies," I E E E T r a n s a c tio n s o n C o m p u te r - A id e d D e s ig n o f I n te g r a te d C ir c u its a n d S y s te m s , \ o \ . 18, no. 10 pp. 1405-1417, Oct. 1999. [37] H uiqun Liu, D. F. W ong, " Integrated P artitioning and Scheduling for H ardw are/Softw are C o-D esign" , P r o c e e d in g s I n te r n a tio n a l C o n fe r e n c e o n V L S I in C o m p u te r s a n d P r o c e s s o r s , O ct. 1998, pp. 609-614, A ustin, USA. [38] J. M adsen, J. G rode. P.V . K nudsen, M .E. Peterson, A. H axthausen, " L Y C O S: the lyngby co-synthesis system " . D e s ig n A u to m a tio n f o r E m b e d d e d S y s te m s , vol. 2,

no. 2, pp. 195-236, 1997.
[39] D.D. M itchell, D.C. Ku, F. M ailhot, and T. T ruong, " The O lym pus S ynthesis System for digital d esign", I E E E D e s ig n a n d T e s t M a g a z in e , pp.37-53, O ct. 1990. [40] A. O sterling, T. Benner. R. Ernst, D. H errm ann, T. Scholz, and W . Y e, " T he C O S Y M A system " , H a r d w a r e /S o ftw a r e C o -D e s ig n : P r in c ip le s a n d P r a c tic e , pp. 263-281. K luw er A cadem ic Publishers, A m sterdam , 1997. [41] D. A. Patterson, J. L. H ennessy, C o m p u te r A r c h ite c tu r e A Q u a n tita tiv e A p p r o a c h 2'"^ E d itio n , M organ K aufm an P ublishers Inc., San Francisco, C A , 1996. [42] S. Prakash and A. Parker, " SOS: Synthesis o f application-specific heterogeneous m ultiprocessor system s." J o u r n a l o f P a r a lle l a n d D is tr ib u te d C o m p u tin g , vol. 16, pp.

338-351, Dec. 1992.
[43] K. Raj an, L. M. Patnaik and J. R am akrishna, "H igh-speed parallel im plem entation o f a m odified PBR algorithm on D SP-based EH topology," I E E E T r a n s a c tio n s o n N u c le a r S c ie n c e , vo ! !, issue 4, pp. 1658-1672, A ug. 1997. [44] E. Salm inen, T. H am alainen, T. K angas, K. K uusilinna, J. Saarinen, " Interfacing m ultiple processors in a system -on-chip video encoder" . I n te r n a tio n a l S y m p o s iu m o n C ir c u its a n d S y s te m s , M ay 2001, vol. 4, pp. 478-481, Sydney, A ustralia. [45] A viral Shrivastava, M ohit Kum ar, Sanjiv K apoor, Shashi K um ar, M. B aiakrishnan, "O ptim al H ardw are/Softw are Partitioning for C oncurrent Specification using D ynam ic Program m ing". I n te r n a tio n a l C o n fe r e n c e o n V L S I D e s ig n , Jan. 2000, pp. 110-113, C alcutta, India.

103

RAnrnH iinAcj w ith nprmI.CLQinn n f t h p n n n v / r in h t n u / n n r

P i i r t h n r r p n r n H i i n t i n n n r n h l h i t p H u / i t h n i i t n orm ic .Q Înn

[46] S. Srinivasan and N. K. Jha, " H ardw are-Softw are C o-Synthesis o f Fault-T olerant R eal-T im e D istributed Em bedded System s," P r o c e e d in g s E u r o p e a n D e s ig n A u to m a tio n C o n fe r e n c e , Sept. 1995, pp. 334-339, B righton, UK. [47] W. W olf, "A n architectural co-synthesis algorithm for distributed, em bedded com puting system s," 1 E R E T r a n s a c tio n s o n V L S I S y s te m s , vol. 5, pp. 218-229, June

1997.
[48] W . W olf, C o m p u te r s a s C o m p o n e n ts , M organ K aufm an Publishers Inc., San D iego, C A , 2001. [49] S. Y ajnik, S. Srinivasan, N . K. Jha, "TBFT: A T ask Based Fault T olerance Schem e for D istributed System s," P r o c e e d in g s I n te r n a tio n a l C o n fe r e n c e o n P a r a lle l a n d D is tr ib u te d C o m p u tin g S y ste rn s, O ct. 1994, pp. 483-489, Las V egas, USA. [50] K un-M in Y ang, M ing-T ing Sun and L ancelot W u, "A Fam ily o f VLSI D esigns fo r the M otion C om pensation B lock-M atching A lgorithm " , I E E E T r a n s a c tio n s o n C ir c u its a n d S y s te m s , vol.36, n o .10, pp. 1317-1325, Oct. 1989. [51] Y ao-M ing Y eh and Y iu-C heng Shyu, " E fficient distributed schem es for em bedding binary trees into incom plete hypercubes," P r o c e e d in g s I n te r n a tio n a l C o n fe r e n c e I E E E R e g io n 1 0 , A ug. 1994, vol. 1, pp. 182-186, Singapore. [52] T.Y . Y en, W . W olf, "M ultiple-process behavioral synthesis for m ixed hardw aresoftw are system s", P r o c e e d in g s 8 " ^ In te r n a tio n a l S y m p o s iu m o n S y s te m S y n th e s is , Sept. 1995, pp. 10-15, Cannes, France.

104

R o n r n H i i P . o d \A/ith n o r m l c c i i n n n f f h o n n n v / r in h f n\A/nor

PEirfhor m n r n r l n n f i n n nrnhiK ifo H vA/ithnnt n o r m l c c i r

A ppendix A - Prototype Device Code Listing
T h e follow ing V H D L and C code define the final prototype device described in sectio n 4.2 and illustrated in figure 4.13. T he device is a sym m etrical three dim ensional hypercube that perform s the block m atching algorithm .
L in R -^ R Y iccc; U S E icec.sld_logic_l 164.ALL: U S E icee.std Jo g ic_ arith .A L L ; U S E iecc.std Jo g ic_ u n sig n ed .A L L ; E N T IT Y regS IS PO R T (load : IN s td jo g ic ; clock : in s td jo g ic ; datain : IN std_ulogic_vcctor(7 dow ntoO ); dataout : O U T std_ulogic_vcctor(7 dow nto 0 )): -p a ra lle l o utputs E N D rcgS; A R C H IT E C T U R E rcgS OK regS IS --SIG N A L int_reg ; integer range 0 to 65535; B E G IN process(clock) --variable vec: std_u lo g ic_ v ccto r ( 1 to size); B E G IN il'( clock'evcnt and clock = '! ') th cn -n sin g _ e d g e (clo c k ) and load - 'T ) then il'(load = 'I ') then - i n t r c g < = datain; dataout <= datain; end if; end if;
E N D PROCESS;

--connect internal register to d ataout port --dataout <= in tr c g ; E N D rcgS; L IB R A R Y iece; U S E ic e c .s td ju g ic i 164.ALL; U S E ieee.stdJogic_arith.A L L ; U S E icec.stdJogic_unsigned .A L L ; --our register definition E N T IT Y reg655.35lnt2 IS PO R T (load : IN s td jo g ic ; clock : in s td jo g ic ; inil : IN s td jo g ic ; datain : IN integer range 0 to 65535; --datainZ : IN std_logic_vcctor( 15 dow nto 0 );-in te g e r range 0 to 65535; dataout : O U T integer range 0 to 65535); -p a ra lle l outputs E N D reg65535lnt2; A R C H H E C T lJR H reg l OK reg65 5 3 5 ln i2 IS --SIG N A L int_rcg : integer range (J to 65535; B E G IN process(elock. init) -v a ria b le vec; std ulogic vector ( I to si/e ); BE G IN if(init = ' l ') then dataout <= 65535. else

105

R o n r n H i i/T<=rl w ith n o r m i c c i n n n f t h n n n n u r i n h t n w n o r

F n r t h n r r<anrnHi m ti n n n r n h i h l t n H w i t h n u t nnrmLQ.Qlnn

it\ clock'evciii and clock = '! ' ) then it'(load = T ) then --inl_reg < = datain; datao u t <= datain; end if; end if; end if; t£ND PROCESS: --connect internal register to datao u t port -d a ta o u t < = in tr c g ; E N D rc g l; L IB R A R Y icec; U SE ieec.std _ lo g ic_ l I64.A LL; U S E icce.std_logic_arith.A L L ; U SE iecc.std_logic_unsigncd.A L L ; EN T IT Y reg655351nt IS PO R T (load : IN std logic; clock ; in std_ ,o g ic; init ; IN s td jo g ic ; datain : IN integer range 0 to 65535; dataout : O U T integer range 0 to 65535); --parallel outputs EN D rcg65535lnt; A R C H I TEC TU R E reg4 OF reg 6 5 5 3 5 ln t IS -S IG N A L int rcg : integer ran g e 0 to 65535; BE G IN processfclock. init) - v a r ia b le vec: std_u lo g ic_ v ecto r ( I to size);

BEGIN

if(in it = T ) then datao u t <= 0; else 11% clo ck 'cv en t and clock = T ' ) then if(load = 'I') then --int_reg < = datain; dataout <= datain; end if; end if; end if; E N D PROCESS; --connect internal register to d ataout port --dataout < = int rcg; EN D reg4; LIB R A R Y ieee; U SE i e e c .s t d j o g i c j I64.A L L ; U S E icee.std_logic_arith.A L L ; USE ic e e .s id J o g ic unsigned.A LL; --o u r c om pare circuit definition EN TITY com p IS PO R T(inV al I : IN Integer ran g e 0 to 65535; -p a ra lle l inputs ini I ; in integer range 0 to 32; inJ I ; in integer range 0 to 32; inV al2 ; IN integer range 0 to 65535; -p a ra lle l inputs start ; in s td jo g ic ; otiti ; out integer range 0 to 32; outJ : out integer range 0 to 32; out I : O U T integer range 0 to 65535); --parallel outputs EN D com p;
A R C IIITK C rU R E co m p l O F com p IS - s ig n a l outT enip ; INTEGER;

106

R o n r n r l ti r .f s d w i t h npsrmiststinn n f t h n r-.nn urinh t n w n n r

F u r t h e r re n ro d tin fio n n r o h i h i t e d w i t h o u t o e rm is s io n .

BHOIN

procc.ss(start) begin ir{start'cvcm and start = 'I') then ir(inV all < lnV al2) then out! < = in V a il; outi < = ini I; outJ < = in JI; end if; en d if; end process; - o u t I < = o u lT c m p ; K N D com pl ; L IB R A R Y ieee; U S E ie e e .s td J o g ic _ l 164.ALL; U S E ieee.std Jo g ic_ arith .A L L ; U S E iece.std_logic_iinsigned.A L.L; --o u r add circuit definition E N T IT Y add IS P O R 'R in l : IN integer range 0 to 65535; -p a ra lle l inputs in2 ; IN integer ran g e 0 to 65535; --parallel inputs out! ; O U T integer range 0 to 65535); -p a ra lle l outputs E N D add; A R C H IT E C T U R E add I OF add IS s ig n a l outT em p ; IN TEG ER ; B E G IN p ro c c ss(in l. in2) begin o u lT em p < = ini + in2; end process; out I <= outTem p; E N D add 1; L IB R A R Y ieee; U S E ieee.std_logic_l 16 4 .ALL; U S E ieec.sld_logic_arilh.A L L ; U S E ieec.std_logic_un.signed.A I .1 ; --our d ifierenec circuit definition E N T IT Y d i i n s P O R T (inl : IN S td ulogic v e c to r;7 D O W N TO 0); --parallel inputs in2 ; IN Std_ulogic_veeu>r(7 D O W N TO 0); --parallel inputs out I : O U T intcaer range 0 to 65535); -p a ra lle l outputs E N D d ilT ; A R C IIIT E C T U R E dill l Ob' dilT IS s ig n a l outT em p : IN TlXiER; B E G IN process; in I. iii2) variable val . IN TEG ER; variable v a il . IN TEG ER; variable v al2 : INTEGEiR; variable b . IN I EG ER;

107

R e o ro d u c e d with oerm ission of the coovrioht owner. Further reoroduction orohibited without oermission.

BW JIN val -- 0; b := I ; for y in 0 to 7 loop ll'(inl(y) = T ) then val := val + b: end if; b:= b · 2 ; end lo o p ;-fo r y val I ;= val; . val := 0; b := t; for y in 0 to 7 loop if\in2(y) = 'l') then v a l v a l + b; end if; b := b * 2; end lo o p ;-fo r y val2 := val; iffval 1 < val2) then outT em p < = (v al2 - val I ); else outT em p < = (val I - val2); end if; E N D PR O C E SS; o u tI < = outT em p; E N D d iffI; LIB R A R Y ieee; U S E icee.std _ lo g ic_ l 164.A LL; U S E ieee.std_logie_arith.A L L ; U S E ieee.std_logie_unsigned.A L L ; --oiir register definition EN TIT Y reg IS ; IN s td jo g ie ; clo ck : in std logic; datain : IN S td _ulogic_veetor(7 D O W N TO 0); --parallel inputs dataout ; O U T S td _ulogic_vector(7 D O W N TO 0)); --parallel outputs E N D reg; A R C H IT E C T U R E v l O F reg IS SIG N A L int reg : Std_ulogic_vector(7 D O W N TO 0); B E filN process! clo ck ) BEGIN ifleloek'cvent and clock = 'I ') then if(load = T ) then in t r c g < = datain; en d if, en d if; EN D PR O C E SS; --connect internal register to dataout port dataout <= int r e g ;- w hen tim eT oO utpul = 'I ' else "Z Z Z Z Z Z Z Z "; E N D v l; LIB R A R Y ieee; U S E ieee..std_logie 1164.A L L; U SE ieee.std logie arith.A LL; U SE ieee.std_logie_unsigned.A L L ; PO R T fload j

|

I

108

ReDfoduced with Dermission of th e copvriflht owner. Further reproduction prohibited without perm ission.

1;NTITY b lo ck m atch IS [>ORT( --stopA IID one : IN S T D LO G IC : IN .S T O _ L O G IC ;-g o e s high w hen it is tim e to a d d a b yte to th e array s a(lclB>te elk IN S T D _ L U G IC ; IN S T D _ U t.O G IC _ V I£ C T O R (7 D O W N T O 0); InByle O U T S T D L O G IC :--goes high w hen E V E R Y T H IN G is finished allD onc O U T in teg er ran g e 0 to 3 2 : --the i shift valu e (SW w ill m ak e it -1 6 to + 1 6 ) out! O U T in teg er ran g e 0 to 32): - t h e j sh ift valu e (SW w ill m ak e it -1 6 to + 1 6 ) ouU E N D b lockm atch;

A RC H ITECTURE description O E blo ck m atch IS

C O M P O N E N T reg IS PO R T (load : IN s td jo g ie : elock : in std logic; datain : IN Std_uiog ic_ v ecto r(7 D O W N T O 0): - p a r a lle l inputs dataout : O U T S td_ulogic_vcctor(7 D O W N T O 0)): --p arallel o utputs EN D com ponent; C O M P O N E N T d itr IS PO R T (inl : IN Std_ulo g ic_ v ecto r(7 D O W N T O 0); --p arallel inputs in2 : IN Sld_u lo g ic_ v ecto r(7 D O W N T O 0); --parallel inputs out I ; O U T integer range 0 to 6 5535): --parallel o u tp u ts EN D co m ponent; com ponent add IS PO R T (inI : IN integer ran g e 0 to 6 5535: -p a ra lle l in p u ts in2 ; IN integer range 0 to 6 5 5 3 5 ; --parallel in p u ts out I : O U T integer ran g e 0 to 65535); --parallel o u tp u ts EN D co m ponent: com ponent c o m p IS P O R T (inV all : IN integer range 0 to 6 5 5 3 5 : --parallel inputs ini I ; in integer range 0 to 32: inJ I : in in teg er range 0 to 3 2 : in V al2 ; IN in teg er range 0 to 6 5 535; --p arallel inputs start ; in std_logic: outI : o u t integer ran g e 0 to 32; ouU ; o u t integer range 0 to 32: ou ti : O U T integer range 0 to 6 5535); --parallel o u tp u ts EN D com ponent: com ponent reg65535lnt2 IS PO R T (load : IN std logic; clock : in std logic; init : IN std logic; datain ; IN integer ran g e 0 to 65535; --datain2 : IN std J o g ie _ v e c to r( 15 dow nto 0 ) ;- in te g e r range 0 to 65535; dataout : O U T integer range 0 to 6 5 5 3 5 ); -p a ra lle l o u tp u ts EN D com ponent:

com ponent rcg65535lnt IS PO R T (load : IN std_logic; clock : in s td jo g ic : init : IN s td jo g ic : datain : IN integer range Ü to 65535: dataout : O U T integer ran g e 0 to 6 5 5 3 5 ): --parallel o u tp u ts EN D co m ponent: --signal load : S T D J.O G IC _ V E C T O R (2 5 5 9 d ow nto ());--th e load lines lo r all the registers --signal regO utpul : S T I)_ I.O (/IC _ V E C rO R (2 5 5 9 d o w n to O l;-lh e line indicates if this reg ister s h o u ld be o u tp u ttin g

109

Reproducetd with p erm ission of th e copyright owner. Further reproduction prohibited without perm ission.

signal rcg A c tiv e O u l : S T D _ U L O O IC _ V K C T O R {7 d o w n to 0); - s ig n a l rcg O ld O m : ST D _U L O G lC _ V E C T O R (7 d o w n to 0); s ig n al d it'flO u t : integer ran g e 0 to 6 5 5 3 5 ; ' signal a d d R e g O u t : in teg er ran g e 0 to 6 5 5 3 5 ; --signal lo ad Z n d R cg ; S T D L O G lC _ V E C T O R (l 0 88 d o w n to 0); - s ig n a l reg Z n d O u tp u t : S I D LO O IC _ V E C T O R ( 1088 d o w n to G); signal iVal : in teg er range 0 to 32; --g e n e ra ted by co n tro l circu itry to tell co m p a ra to r w h a t in d ex is b ein g co m pared signal jV a l : in teg er ran g e 0 to 3 2 ; --as a b o v e signal co m p O u t ; integer ran g e 0 to 6 5 5 3 5 ; signal iO ul ; in teg er ran g e 0 to 32; signal jO u t: in te g e r range 0 to 32; signal b cstE rro rY et : in teg er ran g e 0 to 6 5 5 3 5 ; sig n al lo ad C o m p R eg : S T D _ L O G lC ; signal in ilC o m p R eg ; S T D _ L 0 G 1 C ; --signal rcg A d d e rln 2 : in te g e r ran g e 0 to 6 5535; --signal reg A c liv e T im e T o O u lp u t ; std _ lo g ic_ v e e to r(2 5 5 d o w n to 0); --signal reg O ld T im e T o O u tp u t ; std _ lo g ic_ v ecto r(2 3 0 3 d o w n to 0); signal ad d O u t ; integer ran g e 0 to 6 5 5 3 5 ; signal lo ad A d d R eg ; s td j o g i c ; signal in itA d d R eg : std lo g ic; s ig n al lo ad ln R e g : s td j o g i c ; signal reg 2 n d O u t : s td J o g ic _ v e c to r( 15 d o w n to 0); - s u b ty p e W O R D S is S T D _ L O G lC _ V E C T O R (7 d o w n to 0); --type A R R A Y 1089 is array ( 1088 d o w n to 0 ) o f W O R D S; --signal reg 2 n d O u t ; A R R A Y 1089; sig n al c o m p S tart : s td jo g ic ; B EG IN in R eg A ctiv eL ab el: reg P O R T M A P (lo ad ln R eg , elk , inB yte, reg A ctiv eO u t); d in C irc u if. d iff p o rt m ap (reg A c tiv e O u t, in B y te, d ifflO u t); a d d l : ad d port m a p (d ifflO u t, a d d R eg O u t, a d d O u t); ad d R eg L ab cl: reg 6 5 5 3 5 In t p o rt m ap (lo ad A d d R eg , elk, in itA d d R eg , a d d O u t, ad d R cg O u t); c o m p l: com p p o rt m ap (ad d O u t, iV a l,jV a l, b cstE rro rY et, c o m p S ta rt, iO u t,jO u t, c o m p O u t); co m p R eg ister; reg65 5 3 5 1 n t2 p o rt m ap (lo ad C o m p R eg , elk, in itC o m p R eg . co m p O u t. b cstE rro rY et); --tem p ln R c g O u t < = reg A c tiv e O u t; --te m p D iffO u t < = d ilT lO u t; --tem p A d d R e g O u t < = a d d R eg O u t; --tem p A d d O u t <= ad d O u t; --tc m p C o m p R c g O u t< = b c stE rro rY et; --tem p C o m p O u t < = c o m p O u t; p ro ce ss(clk ) v a ria b le ad d C o u n te r : integer; v a riab le c o m p C o u n tc r: integer; v a riab le i ; in teg er; v a riab le j : in teg er; v a ria b le state : in teg er := 0; - 0 m ean s w e arc lo ad in g values. 1 m ean s we are d o in g the adding b egin if(risin g _ ed g e(clk )) th en --se t all reg isters to no load.... allD one < = 'O'; lo ad ln R eg < = 'O'; lo ad A d d R eg < = 'O'; in itA d d R eg < = 'O'; lo ad C o m p R eg < = 'O'; initC om pR cg < = 'O'; c o m p S tart < = 'O'; if(ad d B y tc = T ) then --then w e are a d d in g an o th e r b y te to th e circu it How tem pS ignal < = '1 '; te m p C lk < = 'l'; ad d C o u n ter := a d d C o u n te r + I; if(s ta te = 1) th en

| |

I
| _|

I
| | a 3 |
j

k

a

j

I

j
i ;
i

g ; 'j j i|
>

j | ; | i

110

i
Î

R e p r o d u c e d with p e rm ission of th e copyright o w ner. F urther reproduction prohibited without perm ission.

load A d d R eg < = '! '; slate := 2; cIsiR state = 2) then lo ad ln R eg < = 'I '; i l'(addC ounter > 511) th en --254) then state := 3; a d d C o u n ter - 1 ; j : = j + I; iflj > 32) then j - 0; i := i + I; en d if; if(i > 32) then - r e s e t i - w e are d o n e - d o n 't update the o u tp u t i's and j's i := 0; else IVal < = i; jV a l < = j; c o m p S ta rt < = 'I '; en d if: else state -- I ; end if: clsif(state = 3 ) then load C o m p R eg <= 'I'; state := 4; clsif(state = 4) then initA ddR eg < = '! ': lo ad ln R eg < = 'I'; co m p C o u n ter := c o m p C o u n tcr + I : ilfco m p C o u n ter > 1088) th en --w e ju s t did the last o ne state := 0; a llD o n e < = 'l': else state := I : end if; else --w e are in state 0 lo ad ln R eg < = '! '; initA ddR eg < = '! ': initC om pR eg < = '! '; i ;= 0; j := 0: -c o m p C o u n te r 0; state := I : - s o w e are p robably in state 0 (lo ad in g o f th e reg isters so do nothing., end if:--if state = 1. 2 . . . . en d if:~ ifa d d B y le = 'I' tem p S tate <= state: en d i f : - i f risin g edge clock end process; outi < = iO ut: otitJ < = jO u t: H N D description: L IB R A R Y ieee: U S n ieee.std logic i I64.A I.L: U S B ieee.sld_logic_arith,A l.l,. U S B ieee.std logic u n sig n cd .A l.t.; B N 'ri TY l>l;_B lockM atch IS I'O R Tt
elk

in std logic:
IN STD_l.OCIIC VI-;CrOR(2 d o w n to 0): IN S I D _I.D (IIC \V I:C fO R (2 d o w n to 0): IN .S T D _U l.t)t;iC V U C ÏO R {7 d o w n to 0);

InD estinationI inSotireel in D ata I

11

R e p ro d u c e d with perm ission of th e copyright ow ner. Further reproduction prohibited without perm ission.

iniD I in S lartl in D e stin a tio n î inSourcc2 inD ata2 inlD 2 inSlart2 in D estination3 inSource3 inD ata3 inID 3 inStart3 m y ID ID I ID 2 1D3 o u tD eslin alio n I o u lS o u rc e l o utD ala 1 o u tlD I o u tS tartI o u tD cstin atio n 2 o u tS o u rce2 outD ata2 o u tlD 2 o u tS ta rtI outD estin atio n 3 oulSoureeS outD ata3 0UIID3 outStart3 E N D P E _ B lü ck M atch ;

; IN S T D _ U 1 .0 G IC _ V E C T 0 R (7 d o w n to 0); : in s ld jo g ic ; - g o e s h igh w hen th e three th in g s ab o v e are read y ; IN S T D _ L O G lC _ V E C T O R (2 d o w n to 0); ; IN S T D _ L O G IC _ V E C T O R (2 d o w n to 0); : IN S T D _ U L O G IC _ V E C T O R (7 d o w n to 0); : IN S T D _ U L O G IC _ V E C T O R (7 d o w n to 0); : in s td j o g i c ; - g o e s h igh w hen th e three th in g s ab o v e are ready : IN S T D _ L O G IC _ V E C T O R (2 d o w n to 0); ; IN S T D _ L O G IC _ V E C T O R (2 d o w n to 0); : IN S T D _ U L O G IC _ V E C T O R (7 d o w n to 0); : IN S T D _ U L O G lC _ V E C T O R (7 d o w n to 0); : in s td j o g i c ; --g o es h ig h w hen the three th in g s above are read y ; in std _ lo g ic_ v ecto r(2 dow nto 0 );--w hat this P E 's ID is : in std _ Io g ic_ v ccto r(2 d o w n to 0 );--w h at PE I's ID is : in std _ lo g ic_ v ecto r(2 d o w n to 0 );--w h at PE 2 's ID is : in sld _ lo g ic_ v ecto r(2 d o w n to 0 );--w hat PE 3's ID is : o u t S T D _ L O G IC _ V E C T O R (2 d o w n to 0); ; o u t S T D _ L O G IC _ V E C T O R (2 d o w n to 0); : o u t ST D _U LO G IC _ V E C T 0 R (7 dow nto 0); ; o u t S T D _ U L O G lC _ V E C T O R (7 d o w n to 0); : o u t s td jo g ic ; : o u t S T D _ L O G IC _ V E C T O R (2 d o w n to 0); ; o u t S T D _ L 0 G IC _ V E C T 0 R (2 d o w n to 0); : o u t ST D _ U L O G IC _ V E C T O R {7 d o w n to 0); : o u t S T D U L 0 a iC _ V E C T 0 R ( 7 d o w n to 0); : o u t s ld jo g ic ; : o u t S T D _ L O G IC _ V E C T O R (2 d o w n to 0); : o u t ST D _L O G IC _ V E C T O R (2 d o w n to 0); : o u t S T D _ U L O G IC _ V E C T O R (7 d o w n to 0); : o u t S T D _ U L 0 G IC _ V E C T 0 R (7 d o w n to 0); : o u t s td jo g ic ) ;

A R C H IT E C T U R E P E d escrip tio n O F PE _ B lo ck M atch IS co m ponen t b lo ck m atch IS PO R T ( --stopA IID one : IN S T D LO G IC ; addB yte : IN S T D _ L O G IC ;-g o c s h igh w hen it is tim e to add a byte to the arrays elk : IN ST D _L O G IC ; inB yte : IN S T D _ U L O G IC _ V E C T O R (7 D O W N T O 0); allD one : O U T S T D _L C X 3IC ;-goes h ig h w h en E V E R Y T H IN G is fin ish ed ou ti : O U T in teg er ran g e 0 to 3 2 ; --the i shift v alu e (SW w ill m ak e it -16 to + 16) o u t) ; O U T integer ran g e 0 to 3 2 ); --th e j shift v alu e (SW w ill m ak e it -16 to + 1 6 ) E N D co m p o n en t; sig n a l sig n a l sig n al sig n al sig n a l sig n a l sig n a l sig n a l sig n a l sig n al circu itS tart ; s td jo g ic ;--tied to elk addin g A B y te : s td j o g i c ; --tied to addB yte in D ata : std _ u lo g ic_ v ccto r(7 d o w n to 0 ) ;- tic d lo inB yte done : s td J o g ic ;- lis tc n if c ircu it is d o n e ou tD atal lot ; integer ran g e 0 to 32; outD ataJ J n t ; integer ran g e 0 to 32; outD atal : std_ulo g ic_ v ecto r(7 d o w n to 0 ) ;- th c v a lu e o f outI from circu it co n v erted to v ecto r to send ou tD ataJ : std _ u lo g ic_ v ecto r(7 d o w n to 0 ) ;- lh e v alu e o f outJ from circu it co n v erted to v ecto r to send outD atal L O G IC : std J o g ic _ v c c to r(7 d o w n to 0); out D ata) LO G IC ; s td J o g ic _ v e c to r(7 d o w n to 0); --w ill be sent on o u tID lines a flag w ill have to be se t in the top 2 bits b eg in B M : blockm atch port m ap(addingA B yte, elk, in D ata, d o n e, o u tD atal Int. o u tD a ta J J n t) ; p rocess(clk) v ariab le v ariab le v a riab le variab le d estC o u n terl : integer ran g e 0 to 3; d eslC ountcr2 : integer ran g e 0 to 3; destC ounter3 : integer ran g e 0 to 3; iTem p ; in teg er range 0 to 32;

112
Reprotduced with perm ission of th e copyright ow ner. Further reproduction prohibited without perm ission.

variable jT c m p

: inicner

0 to 32;

begin if(risin g ed g e(clk )) iben o u tS ta rtl < = '0 '; o u tS lart2 < = 'O'; o u lS lart3 < = '()'; ad d in g A B y te < = 'O'; circu itS tart < = 'O'; tcm p O u t3 < = 'O'; if(done = '!') then --tempOut <='['; -- so the BM circuit just finished! -- convert outDatal lnt and outDataJJnt to outDatal and outDataJ -- set top 2 bits of outDataJ to zero (it won't overwrite any info) -- destination "000" figure out which link to send the data down -- assign outDestinalion# <= "000", outData# <= outDatal, outID# <= outDataJ. -outStart# <= ' I'; -same data must also be sent to ASSERT task at location "011" iTemp := outDatal Inf, JTemp ;= outDataJJnt; --they have been latched, tell the BM circuit to stop having all Done be high! addingAByte <= '0';-- without adding a byte circuitStart <= 'I'; outDatal LOGIC <= CONV_STD_LOGIC_VECTOR(iTemp, 8); outDataJ_LOGIC <=CONV_STDJ.OaiC_VECTOR(jTemp, 8); for i in 0 to 7 loop outDatal(i) <= outDatal_LOGlC(i); outDataJ(i) <= outDataJ LOGIC( i); end loop; outDataJ(7) <= 'O'; outDataJ(6) <= '0';-- Hags to indicate what this info is -- which link is closest to 000 and which to 011? destCounterl ;= 0; destCountcrZ := 0; destCounterS := 0; for i in 0 10 2 loop if(IDl(i) = 'O') then destCounterl := destCounterl + I; end if; if(ID2(i) = '0') then destCounter2 := destCounter2 + I; end if; if(ID3(i) = '0')then destCounter3 := destCounter3 + I; end if: end loop; if(destCounterl > destCounter2) then if(destCounterl > destCounter3) then -- send down link! outDestination! <= "000"; outSourcel <=mylD; outDatal <= outDatal; outiDI <= outDatal; outStartl <='T; -is assert closer to link 2 or 3'.' dcslCounter2 := 0; destCounter3 := 0; for i in 0 to I loop if(ID2(i) = 'l')then dcs;Counter2 := destCounter2 + I; end if; if(ID3(i) = 'l')lhen deslCounter3 destCounter3 + I; end if; end ItK ip; if(ID2(2) = '0')then

Reprotduced with perm issio n of th e copyright ow ner. Further reproduction prohibited without perm ission.

d cslC ounler2 := dcstC o u n tcr2 +
end if;

1;

if(lD 3 (2 ) = '0 ')lh e n destC ounler3 := dcstC o u n ter3 + 1; end if; ir(dcstC ountcr2 > d estC ounter3) then --sen d p ack et dow n Iink2 outD estin atio n 2 < = "000"; o u tS ource2 < = m y ID; o utD ata2 < = o u tD atal; o u tlD 2 < = outD ataJ; outS tart2 < = '1 '; else - s e n d p acket dow n Hnk3 o u tD estin atio n ] < = "000"; outS ourcc3 < = m ylD ; o u tD a ta l < = outD atal; o u tlD 3 < = o utD ataJ; o u tS ta rtl < = T ; end if; else -- send down link3 outDestination] <= "000"; outSource] <= mylD; outDatal <= outDatal; outlDl <= OutDataJ; outStartl <= 'I -- is assert closer to link 2 or 1? destCounter2 ;= 0; destCounterl ;= 0; for i in 0 to I loop iRID2(i) = 't') then destCounter2 := dcstCounter2 + I; end if; if(IDI(i) = 'I') then destCounterl := destCounterl + I; end if; end loop; if(ID2(2) = '0')then destCounier2 := destCounterl + I ; end if; if(IDl(2) = '0') then destCounterl := destCounterl + I; end if; if(dcstCounter2 > destCounterl ) then -ser d paeket down link! outDestination! <= "000"; outSourcel <= mylD: outDatal <= outDatal; outlDl <= outDataJ; outStartl < = 'l'; else -send packet down link I outDestination I <="000"; outSourcel <= my ID: outDatal-<= outDatal; outlDl <= outDataJ; outStartl <='l'; end if; end if; else if(destCounterl > destCounterl) then -- send down linkl outDestinationl <= "000"; outSourcel <= myID; outDatal <= outDatal; outlDl <= outDataJ; outStartl < = 'l'; -- is assert closer to link I or 37 destCounterl ;=0;

| | | | | | I | | 3

114

R e p r o d u c e d with p erm ission of th e copyright ow ner. Further reproduction prohibited without permission.

deslC o»nlcr3 := 0; fur i in 0 to I loop if(ID I(l) = 'r ) then d estC o u n terl ·." d estC o u n terl -t- I; end II; il'(ID3(i) = ' l ') then destC ounler3 ;= d estC ounter3 + I t end IT; end loop; i r ( I D I ( 2 ) = '0')th e n d estC ounterl := destC o u n terl + I ; end if; if(ID3{2) = '0 ')th e n destC ountcrS ;= destC ounterS + I ; end if; if(destC ounlerl > destC ountcr3) then - s e n d packet dow n Iink2 outD estin atio n l < = "000"; ou lS o u rcel < = m ylD ; o u tD atal <= outD atal; outi D I < = outD ataJ ; o u tS ta rtl < = '1 '; else -s e n d packet dow n Iink3 outD estinalion3 < = "000"; outSourceS < = m y ID; outD ata3 < = outD atal; outlD 3 < = outD ataJ; outStart3 < = '1 '; end if; else - s e n d dow n Ilnk3 outD estination3 < = "000"; oulSource3 <= m ylD ; outD ata3 <= outD atal; outlD 3 < = outD ataJ; outStart3 < = '!'; --is assert closer to link 2 o r 1? destC ounier2 ;= 0; destC ounterl 0; for i in 0 to I Itxtp if(ID 2(i) = T ) then d e stC o u n te rl := d e stC o u n te rl + I ; end if; if(ID I(i) = 'l') th e n d estC o u n terl ;= d e stC o u n terl + I; end if; end loop; if(ID 2(2) = '0 ')th e n d e stC o u n terl := d e stC o u n te rl -t- I ; end if; if(ID I(2 ) = '0 ')th e n destC ounterl := destC ountcrI + I; end if; if(d cstC au n tcrl > destC o u n terl ) then --send packet dow n lin k l o u tD estin atio n l <= "000"; o u tS o u rc e l < = m y ID; o u tD a ta l <= outD atal; o u tlD l < = outD ataJ; o u tS ta rtl < = '1 '; else -s e n d packet dow n lin k l outD estinationl < = " 0 0 0 "; ou tS o u rcel <= m y ID; outD atal < = o utD atal; o u tlD l < = outD ataJ; outS tartl < = '1 '; end if; end if;

15

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

end il';

end if; illin S ta rtl = 'I ') then --som ething h as com e in o ff o f the I lines if(inD eslinationl = m y lD ) then --this packet is for here! Pass it alo n g to the BM circuit addingA B yte <= 't'; in D ata < = In D atal; circuitStart < = '!'; else --then we m ust forw ard the packet --forw ard the packet to the neig h b o u r w ith the closest ID d estC o u n te rl ;= 0; desiC ounterS ;= 0; il\inD cstination 1(0) = 102(01) tlicn d estC o u n te rl := d e stC o u n te rl + 1; end if; if(inD estination 1(1) = 1D1( 1)) then d e stC o u n terl := d e stC o u n te rl + I ; end if; if(in D e stin atio n i(l) = I D l( l) ) then d e stC o u n terl := d estC o u n te rl + 1; end if; if(inD estin atio n !(0 ) = 1D3(0)) then destC ounter3 := deslC ounler3 + I ; end if; if(in D e stin atio n l(l) = 1 03(1)) then destC ounter3 ;= destC ounter3 + 1; en d if; if(in O e stin atio n l(l) = 1 0 3(1)) then d e stC o u n terl := d estC o u n te rl + 1; end if; i((d estC o u n terl > d e stC o u n te rl) then -fo rw a rd packet to 103 o u tD estin atio n l < = inO estination 1: o u tS o u rc e l < = inSource 1; o u tD a ta l < = in O atal ; o u ti0 3 < = in lO l; o u tS ta rtl < = 'l '; else --forivard packet to 102 o u tD e stin a tio n l < = inO estination 1; o u tS o u rc e l < = inSource I; o u tD a ta l < = in O atal; o u tlO l < = in lO l; o u tS ta rtl < = '1 '; end if; end if; end if; if(in S ta rtl = T ) then if(inO estination2 = m ylO ) then - th i s packet is for here! Pass it along to the BM circuit addingA B yte < = '! '; in O a ta < = in O a ta l; circuitStart < = '1 '; else --then we m ust forw ard the packet --forw ard the packet to the n eighbour with the closest It) destC ounterl := 0 ; d estC o u n terl ;= 0; if(in O estin atio n l(0 ) = 101(0)) then destC o u n terl " d estC ounterl + 1; end if; il(in O c slin a tio n l(l) = 101(1)) then destC o u n terl " destC o u n terl + 1; en d if; if(in O c stin atio n l(l) = 101(1)) then destC ounterl ;= destC o u n terl + I; end if;

0

| |;

I

| i| *

116

R epro duced with perm ission of the copyright owner. Further reproduction prohibited without permission.

iU iiiCtestinalion2(0) = 103(0)) tlKii dcslC ountcr3 := destC oum cr3 + 1; end if; if(iiiDesiination2Cl ) = 103(1)) ihen dcstC ounlcr3 := desiC ounler3 + I; end if; if(inD cstination2(2) = 1 0 3 (2 » (hen destC ountcrS := des(C ountcr3 + 1; end if; if(desiC ounler3 > d e stC o u n te rl) then --forw ard packet to 103 o utD estination3 < = inO estination2; outSource3 < = inSource2; outO ata3 < = in O atal; o u ti0 3 < = in l0 2 ; outStart3 < = '! ': else -fo rw a rd packet to 101 o utD estin atio n l <= inO estin atio n !; ou lS o u rcel < = inSource!: outO atal <= in O ata!; o u tlD l < = in l0 2 ; o u tS tartl < = '1 '; end if; end if; end if; if(inStart3 = ' l ') then it);inDestination3 = m ylD ) then - th i s p acket is for here! Pass it along to the BM circu it I c m p 0 u t3 < = '1'; addingA B yte < = '! '; inD aia < = in O atal; circuitS tart < = a d d in g A B y te ;-'!'; else --then w e m ust forw ard the packet -fo rw a rd the packet to the neighbour w ith the closest 10 d estC o u n terl := 0 ; d estC o u n ter! := 0; if(inO estination3(0) = 101(0)) then destC o u n terl := destC ounterl + I; end if; if(in O estin atio n 3 (l) = 101(1)) then d estC ounterl := destC ounterl + I; end if; il% inD estination3(!) = 101(2)) then destC ounterl destC ounterl + I; end if; iflinD estination3(0) = 1 0 2 (0 » then d estC o u n te rl ;= d e stC o u n terl + I; end if; if(inO estination3(l ) = 1D2( I )) then d estC o u n te rl := d e stC o u n terl + I ; end if; if(in D estin atio r,3 (l) = 101(1)) then d estC o u n te rl ;= d e stC o u n terl + I; end if; if(d estC o u n terl > d estC o u n te rl) then --forw ard packet to 103 o u tD estin atio n l <= inO estin atio n !; o u lS o u rc e l < = in S o u rcel; o u tO a ta l <= in O atal; ou t!0 2 <= inlD 3; o u tS ta rtl <= ' I ';
else

-fo rw a rd packet to IDI outD estinationl <= inO estin atio n !; ou tS o u rcel <= in Sou re e l; outO atal <= in O atal; outi 01 < = in l0 3 ; outS tartl < = '! ';

117

R epro duced with permission of th e copyright owner. Further reproduction prohibited without permission.

end if; end If;
end il':

end if; end process; end Ptideseriptiim ; L IB R A R Y ieee; U S E ie c e .s td J o g ic _ l 16 4 .A L L; U SE iccc.sld_logic_arilh.A L L ; U S E iee e.sld Jo g ic_ u n sig n cd .A L L ; EN TIT Y PE _ B M _ A ssert IS PO RT( elk inD estinationl inSource 1 inD aial inlD l inStartl inD estination2 inSourcc2 inData2 inlD 2 inStarÜ inD estinalion3 inSourcc3 inOata3 inlD3 inStarÜ m y ID IDI 1D2 ID3 outD estination! oulSourcel o utD atal outi DI outStartl oulD estination2 outSource2 outD ata2
0U 1ID 2

outStart2 outD estination3 outSourcc3 oulD ata3 0UIID3 outStart3 E N D PE BM Assert;

: in sld logic; : IN S 'fb _ L 0 G lC _ V E C T 0 R (2 dow nto 0); : IN S T D _ L 0 G IC _ V E C T 0 R (2 dow nto 0); : IN STD _U L O G IC _V E C T O R (7 dow nto 0); ; IN ST D _U L O G lC _V E C T O R (7 dow nto 0); : in s td jo g ic ; --goes high w hen the three things above are ready ; IN S T D _L O G iC _V E C T O R (2 dow nto 0); : IN S T D _ L 0 G 1 C _ V E C T 0 R (2 dow nto 0); ; IN STD _U L O G IC _V E C T O R (7 dow nto 0); ; IN S T D _ U L 0 G 1 C _ V E C T 0 R (7 dow nto 0); : in s td jo g ic ; --goes high w hen the three things above are ready : IN ST D _L O G IC _V E C T O R (2 d ow nto 0); ; IN S T D _ L 0 G IC _ V E C T 0 R (2 dow nto 0); ; IN STD _U L O G IC _V E C T O R (7 dow nto 0); : IN STD _U L O O IC _V E C T O R (7 dow nto 0); : in s td jo g ic ; --goes high w hen the three things above are ready : in std_logic_vector(2 dow nto 0);--w hat th is PE's ID is : in std_logic_vector(2 dow nto 0);--w hat PE I's ID is : in sld Jo g ic _ v ec to r(2 dow nto 0);--w hat PE 2's ID is : in std_logic_vector(2 dow nto 0);--w hat PE 3's ID is : out ST D _L O G IC _V E C T O R (2 dow nto 0); ; out ST D _L O G IC _V E C T O R (2 dow nto 0); : out S T D _U L O G iC _V E C T O R (7 dow nto 0); : out STD _U L O G IC _V E C T O R (7 dow nto 0); : out s td jo g ic ; : out ST D _L (X j 1C _V E C T 0R (2 dow nto 0); : out S T D _ L 0 G IC _ V E C T 0 R (2 dow nto 0); : out STD _U L O G IC _V E C T O R (7 dow nto 0); : out S T D _ U L 0 G IC _ V E C T 0 R (7 dow nto 0); : out s td jo g ic ; : out S T D _ L 0 G 1 C _ V E C T 0 R (2 dow nto 0); : out S T D _ L 0 G IC _ V E C T 0 R (2 dow nto 0); : out ST D _U L O G IC _V E C T O R (7 dow nto 0); : out S T D _ U L 0 G !C _ V E C T 0 R (7 dow nto 0);
: out Sldjogic);

A R C H IT E C T U R E P E A sscndescription O F PE_B M _A ssert IS begin proce.ss(clk) variable destC ounterl ; integer range 0 to 3; variable dcstC ounter2 : integer range 0 to 3; variable dcslC ounterS ; integer range 0 lo 3; variable scndE rror : integer range 0 to I ; - "goes high if erro r is detected (so a packet m ust be sent to the --control so that that PE is now neglected) variable badBM : std_logic_vcctor(2 dow nto 0);--represents w hich BM is faulty begin il'trising edge(clk)) then outStartl < = '0 ';

118

R e p ro du ce d with perm ission of th e copyright owner. Further reproduction prohibited without permission.

oulStart2 <= 'O'; oinStart3 < = 'O'; sen d E rro r ;= 0; ir(in S tartl = T ) then --so m ething has com e in o n 'o l'lh e I lines iR inD estinationl = m y lD )th e n --th is packet is for here! --is there an error in the packet'.' if( (in lD I(7 ) = '! ') and CinID2{7) - 'I ') ) then - th e n it is an error packet scndf-rror ;= I; badB M := inSource I; end if; else --then we m ust forw ard the paeket --forw ard the packet to the neighbour w ith the closest ID d e stC o u n terl := 0; destC ounterS ;= 0; if(in D estin atio n l(0 ) = 1D2(0)) then deslC ounler2 ;= dcstC ounler2 + 1; end if; if(in D e stin a tio n l(l) = ID 2 (i)) then d estC o u n te rl ;= d estC o u n te rl + I ; end if; il'linO estination I (2) = ID 2(2)) then destC ounter2 ;= d estC o u n te rl + 1; end if; if(in D estin atio n l(0 ) = ID3(0)) then destC ounler3 ;= d estC o u n terl + I ; end if; if\inO eslination 1( 1) = 1D3( I )) then d e stC o u n terl ;= d e stC o u n terl + I; end if; il(in D cslin atio n l(2 ) = I D l(l)) then d estC o u n te rl := d e stC o u n terl + I; end if; iffd estC o u n terl > d e stC o u n terl) then --forw ard packet to ID I o u tD estin atio n l <= inD estinationl ; o u tD a ta l < = inD atal ; o u tlD l < = in lD l; o u tS o u rc e l <= inSource I ; o u tS ta rtl < = '1 '; else -fo rw a rd packet to ID I o u tD e stin a tio n l <= in D estinationl ; o u tD a ta l <= in D atal; o u tlD l <= in lD l; o u tS o u rc e l <= inSource 1; o u tS ta rtl < = T ; end if; en d if; end if; il^in S tartl = '! ') then iffin D estin atio n l = m ylD ) then --this packet is for here! I'ass it alo n g to the BM circuit - w a s there an error in the packet'.' if( (inlD 2(7) - 'I') and (inlD 2(7) = '1') Ithen - th e n it is an error paeket sendE rror := I ; badB M . - in S o u rcel; end if; else --then we m ust forw ard the packet -fo rw a rd the packet to the neighbour w ith the closest ID destC o u n terl := 0 ; d estC o u n terl := 0; if(in D estin atio n l(0 ) - IDl(O )) then destC o u n terl d estC ounterl + I;

119

Reproiduceid with pefm ission of th e copyfight owner. Further reproduction prohibited without permission.

cud if; ir(in D eslin atio n 2 (l) = 101(1)) then destC o u n terl ;= destC o u n terl + 1; end if; if(inD cstination2(2) = 101(2)) then destC ountcr 1 ;= destC ounter 1 + I ; end if; il'(inD estination2(0) = 1 0 3 (0 » then destC o u n ter] ;= d estC o u n tcr] + I ; end if; i(X inO estination2(l) = 103(1)) then destC o u n tcr] := d estC o u n ter] + 1; end if; if(inD estination2(2) = 103(2)) then d estC o u n ter] := d estC o u n ter] + I ; en d if; if(d estC o u n ter] > d estC o u n terl) then --forw ard packet to ID ] o u tD estin atio n ] <= in O estin atio n ]; o u tS o u rce] < = inSourcc2; o u tO a ta ] < = inOata2; o u tlD ] < = inlD 2; o u tS ta rt] < = 'l '; else --forw ard p acket to lO l o u tD estin atio n l < = in O estin atio n ]; o u tS o u rcel < = inSource2; o u tD atal <= inO ata2; o u tlD l < = inlD 2; o u tS tartl < - '1 '; en d if; end if; end if; ilfin S ta rt] = 'I') then i((in O estin atio n ] = m ylD ) then --th is packet is for here! Pass it along to the BM circuit --w as there an error in the packet? if( (inlD 3(7) = ' 1') and (in l0 3 (7 ) = ' 1') )then --then it is an error p ack et sendE rror ;= 1; badB M := inS ource]; en d If; else --then we m ust forw ard the packet --forw ard the packet to the neighbour w ith the closest ID d estC ounterl := 0; d estC o u n ter] := 0; if(in D estin alio n ](0 ) = 101(0)) then destC o u n terl := d estC o u n terl + 1; en d if; if(in O e stin atio n ](l) = 1 0 1 (1 » then destC o u n terl ;= d estC o u n terl + 1; end if; if(in O cstin atio n ](2 ) = 101(2)) then d estC ounterl ;= d estC ounter 1 + 1; end if; if(in O estin atio n ](0 ) = 102(0)) then d estC o u n ter] ;= d e stC o u n tcr] + 1; en d if; if(in O e stin atio n ](l) = 102(1)) tlicn destC o u n tcr] ;= d e stC o u n tcr] + 1; end if; if(in O estin atio n ](2 ) = 102(2)) then d estC o u n te r] := d e stC o u n ter] + I ; end if; if(d estC o u n ter] > d e stC o u n terl) then -fo rw a rd packet to 103 o u tD estin atio n ] <= in O estin atio n ]; o u tS o u rc e ] < = in S o u rce]; o u tO a la ] <= inO ata];

120

R e p ro d u c e d with perm ission of the copyright owner. Further reproduction prohibited without permission.

011Ü D 2 < = iiilD 3 -,

outSlart2 < = '1 '; else --forw ard p ack et to IDI ou tD estin atio n l <= inD estinationS; o u tS o u rc e l < = in S o u rc e3 ; o u tD atal < - iuDalaS: o u IID l <= inlD 3; o u tS tartl < = T. end if: en d if; end if; iffsendE rror = 1) then --sen d a packet to "000" co n tain in g a m essage that say s:d o n 't use BM located in --badB M - w h ic h link is closest to 0007 destC o u n terl ;= 0; d estC ounter2 := 0; dcstC ounterS ;= 0; for i in 0 10 2 loop if(ID I(i) = 'O') then d estC o u n terl := d estC ounterl + 1; end if; ifl:iD2(i) = '0') then d e stC o u n te rl ;= d e stC o u n te rl + 1; end if; ifîlD 3 (i) = '0') then d e stC o u n te rl ;= d estC o u n te rl + I ; end if; en d loop; il% destCounterl > d e stC o u n te rl) then if(d estC o u n terl > d e stC o u n te rl) then --send dow n linkl o u tD estin atio n l < = " 0 0 0 "; o u tD atal (7) < = '0 ';r o u tD atal (6) < = 'O'; o u tD a la l(5 ) <= 'O'; o u tD a ta l(4) < = 'O'; o u tD a ta l(l) <= 'O'; outD ala I (2) < = b ad B M (l); o u tD a ta t(t) < = b ad B M (l); outD atal(O ) < = badBM (O); o u tlD l <= "00000000"; o u tS o u rcel < = m y ID; outS tartl < = 'l '; else --sen d dow n lin k l o u tD estin atio n l <= "000"; o u tD a ta lf? ) <= 'O'; o u tD a ta l(6 ) <= 'O'; ou lD ata3(5) < = 'O'; ou tD ala3(4) < = 'O'; o u tD a ta l(3) <= 'O'; o u tD a ta l(2 ) <= badB M (2); o u tD ata3 (l ) < = hadB M (t ); o utD atal(O ) <= hadBM (O); outlD 3 <= "00000000"; o u tS o u rc e l <= niylD ; o u tS ta rtl < = '! '; end if; else If(d estC o u n terl > d e stC o u n te rl) then - s e n d dow n lin k l o u lD eslin alitm l <= "000". outDal;i2{7) < = 'O'; outD ala2(6) <= '()'. outD ata2(5) <= 'O'; o u tD a ia l(4 ) 'O';

121

R e p ro d u c e d with perm ission of th e copyright owner. Further reproduction prohibited without permission.

ou tD ala2 (3 ) < = 'O'; o u tD ata2 (2 ) < = b adB M (2); outD ata2( 1) < = b adB M ( I ); ou lD ata2 (0 ) < = badBM (O ); 0UIID2 < = "00000000"; o u tS o u rce2 <= m ylD ; oulS tart2 < = '! '; else - s e n d dow n linkS oulD cslinalion3 < = "000"; ou tD ata3(7) < = 'O'; outD ataB fô) < = 'O'; ou tD ata3 (5 ) < = 'O'; ou tD ata3 (4 ) < = 'O'; ou lD ata3 (3 ) < = 'O'; ou tD ala3 (2 ) < = b adB M (2); outD ata3 ( 1) < = b adB M ( I ); ou tD ata3 (0 ) < = badBM (O); o u tlD 3 < = "00000000"; oulSourceS < = m y lD ; o utS lart3 < = '! '; end if; end if; end if; en d if; en d pro cess; end PE A ssertdcscription; L IB R A R Y ieee; U S E ie e e .std Jo g ic _ I I64.A L L ; U S E ieee.sld_logic_arith.A L L ; U S E ieee.std_logic_unsigned.A L L ; EN T IT Y PE _ F in al_ A sscrt IS PO R T (. elk in D estin atio n l inS ource 1 in D atal inlD I in S tartl inD estination2 inSourcc2 in D a ta l inlD 2 in S ta rtl inD estination3 inSourcc3 inDataS inlD 3 in S ta rtl m ylD IDI ID I ID3 o u tD estin atio n l o u tS o u rcel o u tD atal o u tlD l o u tS tartl o u tD e stin a tio n l o u tS o u rc e l o u tD a ta l o u tlD l o u tS ta rtl o u tD estin atio n l o u tS o u rc e l o u tD a ta l in s td jo g ic ; IN S T D _ L O G lC _ V E C T O R (l d o w n to 0); IN S T D _L O G IC _V E C T O R (2 dow nto 0); IN S T D _ U L O G IC _ V E C T O R (7 d o w n to 0); IN S T D _ U L O G lC _ V E C T O R (7 dow nto 0); in s td jo g ic ; --g o es high w hen the three th in g s above are read y IN S T D _L O G lC _V E C T O R C l d o w n to 0); IN S T D _ L O G lC _ V E C T O R (2 d o w n to 0); IN S T D _ U L 0 G IC _ V E C T 0 R (7 dow nto 0); IN STD _U L O G 1C _V E C T O R {7 dow nto 0); in s td jo g ic ; --g o es high w hen the three th in g s above are ready IN S T D _ L 0 G 1 C _ V E C T 0 R (1 d o w n to 0); IN S r D _ L 0 G lC _ V E C T 0 R (2 dow nto 0); IN ST D _U L O G IC _V E C T O R (7 dow nto 0); IN S T D _ U L 0 G IC _ V E C T 0 R (7 dow nto 0); in s td jo g ic ; - g o e s high w hen the three things above are read y in std _ lo g ic_ v e c to r(l d ow nto 0 );--w hat this PE's ID is in std _ lo g ic_ v ecto r(2 dow nto 0 );--w hat PE I's ID is in std _ lo g ic_ v e c to r(l dow nto 0 );--w hat PE I 's ID is in std _ lo g ic_ v e c to r(l dow nto 0);--w hat PE I 's ID is o u t S T D _ L O G IC _ V E C T O R (2 dow nto 0); o u t ST D _ L O G IC _ V E C T O R (2 d ow nto 0); o u t S T D _U L O G IC _V E C T O R (7 dow nto 0); o u t S T D _ U l.O G IC _ V E C T O R (7 d ow nto 0); o u t s td jo g ic ; o u t S T D _ L 0 G IC _ V E C T 0 R (2 dow nto 0); o u t S T D LO G IC _ V E C T 0 R (1 dow nto 0); o u t S T D _U L O G IC _V E C T O R (7 dow nto 0); o u t ST D _U L O G IC _V E C T O R {7 dow nto 0); o u t s td jo g ic ; o u t S T D _ L 0 G IC _ V E C T 0 R (1 dow nto 0); o u t S T D _ L O G IC _ V E C T O R (l dow nto 0); o u t S T D _U L O G IC _V E C T O R (7 dow nto 0);

I

122

R e p ro d u c e d with perm ission of the copyright ow ner. Further reproduction prohibited without perm ission.

<)UtlD3 o utS lart3 i-.N D P(i l'inal_A sscrf.

: o u i S T D _U L O G IC _V K C T Ü R (7 dow nto Ü); : o u t s td jo g ic ) ;

A R C H IT r-C T U R Ë P E F inalA ssertd escrip tio n O F P E _ F in al_ A sscrt IS

b e g in proccss(clk) variable d estC o u n te rl : in teg er ran g e 0 to 3; variable d e s tC o u n te rl : in teg er ran g e 0 to 3; variable destC o u n tcr3 : integer ran g e 0 to 3; variable se n d E rro r : in te g e r range 0 to 1 goes h ig h i f error is detected (so a packet m ust be sen t to the --co n tro l so that that PE is now n eglected) variable badB M : s ld J o g ic _ v e e to r(2 dow nto 0);--represents w hich B M is faulty begin if(risin g _ ed g e(elk )) then o u tS ta rtl < = 'O'; o u tS ta rtl < = 'O'; outSlart3 < = 'O'; sen d E rro r ;= 0; if(in S tartl = T ) then --so m eth in g has co m e in o f f o f the I lines if(in D e stin atio n l = m y ID ) then --th is p acket is for here! --is there an e rro r in the packet? if( (in lD !(7 ) = 'I ') and (in ID 2(7) = '! ') ) then --th en it is an error packet s e n d E rro r ;= I ; badB M ;= in S o u rc e l; end if; e lse - th e n w e m ust forw ard the p acket -fo r w a r d the p ack et to the neig h b o u r w ith the closest ID d e stC o u n te rl ;= 0; d estC ountcr3 ;= 0 ; if(in O estin atio n 1(0) = ID 2(0)) then d e s tC o u n te rl ;= d e stC o u n te rl + I ; en d if; if(in D e stin a tio n l!I) = 1132(1)) then d e stC o u n te rl ;= d e stC o u n te rl + 1; end if; if(in D e stin a tio n l(2 ) = ID 2(2)) then d e stC o u n te rl d e stC o u n te rl + I; end if; if(in D e stin atio n l(0 ) = 1D3(0)) then d e stC o u n te rl ;= d e stC o u n te rl + I ; en d if; if(in D estin atio n 1(1) = I D3( 1)) then d e s tC o u n te rl ;= d e stC o u n te rl + 1; end if; if(in D e stin a tio n l(l) = I D l( l) ) then d e stC o u n te rl := d e stC o u n te rl + I ; en d if; i((d e stC o u n te rl > d e stC o u n te rl) then --forw ard packet to ID1 o u tD e stin a tio n l < - in D e stin a tio n l; o u tD a ta l < = in D a ta l; o u tlD l < = in lD I; o u tS o u rc e l <= in S o u rc e l; o u tS ta rtl < = 'l '; else --forw ard packet to ID I o u tD e stin a tio n l < = in D e stin a tio n l; o u tD a ta l <= in D a ta l;

123

Reprotduced with p erm ission of th e copyright ow ner. Further reproduction prohibited without perm ission .

o u t!D 2 < = in lD l; o u tS o u rce2 < = in S o u rce 1; o u tS ta rt2 < = '1 ';
end if;

end if; en d if; if(in S ta rl2 = T ) th en if(in D estin atio n 2 = m y ID ) then --th is p a c k et is for here! Pass it a lo n g to th e BM circu it --w as th ere an erro r in the p ack et? i!% (in lD 2 (7 ) = '] ') an d (in lD 2 (7 ) = T ) )thcn --th en it is an erro r p ack et se n d E rro r ;= 1 ; b ad B M := inS ource2; end if; else --then w e m u st forw ard th e p ack et --forw ard th e p ack et to th e n eig h b o u r w ith the c lo se st ID d estC o u n te rl := 0 ; d estC o u n ter3 ;= 0; if(in D estin atio n 2 (0 ) = 1 0 1 (0 )) then d estC o u n te rl ." d estC o u n te rl + 1; en d if; if(in O e stin a tio n 2 (l) = 1 0 1 (1 )) then d e stC o u n te rl ;= d e stC o u n te rl + 1; en d if; if(in O estin atio n 2 (2 ) = 1 0 1 (2 )) then d e stC o u n te rl ;= d e stC o u n te rl + 1; e n d if; if(in O estin atio n 2 (0 ) = 1 0 3 (0 )) then destC o u n terS := d e stC o u n te r3 + I ; e n d if; if(inO estination2{ I ) = 1 0 3 (1 )) then destC o u n ter3 := destC o u n terS + 1; en d if; if(in O estin atio n 2 (2 ) = 1 0 3 (2 )) then d e stC o u n ter3 ;= d e stC o u n ter3 + 1; en d if; if(destC o u n ter3 > d e s tC o u n te rl) then --fo rw ard p ack et to 103 o u tO estin atio n 3 < = in O estin atio n 2 ; o u tS o u rc e 3 < = in S o u rcc2 ; o u tO ata3 < = inO ata2; o u ti0 3 < = in I0 2 ; o u tS ta rt3 < = ' 1'; else --forw ard p a e k et to ID l o u tD e stin a tio n l < = in O estin atio n 2 ; o u tS o u rc e l < = in S ource2; o u tO a ta l < = inO ata2; o u tlD l < = in i0 2 ; o u tS ta rtl < = '1 '; en d if; en d if; en d if; if(in S tart3 = '1') then if(in O estin atio n 3 = m y ID ) then --th is p a c k et is fo r here! Pass it a lo n g to the BM circu it --w as there a n e rro r in the p ack et? iR (in l0 3 (7 ) = T ) and (in l0 3 (7 ) = '! ') )then --th en it is an e rro r p acket se n d E rro r := 1; b ad B M := in S ourcc3; en d if; else --then w e m u st forw ard th e p acket --forw ard th e p ack et to th e n eig h b o u r w ith the c lo sest 10 d estC o u n te rl := 0; d estC ounterS := 0; if(in O cstin atio n 3 (0 ) - 1 0 1 (0 » then

124

R e p r o d u c e d with pe rm ission of th e copyright o w n er. Fu rth er reproduction prohibited without perm ission.

d c stC o u n lcrl := d estC o u n terl + I; en d if; if(in D e slin alio n 3 (l) = I D I ( l) ) then d e stC o u n terl := d estC o u n terl + I; en d if; lf(in D cstin atio n 3 (2 ) = ID I(2)) then d e stC o u n terl ;= d estC o u n terl + I; en d if; il\in D estin atio n 3 (0 ) = 1 0 2 (0 » then dcstC o u n tcr2 ;= destC o u n ter2 + I ; e n d if; if(in O e stin atio n 3 (l) = 1 0 2 (1 » then destC o u n ter2 ;= destC o u n tcr2 + I ; e n d if; if(in D estin atio n 3 (2 ) = 1 0 2 (2 » then dcstC o u n ter2 dcstC o u n tcr2 + I ; en d if; if(destC ountcr2 > d e stC o u n terl ) then --forw ard p aek et to 103 o u tO estin alio n 2 < = in O estination3; o u tS o u rcc2 < - inSourcc3; o u tO ata2 < = inO ataS; o u ti0 2 < = inlD 3; o u tS tart2 < = ' I '; else --forw ard p ack et to 101 o u tD estin atio n l <= inO estination3; o u tS o u rc e l < = in S ource3; o u tD a ta l < = in O a ta 3 ; o u tiO I < = inlD 3; o u tS ta rtl < = '1 '; en d if; en d if; end if; if(s e n d E rro r= I) then --sen d a p ack et to "000" co n tain in g a m essag e that say s.d o n 't use BM located in --badB M --w hich link is cloS(est to 000? d estC o u n terl := 0 ; d estC o u n ter2 ;= 0; deslC otinter3 ;= 0; for i in 0 to 2 loop if(IO I(i) = '0 ')th e n d estC o u n te rl := d estC o u n terl + I; en d if; i« ID 2 (i) = '0 ')lh e n destC o u n ter2 := d esiC o u n ter2 + I; en d if; ii(IO 3(i) = '0 ')th e n d estC ounier3 := destC o u n ler3 + I ; en d if; end loop; if(d estC o u n terl > destC o u n ter2 ) then if(d eslC o u n terl > d estC ounter3 ) then - s e n d dow n lin k l o u tD estin atio n l < = "000"; o u tD a ta l < = " 0 0 0 0 0 0 0 0 "; o u tlD l < = "00000000"; o u tS o u rcel < = m y lO ; o u tS ta rtl < = '1 ', else --sen d dow n link3 o utO estinatioii3 <= "000"; o uiO ata3 < = "00000000"; o u tlD 3 < = "0 0000000"; <)utSource3 <= my ID; u u tS ta rtj < = ' 1';

125

R e p ro d u c e d with pe rm ission of th e copyright ow ner. Further reproduction prohibited without perm ission.

end if;

else lfl;destC ounler2 > destC o u n lcrS ) Ihen --send dow n lin k l o u tD e s tin a tio n l < = "000"; o u tD a ta l < = "0 0000000"; o u tlD l < = "00000000"; o u lS o u rc e l < = m y ID; o u tS ta rtl < = '1 '; else --send dow n Iink3 o u tD e stin a tio n ) < = "000"; outD ata3 < = "00000000"; o u tlD 3 < = "00000000"; o u tS o u rc e ) < = m ylD ; o u tS ta rt) < = '1 '; end if; en d if; end if; e n d if; en d pro cess; en d P F .l'in alA ssertd cscrip tio n ; L IB R A R Y ieee; U S E iee e .std _ lo g ic_ l 16 4 .A L L ; U S E ieee.std _ lo g ic_ arith .A L L ; U S E iece.std _ lo g ic_ u n sig n ed .A L L ; EN TITY P E _ C P U IS--th e in terface an d control circu itry PO R T ( elk inS ignalF rom C P U in D ataF rom C P U in D estin atio n l in S o u rcel in D atal inlD I in S tartl in D e stin a tio n l in S o u rc e l in D a ta l in lD l in S ta rtl in D estin atio n ) in S o u rce) in D a ta ) in ID ) in S tart) m y lD IDI ID I "around" the cp u in s td jo g ic ; in s t d j o g i c ; --there is d a ta av ailab le from the C P U IN S T D _ U L O G IC _ V E C T O R (l6 d o w n to 0 ) ; - 8 d o w n to 0 ) ;- th e data --from th e C P U IN S T D _ L 0 G IC _ V E C T 0 R (1 d o w n to 0); IN S T D _ L 0 G I C _ ''E C T u R (2 d o w n to 0); IN S T D _ U L O G IC _ V E C T O R (7 d o w n to 0); IN S T D _ U L O G IC _ V E C T O R (7 d o w n to 0); in s td j o g i c ; --g o es h ig h w hen th e th ree th in g s a b o v e arc read y IN S T D L O G IC _ V E C T O R (l d o w n to 0); IN S T D I l O G IC _ V E C T O R ( 1 d o w n to 0); IN S T D _ U L 0 G IC _ V E C T 0 R (7 d o w n to 0); IN S T D _ U L O G IC _ V E C T O R (7 d o w n to 0); in s ld j o g i c ; --goes hig h w hen the th ree th in g s ab o v e are rcadv IN S T D L O G tC _ V E C T O R (l d o w n to 0); IN S T D _ L 0 G 1 C _ V E C T 0 R (1 d o w n to 0); IN S T D _ U L 0 G IC _ V E C TOR(7 d o w n to 0); IN S T D _ U L 0 G IC _ V E C T 0 R (7 d o w n to 0); in s td j o g i c ; --goes hig h w hen th e three th in g s ab o v e arc read y in s td J o g ic _ v e c to r( l d o w n to 0);--w h a t th is PE's ID is in sld _ lo g ic _ v e c to r(l dow nto 0);--w h at PE I's ID is in s td _ lo g ic _ v e c to r(l d o w n to 0);--w h at PE I 's ID is in std _ lo g ic _ v e c to r(l d o w n to 0);--w h at PE ) 's ID is o u t s t d j o g i c ; --th ere is d ata av ailab le from the C P U o u t S T D _ U L 0 G IC _ V E C T 0 R (8 d o w n to 0 );--the d a ta from the C PU out S T D U L O G IC _ V E C T O R ( 16 d o w n to 0);--th e d a ta front the C P U out S T D _ L O G IC _ V E C T O R (l d o w n to 0); out S T D _ L O G IC _ V E C T O R (l d o w n to 0); out S T D _ U L O G iC _ V E C T O R (7 d o w n to 0); o u t S T D _ U L O G IC _ V E C T O R (7 d o w n to 0); out s td jo g ic ; o u t S T D _ L O G IC _ V E C T O R (l d o w n to 0); out S T D _ l.O G IC _ V E C T O R (2 d o w n to 0); out S T D _ U L O G IC _ V E C T O R (7 d o w n to (I); o u t S T D _ U L O G IC _ V E C T O R (7 d o w n to 0); o u t sld logic; out S T D _ L O G IC _ V E C T O R (l d o w n to 0); o u t S T D _ L O G IC _ V E C f O R ( l d o w n to 0):

ID)
o u tS ignalT oC P U --o utD ataT oC P U ou tD alaT o C P U o u tD estin atio n l o u tS o u rc e l o u tD a ta l o u tlD l o u tS ta rtl o u tD e stin a tio n l o u tS o u rc e l o u tD a ta l o u tlD l o u tS ta rtl o u tD e stin a tio n ) o u tS o u rc e )

126

Reprotducetd with p erm ission of th e copyright ow ner. Further reproduction prohibited without p erm ission.

o u tD ata3 outi D3 --tem p tem p

; o u t S rD _U L 001C _V K C rO R[7 d o w n to 0); : o u t STD_U LOG 1C_V ECTOR; 7 d ow nto Ü);

tem p B M C o u n ter : o u t in teg er ran g e 0 to 13; tem p D estin atio n B M : o u t s td J o g ic _ v c c to r(2 d o w n to 0); o u tS ta n 3 : o u t s td jo g ic ) ; EN D P E _ C P U ; A R C H IT E C T U R E P E C P U O F PE _C PU IS com p o n en t regS IS P O R T (load : IN s td j o g i c ; clock ; in s td j o g i c ; datain : IN std _ u lo g ic_ v ecto r(7 d o w n to 0); d a ta o u t : O U T std _ u lo g ic_ v ecto r(7 d o w n to 0)); --parallel outputs EN D c o m p o n e n t; signal lo a d lR e g ; s td J o g ic _ v e c to r(!3 d o w n to 0); signal lo ad JR eg : s td jo g ic _ v c c to r( l3 d o w n to 0); signal B M In te rm e d ia ie l : std _ u lo g ic_ v ecto r(7 d o w n to 0); signal B M In term ed iateJ : sld _ u lo g ic_ v ecto r(7 d o w n to 0); subtype W O R D S is S T D _ U L O G IC _ V E C T O R (7 d o w n to 0); type A R R A Y O F B Y T E S I4 is array (13 d o w n to 0) o f W O R D S; signal B M lD a ta : A R R A Y O F B Y T E S 1 4 ; signal B M JD a ta : A R R A Y O F B Y T E S I4 ; - s ig n a l B M I D estination : s td J o g ic _ v e c to r(2 d o w n to 0) := "001 "; -s ig n a l B M 2 D estin atio n : s td J o g ic _ v e c to r(2 d o w n to 0 ) := "CIO"; --signal S p a re B M ! : s td J o g ic _ v e c to r(2 d o w n to 0 ) := " 10 1"; --signal S p areB M 2 : s td J o g ic _ v e c lo r(2 d o w n to 0) -s ig n a l S p areB M 3 : std _ lo g ic_ v ecto r(2 d ow nto 0) := " 1 11"; --signal d estin atio n B M : s td J o g ic _ v e c to r(2 d o w n to 0) ;= "001"; --signal B M c o u n tcr : in teg er range 0 to 13 .·= 0; begin - r e g l : lor i in 0 to 13 generate re g l Label: regS p o rt m ap (lo ad lR eg (i). elk, B M ln tc m ic d iate l. B M lD ata(i)); reg 2 L ab el: regS p o rt m ap (lo ad JR eg (i). elk. B M In term ed iateJ. B M JD ata(i)); --end generate; p ro eess(clk ) variable destCounterl ; integer range 0 to 3; variable destCounter2 : integer range 0 to 3; variable destCounterS : integer range 0 lo 3; variable BMcounter : integer range 0 to 13 0; variable BM I Destination : stdJogic_vector(2 downto 0) := "001" variable BM2Destination ; stdJogic_vector(2 downto 0) := "010" variable SpareBM I : stdjogic vector(2 downto 0) := "101"; variable SpareBMZ : stdJogic_vector(2 downto 0) := "110"; variable SpareBM3 ; std_logic_vector(2 downto 0) := "111 variable destinationBM : stdJogic_vector(2 downto 0) := "001": variable BMOutCounter ; integer := 0; variable packotToGo : integer range 0 to I := 0; variable toGoDestination : stdJogic_vector(2 downto 0); variable toGoData : std_ulogic_vector(7 downto 0); variable toGoLink · integer range I to 3; begin tempDestinationBM <= destinationBM; tempBMCounter <= UMCounter; ilUising_edge(clk)) then outStartl <= 'O'; outStart2 <= 'O'; outStartS <= 'O';

" 1 10";

127

ReD roduced with Dermission of th e copvriaht ow ner. Further reproduction prohibited without p erm ission.

o u tS ig n alT o C P U < = 'O'; lo a d lR e g < = (o th ers = > 'O'); lo ad JR eg < = (others = > '0'); il\in S ta rtl = 'I ') then --so m eth in g has com e in otT o f the 1 lines if(in D e stin atio n l = m y ID ) then --th is p acket is for here! --i f it is from a BM circuit w e need to h av e th at d ata ready to g ive --to th e L E D S reg ister - i f it is from th e BM assert then w e need to cancel use o f th e g iv en BM - c ir c u it if(in S o u rcel = "011") then --th en it is an assert signal to b lo ck the use o f a B M circuit --so sim ply change the B M #D estination sig n als a n d sp areB M --s tu ff il\S p a re B M l = "000") then - th e r e are no spares left - do n o th in g else if( (in D a ta l(2) = B M lD e stin a lio n (2 )) and ( in D a ta l( l) = B M lD c s tin a tio n (l)) and (in D aia 1(0) = B M lD estination(O )) ) then --BM 1 is to be replaced BM 1 D estination ;= S p areB M I ; - n o w m o v e th e oth ers d o w n th e line S p areB M ! := S p a re B M 2 ; S pareB M 2 SpareB M S; S p a reB M ] := "000"; else --B M 2 is to be rep laced B M 2D estination := Sp areB M 1; --now m o v e th e o th ers dow n the line S pareB M 1 := S p a re B M 2 ; S pareB M 2 ;= S p a re B M ]; S p a reB M ] := "000"; en d if; en d if; e lsi((in S o u rc e l = " 1 0 0 " ) then --then it is an error on the final task, w e are not su p p o rtin g --erro r recovery in th is case since w e have no sp a re general - p u rp o s e CPU else - it is info from a BM circuit - that needs to be stored in the -- corresponding place BMIntermediaiel <= inDatal; BMIntermediateJ <= inlDl; loadlReg(BMCounter) <='!'; loadJReg(BMCounter) <= '1'; BMCounter ;= BMCounter + 1; if(BMCounter> 1]) then BMCounter := 0; end if; -- now just send it directly to the LEDS for reading by -- software outDataToCPU(15 downto 8)<=inlDl(7 downto 0); outDataToCPU(7 downto 0) <= inDatal(7 downto 0); outSignalToCPU <='!'; end if; else -then we must forward the packet -- forward the packet to the neighbour with the closest ID destCounter] := 0; destCounter] ;= 0; i('(inDestination 1(0) = 1D2(0)) then destCounter] := destCounter] + 1; end if; if(inDestinationl(l) = 1D2(1)) then destCounter] := destCounter] + 1; end if; if(inDcstinationl(]) = 1D2(])) then destCounter] := destCountcr] + 1;

128
R eD roduced with perm ission of th e copvriaht ow ner. Further reproduction prohibited without perm ission.

en d if; if(in D estin atio n l(0 ) = 1D3(0)) then destC o u n ter] := dcstC ounlerd + I : en d if; if(in D e stin a tio n l(l) = 1D3(D ) then d estC o u n ter] .= destC ounter3 t- 1; en d if; if(in l> ;stin atio n l(2 ) = 1D3(2)) then destC o u n ter] := d estC ounter] + I ; e n d if; if(dcstC ountcr3 > d estC o u n ter]) then --forw ard p acket to ID ] o u tD estin atio n ] <= in D estin atio n l; o u tD a ta ] < = inD atal ; o u tlD ] < = in lD l ; o u tS o u rc e ] < = in S o u rce!; o u tS tart] < = '! ';
else

-fo rw a rd packet to 1D2 o u tD estin atio n ] < = inD estinationl ; outD ata2 <= in D atal; outlD 2 < = in lD I: o u tS o u rc e ] < = inSourcel ; outStart2 < = '!'; en d if; end if; end if; iffin S ta rt] = '! ') then if(inD estination2 = m ylD ) then --th is packet is for here! --if it is from a BM circuit we need to have that d ata ready to give --lo the LEDS register - i f it is from the BM assert then we need to cancel use o f the given BM --circuit if(inSource2 = "011") then --then it is an assert signal to block the use o f a BM circuit --so sim ply change the B M #D estination signals and spareB M -stu lT if(S pareB M l = "000") then --there are no spares left - do n o thing else if( (inD ata2(2) = BM 1 D estination(2)) and (inD ata2( 1) = BM I D estination( I )) and (inD ata2(0) = BM 1D cstination(O)) ) then --BM I is to be replaced BM 1D estination := SpareB M 1; --now m ove the others dow n the line SpareB M I ;= SpareB M Z; S p areB M ] := S p a reB M ]; S p areB M ] := "000"; else --BM 2 is to he replaced B M 2D estination ;= SpareB M 1; - n o w m ove the others dow n the line SpareB M I ;= S p a reB M ]; S p a reB M ] ;= S p a reB M ]; S p areB M ] ;= "000"; end if; end if; elsiftin S o u reel -- "100") then --then it is an error on the final task, w e are not supporting --error recovery in this case since we have no spare general --p urpose CIH) else -it is info from a BM circuit - that needs to he stored in the -corresponding place BMlnlerniediatcl <= inData]; BMIntermediateJ <= inlD2; loadIReglBMCounler) <= 'I'; loadJReg(BMCounter) <= T; BMCounler ;= BMCounter + 1;

129

ReDroduced with Dermission of the coDvriaht owner. Further reoroduction prohibited without permission.

iHBMCounler> 13) then BMCounler := 0; end iC ; -- now just send it directly to the LEDS lor reading by -software -outDataToCPU{8) <= 'O '; outDataToCPU(15 downto 8) <= inlD2(7 downto 0); outDataToCPU(7 downto 0) <= inOata2(7 downto 0); outSienalToCPU<='l';
end it;

else --then w e m ust Ibrw ard the packet -fo rw a rd the packet to the neig h b o u r w ith the closest ID destC ounterl ;= 0; destC ounterS := 0; if(inD eslination2(0) = ID l(O )) then else destC ounterl ;= destC ounter! + 1; end if; if(in D estin atio n 2 (l) = I D l(l)) then else destC ounterl := destC o u n terl + 1; en d if; if(inD estination2(2) = ID 1(2)) then else d estC ounterl d estC o u n terl + I; end if; if(inO estination2(0) = ID 3(0)) then else destC ounterS := destC ounterS + I; en d if; if(inD estination2(l ) = ID S (I)) then else destC ounterS := destC ounterS + 1; en d if; if(inD estination2(2) = 103(2)) then else destC ounterS ;= destC ounterS + I; en d if; if(destCountcrS > d estC ounterl ) then -fo rw a rd p acket to IDS outD estinationS < = inD cstination2; outSourceS < = inSource2; outD ataS <= inD ata2; outlD S < - inlD 2; outStartS < = '1 '; else -fo rw a rd packet to 1D 1 o utD estinationl <= inD estination2; o u tS o u rcel < = inSourcc2; o u tD atal < = in D a ta 2 ; o u tlD l < = inlD 2; o u tS tartl < = '1 '; en d if; end if; end if; iffinSlartS = '1') then if(inD cstinationS = my ID) then - th i s packet is for here! --if it is from a BM circuit w e need to have that data ready to give - t o the LEDS register --i f it is from the BM assert then we need to cancel use o f the given BM --circuit if(inSourceS = "011 ") then - th e n it is an assert signal lo block the use o f a BM circuit - s o sim ply change the BM f!D estination signals and spareB M --stulT if(SpareB M l = "000") then --there are no spares left - do nothing

130
R e p ro du ce d with permission of th e copvriqht owner. Further reproduction prohibited without permission.

else il`( (inD ata3(2) = U M lD csliniU ioii(2)) an d (in D ata3 (l ) = BM I D eslinaliiin( 1)) and (inD ata3(0) = BM llD eslination(O))) then --BM I is 10 he replaced BM I D estination := S pareB M I ; - n o w m ove the others d o w n the line SpareB M 1 ;= S p a rc B M 2 ; SpareB M Z := S p areB M ] : S p areB M ] := "000": else - B M 2 is to be replaced B M ZD cstination := S pareB M 1: - n o w m ove the others d o w n the line SpareB M 1 := SpareB M Z; SpareB M Z := S p areB M ]; S pareB M ] ;= "000"; end if; end if; elsif(in S o u rcel = "1 0 0 " ) then - th e n it is an error on the llnal task, u e are not su p p o rtin g --error recovery in th is case since w e have no sp a re general --purpose CPU else - i t is info from a BM circuit - that needs to be sto red in the --corresponding place B M lnterm ediatel < = inD ata]; B M Interm ediateJ < = inlD 3; load I Rcg(BM C ounter) < = '! '; loadJR eg(B M C ounter) <= '1'; B M C ounler := B M C ounter + 1; if(B M C ounter > 13) then B M C ounler := 0; end if; --now ju st send it directly to the LED S for read in g by -so ftw a re -o u tD ata T o C P U (8 ) < = 'O'; outD ataT oC PU (15 dow nto 8) <= inlD 3(7 d ow nto 0); outD ataT oC PU (7 dow nto 0) <= in D ata] (7 d o w n to 0); outSignalT oC PU <= '1'; e n d if; else -- then we must forward the packet -- forward the packet to the neighbour with the closest ID destCounterl :=0; destCounter] ;- 0; if(inDestination](0) = 101(0)) then destCounterl := destCounterl + 1; end if; if(inDestmation](l) = 1DI(1 )) then destCounterl := destCounterl + 1: end if; iftinDestination](Z) = ID 1(2)) then destCounterl := destCounterl + 1; end if; if(inDestinalion](0) = 102(0)) then destCounter] ;= destCounterZ + 1; end if; if(inDestination](l) = ID2(1 )) then destCounterZ := destCounterZ + 1; end if; if(inDostination](2) = 102(2)) then destCounterZ := destCountcr] r I ; end if; if(destCounter2 > destCounterl ) then -- forward packet to ID] outDestination] <= inDestination]; outSourccZ <= inSource]; outDalaZ <= inData]; oullDZ <= inlD]; uutStartZ <='1';

131

R e prod uc e d with perm ission of the cop'/right owner. Further reproduction prohibited without permission.

else --Ibrw ard packet to IDI outD estin atio n l < = in D estin atio n ]; o u lS o u rcel < = in S o u rce]; o u tD atal < = in D ata3 ; o u tlD l < - inlD 3; outStart 1 < = ' I '; end if; end if; end if; iRinStgnalFromCPU = '1') then - th e n there is incom ing data Irom the CPU it needs tu be distributed to a 13M - c ir c u it - o r if it is a sig n allin g p acket w e need to put info on the LED S for reading.... il\inD ataF rom C P U (16) = '1') then --then it is sig n allin g and \vc should load the contents o f the register --indexed --in the low er 7 bits to the LEDS if(inD ataP rom C P U (15) = '1') then if(inD ataFroniC PU (14) = '1') then -sig n a l from CPU to change the 13M destination -circu it! if(SpareB M l = "000") then - th e r e are no spares left - d o n o thing else il% (inD ataFrom C PU (2) = BM 1D estination(2)) and (inD ataF rom C P U ( 1) = BM 1D estination)I )) and (inD ataFrom C PU (O ) = B M lD estination(O ))) then --BM 1 is to be replaced BM I D estination := SpareB M 1; --now m ove the others - d o w n the line SpareB M 1 = SpareB M 2; SpareB M 2 = S p a reB M ]; S p areB M ] " 000"; else --BM 2 is to be replaced f]M 2D estination := S pareB M I; --now m ove the others --dow n the line SpareB M 1 = SpareB M 2; SparcB M 2 = S p a reB M ]; S p areB M ] = " 000 " ; end if; end if: end if; else end if; -o u tS ig n a lT o C P U < = 'l '; else - th e n data needs to be distributed to the BM circuit! --im m ediately send data to destinationB M - w h ic h link do 1 sen d it out on? packetT oG o ;= 1; toG oD estination ;= destinationB M ; to G oD ata := inD ataFrom C PU )? dow nto 0); destC o u n terl ;= 0 ; d estC o u n ter] := 0; d estC o u n ter] ;= 0; if)d estin atio n B M )]) = ID I)])) then d estC o u n terl ;= destC ounterl + I;

132

R e p ro d u c e d with perm ission of th e copyright owner. Further reproduction prohibited without permission.

end if; if(deslinationB M (l ) = ID I{I )) then d estC ounterl := d eslC ounterl

*

I;

en d if; ir(destinationB M (0) = IDI(O )) then destC ounterl -- d estC ounterl + It en d if; if(destinatlonB M (2) = ID 2(2)) then deslC ounter2 := destC ounterZ + I; end if; if(d estin atio n B M (l) = ID 2(I )) then destC ounterZ ;= destC ounterZ + I ; end if; if(destinationB M (0) = ID 2(0)) then destC ounterZ ;= destC ounterZ + I; en d if; if(destinationB M (Z ) = ID 3(Z)| then destCounterZ := destCounterZ + I . en d if; if(d estin alio n B M (l) = ID3( I )) then destCounterZ := destCounterZ + I; end if: if(desiinaiionB M (0) = ID 3(0)) then destC ounterS := destC ounterS + I; end if; if(d estC o u n terl > destC ounterZ) then if{destC ounlerl > destC ounterZ) then - s e n d to IDI outD estination I < = destinationB M ; o u tD atal <= inD atal-rom C PU (7 dow nto 0); o u lS o u rcel <= "000"; outi L I <= "00000000"; o u tS tartl < = '! '; toGoL.ink ;= I ; else - s e n d to 1D3 outD estinalionZ < = destinationB M ; outDataZ <= inD atal-roniC I'U(7 dow nto 0); outSourccZ <= "000";
0UIID3 <="00000000";

outStartZ <= ' I '; toG o l.in k ;= Z: end If; else if(destCounterZ > destC ounterZ) then - s e n d to ID2 outD estinationZ < = destinationB M ; outD ataZ <= inD ata[-rom C I'U (7 dow nto 0); outSourceZ < = "000"; outlD Z < = "00000000"; outStartZ < = '! '; toG ol.ink := 2; else -send to IDZ outDestinationZ <= destinationBM; OutDataZ <= inDatal'roniCI'U(7 downto 0); outSt'ureeZ <= "000"; outlD3 <= "00000000"; outSiart3 <= 'I'; toGol.ink := 3; end if; end if;

R epro duced with permission of th e copyright owner. Further reproduction prohibited without permission.

1
U M O utC ountcr ;== B M O utC ounter + I ; iR B M G iitC ountcr = 1951509) th en --3 9 0 3018) then --it Is tim e to change destinationB M ! (sw ap...) it\d estin atio n 8 M = BM I D estination) then destinationB M := B M 2D estination; else d estinationB M := BM I D estination: end if; B M O utC ounter := 0 ;-s ta r t again! end if; end if; end if; if(packctToG o = 1) then ifltoG oL ink = I) then outD estin atio n l < = toG oD estination; o u tD a ta l < = toG oD ata; o u tS o u rcel < = " 0 0 0 "; o u tlD l < = "0 0 0 0 0 0 0 0 "; o u tS ta rtl < = ' I'; elsif(toG oL ink = 2 ) then o u tD e stin a tio n l < = toG oD estination; o u tD a ta l <= toG oD ata; o u tS o u rc e l < = "000"; o u tlD l < = "00000000"; o u tS ta rtl <= '1'; else o utD estination? < = toG oD estination; o u tD a ta l <= toG oD ata; o u tS o u rc e l < = "000"; o u tlD l < = "0 0 0 0 0 0 0 0 "; o u tS ta rtl <= ' 1'; end if; end if; end if; en d process; end PEC PU ;

-- Purpose : T h is A PB peripheral contains registers

library IEEE; use lÉEE .std J o g ic l 16 4 .all;

entity A P B R egs i p o rt( -- Inputs PCLK nR E SE T PENABLE PSE l. PW R ITE n P B U 'lT SW P W D A IA PA - Outputs C T R l.C L K I

ill s td jo g ic ; - APB clock : in s td jo g ic ; - AM BA reset : in s td jo g ic ; -- A PB enable in std logic; - APB select : in s td jo g ic ; - A PB read/w rite ; in s td jo g ic ; - input that will be latched for -- an interrupt exam ple ; in s td jo g ic _ v e c to r(7 dow nto 0); -- sw itches in std J o g ic _ v e c to r(l 1 dow nto 0); -- A PB write data : in s td j o g i c vector(4 dow nto 2); -- APB address bus ; out std Jo g ic _ v ec to r( 18 dow nto 0);

134

R e p ro d u c e d with perm ission of the copyright owner. Further reproduction prohibited without permission.

C T R I.C 1.K 2 R C G SIN T

t.r-D
I'R D A TA
):

-- se ts frequency o fC L K l ; o u t sld_logic_veclor( 18 dow nto 0); -- sets frequency o fC L K 2 : o u t s td jo g ic ; -- interrupt output : out std_loglc_vcctor(8 d ow nto 0); -- L E D control ; out std_logic_vector(31 dow nto 0) -- A PB read data

end A P B R egs;

A P B R egs

-- O verview -- fitis A P B peripheral co n tain s registers to... -- * program &. lock the tw o clock oscillators -- * w rite to the general p u rp o se LED s -- * clear push button interrupt -- * read the general purp o se sw itches -- C ertain registers are p ro tected by the L O C K register. Y ou m ust w rite 0.xA05F -- to the lock register to en ab le the follow ing registers to be m odified: -- L M _O S C I -- L M _O S C 2 -- Provides nL M IN T to the top level & registers all interrupt sources

= A R C H IT E C T U R E = architecture synth o f A P B R egs is

-- C om ponent declarations com ponent P E _B lockM alch IS PO R T( elk in D estinationl inS ourcel in D atal inlD I inS tartl in D estin atio n l inSource? in D a ta l in lD l in S ta rtl in D estin atio n l inSourcc3 in D a ta l inlD3 in S ta rtl m y ID IDI ID I ID I outD estinationl in std logic; IN ST D L O G IC V E C T O R !! dow nto U); IN ST D L O G IC V E C T O R !! dow nto 0); IN ST D U L O G IC V E C T O R !? dow nto 01; IN ST D _ U L O G IC _ V E C T O R !7 dow nto 0); in std logic; --goes high w hen the three things above are ready IN ST D L O G IC V E C T O R !! dow nto 0); IN S T D LO G IC V E C T O R !! dow nto 0); IN ST D U L O G IC V E C T O R !? dow nto 0); IN ST D _ U L O G IC _ V E C T O R !? dow nto 0): in sld logic; --goes high w hen the three things above are reads IN S T D L O G IC V E C T O R !! dow nto 0): IN ST D L O G IC V E C T O R !! dow nto Of, IN ST D U L O O IC V E C T O R !? dow nto 0 |; IN ST D _ U L O G IC _ V E C T O R !7 dow nto Of. in s td jo g ic ; --goes high when the three things above are ready in std Jo g ic _ v e c to r!2 dow nto 0 );--w hat this PE's II) is in s td J o g ic _ v c c to r!2 d o w n to 0 );-w h a t PE I's ID is in std logic_vector!2 dow nto ());--what PE 2's ID is in sld logic v e c to r!! dow nto 0 );--what PE I 's ID is out S T d ' l O G IC _ V E C T O R !! dow nto 0);

135

R e p ro d u c e d with perm ission of the copyright owner. Further reproduction prohibited without permission.

o u tS o u rc e l o u tD a ta l o u tlD l o u tS ta rtl outD estinationZ outSourceZ outD ataZ outlD Z outStartZ o u tD estin atio n ] o u tS o u rc e ] o u tD a ta ] o u tID ] o u tS ta rt] F;ND com p o n en t; com ponent P E J3 M _ A ssc rt IS PORT{ elk inD estination 1 in S o u rcel in D atal inlD I in S ta rtl inD cstinationZ inSourceZ inD ataZ inlDZ inStartZ in D estin atio n ] in S o u rc e ] in D a ta ] in lD ] in S ta rt] m ylD IDI IDZ ID ] o u tD estin atio n l ou tS o u rce I o u tD a ta l o u tlD l ou tS ta rtl outD estinationZ outSourccZ outD ataZ outlD Z outStartZ o u tD estin atio n ] o u tS o u rc e ] o u tD a ta ] o u tID ] outStarLi E N D com p o n en t; com ponent P E J 'in a l A sscrt IS PO R T( elk inD estin atio n l inS o u rcel in D atal inlD I inS tartl inD cstinationZ inSourceZ inDataZ inlDZ inStartZ in D estin atio n ]

: o u t S T D _L O G IC _V E C T O R (2 dow nto 0); ; o u t ST D _ U L O G IC _ V E C T O R (7 dow nto 0); : o u t ST D _ U L O G IC _ V E C T O R (7 dow nto 0): ; out std_logic; : o u t S'I'D LO G IC _V E C T O R (2 dow nto 0); : o u t S T D _ I.0 G IC _ V E C T 0 R (2 dow nto 0); : o u t ST D _ U L O G IC _ V E C T O R (7 dow nto 0): : o u t ST D _ U L O G IC _ V E C T O R (7 dow nto 0); : o u t std logic; : o u t S T D _L O G IC _V E C T O R (2 d o w n to 0); : o u t S T D _L O G lC _V E C T O R (Z dow nto 0); : o u t ST D _ U L O G IC _ V E C T O R (7 dow nto 0); : out ST D _ U L O G IC _ V E C T O R (7 dow nto 0); : o u t s td jo g ic ) ;

; in s td jo g ic ; : IN S T D _L O G lC _V E C T O R (Z d o w n to 0); : IN S'l D _ L O G IC _ V E C I O R (2 dow nto Q); ; IN S T D _ U L O G IC _ V E C T O R (7 dow nto 0); ; IN ST D _ U L O G IC _ V E C T O R (7 dow nto 0); : in s td jo g ic ; --goes h igh w hen th e three th in g s ab o v e are ready ; IN ST D _ L O G IC _ V E C T O R (2 dow nto 0); : IN S T D _L O G IC _V E C T O R (Z dow nto 0); : IN S T D _ U L O G lC _ V E C T O R (7 dow nto 0); : IN ST D _ U L O G IC _ V E C T O R (7 d o w n to 0); : in s td jo g ic ; - g o e s h igh w hen the three th in g s above arc ready : IN S T D _L O G IC _V E C T O R (Z dow nto 0); : IN ST D _L O O IC _V E C T O R (Z d o w n to 0); ; IN ST D _ U L O G IC _ V E C T O R (7 dow nto 0); : IN S T D _ U L 0 G IC _ V E C T 0 R (7 dow nto 0); : in s td jo g ic ; - g o e s high w hen the three th in g s above are ready : in std Jo g ic _ v ec to r(Z d ow nto 0 );--w h at this PE 's ID is : in std Jo g ic _ v ec to r(Z d o w n to 0);--w hat PE I's ID is : in s td jo g ic _ v e c to r(2 dow nto 0);--w hat PE 2 's ID is : in s td J o g ic _ v e c to r(2 d o w n to 0 );--w hat PE ] 's ID is : o u t S T D L O G IC V E C T O R (2 d ow nto 0); : o u t S T D _L O G IC _V E C T O R (Z d ow nto 0); : o u t ST D _ U L O G IC _ V E C T O R (7 dow nto 0); ; o u t ST D _ U L O G IC _ V E C T O R (7 dow nto 0); : out s td jo g ic ; : o u t S T D LO G IC _ V E C T 0 R (2 d ow nto 0); ; out S T D _ L 0 G IC _ V E C T 0 R (2 d o w n to 0); ; o u t ST D _ U L O G IC _ V E C T O R (7 dow nto 0); : o u t S T D _ U L 0 G IC _ V E C T 0 R (7 dow nto 0); : out s td jo g ic ; : o u t S T D J-O G IC _ V E C T O R (Z dow nto 0); ; o u t ST D L O G IC _V E C T O R (Z dow nto (I); ; o u t S T D _ U L O G iC _ V E C T O R (7 dow nto 0); : o u t ST D _ U L O G IC _ V E C T O R (7 dow nto 0); : out s td jo g ic ) ;

in sld logic; IN ST D LO G IC V ECTO R(Z d ow nto 0); IN S T D L O G IC V EC TO R (Z d ow nto 0); IN S T D U L O G IC V E C T 0 R (7 dow nto 0); IN ST D _ U L O G IC _ V E C T O R (7 dow nto 0); in std logic; --goes high w hen the three things above arc ready IN S I D LO G IC V EC TO R (Z d ow nto 0); IN S T D LO G IC V F.C TO R (2 d ow nto 0); IN ST D U L O G IC V E C T 0 R (7 dow nto 0); IN ST D _ U L O G IC _ V E C T O R (7 dow nto 0); in std logic; --goes high w hen the three things ahove are ready IN S T D _ L O G IC JV E C T O R (2 d o w n to 0);

136
R e p ro d u c e d with perm ission of the copyright ow ner. Further reproduction prohibited without perm ission.

inSourcc3 inD ata3 inlD 3 inSlarO m y ID ID l
102

103 o u tD e stin a tio n l o u tS o u rccI o u tO a ta l o u tlD l o u ts tart 1 o u tO cstin atio n 2 o u tS o u rce2 o u tO ata2 outlD 2 outS tart2 o u tO cstin atio n 3 o utS ource3 outO ata3
OUI103

outS tart3 EN D co m ponent;

IN S T O _ L O G IC _ V E C T O R (2 d o w n to 0); IN S T O _ U L O G IC _ V E C T O R (7 d o w n to 0); IN S T O _ U L O G lC _ V E C T O R (7 d o w n to 0): in sld _ lo g lc; --goes high w hen th e three th in g s ab o v e are ready in std _ lo g ic_ v ecto r(2 dow nto 0 );--w hat th is P E 's lO is in std _ lo g ic_ v ecto r(2 dow nto 0 );--w hat PE I's lO is in std _ lo g ic_ v ecto r(2 dow nto 0);--w hat PE 2's 10 is in s td jo g ic _ v e c lo r(2 dow nto 0 );--w h at PE 3 's ID is o u t ST O _L .O G IC _V E C T O R (2 dow nto 0); o u t ST D _ L O G IC _ V E C T O R (2 dow nto 0); o u t S T D _ U L O G IC _ V E C T O R (7 dow nto 0); o u t S T D _ U L O G lC _ V E C T O R (7 dow nto 0); o u t s td jo g ic ; o u t ST D _ L O G IC _ V E C T O R (2 d o w n to 0); o u t ST O _ L O G IC _ V E C T O R (2 dow nto 0); o u t S T O _ U L O G lC _ V E C T O R (7 dow nto 0); o u t S T D _ U L O G lC _ V E C T O R (7 dow nto 0); o u t s td jo g ic ; o u t ST O _ L O G IC _ V E C T O R (2 d o w n to 0); o u t ST O _L O G 1C _V E C T O R (2 dow nto 0); o u t S T D _ U L O G IC _ V E C T O R (7 d o w n to 0); o u t S T O _ U L O G IC _ V E C T O R (7 dow nto 0); o u t s td jo g ic ) ;

c o m ponent PE _C PU IS--th e interface an d c o n tro l circu itry "around" the cpu PO R T ( elk in s td jo g ic ; in s td j o g i c ; --there is data av ailab le from th e C PU inS ignalF rom C P U IN S T D _ U L O G IC _ V E C T O R (l6 d o w n to 0 ) ;- th c d ata from the C PU inO ataF rom C P U IN S T O _ L O G IC _ V E C T O R (2 d o w n to 0); inO estin atio n I IN ST D _L O G iC _V E C T O R {2 d o w n to 0); in S o u rcel IN S T 0 _ U L 0 G 1 C _ V E C T 0 R (7 d o w n to 0); in O atal IN S T 0 _ U L 0 G 1 C _ V E C T 0 R (7 d o w n to 0); InlD I inS tarti in s td j o g i c ; --g o es high w hen the three th in g s above arc ready IN S T O _ L O G lC _ V E C T O R (2 d o w n to 0); in O cstin atio n 2 inSource2 IN S T O _ L O G lC _ V E C T O R (2 d o w n to 0); IN S T O _ U L O G lC _ V E C T O R (7 dow nto 0); inO ata2 IN S T D _ U L O G lC _ V E C T O R (7 d o w n to 0); in l0 2 inStart2 in s td jo g ic ; --g o es high w hen the three things above arc rcadv IN S T O _ L O G lC _ V E C T O R (2 dow nto 0); in O estination3 IN S T O _ L O G !C _ V E C T O R (2 dow nto 0); lnSourcc3 inO ataS IN S T D _ U E O C IC _ V E C T O R (7 d o w n to 0); IN S T O _ U L O G lC _ V E C T O R (7 d o w n to 0); ini 0 3 inStartS in s td jo g ic ; --g o es high w hen the three th in g s above arc ready in s td jo g ic _ v e c to r{ 2 dow nto 0);--w hat this PE 's II) is m y ID in s td J o g ic _ v e c to r(2 dow nto 0 );--w hat PE I's 10 is 101 in std J o g ic _ v e c to r(2 dow nto 0 );--w hat PE 2 's ID is 102 in std J o g ic _ v c c to r(2 dow nto 0 );-w h a t PE 3's 10 is 103 o u t s td j o g i c ; --th ere is data av ailab le from the C P U ou tS ig n alT o C P U ou tO ataT o C P U o u t S T O _ U L O G lC _ V E C T O R (8 dow nto ());-lh e d a ta from the C P U o u t ST D _ U L O G lC _ V E C T O R ( 16 d ow nto 0 ) ;- th c d a ta from th e C PU o u tO ataT o C P U o u tD estin atio n l o u t ST O _ L O G IC _ V E C T O R (2 d o w n to Ü); o u t S T O J .O G IC _V E C TO R 12 dow nto 0); o u tS o u rcel out ST O _U L O G 1C _V E C T O R (7 dow nto 0); o u tO atal o u tlO l o u t STD _U LO G IC _V E C rO R (7 dow nto 0); outStart 1 o u t s td jo g ic ; o u t ST D _ L O G IC _ V E C I O R (2 d o w n to 0); ou tO estin atio n 2 o u tS o u rcc2 o u t S T D _L O O IC _V E C T O R (2 dow nto 0); outO ata2 o u t S T O _ U L O G lC _ V E C T O R (7 dow nto 0); 0U11D2 o u t S T D _ U L O G lC _ V E C T O R (7 dow nto 0); outStart2 o u t s td jo g ic ; o u t S T 0 _ L 0 G 1 C _ V E C T 0 R (2 dow nto 0); outO estlnation3 o utS ource3 o u t S T D _ L O (ilC _ V E C T O R (2 dow nto 0); outO ata3 o u t S T D _ U E O G lC _ V E C T O R (7 dow nto (I); outlD 3 o u t S T D _ U E O G IC . VEC rO R (7 dow nto (!); outStart3 o u t s td jo g ic ) ; EN D c om ponent; -- C onstant declarations

137

R e p ro d u c e d with perm ission of th e copyright ow ner. Further reproduction prohibited without perm ission.

-- I M H z d e fa u lt clo ck v alu es constant O S C 1 V E C T O R : std _ lo g ic_ v e c to r( 18 d o w n to 0)
· = "

1100111110000000100" ;

c o n stan t O S C 2 V E C fO R
:= "

: sld _ lo g ic_ v c c to r( 18 d o w n to 0)

1100111110000000100 " ;

-- Lock re g iste r k ey OxAOSF constant l.O C K _ K l:Y : std J o g ic _ v e c to r{ 15 d o w n to 0)
:= " 1 0 1 0 0 0 0 0 0 1 0 1 1 1 1 1 ";

-- A ddress d e c o d in g constant L M _ O S C l -- read /w rite constant L M _ O S C 2 -- rcadA vrilc constant L M _ L O C K -- read/w rite constant L M _ L E D S -- read/w rite constant L M _1N T -- read/w rite constant L M _ S W -- read only -- Signal d e c la ratio n s signal L in O scR cg t -- O sc illa to r reg iste r 1 signal L in O scR eg 2 -- O sc illa to r rcg ister2 signal L m L ck R eg -- Lock re g iste r -s ig n a l L m L ed sR eg signal L m L ed sR eg -- LED re g iste r signal L n tlm R e g -- I N T re g iste r signal L m S w R eg -- Sw itch re g iste r
:

: std _ lo g ic_ v e e to r(4 d o w n to 2) ;= "000"; ; sld _ lo g ic_ v e c lo r(4 d o w n to 2 ) := "001 "; ; std _ lo g ic_ v e c lo r(4 d o w n to 2) := "010"; ; s td J o g ic _ v e c lo r(4 d o w n to 2) ;= "011"; ; sld _ lo g ic_ v e c to r(4 d o w n to 2) := " 100"; ; std _ lo g ic_ v e c to r(4 d o w n to 2) := " 101";

: sld _ lo g ic_ v c c to r( 18 d o w n to 0); ; sld _ lo g ic_ v e c to r( 18 d o w n to

0 ):

std _ lo g ic_ v e c to r( 15 d o w n to 0); : std _ lo g ic_ v e c to r(8 d o w n to 0); : std _ lo g ic_ v e c lo r(l 6 d o w n to 0);

: std _ lo g ic; ; std _ lo g ic_ v e c to r(7 d o w n to 0);

signal t.o c k e d : std logic; - R egisters a re Locked signal N cx lP R D A TA -- read data : s ld _ lo g ic _ v e c to r(3 1 d o w n to 0);

-- a duplex b u s based c o n im lin k w ith a bunch a n ecessary sig n a ls (from PE 0 0 0 to PE 001 ) signal cominDestOOO OOl ; std _ lo g ic_ v e c to r(2 d o w n to 0); signal comm SourceOOO OO 1 ; std _ lo g ic_ v e c to r(2 d o w n to 0); signal c o m m D ata0 0 0 _ 0 0 1 : std _ u lo g ic_ v c c to r(7 d o w n to 0); signal commlDOOO OOl ; std _ u lo g ic_ v c c to r(7 d o w n to 0); signal eommStartOOO OO 1 : std logic; signal signal signal signal eo m m D est0 ()l_ 0 0 () : std _ lo g ic_ v c c to r(2 d o w n to 0); com m SoureeO O I 0 0 0 : std _ lo g ic_ v ecto r(2 d o w n to 0); com m D ataO O l OOO : std _ u lo g ic_ v e c to r(7 d o w n to 0); co m m IDÜOI 0 0 0 : std _ u lo g ic_ v e c to r(7 d o w n to 0);

138

R e p ro d u c e d with p e rm issio n of th e copyright ow ner. Further reproduction prohibited without perm ission.

signal comniStartOOl OOO ; s td jo g ic .

-- a duple.s b u s based com m iin k w ith a b u n ch a necessary sig n ais signal eom m D est0 0 0 _ 0 1 0 ; s ld J o g ic _ v e c to r(2 dow nto 0); signal conim S o u rcc0 0 0 _ 0 1 0 ; s td J o g ic _ v c c to r(2 d o w n to 0); signal c o m m D ala000_010 : sld _ u lo g ic_ v ecto r(7 dow nto 0); signal com m lD 0 0 0 _ 0 1 0 ; sld _ u lo g ic_ v ecto r(7 d ow nto 0); signal coium .Start000_010 ; std logic; signal signal signal signal signal coinniD cstO lO JlO O : s td J o g ic _ v e c to r(2 dow nto 0); com m S o u rcc0 1 0 _ 0 0 0 : std Jo g ic _ v ec to r{ 2 dow nto 0); com m D ata0 1 0 _ 0 0 0 : std _ u lo g ic_ v ecto r(7 dow nto 0); c o m m lD 0 1 0 _000 ; std _ u Io g ic_ v ecto r(7 d o w n to 0); com m StartO i 0 000 : s td jo g ic ;

-- a duple.N b u s based com m iin k w ith a b unch a necessary signals signal co m inD est000_100 ; std J o g ic _ v c c to r(2 dow nto 0); signal com m S o u rce0 0 0 _ 1 0 0 : std_lo g ic_ v ecto r(2 dow nto 0); signal com m D ataO O O JO O : std _ u lo g ic_ v ecto r(7 dow nto 0); signal co m m lD 0 0 0 _ 1 0 0 : std _ u lo g ic_ v ecto r(7 d ow nto 0); signal c o m m S lart000_10 0 ; s td jo g ic ; signal signal signal signal signal c o n im D e sll0 0 _ 0 0 0 : std J o g ic _ v e c to r(2 dow nto 0); com ntSourcclO O OOO ; std J o g ic _ v e c to r(2 dow nto 0); c o m n iD a ta l0 0 _ 0 0 0 ; std _ u lo g ic_ v ecto r(7 dow nto 0); co m in lD I0 0 _ 0 0 0 : std_u1ogic_vector(7 dow nto 0); c o m m S ta n 100_000 : s td jo g ic ;

-- a duplex bus based com m iin k w ith a bun ch a necessary signals signal com m D eslO O l 101 : std J o g ic _ v e c to r(2 dow nto 0); signal com m SourceO O 1 1 0 1 : s td jo g ic _ v e c lo r(2 dow nto 0); signal c o m m D a ta 0 0 1 _ I0 I : std_ulogic_vector{7 d ow nto 0); signal com m lD 001_101 : std_ulogic_vector{7 dow nto 0); signal com m StanO O l 101 ; s td jo g ic ; signal signal signal signal signal c o m m D e stl0 1 _ 0 0 I : s td jo g ic _ v e c to r(2 dow nto 0); co m m S o u rce 1 0 1 0 0 1 : s td J o g ic _ v e c to r(2 dow nto 0); c o m m D atalO l OOl : std _ u lo g ic_ v ecto r(7 d o w n to 0); co m m lD I0 1 _ 0 0 1 : std _ u lo g ic_ v ecto r(7 dow nto 0); c o m m S ta rtI0 l_ 0 0 1 : s td jo g ic ;

" a duplex bus based com m iin k w ith a bun ch a necessary signals signal com m D eslO O l OI I : std J o g ic _ v c c to r(2 dow nto 0); signal com m SourceO O 1_ 0 1 1 : s td J o g ic _ v e c to r(2 dow nto 0); signal com m DataOOl OI I : std _ u lo g ic_ v ecto r(7 dow nto 0); signal com m IDOO l Ol 1 : std _ u lo g ic_ v ccto r(7 dow nto 0): signal com m Start001_011 : s td jo g ic ; signal signal signal signal signal com m D estO l 1 0 0 1 : s td J o g ic _ v e c to r(2 dow nto 0); com m SourceO l 1 0 0 1 ; s td J o g ic _ v e c to r(2 dow nto 0); com m D ataO l l_ 0 0 l : std_ulogic_vector{7 d ow nto 0); com m ID O I 1 0 0 1 : std _ u lo g ic_ v ecto r(7 dow nto 0); com m S tanO l 1 0 0 1 : s td jo g ic ;

-- a duplex bus based co m m iin k w ith a bunch a necessary signals signal c o m mDestO 10 0 1 1 : s td jo g ic _ v e c lo r(2 dow nto 0); signal co m m S o u rceO l0 0 1 1 ; s td J o g ic _ v e c to r(2 dow nto 0); signal com m D ataO lO OI 1 : std _ u lo g ic_ v ecto r(7 dow nto 0); signal c o m m lD 0 1 0 _ 0 l 1 : std _ u lo g ic_ v ecto r(7 dow nto 0); signal com m StartO lO Ol I : std j o g i c ; signal signal signal signal signal com m D estO l 1 0 1 0 : std _ lo g ic_ v ecto r(2 dow nto 0); com m SourceO l t _ 0 10 ; s td J o g ic _ v c c to r(2 dow nto 0); Com m D ataO l 1_010 : std _ u lo g ic_ v ecto r(7 dow nto 0); com m lD O i 1_010 : std_ulogic_vector{7 dow nto 0); c o m niS tanO l l_01Ü : s td jo g ic ;

-- a duplex bus based com m iin k w ith a h unch a necessary signals signal co m m D e stO l0 1 1 0 : s td jo g ic _ v c c to r(2 dow nto 0); signal c o m m S o u rc eO l0 _ 1 10 : s td J o g ic _ v e c to r(2 dow nto 0);

139

R e p ro d u c e d with perm ission of th e copyright ow ner. Further reproduction prohibited without perm ission.

s ig n al c o m n iD a ta 0 1 0 _ l 10 ; std _ u lo g ic_ v ecto r(7 d o w n to 0); signal com nilD O IO _l 10 : std _ u lo g ic_ v ccto r(7 dow nto 0); signal com niStartO IO _l 10 ; s td jo g ic ; signal s ig n al signal signal signal c o m n iD c stl lO OlO ; s td J o g ic _ v c c to r(2 d o w n to 0); c o n im S o iircel IO_OIO : std lo g ic_ v ecto r(2 d o w n to 0); co rn m D a ta i 10 0 1 0 : std _ u lo g ic_ v ccto r(7 d o w n to 0); c o n im lD I 10 0 1 0 ; std _ u lo g ic_ v ccto r(7 d o w n to 0); c o m m S ta rtl 10 0 1 0 : std logic;

-- a duplex b u s based co m m iin k w ith a bun ch a ncccssar)' sig n ais signal c o m m D c stl 10 1 11 ; std _ lo g ic_ v ecto r(2 d o w n to 0); signal c o m m S o u rce 11 0 1 11 : std lo g ic_ v ecto r(2 d o w n to 0); signal c o m m D a ta l 10 1 11 : std _ u lo g ic_ v ecto r(7 d o w n to 0); signal c o m m lD I I0 _ l II : std _ u lo g ic_ v ecto r(7 dow nto 0); signal c o m m S ta rtl 1 0 1 11 : s td jo g ic ; s ig n al s ig n al signal signal signal c o m m D c stl 11 I 10 ; std _ lo g ic_ v ecto r(2 d o w n to 0); c o m m S o u rce 11 I I 10 : std J o g ic _ v e c to r(2 d o w n to 0); c o m m D a ta l I I I 10 : std _ u lo g ic_ v ccto r(7 d o w n to 0); c o m m ID I I I I 10 : std _ u lo g ic_ v ecto r(7 d ow n to 0); c o m m S ta rtl I I I 10 : s td jo g ic ;

-- a duplex b u s based co m m iin k w ith a b u n ch a necessary sig n ais signal c o m m D c stl 1 0 1 0 0 : std J o g ic _ v e c to r(2 d o w n to 0); signal c o m m S o u rce 110_100 ; s td J o g ic _ v e c to r(2 dow nto 0); signal c o m m D a ta l 10 100 : std _ u lo g ic_ v ecto r(7 d o w n to 0); signal c o m m lD l lO lüO : std _ u lo g ic_ v ecto r(7 d o w n to 0); signal c o m m S ta rtl 1 0 1 0 0 : s td jo g ic ; signal signal signal signal signal c o m m D c stl 00 1 10 : s td J o g ic _ v e c to r(2 d o w n to 0); c o m m S o u rce I0 0 _ l 10 : s td J o g ic _ v e c to r(2 d o w n to 0); c o m m D a ta l00 1 10 : std _ u lo g ic_ v ecto r(7 d o w n to 0); com m lD IO O 1 10 : std _ u lo g ic_ v ecto r(7 d o w n to 0); c o m m S ta rtl0 0 1 1 0 : s td jo g ic ;

-- a duplex b u s based co m m iin k w ith a b u n ch a n ecessary sig n als signal c o m m D estlO I I 11 : s td J o g ic _ v e c to r(2 d o w n to 0); signal c o m m S o u rc e I0 l_ l 11 : s td J o g ic _ v e c to r(2 d o w n to 0); signal co m m D a ta lO l l 11 ; std _ u lo g ic_ v ecto r(7 d o w n to 0); signal c o m m ID IO l t 11 ; std _ u lo g ic_ v ecto r(7 dow nto 0); signal c o m m S ta rtl0 1 1 11 : s td jo g ic ; signal signal signal signal signal c o m m D c stl 11 101 : s td jo g ic _ v e c to r(2 dow nto 0); c o m m S o u rc e 11 I 101 : std J o g ic _ v e c to r(2 d o w n to 0); c o m m D a ta l 11 101 : std _ u lo g ic_ v ccto r(7 d o w n to 0); c o m m lD I 11 101 : std _ u lo g ic_ v ecto r(7 d o w n to 0); c o m m S ta rtl 11 101 : s td jo g ic ;

-- a duplex b u s based co m m iin k w ith a bun ch a n ecessary sig n als signal com m D estlO O lOI ; s td J o g ic _ v e c to r(2 d o w n to 0); signal c o m m S o u rc e 10 0 1 0 1 : s td jo g ic _ v e c to r(2 d o w n to 0); signal com m D aIalO O _IO I ; sld _ u Io g ic_ v ccto r(7 d o w n to 0); signal com m lD IO O lOI : std _ u lo g ic_ v ecto r(7 d ow nto 0); signal c o m m S ta rtl00 101 : s td jo g ic ; signal signal signal signal signal c o m m D cstlO I 100 : std J o g ic _ v c c to r(2 d o w n to 0); c o m m S o u rce 10 1_ 100 : s td J o g ic _ v e c to r(2 d o w n to 0); c o m m D a ta l01 100 : std _ u lo g ic_ v ecto r(7 d o w n to 0); c o m m ID IO l 100 ; std _ u lo g ic_ v ccto r(7 d o w n to 0); c o m m S tartIO l 100 : sid logic;

-- a duplex b u s based co m m iin k w ith a bun ch a n ecessary sig n als signal com m D estO l I I 11 : s ld jo g ic _ v e c to r(2 d o w n to 0); signal com m SourceO l l_ l.l I : s td J o g ic _ v c c to r(2 d o w n to 0); signal com m D ataO l I I I I : std _ u lo g ic_ v ecto r(7 d o w n to 0); signal com m ID O I I I 11 : std _ u lo g ic_ v ecto r(7 d ow nto 0); signal com m StartO I I I 11 : s td jo g ic ; signal c o m m D c stl 11 0 1 1 : s td jo g ic _ v e c to r(2 d ow nto 0);

140

R e p ro d u c e d with p erm ission of th e copyright ow ner. F urther reproduction prohibited without perm ission.

signal signal signal signal

co m m S o u rc e 111 0 1 1 ; sld J o g ic _ v e c lo r(2 d o w n to 0); c o m m D a ta l 11 0 1 1 : sld _ u lo g ic_ v ecto r(7 d o w n to 0); c o m m lD I 11_011 ; sld _ u lo g ic_ v eclo r(7 d o w n to 0); c o m m S ta rtl 1 1 0 1 1 : s td jo g ic ;

--signal d a ta T o L liD s : std _ u lo g ic_ v ccto r(8 d o w n to 0); signal d a ta T o l.E D s ; std _ u lo g ic_ v ecto r( 16 d o w n to 0): signal d a la l'ro m L E D s ; std _ u lo g ic_ v ecto r( 16 d o w n to 0 ); signal sig n a lT o L E D s : std _ lo g ic; signal sig n a l From LED s : s td j o g i c ; signal signal signal signal signal signal signal signal VALOOO ; s td J o g ic _ v e c to r(2 VA LO Ol : s td jo g ic _ v e c to r(2 V A LO lO : s td J o g ic _ v e c to r(2 V A L O l I : s td jo g ic _ v e c to r(2 V A LIO O : s td J o g ic _ v e c to r(2 V A L lO l : s td J o g ic _ v e c to r(2 V A L l 10 ; s td J o g ic _ v e c to r(2 V A L l 11 ; std J o g ic _ v e c to r(2 d o w n to d o w n to d o w n to d o w n to d o w n to d o w n to d o w n to d o w n to 0) 0) 0) 0) 0) 0) 0) 0) := := ;= := ;= := := := "000' "001 "010 "011 "100 "101 " 1 10 " 111

-- F u n ctio n declarations

- M ain b o d y o f code

begin --i f you are c irc u it 000 then y o u r inputs start w ith 0 0 0 a n d y o u r o u tp u ts e n d w ith 000 PEOOO: P E _ C P U port m ap (P C L K , sig n alF ro m L E D s, d ataF ro m L E D s, com m O estO O O JlO l. comm SourceOOO OO 1. co m m D ata0 0 0 _ 0 0 1 , co m m ID 0 0 0 _ 0 0 1 , co m m S tart0 0 0 _ 0 0 1 . commDcstOOO lOO, c o m m S o u ree0 0 0 _ 1 0 0 , commDataOOO_IOO, c o m m lD 0 0 0 _ l 0 0 , commStartOOO l 00, commDcstOOO O 10, c o m m S o u rc e0 0 0 _ 0 10, c o m m D a ta 0 0 0 _ 0 10, co m m lD 0 0 0 _ 0 1 0 , c o m m S lart0 0 0 _ 0 1 0 . VALOOO, VA LO Ol, VALIOO, VA LO lO , sig n alT o L E D s, dataT oL E D s, co m m D est0 0 1 _ 0 0 0 , com m SourceO O 1_000, comm DataOO 1 0 00, com m 1DUO 1 0 0 0 , c o m m S lart0 0 1 _ 0 0 0 , c o m m D est 100 _ 0 0 0 , co m m S o u rce 10 0 _ 0 0 0 , c o m m D a ta l0 0 _ 0 0 0 , com m lD 100__000, c o m m S ta rt 100_0(I0, c o m m D estO l0 _ 0 0 0 , com m SourceO 10 0 00, c o m m D ataO l0 _ 0 0 0 , eom m lD O lO OOO, com m StartO 10 _ 0 0 0 ); PEOOl : PE B lo ck M atch p o rt m ap(PC L K , com m D estO O l 101, com m SourceO O 1 1 0 1 , comm DataOO 1_ 101, com m lDOO l 101, comrnStartOO 1_ 101, co m m D cst0 0 1 _ 0 1 1 , com m SourceO O 1 0 11, comm DataOO 1 0 1 1 , com m lDOO l Ol 1. com m StartOO I Ol 1, com m DestOO 1 00 0 , com m SourceO O 1 000, comm DataOO 1_ 0 0 0 . co m m lD 0 0 1 _ 0 0 0 , com m StartO O l J ) 0 0 . VA LO O l, V A L lO l, VALOl 1, VALOOO, c o m m D est 101 _ 0 0 1, c o m m S o u rce 101 _ 0 0 1 , c o m m D atalO l OOl. co m m lD 1 0 1 _ 0 0 1 , c o m m S la rtlO l J1 Ü I, cfim m D cstO l l _ 0 0 i, com m SourceO l 1 0 0 1 , com m D ataO l 1 0 0 1 , com m lD O l 1 0 0 1 , com m S tartO l 1 001. co m m D e st0 0 0 _ 0 0 1, com m SourceO OO OO 1, comm DataOOOOO 1, com m lD O O O O O l, eom m StartO O O O O I ); PEOlO: PE B lock M atch p o rt m ap(P C L K , com m D cstO 10 0 0 0 , com m SourccO 10 0 00, com m D ataO 10 _ 0 0 0 , com m lD O 10 0 0 0 , com m StartO 10 _ 000, com m D cslO IO Ol 1, c o m m S o u rc eO l0 _ 0 1 1, co m m D ataO l0 0 1 1, com m lD O lO jO l 1. com m StartO lU 011. com m D estO l 0 _ l 10, com m S ourceO l 0 _ 1 10, com m D ataO l 0 _ 1 10, com m lD O lO 110, com m StartO 1 0 _ 1 10, VA LO lO , VALOOO, VALOl 1. V A L l 10, co m m D cst0 0 0 _ 0 1 0 , commSourceOOO O 10, commDataUUO OlO, commlDUOO OlO. commStartOOO O 10, com m D estO l 1 0 1 0 , com m S ourceO l 1 0 1 0 , com m D ataO l 1 0 1 0 , com m lD O l 1 0 1 0 , com m StartO 1 1 0 1 0 , co m m D e st! 10 0 1 0 , co m m S o u rce 110 0 1 0 , co m m D a ta l 1 0 0 10, co m m lD l 10 0 10. c o m m S ta rtl 10 OlOl: P E O I1: PE B M A ssert p o rt m ap(P C L K . com m D estO l 1 0 1 0 , com m SourceO l 1 0 1 0 , Com m D estO l 1 1 1 1 , com m SourceO l 1 1 1 1 . com m D estO l 1 0 0 1 , com m SourceO l 1 00 1 , V A LO l 1, VALOlO, V A L l 11, VA LO O l. co m m D e stO l0 _ 0 1 1, com m SourceO 10 011. c o m m D c stl 1 1 0 1 1 , co m m S o u rce 1 1 1 0 1 1 . com m DcstOOI Ol 1, com m SourceO O 1_ 0 11, com m D ataO l 1 0 1 0 , com m lD O l 1J I I O , com m StartO 11 (110. com m D ataO l 1 1 1 1, com m lD O l 1 1 1 1 . co m m S laaO 11 1 1 1 . com m D ataO l 1J lO 1, com m lD O l 1 0 0 1 , com m StartO 1 1_001. com m D atal) 10J ) 1 1, com m lD O lO 0 1 1 , c o m m S ta rtl)lO J Il 1. co m m D a ta l 1 1 0 1 1 , co m m lD l 11 J ) 1 1, co m m S lart 1 1 1 0 1 1 . comm DataOO 1 0 1 I, comm lDUOl 0 1 1 , com m StartO O l J ) 1 1 );

PE 100: Pl J F in a l A ssert p o rt m ap(PC L K , c o m m D est 1 0 0 _ l01, co m m S o u rce 100 101, c o m m D a ta lO O JO I. coinm lD IO O lO I. com m .Siart I00_ 101.

141

Reprotduced with pe rm ission of th e copyright ow ner. Further reproduction prohibited without p erm ission.

co m m D est 1Ü0_000, co m m S o u rce 10ü_000, co m m D atal 00_000, c o m m lD I0 0 _ 0 0 0 . co m m S tart 100 000. com m D estlO O l 10, co m m S o u rce 1 0 0 _ 1 10, c o m m D a ta l0 0 1 1 0 , com m lD lO O l 10, c o m m S tart 1 0 0 _ 1 10, VA LIOO, V A L lO l, VALOOO, V A L l 10, c o m m D est 1 0 1 1 0 0 , co m m S o u rce 1 0 1 1 0 0 , c o m m D a ta l0 1 _ 1 0 0 , co m m lD 1 0 1 _ 1 0 0 , c o m m S tart 1 0 1 100. co m m D est0 0 0 _ 100, commSourceOOO l 00, commDataOOO l 00, commlDOOO lOO, co m m S tarl0 0 0 _ 1 0 0 , c o m m D c stl 10 1 0 0 , co m m S o u rce 1 1 0 1 0 0 , co m m D atal I0 _ 1 0 0 , c o m m lD l 10_100, c o m m S ta rtl 1 0 1 0 0 ) : P t l O l : P l;_ B lo ck M atch p o rt m ap(P C L K , co m m D e st 1 0 1 0 0 1 , c o m m S o u rce 101 _ 0 0 1, c o m m D a ta lO lO O l, co m m D est I O i l 1 1, c o m m S o u rc e l0 1 _ l 11, c o m m D a ta l0 1 _ l 11, co m m D est 10 1_ 1 0 0 , c o m m S o u rce 1 0 1 _ I0 0 , c o m m D a ta l0 1 _ 1 0 0 , V A L lO l, VA LO Ol, V A L l 11, VALIOO, co m m D est0 0 1 _ 1 0 1 , com m SourceO O 1_101, commDataOO 1 1 0 1 , c o m m D c stl 1 1 1 0 1 , c o m m S o u rce 1 11_101, co m m D atal 1 1 1 0 1 , co m m D est 10t1_l0 1 , c o m m S o u rce 10 0 _ 101, c o m m D a ta l0 0 1 0 1 , c o m m lD lO IO O l, co m m S tart 1 0 1 0 0 1 , co m m lD 1 0 1 _ l 11, c o m m S ta rtl0 1 _ l 11, c o m m lD l O i l 00, co m m S tart 10 I I 00, com m lDOO l lO l, co m m S tart0 0 1 _ 1 0 1 , co m m lD l 1 1 1 0 1 , co m m S ta rtl 11 101, com m lD IO O IO l, co m m S tart 100 _ 101);

PEI 10: PE_I31ockM atch p o rt m ap(PC LK ., c o m m D c stl 10 _ 0 1 0, c o m m S o u rce 1 1 0_010, co m m D atal 10 _ 0 10, co m m lD l 10 _ 0 10, co m m S ta rtl 10 _ 0 10. co m m D est 1 10_l 11, c o m m S o u rce 1 1 0 _ 1 11, co m m D atal 1 0 1 11, co m m lD l 1 0 _ 1 11, c o m m S ta rtl 1 0 1 11. c o m m D c stl 10_100, c o m m S o u rce 1 1 0 1 0 0 , co m m D atal 1 0 1 0 0 , co m m lD l 10_100, co m m S ta rtl 1 0 1 0 0 , V A L l 10, V A LO lO , V A L l 11, VALIOO, C om m D estO l0 1 1 0 , com m SourceO 10 1 1 0 , co m m D ataO l0 1 1 0 , com m lD O lO l 10, com m StartO 1 0 1 1 0 , co m m D c stl 1I I 10, c o m m S o u rce 1 11 1 1 0 , co m m D atal 1 ! _ 1 10, co m m lD l II I 10, c o m m S ta rtl 1I I 10, c o m m D c stl 0 0 1 1 0 , c o m m S o u rce 10 0 1 1 0 , co m m D atal 0 0 1 1 0 , c o m m lD lO O l 10, c o m m S ta rtl 0 0 1 1 0 ) ; PE I 11: P E _ B lo ck M atch p o rt m ap (P C L K , co m m D c stl 1 1 _ 1 0 I, c o m m S o u rce 111_101, co m m D atal 1 1_101, c o m m lD l 1 1 1 0 1 , c o m m S ta rtl 1 1 1 0 1 , c o m m D c stl 1 1 0 1 1, c o m m S o u rce 1 1 1 0 1 1 , co m m D a ta l 1 1 _ 0 1 1, co m m lD l 11 0 1 1 , c o m m S ta rtl 1 1 0 1 1 , co m m D est 1 1 1 1 1 0 , co m m S o u rce) 1 1 1 1 0 , co m m D atal 1 1 1 1 0 , co m m lD l 1 1 1 1 0 , co m m S ta rtl 1 I I 10, V A L l 11, V A L lO l, V A LO l I, V A L l 10, c o m m D e s t lO ll 11, c o m m S o u rce 1 0 1 _ 1 1 1, co m m D atal O i l 11, c o m m l D l O l l 11, co m m S ta rtl O i l 11, com m D estO l 1 1 1 1 , com m S ourceO l 1 _ 1 1 1, com m D ataO l l_ l 11, com m lD O l I I I ) , com m StartO 1 1 1 1 1 , c o m m D c stl 1 0 1 1 1 , co m m S o u rce) 1 0 _ 1 11, co m m D atal 1 0 1 1 1 , co m m lD l 1 0 _ 1 1 1, co m m S ta rtl 1 0 1 1 1); -- Locked signal p ro tects reg isters that c o u ld be accid en tly changed L ocked < = 'O' w hen (L m L ck R eg = L O C K _K E Y ) else
')';

- sw itch reg ister is read o nly L m S w R eg < = SW ; -- Lock reg ister is read /w rite p L dL ckR egS eq : process(PC LK ., n R E S E T ) begin if(n R E S E T = '0') then L m L ck R eg < = (others = > '0 '): elsil'(P C L K 'c v c n t and P C L K = 'I ') then if((P S E L and PW R IT E an d P E N A B L E ) = ') ') then if(P A = L M _L O C K ) th en L m L ck R eg < = PW D A T A (1 5 d o w n to 0); end it': end if: end if: end process p l.d L ck R cg S eq : -- O scillato r) reg ister is read /w rite, p ro tected by lock reg ister p _ l.d O sc R e g S e q l : p ro cess)P C L K . n R E S E T ) begin if (n R E S E T = '0') then l.m O sc R eg l <= 0SC 1_V E C T G R : e ls if (P C L K 'ev en t and P C L K = ') ') then if ((P S E L an d PW R IT E an d ['E N A B L E an d not Locked) = ') ') then if(P A = L M _ O S C I)th e n L .m O scR egl <= P W D A T A (I8 d o w n to 0): end if;

142

R e p r o d u c e d with perm ission of th e copyright owner. Further reproduction prohibited without permission.

end ill end ill end process p_L dO seR egS eq l ; C T R I.C I.K 1 < = l.m O s c R e g l; --O scilla lo r2 register is read/w rite, protected by lock register p_L dO scR egS eq2 : process(PC L K . nR E SE T ) begin il (nR E SE T = '0') then L m O scR cg2 < = O S C 2_V E C T O R ; e lsif (PC L K 'event and PCLK = 'I ') then i f ((PS CL and PW RITE an d PEN A B LE an d not Locked) = '! ') then if(P A = L M _ 0 S C 2 ) then I .m O scR eg2 < = PW D A TA ( 18 dow nto 0); end ill end ill end ill end process p_L dO scR egS eq2; C I RLCLK 2 < = L.mOscReg2; -- LEDS reg ister is read/w rite

p_L dL E D SR egS eq ; process(PC L K , nR E SE T ) begin if(n R E S E T = '0 ')th e n -- put a pattern on them Lm L edsR eg(8 dow nto 0) < = "101010101"; signalFrom L E D s < = 'O'; e lsif (P C L K 'event and PC LK = '1') then signalFrom L E D s < = 'O'; if ((PSE L an d PW RITE an d PEN A B LE) = 'I ') then if (PA = L M _LED S) then --w e need to place this info in d ata from LED S " Lm L edsR eg(8 dow nto 0) < = P W D A T A (8 dow nto 0); Lm L cdsR eg(16 dow nto 0) <= P W D A T A (16 dow nto 0); dataProm L E D s( 16) <;= P W D A T A (I6 ) dataFrom L E D s( 15) <` PW D A TA (15) d a ta l'ro m L E D s(l4 ) <;= P W D A T A (I4 ) dataFrom L E D s(13) <:= P W D A T A (I3 ) dataFrom L E D s( 12) < P W D A T A (I2) dataFrom L E D s( 1 1) := P W D A T A (1 I) dataProm L E D s( 10) <:= P W D A T A (I0 ) dataFrom L E D s(9) < - PW D A TA (9): dataFrom L E D s(8) <= PWDATA(g) dataFrom L E D s(7) <= PW D A T A (7) dataFrom L E D s(6) <= PW D A T A (6) datal'roniL E D s(5) <= PW D A T A (5) dataFrom L E D s(4) <= PW D A TA (4) dataFrom L E D s(3) <= PW D A T A (3) dalaFrom L E D s(2) <= PW D A T A (2) dataFrom L E D s! I ) <= P W D A T A (I) dataF rom l,E D s(0) < = PW DATA(O) signalFrom L E D s <= 1'; end ill end ill if( sign: lafl'oI.E D s = '1') then 1.m l.edsR eg! 16) < = data'I'oL.EDsI 16); I.m l.edsR eg(15) < = dataT oL E D s( 15); l,m l,edsR eg( 14) < = dataT oL E D s(14) Lm LedsReg! 13) < = dataT oL E D s! 13) Lm LedsReg! 12) < = dataT oL E D s! 12)

143

ReproducecJ with perm ission of th e copyright owner. Further reproduction prohibited without permission.

L m l.edsR cgO I) < = clataToLED s( 1 \ l.m l.ed sR eg (lO ) < = dalaT oL E D s(IO ); L m L edsR cg(9) < = dataT oL E D s(9); L.m LedsReg(8) < = dataT oL E D s(8); Lm l,.cdsReg(7) < = dataT oL E D s(7); L niL cdsR eg(6) < = dataT oL E D s(6); l.n il.cd sR eg (5 ) < = dataT oL E D s(S); l.n il.cd sR eg (4 ) < = dataToLEDs(4V. l.nil.cdsR eg{3) < = dataT oL E D s(3); L m LedsR eg{2) < = dalaT oL E D s(2); [,m L c d sR e g (l) < = d a ta T o L E D s(l); L m i.cdsR eg(O ) < = dataToLEDs(O); end if; end il; end process p _ l.d l.E D S R eg S eq ; L E D <= L niL cdsR cg(8 dow nto
O Y.

- interrupt is latched on rising edge ol nPS U T L u tto n input -- IN T register is read/w rite(lo clear int)

p_L dlntR cgS eq : process(PC L K , nR E SE T , nPB U TT) begin if(n R E S E T = '0 ') then L m lntR eg < = 'O'; e ls if(n P B U T T = '0 ')th e n L m lntR eg < = T ; elsir(P C L K .'ev en t and PCLK. = 'I ') then it'U P S E L a n d PW R ITE an d PE N A B L E ) = 'I ') then it'(P A = L M J N T ) then L m lntR eg < = PW DA TA (O ); end if; end if; end if; end process p L dlntR egSeq; R E G S IN T < - L m lntR eg; -- Read registers p_G enN P R D A T A C o m b ; pro cess (PA, L m O sc R e g l. L m O scR eg2, L m LckR eg, Locked, L m L edsR eg. L m lntR eg, Lm Sw R eg) begin N extP R D A T A < = (others = > '0'); ease PA is w hen L M _0.SC I => N ex tP R D A T A (l8 dow nto 0) < = l.m O sc R eg l; w hen LM 0 S C 2 => N cxtP R D A T A (l 8 dow nto 0 ) < = L m 0 scR eg 2 ; w hen LM LO C K = > N extPR D A T A ( 15 dow nto 0 ) < = Lm LckR eg; N extP R D A T A( 16) <= Locked; w hen L M _L E D S => --N extP R D A T A (8 dow nto 0) <= Lm LedsR eg; N extPfiD A T A ( 16 dow nto 0) < = Lm LedsR eg; w hen L M _IN T => N extPR D A TA (O ) < = L m lntR eg; w hen LM _.SW => N extPR D A T A (7 dow nto 0) <= L m Sw R eg; w hen others = > N extPR D A TA (31 dow nto 0) < = "00000000000000000000000000000000"; end case: end process p C ienN PR D A 'fA C om b; -- W hen the peripheral is not b ein g accessed, 'O's arc driven -- on the R ead D atabus (PR D A T A ) so as not to place any restrictions -- on the m eth o d o f external bus connection. T h e external d ata buses o f the

144

Reprotducetd with perm ission of the copyright owner. Further reproiduction prohibiteid without permission.

- p erip h erals on the APB m ay then be connected to th e A S B -to-A PB bridge using - M iixed or O R cd bus connection m ethod, p_R dS eq ; process (PC L K , nR ESET) begin il (n R E S E T = '()') then PR O A TA < = (others = > '0'): e lsir(P C L K 'c v c n t and PC LK = 'I ') then P R O A I'A <= NextPRDATA: end ip end pro cess p_R dS eq; end .synth; = End = Sinctude <sldio.h> ^ in clu d e < tim e.h> //as delm ed in irqint.s extern v oid uH A L ir_E nablelnt(void); extern void uH A L ir_D isableInt(void); extern extern extern extern extern extern v o id \vord_w rite(int addr, int data); int vvord_read(int addr); v oid h w o rd_w rite(int addr, int data); in t h w ord_read(int addr): vo id byte_ w rite(in t addr, int data); int byte_read( int addr); + * *********** FR A M E _D IM E N S!O N 16 ,SCAN N IN G _R A D 1U S 16 1M A G E _R 0W S 64 IM A G E _C O L S 64 FR A M E.S_IN _R O W 4//m ust be !M A G E _R O W S / FR A M E _D IM E N S10N F R A M H ,S JN _ C O L 4//m ust be IM A G E _C O L S / FR A M E _D IM E N SIO N - e n d with 8 = lock roe. end

/***** # d elin e # d etm e A deline # d etm e Adeline S dellne

//detlne LM _LRD.S OxCOOOOOOCV/OxCOOOOOOS //tem p set to lock register instead// OxCOOOOOOC w ith C = LED /* T im e r register inform ations*/ Sdetlne T IM E R I_ C T R L (0x13000108) /fdeline T IM E R I_ V A L U E (0x13000104) «define T IM E R l_ L O A D (0x13000100) «define T IM E R 1_C L R (Ox 13000 IOC) « define T IM E R 2 _ L 0 A D (0x13000200) /* R egister set for IRQ controller ... pp 4-32 / «define IRQ STATUS (0x14000000) «define 1R Q _R A W STA T (0x14000004) «define IR Q _E N A B L E SE T (0x14000008) «define IR Q _E N A B L E C L R (OxMOOOOOC) /* hit assig n m en t for interrupts for interrupt controller 0 (first C P U ) */ «define S O F T IN T (0x1 « 0 ) «define T IM E R IN T l (0x1 « 6 ) «define T IM E R IN T 2 (0x1 « 7 ) /* IRQ V ector address for Integrator/A P platform */ «define IR Q V E C T ' (0x18) «define A N D FlL fE R OxOO()OFFFF//0.xOOOOQ03F

unsigned char activ cF ram e[F R A M E _ D IM E N S I0 N l(F R A M E _ D IM E N S 1 0 N |; unsigned char oldFram cA rea(FR A M E _D IM E N ,S IO N +2*SC A N N IN G _R A D IU ,S|(F R A M E _D IM E N .SIO N +2' SC A N N lN C i_R A D lU .S|; unsigned ch ar w h o leln iag el | IM A G E _R O W S lllM A G E _C O L S ]; unsigned ch ar w holclm agc2[IM A G E _R O W S l[lM A G E _C O L S ); unsigned ch ar h itm a p lle a d e rln fo (l4 |; unsigned ch ar int'ol leadcrlnfo[40j;

145

Reproducetd with permission of th e copyright owner. Further reproduction prohibited without permission.

im coinUi;r;//uscd by liming lunclions

struct bilm apl Icaticr! unsigned sh o rt int type;

/* M agic identi lier

'/

unsigned int size: / 1-ile size in b) tes */ unsigned sh o rt int reserved 1. reservedZ: // unsigned sh o rt int paddingV /l've been g ettin g this padded so that offset is alligned causing problem s!! unsigned int o llsef, / O ffset to im age data, bytes */

struct inlb H cad erl unsigned int size; /* H eader size in bytes */ int « tdth.height; / W idth and heig h t o f im age * ! unsigned sh o rt int planes; /* N um ber o f colour planes unsigned sh o rt int bits; /* Bits per pi.\cl */ unsigned int com pression; /* C om pression type */ unsigned int im agesize; /* Im age size in bytes */ int xresolution.yresolution; /» Pixels p er m eter */ unsigned int ncolours; /* N um ber o f colours */ unsigned int im portantcolours; /* Im portant colours */ struct te c tor I int row M ovem ent; int colum nM ovcm ent;

struct te c to r M a ste r0 u tlF R .A M B S _ lN _ R 0 W l(F R A M E S _ IN _ C 0 1 ,l; /»**»****FU N C T IO N P R O T O T Y PE S********/ struct vector h lockM atch(void): int init(void); int absulutctint in), void cotinler_stan(void); double counter_stop(void); void c_enableinterrupt(void); void lR Q cnablc_interrupts(void); unsigned lR Q _install_handler(ttnsigned location, unsigned *vector); irt| void IRtJI landler(void); void loadA rrats(v o id ); Moat dum bC ounter - 0; int mainOI int i, j, m, n, p, q; stru ct vector tem p; double tim er, int blockM titehC ounler = -1 ; int upperV al; int low erV al; int int l em p; u nsigned char to C irc u it|2 |; int tvlm 2First = 0; int tvlm 2Second = 0; int « Im I First = 0 : int «1m l,Second - 0; int crrorD etectFlag = 1; //tcin p ln t - « ord read fI.M 1,E 1)S); //printfC 'tem plnt: % d\r\n", tem pint); //retu rn 11; printl'C 'starting up\r\n"); co u n ter startO ;

146
Reproiduced with permission of the copyright owner. Further reproduction prohibited without permission.

return 0;

I //te st lest //retu rn tl./Zdid the l.KDS g o o ir? //iKuv lotnl up une fram e from each im age and call bloekm ateh. then sw itch to the next fram e. fur(i - I), i < KRAM ES_1N_R0VV; i++)j Ibrfi - 0; j < FR A M B S_IN _C O L ; j+ + ) | //now load the w hole corresp o n d in g sectio n o f each im ag e into the frame! for(m = O', m < FR A M E _D IM E N SIO N ; m++){ for(n = 0; n < FR A M E _D IM E N SIO N ; n++1 j activeFram clm }[n] = w holelm agc2[i»FR A M H _D IM E N SIO N -t-m l!j*F R A M H _D IM E N SIO N r III: //printl'C 'aclivcFram c: % d\r\n", a c tiv c F ra m e |m ||n |)t w im 2 F irst = i* FR A M E _D lM E N SIO N +m t w ln i2Second= j*FR A M H _D IM E N .SIO N 't-iu I//end for n I//end for m //printlV 'vvholclm agc2[% dll% d]\r\n", wI m 2 First. w ln ü S c c o n d ); for(m = 0; m < FR A M E_D lM EN SIO N +2*.SC A N N IN G _R A D IU .S; m r + ) | for(n = 0; n < FR A M E _D IM E N S fO N + 2*S C A N N lN G _R A D IU S ; rvi-i-)| if( (i*FR A M E _D lM E N SIO N -.SC A N N lN G _R A D IU S+m ) < 0 )| old F ran ieA rea[m )[n | = w h o leln iag el l0 |[0 |://0 ; w lm I First = 0; wl m l.Second = 0;
I

else if( (i' F R A M E _D lM E N S 10N -.S C A N N lN G _R A D lU S + m ) > 1M A G E_R0W .S )| o ld F ram cA rea|m ]fn | = w ho leln iag el |0 |[0 |;//(); w lm 1 First = 0; w lm 1S econd = 0; 1 else il% (.i*FR A M E _D lM E N S10N -.SC /\N N lN G _R A D lU Sr-n) < 0 X o ld F ranieA rea[niJ[n| = \v h o le lm a g e l|0 1 |0 |://0 . w lm 1First = 0; w lm lS e c o n d = 0;
1

else if( fj'*FR A M E _D lM E N SIO N -SC A N N lN G R A D IU S Ui) 1M A G E _C 0L S ) { o ld F ra m c A rea [m ||n | - vvholelm agel|()||()|'7/(): w lm I First = 0; w lm lS e c o n d = 0;
)

else I o ld F ra m e A rea (m ||n | = w h o leln iag el ( i*FR AM E _I>IM E N S10N SC A N N IN G _R ADI I IS+m j[i * FR A M E_D hM EN SIO N SC A N N IN G _R A D IU S + nl; w lm I First = i*F R A M E _D lM E N S 10N S C A N N lN G _ R A D lU S H ii; w lm lS e c o n d = j'*F R A M E _D lM E N S IO N SC A N N 1N G _R A D IU S h k
)

)//end for n I//end for m //printfC 'w holelniagel (% d |[% d |\r\n ", w lm 1First, w lm I.Second); blockM atchC ountert-t-; printlC 'w orking on bloekm ateh task #% d \r\n ''. b lo ckM atchC ounterl;

//il'( (bltickM atchC oniiler < 13) || (lilnckM atchC ounter ="= U ) || (bloek M alch C o n n ter  l.S) )] if( (blockM atchC ounter < 12) || (blocklvlatchC ountcr = 1.3) ji (hlo ek M ateh C o u n ter - - 14| || //then do it in IIW //so ju st w rite all the d ata to IIW forip - 0; p < (2 * S C A N N IN G _ R A D IU S H l . p t t | |

147

R ep ro du ced with permission of the copyright owner. Further reproduction prohibited without permission.

Ibr(q ·= 0; q < (2 ` S C A N N lN G _ R A n iU S H ); q + 0 | ror(ni --- 0 , ni < F R A M IiJllM I-N S IO N ; m n - , | lbr(n = 0; n < [·RA(Vll-;_l>IMl-.N.Si()N; n n -){ short * sh o rtT cn ip l'tr; int inlcgcrT cm p; loC irciiit(0| = a c tiv o l-ram clm lln l; (o C iraiitI I j okll'raiiio A ro alp I n i||q + n | sh o rtl'cm p P lr = (short * )(& to C irc iiit|0 |); integer lo n ip = "sltort'I'enrpPlr. \vortl_w rite(l,M _l,L;h)S, integcr'i'enip); inlTctrip = integer'I'einp; 1//en J for n )//end for in I//end for q }//cnd for p prinirC 'inlTeinp: % d\r\n". inlTeinp); //w ait to be sure HW circuit has generated th e results lbr(p = 0; p < 20; p++){ d um bC ounter = d u m bC ounter * 7; d u m bC ounter = dum b C o u n ter / 5; !//end for p upperV al = word_re-ad(LM _t.L'.DS); low erV al = upperV al; //printfC 'initial value: % d\r\n", upperV al); //rem ove unw anted upper bits low erV al = low erV al & OxOOOOOOFl-; upperV al = upperV al & OxOOOOFFOO; upperV al = upperV al » 8; M asterO u t[i|fj].eo lu m n M o v cm en t = upperV al; M asterO u tlijfjj.row M o v em en t = low erV al;

I
else I tem p = blockM alchO ; M asterO ut[i][jJ.colum nM ovem ent = tem p.coluninM ovem cnt; M asterO utfil[ij.row M ovem ent = tem p.row M ovem ent; IlferrorD etectFlag --- i ) | if(i = 1 ) 1 if(j = 0)l crrorD etectF lag - OV/don't do this again! //send an error reconfigure packet to the circuit //vvord_w ritc(l.M _L FD S, OxICOOl );//tell them to stop u sin a //B M O O l //now we m u st resend e v ery th in g from the beginning! //i = - 1; //j = - I ;//so that they will he increm ented to 0

'//e n d for j I //en d for i

fo rd = 0; i < FR A M FS IN J (O W ; if+ ) | for(i = (I; j < FK A M F:S_IN _R 0W ; j+ + )| //llrst .shift the values.... M asterO u lli|[j|.ro w M o v em en t = M a ste rO u t|i||j|.ro w M o v e m e n t - 16; M a.sterO ut[ij|j).colum nM ovem cnt = M a ste r()u t|i||j|.c o lu in n M o v ein e n t - 16; printl'C'BM task H % n - row shift.-'FidI, colum n shifl.'X,d\r\n". 4*1 rj.

148

Reproduceid with perm ission of the copyright owner. Further reproiduction prohibited without permission.

M astcrO iulijlj],row M ovem ent, M;LStcrt)iitlii|j|.colnmiiMovemenl). I //end lor j I //end Ibri

tim e r = c o u n le rs to p O ; p rln tl\"tim e r lor everything is % l'\n ". tim er); printl'C lnnshethrX n");
re liirri I;

in i in ilO l
I*

//tim e to open the two big intages KU.It* llrst. second; int i.j; int llrstln d ex . .sceondlndex; llrst - ropen("c;\\0.bm p", "r"); seco n d = I'opcnC'ctW I.bmp". "r"); il't (llrst = - N U L L ) || (second -- N U LL) )| printlC 'read error on input llles\r\n"); return 0;
I

fseekt llrst, OL, SLi-:K _Si;T); lscek (seco n d , OL, SE E K _SL T ); lbr(i = 0; i < id ; i+ + )| I'scanl'illrst, '"koc", & (b itm ap H ead erln lb [il)); I//en d lor i
lb r ( i = 0; i < 4 0 ; i+ + ) |

I'scanR llrst, "% c", & (inroH eaderlnfo(i])); }//cnd lor i //ju m p to the sta rt o l'th e im age data tscek (scco n d , 44L , SL E K _SE T ); fscek(llrst. 4 4 L , SF.E1C_S[1T); llrstln d ex = 44L ; seco n d ln d ex = 44L ; //n o w load up the overall im age lbr(i - 0; i < IM A G F J^ O W S ' i-H-){ l'or(i = 0; i < IM AGR_COL.S; j + + ) | //ch ar charTem p; //ch ar charT em p 1, ch ar TempZ; //u n sig n ed ch ar u C h a rT e m p l. u C harT em p2; ini outputT em p; int tails; //Isca n tjllrst, "% c". & .(charTem pl ));//(w h o lelm ag el (IM A G f:_C ()L.S*i + j|) ) ; //I'scan('(second, "% c", & (ch ar'!em p2));(w hole!m agc2(IM A G l'._C ()l..S *i  j|) ) . Iscan l(llrst, "% c", (w ho lelm ag el[IM A G F _ C O L .S ^i t-jj)); I'scan((second, "% c", (w holelm age2(IM A G F._C Ü L S *i + J |)) ; o u tputT em p = (int)(w holelEiiagel [IM A G E _C O L S *i + j |) ; p rin tf("w h o le lm a g e l["'od| = % d \r\n ", IM A G E C O l.S ^ i + j, output Temp); o u tputT em p = (int)(w holclm age2[IM A G E _C ()L ,S*i + j |) ; p rin ltV 'w holelm age2[% d| = % d \r\n ", IM A G E _C O L S*i + j, o u tp u ti'em p ); charT em p I = fgeic(llrst); i ((charTem p I = EO F) printl'C'l'getc 1 returned null\r\n"); ch arT em p2 = (gctc(second); i((charT em p2 = EO F) printl'C't'getc 2 returned nu ll\r\n "l, //ch arT em p = (unsigned char)(w h o lelm ag el|IM A G H _ C O I..S * i + j |) ; uC harT cm pI = (unsigned c h a r)(ch a r(e m p I ); u C harT cm p2 = (unsigned char)(char (em p 2 ); o u tputT em p = (in t)(ch arT em p l ); //p rin tl't"w h o leln iag el; % d\r\n". o u tp u tT em p );//w h o lelm ag elllM A C iE C'OL.S' i  - j|); //c h a r(e m p = (unsigned c h a r)(w h o lelm a g e 2 |IM A (iE C O LS*i  j |) ; output'I'em p = (in t)(ch ar'(em p 2 ); //print(("w holelm age2: % d\r\n", output (em p );//w h o lelm ag e 11 IM.AGE (.'Ol ,,S*i + j| ). w h o leln iag el [IM A G L C O t.S 'i -I- j| - (unsigned eh ar)(u C liar (em p I ); w holciniage2[IM A CiE_C O L.S^i i- jj - ()://utFliar'(enip2,

// // // // // // // // // //
U

//

149

Reprotduced with p eu nission of the c op yn ght o w n e r Fu(thor rep(oduction p(ohibited without pe(mission.

llrstln d e x ++; scco n d liid ex + + ; //printl'C 'that w as Ibr i: % d, j: % d\r\n", I. j); fails = Iseckfsecond, llrstln d ex . SliH K SIiTX printf("fails; % d\r\n". falls); fseck(first, secn n d ln d ex . .SliRK S I;!'); printfC 'fails: '% d\r\n". fails); [//end for j //priiuf("nnc row o f loading it up donc\r\n"); I//end for i ;'/word_ wrile{LM _LI;[3.S.0x lOR); //load up the arrays*/ loadA rraysO ; prinlfC 'init is done\r\n"); return I; im ab so lu le(im in )| i f ( in < 0 ) return -in, else return in; I .struct vecto r blockM ateliO l int b estR o w l.o catio n . b estC o lu m n l.o catio n ; int lo w e s t!irr o r =-100000000; int currcntR rror - 0; // int h allW ay = SC A N N IN G _R A D lU S;//used to be + 1 but 1 think that is w rong S tru ct v e c to r out; tut i. I. in. n; ford -0; i < (2*.SCA N N !N G _RA D 1U S+1 ); i+-t-)| lo rd = 0 ;j < (2 * S C A N N IN G _ R A D iU S + l);j-H -)j for(m = 0; in < FR A M B JD IM R N S IO N ; for(n = 0; n < l-R A M R .,D IM E N S 10N ; n4-t-)| ciirrentR rror + = absolute((activch`ran ie |m l[n |o ld l'ra in e .\re a |iii r i||n rj|)); [//en d for n [//en d for ni if(currentG rror < low est Error )| low estR rror = currcntR rror. b estR ow L ocation = i; b esiC olum n Local ion = j;

I
I I I I
'f i

' J i .! '

[
:· currcntR rror - 0; [//end fo rj I //end for i //set them to he -ive if below the h a lfw a y m ark .... o ut.ro w M o v em en t - b estR o w L o catio n ;// - halfW ay; o ut.eolum nM ovem cnt = bestC o lu m n L o eatio n ;// - 1ml W a y ; return out; \ O l d c o u n ter slart() e enableinterrupl(). 1R tjeu ah le interrupts!); eouiiter - 1). *(im *) TIM R R l_ C I'RL = OxOOOOOOCS;

double co u n ter stopt ) double total tim e; //prim f("stop\n");

150

Reprotduced with perm ission of th e copyright owner. Further reproduction prohibited without perm ission.

 (im )T liV U -:R I_ C rR I. = 0x00{)00()0();

// T h e last n u m b er 0.01936 Is the o v erh ead for startin g an d lini.shing the function calls. t o ta l ji m c = (d ouble) 1/(24000000/2.06)  (65535 - (int ) T1MI-.R1_VA1.IJ1-: + co u n te r  6 5 5 3 5 )- 0 .0 1 0 . //,,rim l("% d \n ". (int  ) T lM H R l_ V A 1 ,IJH ); //prinll'C 'tinie % l\n ". total tim e): retu rn total tim e; // T his fu n ctio n will e n ab le tim er 1. void e _ e n ab lein terru p t(v o id )

!
(int ) T IM C R L V A L U Ü = 65535; (int ) T IM R R 1 J .O A D - - 6 5535; void lR (,)en ab le_ in terru p ts(v o id ) u n sig n ed o rig in al vecto r 0x0;

original v ecto r = IRQ install han d ler((tin sig n ed ) IR Q l-landler, (un sig n ed ) IR Q V R C r); (int ) (IR Q JH N A B l.C SF.T ) = 0x0; //d isab le A L L interrupts (int ) (1R Q _I:N A B L I:C L R ) = Oxl-'Tl-l-Kl-l'r; //c lea r A L L interrupts (int (int (int (int ) ) ) ) (IR 0 _ E N A B L E S E T ) |= T IM E R IN T l; (IR Q J-:N A B L E C L R ) & = -T IM E R IN T l; (1R Q _E N A B LE.SE T) 1=T1M ER IN T2; (1R 0_F:N A B L U C L R ) & - -T 1M E R 1N T2;

//p rin tf("lR O _ E N A B L E S E T = 0x% X \n". (int ) (1R Q _E N A B L E SE T ) ); //printl% "lR Q _E N A B L E C L R = 0.x% X\n", (int ) (1R Q _E N A B L E C L R ) ); //p rin tfC 'callin g E n abling ints ...\n"); ul IA L ir_ E n ab leln t(); //p rin tfC 'E in ish ed E n abling ints ...\n"); //p rititr("o rig in al_ v eeto r = O x% X \n". o rig in al vector);

u nsigned IRQ install_h-andler(unsigned location, u nsigned vector) u n sig n ed vec, oldvee; « ifd e f DEBUG p rin tR "lo catio n % % p: 0.x% p\n", location); p rinifC 'location % % X : O x% X \n", location); prin tfC 'v ccto r % % p: Ox% p\n". vector); p rinifC 'vcctor % % X : 0.x% X \n", vector); p rintfC 'location - vector %%.X: Ox% X \n", location - (u n sig n cd )v ecto r); printl'C'lo cation - vector - 0 x 8 % % X : O x% X \n", location - (u n sig n ed )v ecto r - 0x8); p rintl'("(locatinn - vecto r - 0 x 8 ) » 2 % % X ; Ox% X\n", (location - (u n sig n ed )v ecto r - O x 8 ) » 2 ) ; p rin tf("((lo catio n - v ecto r - 0 x S ) » 2 ) | OxcaOOOOOO) % % X ; O x% X \n". ((location - (u n sig n c d )v e c lo r - 0 x 8 ) » 2 ) | OxeaOOOOOO): # c n d if vec = ((lo catio n - (u n sig n ed )v ecto r -0 x8) » 2 ) ; if(vcc & OxflOOOOOO) p rin tf("\n In stallatio n o f han d ler failed !!\n"); return) 1); vec = OxeaOOOOOO| vec; o ld v ee = vector; vector = vec: / Install new v ecto r / retu rn (o ld v ec);

151

Reprotducetd with p erm ission of the copyright ow ner. F urther reproduction prohibited without p erm ission.

i|

irq voiil IKOHandlor(voi(J)
//int n;

iinsignecl ini "b ase = (u n sig n e J int *) IR Q S T A T U S ; / · O o le n n in e in terru p t type and call a p p ro p riate h an d le r */ ilC h a s e & IIM IiR IN T I)

I*

IR Q sta tu s re g iste r Ibr p ro cesso r 0 */

1
"tin t ) T IM [-;R I_C T R L = OxOÜOOOOüO; counter+H ; //lb r(n = 0 ; n<IO ; n++) //p rin ttC '% d \n ". * (in t Q T IM E R L V A l.U H ); * (in t )T IM 1-.R I_C 1.R = 0; * |in t  )T IM I-R 1 C T R L =· Ox OOOOOOC8;

152

R e p r o d u c e d with pe rm issio n of the copyright o w n er. Fu rth er reproduction prohibited without p erm ission.


