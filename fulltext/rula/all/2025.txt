ADAPTIVE ECHO CANCELLATION ANALYSIS
by Yongdong Sun (B.Eng., Shenyang, China, June 1993)

A Project presented to Ryerson University in partial fulfillment o f the requirements for the degree of Master of Engineering in the Program of Electrical and Computer Engineering

Toronto, Ontario, Canada, 2004 © Yongdong Sun 2004

PR0P,^7rrvf)F nVERSC/îj i

UMl Number; EC52987

All rights reserved
INFO RM ATION TO USERS

The quality of this reproduction is dependent upon the quality of the copy submitted. Broken or indistinct print, colored or poor quality illustrations and photographs, print bleed-through, substandard margins, and improper alignment can adversely affect reproduction. In the unlikely event that the author did not send a complete manuscript and there are missing pages, these will be noted. Also, if unauthorized copyright material had to be removed, a note will indicate the deletion.

UMl'
UMl Microform EC52987 Copyright 2008 by ProQuest LLC All rights reserved. This microform edition is protected against unauthorized copying under Title 17. United States Code.

ProQuest LLC 789 East Eisenhower Parkway P.O. Box 1346 Ann Arbor, Ml 48106-1346

Author's Declaration
I hereby declare that I am the sole author o f this Research Paper. I authorize Ryerson University to lend this Research Paper to other institutions or individuals for the purpose o f scholarlv research. ______ _

Signature______________________ .

______________

I further authorize Ryerson University to reproduce this Research Paper by photocopying or by other means, in total or in part, at the request o f other institutions or individuals for the purpose o f scholarly research.

Signature____________

__________________

u

Borrow List
Ryerson University requires the signatures o f all persons using or photocopying this thesis. Please sign below, and give address and date.

Ill

Abstract
Title: Adaptive Echo Cancellation Analysis
Echo cancellation is a classic problem in DSP and digital communication. Adaptive echo cancellation is an application of adaptive filtering to the attenuation o f undesired echo in the telecommunication network. This is accomplished by modeling the echo path using an adaptive filter and subtracting the estimated echo from the echo-path output. In this project, the concept o f echo cancellation and echo cancellation systems are studied, simulated, and implemented in Matlab and TI TMS320C6711 DSK. The LMS, NLMS, Fast Block LMS and RLS algorithm are investigated for echo canceller and two double talk detection algoritlims: the Geigel algorithm and the normalized cross correlation algorithm are presented and combined with NLMS adaptive algorithm against double talk. Finally The adaptive echo cancellation system successfully developed by the NLMS and normalized eross-eorrelation DTD algorithms meet the general ITU G. 168 requirements and show excellent robustness against double talk.

IV

Acknowledgements
Many thanks to Dr. Mike Kassam, my supervisor, for his thoughtful advice, assistance and comments. Also, thanks to m y wife and m y family for supporting me during this project.

Table of Contents
CHAPTER 1 i n t r o d u c t i o n ................................................................................................ 1 1.1 Adaptive Echo Cancellation............................................................................................. 1 1.2 Adaptive Filters...................................................................................................................3 1.3 Project Objective................................................................................................................ 5 CHAPTER 2 ECHO CANCELLATION ADAPTIVE M ETHOD S..................................... 6 2.1 LMS Algorithm s................................................................................................................ 6 2.2 NLMS Algorithm s............................................................................................................. 9 2.3 Fast Block LMS A lgorithm ............................................................................................10 2.4 RLS algorithm...................................................................................................................13 CHAPTER 3 DOUBLE TALK DETECTION ALGORITHMS.......................................... 15 3.1 The Geigel algorithm .......................................................................................................15 3.2 Normalized cross-correlation algorithm ....................................................................... 16 3.3 Evaluation procedure o f double detectors..................................................................... 18 CHAPTER 4 MATLAB SIMULATION & ANALYSIS......................................................20 4.1 Adaptive algorithms.........................................................................................................20 4.1.1 L M S ........................................................................................................................... 21 4.1.2 N L M S ........................................................................................................................ 23 4.1.3 Fast Block L M S ........................................................................................................25 4.1.4 R L S ............................................................................................................................ 27 4.2 NLMS and DTD A lgorithm s......................................................................................... 29 4.2.1 The Geigel DTD algorithm ..................................................................................... 30 4.2.2 NLMS and normalized cross-correlation DTD algorithm .................................. 33 4.3 Matlab Simulation Sum m ary......................................................................................... 35 CHAPTER 5 ADAPTIVE ECHO CANCELLER WITH DTD STRUCTURE.................39 5.1 Adaptive Echo Canceller with D T D ..............................................................................39 5.2 Non-linear processor........................................................................................................41 5.3 Software W orkflow..........................................................................................................42 CHAPTER 6 ITU G.168 TEST CASES..................................................................................43 6.1 Test 1: Steady state residual and residual echo level te s t........................................... 43 6.2 Test 2A and 2B: Convergence test with NLP enabled and disabled........................ 44 6.2.1 Test 2A: Convergence test with NLP enabled......................................................44 6.2.1 Test 2B: Convergence test with NLP disabled.....................................................44

V I

6.3 Test 2C: Convergence test in the presence o f background noise...............................45 6.4 Test 3; Performance under conditions o f double talk................................................. 47 6.4.1 Test 3A: Double talk test with low near end levels............................................. 47 6.4.2 Test 3B: Double talk test with high near end levels............................................48 6.5 Test 3C: Double talk test under simulated conversation............................................ 50 6.6 Test 4: Leak rate test........................................................................................................51 6.7 Test 5: Infinite return loss convergence te st.................................................................52 6.8 Test 6: Non-divergence on narrow-band signals......................................................... 53 6.9 Test 7: Stability te s t.........................................................................................................54 6.10 Test 8: Non-convergence, in-band signaling, and continuity check to n e s............ 55 6.11 Sum m ary......................................................................................................................... 56 CHAPTER 7 REAL TIME SIM ULATION........................................................................... 59 7.1 TI TMS320C6711 D SK .................................................................................................. 59 7.2 C6711 DSK Simulation using Code Composer S tudio.............................................. 59 7.2.1 Simulation Procedure Introduction........................................................................ 59 7.2.2 C6711 DSK Simulation Results..............................................................................61 7.3 Real time simulation sum m ary...................................................................................... 70 CHAPTER 8 CONCLUSION................................................................................................... 72 CHAPTER 9 FURTHER W ORK.............................................................................................73 REFER EN CES........................................................................................................................... 74 APPENDIX A: MATLAB CODE............................................................................................76 APPENDIX B: TI CCS CODE................................................................................................. 87

Vll

Chapter 1 Introduction
1.1 A daptive Echo C ancellation Echo is a phenomenon in which a delayed and distorted version of an original sound or electrical signal is reflected back to the source. In real life, echoes often occurrence among conversations. The echoes of speech waves can be heard as they are reflected from the floor, wall and other neighboring objects. In such a case when the reflected wave arrives a few tens o f milliseconds delay after the direct sound, it can be heard as an obvious echo. These echoes are bothering and may unexpectedly interrupt a conversation. Thus it is desired to eliminate these echoes. In telephone communication, there are two main types o f echo: network and acoustic echoes. The network echo results from the impedance mismatch at points along the transmission line, for example, at the hybrids of a public switched telephony network (PSTN) exchange, where the subscriber two-wire lines are connected to four-wire lines. Acoustic echo is due to the acoustic coupling between the loudspeaker and microphone in hands-free telephone systems, for example, if a communication is between one or more hands-free telephones (or speaker phones), then acoustic feedback paths are set up between the telephone's loudspeaker and microphone at each end. Acoustic Echo is more hostile than network echo mainly because o f the different nature o f echo paths. The solution to these echo problems is to eliminate the echo with an echo suppressor or echo canceller.

The problems with echo suppressor are: · · · only one speaker can talk at a time clips speech take time to detect the beginning o f speech

Now using adaptive filter to reduce the echo and increase communication quality is a common technology in communication system, but there are still some challenges : · · · many existing adaptive algorithms give different performance different adaptive algorithms need different parameter setting overcome double talk disturbance

This project focuses on the following achievements: (1) Providing an easy approach to compare and review various adaptive algorithms based on their convergence rate, steady state ERLE and complexity o f implementation, etc. (2) Supplying different pre-designed double talk detection methods that can be easily configured with different parameter to obtain the expected performance.

(3) Implementation o f AEC and DTD algorithms to work practically and efficiently using smooth estimation and the pre-set parameters selected from experiments. Adaptive cancellation o f such acoustic echo has became very important in hands-free communication systems, e.g. tele-conference, video-conference and PC telephony systems.

Echo canceller is a better solution to the acoustic echo problem, which allows both speakers to talk at the same time. The Basic Structure o f Adaptive Echo Canceller is shown in Figure 1.1 and the estimated echo signal y{t) generated by an adaptive filter eliminates the echo signal y { t ) . The coefficients of the adaptive filter are adjusted by adaptive algorithm according to the estimation error signal e{t ) .

x{t)

Adaptive Filter

Echo Path

y(t)
+ +

e(0 = y(t) + u{t)

u(t)

Figure 1.1 Basic structure o f adaptive echo canceller: far end signal x{t ) , echo signal y{t ) , near end signal u{t), received signal z{t ) , estimated echo signal y{t) and error signal e { t ) .

1.2 A daptive Filters

Adaptive usually deploys a traversal Finite Impulse Response (FIR) structure due to its guaranteed stability and the adaptation o f the FIR filter coefficients is controlled by an adaptive algorithm. The adaptive algorithm is the heart o f an AEC, which decides the convergence behavior and tracking behavior o f the AEC. The tracking behavior indicates

how fast the adaptive filter can follow enclosure dislocations, whereas the convergence behavior is studied as an initial adjustment o f the adaptive filter to the impulse response o f the room or car. In Figure 1.2, w represents the coefficients o f the FIR filter tap weight vector, x(k) is the input vector samples, z "' is the delay unit, y(k) is the adaptive filter output, desired echoed signal and is the estimation error at time k. is the

input

x(k)

Figure 1.2 Adaptive filter block diagram

The adaptive filter is used to calculate the difference between the desired signal and the adaptive filter output, . This error signal is fed back into the adaptive filter and its

coefficients are changed algorithmically to minimize the cost function that is a function of . In acoustic echo cancellation, the optimal output o f the adaptive filter is the value

o f the unwanted echoed signal. When the adaptive filter output is equal to desired signal, the error signal becomes 0, in this ideal situation, the echo signal will be completely cancelled and the far end user will not hear his original speech returned to him.

1.3 Project Objective

In the project, the LMS, NLMS, Fast Block LMS and RLS algorithm are studied and alternatively used in adaptive acoustic echo canceller. The NLMS with two different Double Talk detection algorithms are integrated in the adaptive echo canceller against double talk. The performance and parameters of these adaptive algorithms such as filter length, step size and convergence speed are studied in details and the two Double Talk algorithms: detection algorithms: the Geigel algorithm and the normalized cross correlation algorithm are studied and simulated with NLMS algorithm in Matlab and TI TM S320C6711 DSK. The ITU G.168 standard is used to study the performance of the adaptive echo canceller.

Chapter 2 Echo Cancellation Adaptive Methods
M ost echo cancellers use variants of the LMS adaptation algorithm [1] [2][3]. The attractions o f the LMS are its relatively low memory and computational requirements and its ease o f implementation and monitoring. In practice, LMS adaptation has produced effective line echo cancellation systems. 2.1 LMS Algorithms In Figure 1.1, the error signal is
(2 . 1. 1)

and y , = X lW = W X , So, g ,= d , - x l w = d , - w " x , We can square to get the instantaneous squared error. (2.1.4) (2.1.5) (2.1.3)
(2 . 1.2)

6 ^ =d ^ +W X, x rW - 2d ,'k X| :W ^^k
E [ s l ] - E [ d l ] + W ^ E [ X , X l ]W -2E[d, X [ ]W Let R be defined as the autocorrelation matrix XkXk ^k-l^k R = E [X i,X l] = E ^
X k-N + l^ k X k-N + l^ k-1 X k-N + l^k-N + l

XkXk-1 X k-l^k-1

^k X k -N + 1
^k-l^k-N + l 1 j

(2.1.6)

6

Let P be similarly defined as the cross-correlation matrix

P - £ [ d ,X ,[ ] = £ 7

dk^k-



1

ditaifc-jv+i (2.1.7) And the mean-square error can be designated by ^ and we can obtain the following expression: M SE= # = E[ ]=E[d I ]+W ^ RW-2PW (2.1.8) is a quadratic function o f the weight vector

Now it is clear that the mean-square error

W. W hen we expand this expression, the elements of W will appear in first and second degree only. If we have two weights, we can get the quadratic error function, or performance surface. ( the vertical axis represents the mean-square error and the horizontal axes the values of the two weights.) The point at the "bottom of the surface" is projected onto the weight-vector plane and then we can obtain the optimal weight vector W* or the minimum mean-square error point. And there is only a single global optimum in this performance surface. To search the performance surface for minimum point, we can do gradient methods:
T

V « )£

dW

awo

dw^

a^ dw N - \

=2RW-2P

(2.1.9)

To obtain the minimum mean-square error, the weight vector W is set at its optimal value W* and where the gradient is zero. V =0=2RW*-2P RW *=P (2.1.10) (2.1.11)

Then the W * = R -'P . To develop the Least Mean Square (LMS) algorithm, we take (2.1.12) itself as an estimate o f

· Then, for each iteration in the adaptive process, we have a gradient estimate o f the form 'ds^ 5Wo · (2.1.13)

W ith this simple estimate o f the gradient, we can have V, = W , + 2 / , « , X . (2.1.14)

This is the LMS algorithm, ju is the gain constant that regulates the speed and stability o f adaptation. The LMS algorithm can be implemented in a practical system without squaring, averaging, or differentiation and is simple and efficient. For each iteration the LMS algorithm requires 2N additions and 2N+1 multiplications (N is the filter length, N for calculating the output, one for 2p multiplication). and an additional N for the scalar by vector

2.2 NLM S Algorithm s W hen n is optimized as described by u.(n) = ------- ^ --------- , a e (0,2), 0 < B , (2.2.1)

P guarantees that the denominator never becomes zero, while a is a relaxation factor, the normalized LMS algorithm results. In this case, pi is time varying. The echo canceller coefficients {m) are adapted to minimize the energy o f the echo (m) and Xg (m) are

signal on a telephone line. Assuming that the speech signals

uncorrelated, the energy on the telephone line from B to A is minimized when the echo
A

echo

A

ech o

canceller output

xa

(m) is equal to the echo

xb

{m) on the line. The echo canceller

coefficients can be adapted using the least mean squared error (LMS) adaptation algorithm or one of the most widely used algorithms for adaptation of the coefficients o f an echo canceller is the normalized least mean square error(NLMS) method. The timeupdated equation describing the adaptation o f the filter coefficient vector is e{m) w{m) = w(jn-V) + pi--^--^ -- where x^ (m) = ;-x^(m) (2.2.2)

{m),...,x^ { m - N + 1)] and x{m) = [x^ (m),..., x,,_, ( m - N + 1)] are the

input signal vector and the coefficient vector of the echo canceller, and e(m) is the difference between the signal and the echo line and the output of the echo synthesizer. The normalized quanity x(m )^x^(w) is the energy of the input speech to the adaptive filter. The scalar pi is the adaptation step size, and controls the speed o f convergence, the steady-state error and the stability of the adaptation process. Each iteration of the NLMS algorithm requires 3N+1 multiplications (N is filter length), this is only N more than the standard LMS algorithm.

2.3 Fast Block LMS Algorithm In the normalized LMS algorithm, the filter coefficients of a finite-duration impulse (FIR) filter are adapted in the time domain. Because the Fourier transform maps timedomain signals into the frequency domain and the inverse Fourier transform provides the inverse mapping that takes the signals back into the time domain, it is workable to perform the adaptation of filter coefficients in the frequency domain, which is called frequency-domain adaptive filtering. In a block-adaptive filter, shown in Figure 2.1, the input data sequence x(n) is sectioned into L -point blocks by means of a serial-to-parallel converter, and the blocks o f input data so produced are applied to an FIR filter o f length M , one block at a time. The coefficients o f the filter are updated after the collection of each block o f data samples, so that adaptation o f the filter proceeds on a block-by-block basis rather than on a sampleby-sample basis as in the conventional LMS algorithm.

input signal x(n) B lock input
B lo c k F IR F ilte r

filter outupt y(n) U nblock input
Select

Block correlation, w eight update

Block input error signal

Figure 2.1 Block-adaptive filter

10

The Fast Block LMS algorithm represents a precise frequency-domain implementation o f the block LMS algorithm and its convergence properties are identical to those o f the block LMS algorithm.

Fast Block LMS Algorithm is based on Overlap-Save Sectioning (Assuming RealValued Data). Initialization: w(0) = 2M by 1 zero vector Pi(0) = S; where the S; are small positive constants and i = 0,...,2M -- 1 Notations: 0 FFT IFFT a

(2.3.1) (2.3.2)

= M by 1 zero vector = fast Fourier transformation = inverse fast Fourier transformation = adaptation constant

Computation: For each new block of M input samples, compute: Filtering U{k) = d i a g { F F T [ u { k M - M ) , . . . , u { k M + M - \ ) f ) _y^(A;) = the last M elements of IFFT [U{k)W{k)'\ Error estimation e(k) = d ( k ) - y { k )
0 /W .

(2.3.3) (2.3.4)

(2.3.5) (2.3.6)

E (k) = F FT

Signal-power estimation Pi(k) = yPi{k - \) + (I - y)\Ui(k)\^

,

i = 0,1,....,2M - 1

(2.3.7) (2.3.8)

D{k) = diag[P^~'(k),P~' (k),...,P2M-i '(^)] Filter coefficient adaptation ^(k ) = the first M elements of IFFT[Z)(A:)C/"(^)E'(Æ^)]

(2.3.9) (2.3.10)

W{k + l) = W(k) + aFFT

11

Choice of Block Size: The block size L in relation to the length M o f the adaptive filter. There are three possible choices that can be chosen, each with its own practical implications: · · L =M L<M which is optimum choice advantage o f reduced processing delay and if the block size smaller

than the filter length, the adaptive filtering algorithm computationally is still more efficient than the conventional LMS algorithm.

·

L> M

increased redundant operations in the adaptive process, because the

estimation of the gradient vector now uses more information than the filter itself.

In the fast block LMS algorithm there are 5 FFT transforms, requiring approximately 2M log(2M) real multiplications each, and also other 16M operations (when updating the parameters, computing the errors, element-wise multiplications o f FFT transformed vectors), so the total is lOM log(2M) + 16M = lOM log(M) + 26M.

12

2.4 RLS algorithm

The Recursive Least Square (RLS) algorithm is used to minimize the cost function: f =
k= \

(2.4.1) is a small positive

Where k-- 1 is the time at which the RLS algorithm starts and constant very close to, but smaller than 1.

Unlike the LMS algorithm and its derivatives, the RLS algorithm directly considers the values o f previous error estimations. In fact, it is impossible to use all previous values o f the estimation error from the start o f the algorithm with the cost equation in real FIR implementation for the computation complexity. In practice, only a finite number o f previous values are considered, this number corresponds to the order o f the RLS FIR filter, N. y,, (^) = i.n)x{k ) , e,, ik) ^ d { k ) - (k) (2.4.2) (2.4.3) (2.4.4) ( n ) À e(n ) = d^ k d - 2 9 l w + w"' w (2.4.5)

d(n) = [ d (l),d(2 )...d (n)f , e(n) = [e,,(l),e,,(2)...e,,(n)f e(n) = d{n) --y(n) (k) =
k= \

where 9x(n) = x ( n ) A d ( n ) , 0;i(n) = x{n) A(n)x^(n) w(n) = 0 ^ " '(n) 9x(n) Find the inverse matrix using recursive form, Ô a"* (n) = A ( « - ! ) + x{n)x^(n) = r ' (Oa"`(« - 1 ) - k(n)x^ («) 0 a "`(n - 1)) (2.4.6)

(2.4.7)

13

where

=
1+ r V ( « ) (!)-'(«- 1)a:(«)

^------- «(»)
(« M « ) (2.4.8)

d i { n ) = k G x { n - \ ) + x{n)d{ri) so RLS algorithm filter weight update vector

w(n) = 0 ;i"'(«) ^a(«) - o r '(n - 1) 0 A ( n - l ) - k(n)x^ O L ' (n -1 )) 0 a (« - 1 ) + k{n)d{n) = w{n - 1 ) + k{n) e,,-i (n) (2.4.9)

where

e«-i (n) = d ( n ) - w^(n - l)z(«)

Each iteration o f the RLS algorithm requires 4N^2 multiplication operations (N is the filter length).

14

Chapter 3 Double Talk Detection Algorithms

During double-talking periods, there exists the other end speaker's adaptive signal v(«) which acts as a very large interference to the adaptive filter. If the adaptive filter continues to adjust its coefficients during double-talking periods, the adaptive filter will be greatly disturbed and will quickly diverge from its convergence state. Therefore, double-talk detectors are used in adaptive voice echo cancellers to detect the doubletalking periods, and the adaptive filter coefficients adjustment is prohibited during these periods to prevent the echo canceller from being disturbed by the other end speaker's signal. Double-talk detection plays a very important part in adaptive acoustic echo cancellation. The basic requirement for a double-talk detector is that it can detect doubletalking quickly and accurately and it should also have the ability to distinguish the double-talking conditions from echo path variations and quickly track variations in the echo path.

3.1 T he Geigel algorithm

A simple approach is to measure the power o f the received signal and compare it to the power o f the far-end signal; as shown in Figure 1.1, z{t) is the received signal, x(t) is the far end signal, this is the Geigel algorithm [4] and the decision variable is defined as
dn(.` ) = ------------------------( 3 . 1. 1)

m ax{|x(f) !,...,!%(r-M + l)}

15

If d(j (0 is larger than some preset threshold,

, it is treated that Double Talk is

occurring, otherwise not. The Geigel detector is computationally simple and need little memory, but the choice o f is not easy to obtain good performance.

3.2 N orm alized cross-correlation algorithm As shown in Figure 1.1, the power of the received signal can be written as R,{t)h, + crl(t) where (t) = E { x , x f } is the L x L covariance matrix o f the far-end signal, crj ( 0 is the power o f the near-end signal, cx^ {t) is the power o f the received signal, hi is room acoustic response. As y(t) = h j x , , Then r^{t) = E{x,y{t)] = Yielding, h,= R :\ty^(t) So, . W hen there is no near-end signal is present,v(?) = 0, then z(t) = y{t) and cr"( 0 X {t)r \ xy'(f), with (0 = E{x,z{t)} (3.2.6) (3.2.5) (3.2.4) , (3.2.2) (3.2.3) (3.2.1)

The detection variable is d(t) =

(0

ik M ,

(0

(3.2.7)

16

where h is the estimated room acoustic response and

(t) is the estimated cross

correlation between the far-end signal and the received signal. The nominator is the power o f the received signal if no near-end signal is present. The denominator is the actual power of the received signal. Thus, if no near end signal is present, » 1, otherwise d{t)< \ . The Double Talk decision is formed as d{t) < T,,,

double talk present, otherwise not. When there is no near-end talk, it is known thatthe decision variable d < I for
V

d is =1 for v=0 and

when there exist near-end talk. To calculate the deeision variable d , in

implementation, we use the following smoothed estimate: ^xz ( 0 = ccTxz (f - 1 ) + (1 - a)X{t)z{t) a ] (0 = acy] (r - 1 ) + (1 - a)z{t)(3.2.8) (3.2.9)

where a is a smoothing factor which lies in (0,1). In experiment, a. is set to be 0.9 and
L -\

(f) = 2 ^ ( ( - k)z{t - k ) , k= 0 using a L length sliding window, the (t) can be estimated [5] [6][7][8].

(3.2.10)

17

3.3 Evaluation procedure of double detectors

comp

threshold

Figure 3.1 Voice activity detector

Activity Detector Activity Detector

AND

DTD method

com p

Th

Figure 3.2 DTD test procedure diagram

In the DTD methods discussed in the previous section, the role of threshold T is essential to the performance. However, there hasn't been a systemic approach to select the value o f T. In the paper [6] [9][10], an objective technique is proposed for evaluating doubletalk detectors in acoustic echo cancellers. It view DTD as a binary detection problem and use it in actual operating environments. The general characteristics o f a binary detection scheme are as follows.

18

Probability o f False Alarm ( P^): Probability of declaring detection when a target is not present. Probability o f Detection { P^)'. Probability o f successful detection when a target is present. Probability o f Miss ( P ^ - l - P ^ y . Probability o f detection failure when a target is present.

(3,3.1) ^ N
a : * v /^ ;c

·V

(3.3.2)

=

1

-

·

V/

«V

(3.3.3)

19

Chapter 4 Matlab Simulation & Analysis
4.1 A daptive algorithm s Graphical User Interface In this project, the command `guide' is used in MATLAB v6.5 to make the Graphical User Interface (GUI) of the AEC Analysis and Design program to help study different AEG algorithms. The GUI of the program can be seen in Figure 4.1.
gui_algorithm

AEC Analysis and Design v1.0
A E C A Ig o r ith m v o i c e F ile , m B kw av L e a k y F a c to r F o rg e ttin g F a c to r 01

S tm t sim ulating S ta tu s
T im e (s )

<S
r

IM S

r

F a s t IM S F ilte r L e n g t h |1 0 2 < S te p S iz e 0 .0 0 7

N LM S

r

R L S

2 9 0 .0 7 0 s

L V S .

icna

L W S .f i l U r 90tr f r c * n îB

.V S

flltê?

L V S: r r.* ir K k # » *rrof

LVS. t t t o ts e r a i

' LU S. a 1t* n w iio n In cB2 5

3

3 .9

4

I

»vafiQ»«ttBnmtc«>lt.?S94 efl

N L M S & D T D A n a ly s is a n d D e s ig n

Figure 4.1 AEC Analysis and Design program GUI In this program, user can choose: 1. AEC Algorithm a. LMS algorithm b. NLMS Algorithm

20

c. Fast LMS Algorithm 2. Input signal file (wav format) 3. Filter Length 4. Step Size 5. Leaky Factor 6. Forgetting F actor

4.1.1 LM S The Figure 4.2 shows the desired signal, adaptive output signal, estimation error and mean square error for the LMS algorithm with FIR Filter length o f 1000, step size o f 0.007.

filtaicr

21

"4*"-- # !» »* < > I # '#1 * '" ^ 1 # " f¥ > i

Figure 4.2 LMS algorithm

o'

Figure 4.3 LMS echo signal attenuation The average attenuation for LMS FIR filter is -- 18.16dB.

22

Figure 4.4 LMS FIR filter impulse response

4 . 1 .2

NLM S

The Figure 4.5 shows the desired signal, filter output signal, estimation error and mean square error for the NLMS algorithm with FIR Filter length o f 1000.

23



_ s--*

^

'i ^

Figure 4.5 NLMS algorithm
c t o s t r o c i s s tg n m

Figure 4.6 NLMS echo signal attenuation

The average attenuation for NLMS FIR filter is -27.99dB

O &

0.»
o _ -*

0 .3
o
1

24

*

^

, "' 'w JjS »

Figure 4.7 NLMS FER filter impulse response

4.1.3 Fast Block LMS The Figure 4.8 shows input signal, the desired signal, filter estimation error and mean square error for the FLMS algorithm with FIR Filter length o f 1000.

I f - » |3 - L r t s i o r k a l

d e s iro c i s ig n a l

if-  " i

25

» . I'll

#
Figure 4.8 Fast Block LMS algorithm

le s
æ m

-- 1 '

' mr,

Figure 4,9 Fast Block LMS FIR filter impulse response

p r o p e r t / of

26

RYEMQN

iY UBRAflY



C «JB >

Figure 4.10 Fast Block LMS FIR filter echo signal attenuation The average attenuation for NLMS FIR filter is -5.33dB.

4.1.4 RLS The Figure 4.11 shows the desired signal, filter output signal, estimation error and mean square error for the RLS algorithm with FIR Filter length o f 1000 and À = 1.

"i o o o o

3S tk n r > a te ^ c l o r r o r

f .t

27

J

:

Ik Figure 4.11 RLS algorithm

_fuVn/WWww^_

Figure 4.12 RLS FIR filter impulse response

= #

28

V -» o

Figure 4.13 RLS echo signal attenuation The average attenuation for RLS algorithm is -33dB.

4.2 N LM S and DTD Algorithm s

The NLM S & DTD Analysis and Design program is another GUI program made by `guide' to study NLMS and DTD performance, and shown in Figure 4.14.
V gui_nlms_dtd_algorithm

NLMS & DTD Analysis and Design v1.0
N L M S & D T D A l g o r i l h m ----------------F ilte r L e n g th [l0 2 4 N C C l o w lim it f0 9 c o v e r g e h o ld (s )

f 0 .1 1 2 5
1 0 .0 3 7 5

Start sim ulating

C

N L M S a G ie g e l D T D

a lg o rith m G e ig e lT h fT ^ N C C h ig h lim it | l 05 D T h o ld (5 )

N L M S & N C C D T D

a E g o rith m

riôô
N L l'3 & NCC: « s tir rjlM i g r j i

NLMS & NCC: `i r gr-j g g ra l

IfH'i
NLMS I NCC: f a 'f e r : & y««SCrj!
N L I/5 S s e e

fH * * "

«
NLMS i, NCC. r « r e rd s e r a i

s
rtis o n it

NLMS £ NCC: filter

e

NLVS & NCC: rr-gaSLffri s e ^ a l

5

T 3

* 3 0

»»
NLMS £ NCC. ERIE

g.))

A E C A n a ly s is a n d D e s ig n

Figure 4.14 NLMS & DTD Analysis and Design program GUI

29

In this program, user can choose: 1. NLMS & DTD Algorithm a. NLMS and Giegel DTD algorithm b. NLMS and normalized cross-correlation (NCC) DTD algorithm 2. Filter Length 3. Geigel Threshold 4. Geigel Length 5. NCC low limit 6. NCC high limit 7. Converge hold time 8. Double Talk period hold time

4.2.1 The Geigel DTD algorithm The Figure 4.15 shows the far end signal, far end echo signal, near end signal with DTD detection, received signal, error signal, filter impulse response, and ERLE for N L M S Geigel DTD algorithm.
&

O

O

30

; ts n _ iv is A

2 5
O

· 2

,S

NLIV1S &

O e i g e k n e a r e n d s ig n a l

rNll_rw1S A . O e i g e i

m e a s u re d

si

S

islL-MS & O e ig e l: e s ti

te d s i g n a l

O .S

o

-1 . s

o

2

-rry ^ ^ m W .

31

e r r o r s ig rM il

ii

0-3

O

->0.3

O O

800

-lOOO

-1 S

'·£

Figure 4.15 NLMS & Geigel DTD algorithm The Geigel DTD miss alarm rate is Pm=\- 21715 / 33368=35%. and its false alarm rate is Pÿ= 15559/96009=16%.

32

4.2.2 NLMS and normalized cross-correlation DTD algorithm The Figure 4.16 shows the far end signal, far end echo signal, near end signal with DTD detection, received signal, error signal, filter impulse response, and ERLE for . NLMS and The normalized cross-correlation DTD algorithm.

-IO '*
r v Jl_ M S & N O O : fa r e n d a c T io s i g o a l

{M i_rN rftS & r s i O O : n e a r a n d s l o r t a l

33

e r r o r s ig rte l

L _ IS /IS

& . IN IC^C^; f i l% e r i m

p u l s e

r e s p o n s t

Figure 4.16 NLMS and the normalized cross-correlation DTD algorithm

The miss alarm rate is Pw = l-30118/ 33368=0.1=10% and the false alarm rate is Pf= 2432/96009=2.5%.

34

4.3 Matlab Simulation Summary The ERLE (Echo Return Loss Enhancement) is used o assess the quality o f an echo cancellation filter. ERLE, a function o f the discrete-time index n, is defined as the ratio o f the instantaneous power o f signal d(n) and the instantaneous power o f the residual echo e(n): ERLEi n) = LMgorithm LMS NLMS Fast LMS RLS Average ERLE -18.16 dB -27.99 dB -5.3 dB -33 dB Multiplication (Filter Lengtb:L() 2N+1 3N+1 10 Nlog2N+26N 4N^2

Table 4.1 Algorithm summary The LMS algorithm belongs to the class of stochastic gradient algorithms and it's the simplest one. The mean square error of LMS in Figure 4.2 shows that the LMS filter's impulse response converges to the actual impulse response as the average value o f the cost function decreases so that the filter could more accurately emulate the desired signal and more effectively cancel the echo signal. LMS is easily to be implemented and if the step size is correctly selected, it is stable. In Figure 4.5, the error signal and mean square error o f the Normalized Least Mean Square (NLMS) algorithm is obviously smaller than those o f LMS and has faster convergence speed than that of the LMS algorithm. The NLMS differs from the standard LMS algorithm in the sense that it varies the step size according to the power level of the far-end signal. Thus the convergence speed is independent o f the input signal power. The average echo signal attenuation o f NLMS

35

algorithm is -- 27.99 dB and is much better than the LMS average echo signal attenuation -- 18.16 dB. Due to the presence of feedback in the NLMS algorithm, there exists a possibility o f it becoming unstable. The stability o f the algorithm depends on the step seize parameter /5. For the NLMS algorithm, the step size |S should satisfy: 0</3<2 and the fastest convergence occurs when (3=1. Since NLMS algorithm is easier to be implemented and the computation is not very intensive, as well as good echo cancellation performance, it is widely used in real time adaptive echo cancellation. Figure 4.8 shows the Fast LMS error estimation signal is larger, the average echo signal attenuation is o n ly -- 5.3 dB, but its converge speed is faster and computation complexity is lighter. The RLS algorithm is more effective than all other algorithms. Figure 4.11 shows its error estimation signal is also very small and its mean square error quickly approach to zero and its average echo signal attenuation is -33 dB, but each iteration o f the RLS algorithm requires 4N^2 multiplication operations, it is more intensive computation so that in practice it is not popular to be implemented. From Figure 4.11 and Figure 4.2, we can see that RLS algorithm has a much better convergence rate that the LMS algorithm, but it comes out with more computational complexity. In addition, echo cancellation generally requires large FIR order and thus the RLS algorithm is not suitable for real time implementation.

Figure 4.15 shows the simulation results o f the NLMS FIR filter combined with The Geigel DTD algorithm. When the near-end speaker is silent, the FIR has a good performance to cancel the echo signal and keep the error signal in very low level. When both the near-end and the far-end are active - the Double Talk is occurring, the error signal not only contains the echo estimation error, but also the near-end signal.

36

At this time, the Geigel DTD algorithm will detect the DT period and not update the filter coefficients to prevent the echo canceller from being disturbed by the near end speaker's signal. From the miss alarm rate and false alarm rate, the Gegel algorithm is not very accurate to detect double talk. For cross-correlation double talk detection algorithm, at the beginning, the decision

variable is simplified as d (/) =

where

<Tz(0 - CTz(t - 1) +

(ï) -

(t - L)

(Tz (t) = <T z (f -1 ) + z(t) y(t) - z(t - L) y{t - L) W hen double talk is presented, Figure 5.1 shows the filter output error signal is not correct and Figure 5.2 displays the double talk detection is not accurate. Through introducing the smoothed estimate and adjusting the smooth factor that described in 3.2, the better results can be achieved.
e rro r s i ^ oe l

Figure 4.17 Error signal

37

 t»iK^otpctioni

iU p P ïf.

Figure 4.18 Double talk detection Figure 4.16 shows the simulation results of the NLMS FIR filter combined with the selected normalized cross-correlation DTD algorithm described in 3.2. In no Double Talk period, the filter echo cancellation keep the same as the Geigel DTD algorithm. Figure 4.16 shows the normalized cross-correlation DTD has a better decision in distinguishing DT period. Though it causes more intensive computation, the miss alarm rate is 10% and the false alarm rate 2.5% is much better than Geigel algorithm.

38

Chapter 5 Adaptive Echo Canceller with DTD Structure
5.1 Adaptive Echo Canceller with DTD Based on above adaptive algorithm analysis and DTD studies, the NLMS algorithm and normalized cross-correlation DTD algorithm are finally selected in designing the AEC as shown in Figure 6.1.

F ar E nd

A d aptive Filter

Echo Path

DTD

NLP

A daptive E c h o C a n ce lle r w ith DTD

Figure 5.1 Adaptive echo canceller with DTD The adaptive filter is based on the normalized least mean square (NLMS) algorithm and in the NLMS coefficient update equation (2.2.2), w{m) = w(jn - 1 ) -(-// e{m)

the variable jj is the step size, which is usually between (0, 2) to maintain the system stable.

39

The length o f the adaptive filter depends on the reverberation time constant o f the room. The system is working with sample rate of 8KHZ and the predicted echo path is about 128msec. Thus adaptive filter length will be set as: Filter length = echo path * sample rate /1000 = 1024. W ith the equations (3.2.7), (3.2.8) and (3.2.9) of the normalized cross-correlation DTD algorithm, the smoothing factor a is set to be 0.9 in the equations (3.2.8) and (3.2.9) from experiments. Thus the received decision variable value only after the adaptive filter converge, as well as is a good estimate o f the theory , cr, become good statistical

estimates. Hence the adaptive filter has to converge first to make this DTD algorithm effective. However, it won't cause much problem; because the adaptive algorithm takes relative short time to converge and remain converge most o f the time. Initially, the DTD has to be switched off until the adaptive filter first time converges. To detect the convergence o f the adaptive filter, we still use the same decision variable d. We know that the decision variable d is about 1 only when the adaptive has converged and there is no double-talk. Hence, the convergence is claimed when the decision variable d approaches 1 and remaining approaching 1 for a certain time. The range o f approaching 1 is set to be (0.9, 1.05) and the certain time is set to be 0.125 second in practice. In this project, the AEC takes about 25472 samples to converge and the convergence time is calculated as: Initial Convergence Time= 25472/8000=3.2 sec. Once the convergence is claimed, we switch on the DTD. After that DTD monitors the decision variable d and it claims double-talk occurs when the decision variable d is out o f the range (0.75,1.35). Once double talk is declared, the detection is held for a minimum

40

period o f time. W hile the detection is held, the filter adaptation and non-linear processor is frozen. After the hold time, the DTD resumes monitoring again. The hold time is necessary due to the noisy behavior of the detection statistic and is set to 38 ms in implementation.

5.2 Non-linear processor

Since the residual echo is inevitable for the non-linearity o f the echo path, the non-linear processor (NLP) is used to degrade the residual echo to an inaudible level. Only during single talk, NLP is active and it is controlled by the DTD. The NLP in this project is set as a controlled attenuator, which attenuates the echo during single-talk by 20dB.

41

5.3 Software Workflow

s ta r t

load Far e n d & M ea su red

S ig n al

Initialize NLM S & DTD variab les

N e w S a m p le

A daptation of filter c o e ffic ie n ts

No co n v erg ed ? N ew S a m p le D oute Tattr

Yes

Inhibit adaptation

No

A d aptation o f filter c o e ffic ie n ts

No

E n d Of S a m p le Y es

End

Figure 5.2 Adaptive echo canceller with DTD software workflow

42

Chapter 6 ITU G.168 Test Cases
The International Telecommunications Union (ITU), as well as the European Telecommunication Standard Institute (ETSI) regulated the specifications o f telephone systems. The ITU-T recommendations: G.167 specifies the performance requirements o f acoustic echo control devices. G. 165 specifies the requirements o f network echo canceller. G.168 is an enhanced version and specifies the new requirements o f digital network echo canceller.

6.1 Test 1: Steady state residual and residual echo level test

The G.168 Requirements for Test 1: In the Table 6.1 below, "L(Rin) Input", are the various input levels. "L(Res), NLP Dis, Output Req." are the requirements per G.168 (2000). "Sample" column is for the users to record their test results.

L(Rin) Input -10 dBmO

L(Res), NLP Dis Output Req. -37 dBmO

Result -46.15 dBmO

L(Res), NLP enab Output Req. -65 dBmO

(NLP Enabled) -66.15 dBmO

Table 6.1 Test 1 results

error signal Figure 6.1 Test I 43

6.2 Test 2A and 2B: Convergence test with NLP enabled and disabled 6.2.1 Test 2A: Convergence test with NLP enabled The G.168 Requirements for Test 2A: the echo path delay is considered as time "zero". For 50 ms beyond the echo path delay, the EC is required to do no better than the minimum ERL o f 6 dB. Between 50 ms and 1 sec, the performance o f the EC must increase from the minimum of 6 dB to up to 20 dB. Beyond 1 sec, the EC performance is dependent on the input signal level and should be 55 dBmO or greater for input signal levels o f 0 dBmO and -1 0 dBmO. Time (ms) 0 5 0m s-Is ls+ L (Rin)-L (Ret) (NLP Enabled) 6dB 6 dB~20 dB @-10dBm0 55dB Table 6.2 Test 2A results 6.2.1 Test 2B: Convergence test with NLP disabled The G.168 Requirements for Test 2B: the echo path delay is considered time "zero". From 0 to 50 ms, the EC is not required to perform, therefore the 6 dB minimum requirement (equal to the minimum ERL). Between 50 ms to 1 sec, the EC is required to increase its performance to 20 dB of loss and maintain at least this requirement for up to 10 sec. Beyond 10 sec, the requirement is dependent on signal level. Time "L: 0 50m s-Is Is-lOs 10s+ L (Rin)-L (Ret) (NLP Disabled) 6dB 6 dB~20 dB 20 dB (%-lOdBmO 27dB Table 6.3 Test 2B results 44 8.8 dB 9 dB -2 0 dB 40 dB 42dB Result (NLP Enabled) 48 dB 50 dB 57 dB

6.3 Test 2C: Convergence test in the presence of background noise The G.168 Requirements for Test 2C Convergence Test with NLP Enabled (part (a)). The columns are interpreted as follows. "L(Rin) Input" is the input signal level. There are three separate files provided for levels -0 dBmO, -10 dBmO, and -2 0 dBmO. The "Noise Level L(Rin) -- 15" is the noise level mixed in along with the echo. Note that the maximum level o f the noise is -30 dBmO. "L(Ret) Requirement" is the appropriate requirement from G.168 (2000) specification. L(Rin) Input -10 dBmO Noise Level L(Rin)-15 -30 dBmO L(Ret) Requirement -30 dBmO Result > (N L P # # # -46 dBmO

Table 6.4 Test 2C(a) results

error signal Figure 6.2 Test 2C(a)

The G.168 Requirements for Test 2C Steady State Test with NLP Enabled (part (b)). The columns are interpreted as follows. "L(Rin) Input" is the input signal level. The "Noise Level -55 dBmO" is the noise level mixed in along with the echo. "L(Ret) Requirement" is the appropriate requirement from G.168 (2000) specification.

Noise Level Dffiput -10 dBmO -55 dBmO

L(Ret) Requirement -38 dBmO

(N L P rn # m r T -46 dBmO

Table 6.5 Test 2C(b) results

45

r

.

 ' 

"* ®

5 l'»w

error signal Figure 6.3 Test 2C(b)

The G.168 Requirements for Test 2C with NLP disabled (part (c)). The columns are interpreted as follows. The input requirements with NLP disabled are similar to those for NLP enabled. The corresponding requirements are given in the column "L(Ret) Requirement".

L,(Rin) in p u t -10 dBmO

Noise Level L(Rin)-15 -30 dBmO

L(Ret) Requirement -30 dBmO

Sample (NLP Disabled) -37 dBmO

Table 6.6 Test 2C(c) results

error signal Figure 6.4 Test 2C(c)

46

6.4 Test 3: Performance under conditions of double talk

6.4.1 Test 3A: Double talk test with low near end levels The G.168 Requirements for Test 3A: the requirement as given in the Table 6.7 below is such that the residual echo level should be equal to lower than the doubletalk level. The convergence occurs during the periods when the echo and doubletalk signals do not overlap.

L(Rin) Input -10 dBmO

Low Near-End L(Rin)-15 -25 dBmO

Level L(Res) Requirement -25 dBmO

Result (NLP Disabled) -34 dBmO

Table 6.7 Test 3A results

0

. 6

far end signal X 1o'*

O

- 0.8

1O fare end echoed signal

47

near end signal
2SOO 2000

1so o 1ooo
& 0 0

o -so o ooo
--I s o o

iW

-2000 -2 5 0 0

error signal Figure 6.5 Test 3A 6.4.2 Test 3B: Double talk test with high near end levels

The G.168 Requirements for Test 3B: notice that the doubletalk level should be at least as great as the input level. The residual echo requirement is relaxed by 10 dB from the steady state requirements.

L^n) Input -10 dBmO

Doubletalk N>JL(Rin) -10 dBmO

Level L(Ret) Requirement -27 dBmO

(N L P ^ I^ b a i# ^ K -35 dBmO

Table 6.8 Test 3B results

48

o .e >

far end signal

0 --

o .e

o

ia

far end echoed signal

near end signal

m
error signal Figure 6.6 Test 3B

i'-lk % O .

49

6.5 Test 3C: Double talk test under simulated conversation

The G.168 Requirements for Test 3C: in the Table 6.9 below, note that the table continues, i.e. there are actually eight (8) columns. The doubletalk signal is applied sim ultaneously with the input signal. The resultant signal is divided into 5 periods (refer to G.168 (2000) spec) and denoted as ti, ti, t3, t4, and ts. The requirements for these different periods are given in the table below.

L(Rin) Input -10 dBmO

Doubletalk Level N Performance -10 dBmO

t2(Req.) no peaks>N

Result meets req.

t3(Req.) Performance -65 dBmO

Result -52 dBmO

t4(Req.) no peaks>N+6 dBmO

Result meets req.

Table 6.9 Test 3C results

0 . 2;

o

1

o

ie X1o'*

far end signal

O

far end echoed signal

50

":

near end signal

error signal Figure 6.7 Test 3C

6.6 T est 4: L eak rate test The G.168 Requirements for Test 4: the requirements for the residual echo level are relaxed by 10 dB from the requirements for steady state in Test 1 and 2.

L(Rin) Input -10 dBmO

L(Ret) Requirement (NLP Disabled) -27 dBmO Table 6.10 Test 4 results

-25 dBmO

far end signal

51

error signal Figure 6.8 Test 4

6.7 Test 5: Infinite return loss convergence test

The G.168 Requirements for Test 5: the requirements are such that any spurious response vanishes to less than 20 dB below the input level by 1 sec after the echo path is cut o ff and to less than 27 or 25 dB below the input level by 10 sec after the echo path is cut off.

X (R ln) Input -10 dBmO

L(Rin) - L(Res) Requirement (NLP Disabled) >20 dB after 1 sec >27 dB after 10 sec Table 6.11 Test 5 results

Sample

"

meet req.

far end signal

52

received signal Figure 6.9 Test 5

6.8 Test 6: Non-divergence on narrow-band signals The G.168 Requirements for Test 6: the requirements for this test for the residual echo are relaxed by 10 dB versus the steady state residual echo requirements for Tests 1 and 2.

-10 dBmO

L(Ret) Final Requirement -27 dBmO

(NLP D isabI^^^^^V :` ' f^ S -32 dBmO

Table 6.12 Test 6 results

far end signal

53

^

'

3

0

0

0

W nm

2000

 O'

-2000

-.3 0 0 0 -- ^ O
O O

error signal Figure 6.10 Test 6 6.9 Test 7: Stability test The G.168 Requirements for Test 7; note that the requirements for this test are actually m ore stringent than that for steady state. L(Rin) Input -10 dBmO (1 kHz) L(Res), NLP dis Output Requirement -38 dBmO Table 6.13 Test 7 results Result (NLP I -48 dBmO

n

a i n

far end signal

error signal Figure 6.11 Test 7

54

6.10 Test 8: Non-convergence, in-band signaling, and continuity check tones The G.168 Requirements for Test 8: in this test, the signal applied at near end signal must remain uncancelled, while the echo o f far end signal should be cancelled. The variation at filter output as compared to input should be within ± 2 dB.

Far end/near end Input 2400/2400

Variation Requirement ±2 dB Table 6.14 Test 8 results

Result ?C (NLP Enabled) meet req.

-

^

far end signal

K received signal

55

0.2S-

0.2

0:1 à
o 1
0-0s

-o o s
- O .- f

-0.1 s 0 2 - 0 .2 5

error signal Figure 6.12 Test 8

6.11 Summary Test 1: Steady state residual and residual echo level test L(Rin) Input -10 dBmO L(Res), NLP Dis Output Req. -37 dBmO Result -46.15 dBmO L(Res), NLP enab Output Req. -65 dBmO

(NLP Enabled) -66.15 dBmO

Test 2A and 2B: Convergence test with NLP enabled and disabled Test 2 A Time (ms) 0 50m s-Is ls+ L (Rin)-L (Ret) (NLP Enabled) 6dB 6 dB -20dB (%-lOdBmO 55dB Result (NLP Enabled) 48 dB 50 dB 57 dB

Test 2B L (Rin)-L (Ret) (NLP Disabled) 6dB 6 dB~20 dB 20 dB @-10dBm0 27dB Result 8.8 dB 9 dB -2 0 dB 40 dB 42dB

#1

: 0 50m s-Is Is-lOs 10s+

"

'

56

Test 2C; Convergence test in the presence o f background noise Test 2C(a) L(Rin) Input -10 dBmO Test 2C(b) L(Rin) Input -10 dBmO Noise Level -55 dBmO L(Ret) Requirement -38 dBmO Result (NLP Enabled) -46 dBmO Noise Level L(Rin)-15 -30 dBmO L(Ret) Requirement -30 dBmO Result , \ , 5, (NLP Enabled) -46 dBmO

Test 2C(c) L(Rin) Input -10 dBmO Noise Level L(Rin)-15 -30 dBmO L(Ret) Requirement -30 dBmO Sample (NLP Disabled) -37 dBmO

Test 3: Performance under conditions of double talk Test 3 A L(Rin) Input -10 dBmO Test 3B L(Rin) Input -10 dBmO Test 3C L(Rin) Inbut -10 dBmO Doubletalk Level N Performance -10 dBmO t2(Req.) no peaks>N Result meets req. Doubletalk N>L(Rin) -10 dBmO Level L(Ret) Requirement -27 dBmO Result (NLP Disabled) -35 dBmO Low Near-End L(Rin)-15 -25 dBmO Level L(Res) Requirement -25 dBmO Result (NLP Disabled) -34 dBmO

t3(Req.) Performance -65 dBmO

Result -52 dBmO

t4(Req.) no peaks>N-»-6 dBmO

Result meets req.

57

Test 4: Leak rate test L(Rin) Input -10 dBmO L(Ret) Requirement (NLP Disabled) -27 dBmO

-25 dBmO

Test 5: Infinite return loss convergence test L(Rin) Input -10 dBmO L(Rin) - L(Res) Requirement (NLP Disabled) >20 dB after 1 sec >27 dB after 10 sec Sample

meet req.

Test 6: Non-divergence on narrow-band signals L (m n ) -10 dBmO Test 7: Stability test L(Rin) Input -10 dBmO (1 kHz) L(Res), NLP dis Output Requirement -38 dBmO Result (NLP Disabled) -48 dBmO L(Ret) Final Requirement -27 dBmO Result (NLP Disabled) -32 dBmO

Test 8: Non-convergence, in-band signaling, and continuity check tones Far end/near end Input 2400/2400 Variation Requirement ± 2dB Result (NLP Enabled) meet req.

Table 6.15 Test result summary

58

Chapter 7 Real time simulation
7.1 TI TMS320C6711 DSK The TI TMS320 floating-point family includes C3x, C4x, and C67x. Each generation o f the TM S320 series has a unique central processing unit (CPU) with a variety o f memory and peripheral configurations. In this project, the TM S320C6711 DSK is chosen to the real-time AEG simulations. The TI TM S320C6711 DSK is a digital signal processing development kit used to prototype DSP applications targeted for the C6711 family o f processors. It has a 3.5-mm audio IN jack and 3.5-mm audio OUT jack, with ADC and DAC executed onboard. The AD535 codec works at a fixed sample rate o f 8kHz. The DSK also includes 16MB o f synchronous dynamic RAM and 128 KB flash ROM and the 150-MHz C6711DSP is capable o f executing 900 million floating-point operations per second (MFLOPS). The DSK board is connected to a PC via a parallel port. The program files can be created in TI code composer studio on the PC, and then loaded onto the DSK [16].

7.2 C6711 DSK Simulation using Code Composer Studio 7.2.1 Simulation Procedure Introduction CCS IDE firom TI is easy to use development environment allows DSP designers o f all experience levels to move quickly through each phase o f the application development process including design, code and build, debug, analyze and optimize. The fully integrated development environment includes, real-time analysis capabilities, easy to use

59

debugger, C/C++ Compiler, Assembler, linker, editor, visual project manager, simulators, XDS560 and XDS510 emulation drivers and DSP/BIOS support.

MIC

TI TMS320C6711 DSK
Speaker

PC and n Code Composer Studio

Figure 7.1 Adaptive echo cancellation implementation block diagram The real-tim e acoustic echo cancellation system has been implemented as shown in figure 8.1. A microphone is used to input a voice signal from the user, this is then fed into the Texas Instrument TM S320C6711 development board. Based on human voice frequency range and adaptive echo cancellation system performance consideration, the sampling rate 8 KHz is used in the AD535 codec. The echo cancellation system use the normalized LMS algorithm and the normalized cross-correlation DTD algorithm detailed in previous sections. At each new sample time the input is sampled and input to memory and these memory audio data can be output to a file. In this project, there are two audio data files that contain these samples are loaded into memory as far end signal and received signal, and the CCS development workbench window is show in the Figure 8.2. The step size value for this iteration o f the NLMS algorithm is then calculated by inverting the dot product o f the input vector and a small constant should be included in the denominator to avoid zero divides. The output of the adaptive filter is then calculated by the dot product o f the input vector and the current filter tap weight vector. This output is then subtracted firom the desired signal to determine the estimation error value, e(n). This error value, the step size value and the current FIR tap weight vector are then input to the NLMS
a lg o r ith m

to calculate the filters tap weight to be used in the next iteration. If the filter is

60

claimed to converge, the DTD detector will start monitor if there is a double talk situation. W hen double talk happens, the DTD detector inhibits the filter adaptation for a hold time to avoid divergence of the adaptive algorithm. Finally the AEC output error signal data is streamed out to a specified file using File I/O function provided by CCS to do further analysis [13][16][17].
' C o d eC o m p o se r

FBe

Edit

Ve.v

Project

Debug

Profiler

GEL

O pton

Tools

P6C

DSP,·'BIOS

Window

Help

aG â :B
jc ls lu d i e s .p jt " ^ jP e b u g

, Ma #aa
n im s d t d re s u lC c #include #in clud © ^ includ e #include
/ /

at?

^
nu

Af

Û ^ S 3 [|][3 S ii

t^î : â Files CJ GEL files I - Q Projects ^ d s tu d ie & p jt -11: ID C6xdsk.cmd Cl DSP/BIOS C or L J Generated RIe;  - CJ Include  [il c6x.h H c6xdsk.h JO cSxdskinit.l J ] cSxinterrup j g fücer.h - Cl Libraries ii] rTs6701.lb - Cl Source i ll c6xdskln)t.(

< m a t h .h > < stdio.h> (std lib .h ) "filte r.h ' LOOP.LENGTH 2000 F I LTER_LEN(?rH 100 S T E P_SI2E 5 e - 5 SCALE SOOO.O GAIN 15

I ___

D o f 1 n& s

#define #define #define #defxne #define Float Float Float flo a t

c i 'i r e

in p u t, echoed, a f_ o u tp u t, erro r_ $ ig n a l input_signal[LO O P_LEN G TH ]; e c h o e d _ s i g a a l [L00P_LEINGTH1 ; error_signol_array[L O O P _L E N G T H ]; iitd_a rray[L OO P_L ENG TH] ;

f l o a t input_vector[FIL TER _L EN (nH ] : f l o a t input_vector_c{FIL TER_L EN G TH ]; f l o a t f il te r [ F I L T E R _ L E N G T H ] f l o a t f il t e r _ h o l d ( F I L T E R _ L E N G T H ] f l o a t rx y[F IL TE R_L EN GTH ]; f l o a t s t e p _ s i z 0 - CT EP_ SI 2E; flo a t n step _ size; s h o rt o u tp u t; OOODIEIC 00001E20 0 0 0 01 E 2 4 00001E26 00001E28 00001E2C 00001E30 000G1E34 Ü0001E3B 02260940 05 3C 92E 6 00006000 00000000 00000190 00006000 00000000 00000000 || abort:

D e c l a r e v e r i ' ^ k l e s f o r do u Ll f l o a t tm p, sd -O .D . a k 2 - 0 . 0 , dv-Q.O; < >

'sidJ
INmAUZING CPU For Help, press Fi Ln I , c o l l

Figure 7.2 CCS Workbech window
7.2.2 C6711 DSK Simulation Results

Using the CCS graphing function provided by CSS integration development environment, the far end signal, received signal and the error signal o f the echo cancellation system can be viewed and shown in the following figures. As can be seen that the real time adaptive echo cancellation system is successfully developed with the NLMS and the normalized cross-correlation DTD algorithm.

61

(1) Steady state residual and residual echo level test

0 .8 5 2 -

- 0 .8 5 2 -

222

1 3 3 3

1 5S 6

1 7 7 8

1 9 9 9

(999, -0.246875)

Lin Auto Scale

far end signal

0 .8 3 6 -

- 0 .8 3 6 -

0

222

444

67

689

1111

1333

1556

1778

1999

(1 3 1 9 ,0 .0 1 4 8 1 2 5 )

Time

Lin Auto Scale

received signal

G

G raphical Display

0.0121

0 .0 0 7 2 4

0.00241
- 0 .0 0 2 4 1 -

- 0 .0 0 7 2 4 ;

- 0 .0121:
0 2 2 2 4 4 4 6 6 7 8 8 9 1111 1 3 3 3 1 5 5 6 1 7 7 8 1 9 9 9

(999, -0.00401494)_____________________ Time______________ Lin Auto Scale_____________

error signal Figure 7.3 Steady state residual and residual echo level test

iB&iPut -10 dBmO

O u tp u t Req. -37 dBmO

Result | -44 dBmO

-46 dBmO

Table 7.1 Steady state residual and residual echo level test result

62

(2) Convergence test in the presence o f background noise

aaaa
0 .8 4 8 -

0 .8 4 8 -

200

1 4 0 0

1 6 0 0

1 8 0 0

1 9 9 9

(999, -0.210475)

Lin Auto Scale

far end signal

1 .6 9

1 . 02 0 .3 3 9

- 0 .3 3 9

-

1.02 _L
0 200
400 6 0 0 BOO

- 1 .6 9 .

10 0 0

1200

1 4 0 0

1 6 0 0

1 8 0 0

1 9 9 9

(999, -Û.372184)

Time

Lin Auto Scale

received signal
Graphical Display
0 .0 1 1 9 0 .0 0 5 9 7

0 .0 0 5 9 7

0 .0 1 1 9 0 2 0 0 4 0 0 6 0 0 BOO 1 0 0 0 1 2 0 0 1 4 0 0 1 6 0 0 1 8 0 0 1 9 9 9

(999, -0.00 3 4 7 2 8 3 )_______________________________Time______________ Lin Auto Scale

error signal Figure 7.4 Convergence test in the presence of background noise

lit p u t -10 dBmO

Noise -30 dBmO

Output Req. -30 dBmO

Matlab Result -46 dBmO

Resiilt 7 -44 dBmO

Table 7.2 Convergence test in the presence o f background noise test results

63

(3) Double talk test with low near end levels
S5 Graphical Display
1 .7 0 0 .8 5 2 -

I- iiniiXj

0 - 0 .8 5 2 - 1 .7 0 j 0 3 3 3 6 6 7

Iff
1 0 0 0 1 3 3 3 1 6 6 7 1 9 9 9

(999, -0.246875)

Time

Lin Auto Scale

far end signal

E

Graphical Display

0 .9 1 5

0 .4 5 &

- 0 .4 5 8 -

- 0 .9 1 3 3 3 6 6 7 1 0 0 0 1 3 3 3 1 6 6 7 1 9 9 9

(999, 0)

Time

Lin Auto Scale

I

near signal

0 .8 3 6 -

0 .8 3 6 -

(999, -0.432443)

jTime

Lin Auto Scale

received signal

64

Graphical Display
1.00

0.500-

-0.500-

- 1 .00 .
333 667 1000 1333 1667 1999

(999, 0)

Time

Lin Auto Scale

double talk detection

G

Graphical Display

0.513 0.256:

m am

-0,256: -0.513: 0

333

667

1000

1333

1667

1999

(9 9 9 ,-0 .0 0 4 0 1 4 9 4 ) iTlme

Lin Auto Scale

error signal Figure 7.5 Double talk test with low near end levels

Input -10 dBmO

Near end -25 dBmO

Output Req. -25 dBmO

Matlab Result -34dBmO

-33dBmO

Table 7.3 Double talk test with low near end levels test results

(4) Double talk test with high near end levels

e

Graphical Display

0.568- 0 .5 6 8 -

-1.70:

(999, -0.246875)

Lin Auto Scale

far end signal

65

G rap hical Display
1 .6 3 0 .8 1

a .

0 - 0 .8 1 5 -

- 1 .6 3 .

°

6 6 7

1 0 0 0

1 3 3 3

1 6 6 7

1 9 9 9

Ç 9 9 9 , 0 ) ______________ T im e

un

A u to S c a le ;

near end signal

l--
9 .5 5 7 0 .5 5 - 7

M

0

333

667

1000

1333

1667

1999

(999, -0.432443)

Time

Lin Auto Scale

received signal
G rap hical Display
1. 0 0
0 .5 0 0 -

a m

0
- 0 .5 0 0

-1 0 0 .
3 3 3 6 6 7 1 0 0 0 1 3 3 3 1 6 6 7 1 9 9 9

(9 9 9 , 0)

T im e

Lin

A u to S c a le i

double talk detecion

1.63 0.542 -0.542 -1.63 333 667 1000

is a æ

1333

1667

1999

(999, -0.00401494) Time

Lin Auto Scale

error signal Figure 7.6 Double talk test with high near end levels In p u t -10 dBmO Near end -10 dBmO Output Req. -27 dBmO Matlab Result -35 dBmO

30 dBmO

mÊÊBÊÊi

1

Table 7.4 Double talk test with high near end levels test results

66

(5) Non-divergence on narrow-band signals

OBixi
0562-

-0.523

1250

1500

1750

1999

(999, 0)

Lin Auto Scale

far end signal

0 ,5 2 9

0 .2 6 5

0 .5 2 9

250

500

750

1000

1250

1500

1750

1999

(999, 0)

Time

Lin Auto Scale

received signal
Graphical Display
0.00427 0.00213-

0.0021 > 00427 1000 1250 1500 1750 1999

(999, 0)

Lin Auto Scale

error signal Figure 7.7 Non-divergence on narrow-band signals

Input -10 dBmO

Output Req. -27 dBmO

Matlab Result -32 dBmO

R®SU -34 dBmO

Ï

Table 7.5 Non-divergence on narrow-band signals test result

67

(6) Stability test
Wc#,,®splay
0.578

- O lX i

- 0 .5 7 8

0

333

667

1000

1333

1667

1999

(9 9 9 ,0 .5 5 4 6 8 8 )

Time

Lin Auto Scale

far end signal

0.347

-

0.347 1000 1333 1667 1999

- 0 .5 7 8 3 3 3 6 6 7

(9 9 9 ,0 .4 0 2 2 1 4 )

Time

Lin Auto Scale

received signal
Graphical Display
0 ,0 0 3 9 1

B

B E IB

0 .0 0 1 3

- 0 ,0 0 1 3 0 -

-0 .0 0 3 9 1 J 0 3 3 3 6 6 7 1 0 0 0 1 3 3 3 1 6 6 7

1999

(999, -4.068613e-4)

Time

Lin Auto Scale

error signal Figure 7.8 Stability test

Input -20 dBmO

Output Req. -47 dBmO

M aUab R a O m -48 dBmO @- \ Q dBmO input

,

"

-58 dBmO

Table 7.6 Stability test results

68

(7) Non-convergence, in-band signaling, and continuity check tones

- 0 .2 5 0

0 .5 0 0 .

1000

1333

1667

(999, 0)

Lin Auto Scale

far end signal

0 .0 5 0 0

0 .0 2 5 0 -

0
- 0 .0 2 5 0 0

- 0 .0 5 0 0 . 0 3 3 3 6 6 7 1 0 0 0 1 3 3 3 1 6 6 7 1 9 9 9

(9 9 9 ,^ .0 4 9 2 1 8 8 ]

Time

Lin Auto Scale

near end signal
Graphical Display
0 .6 7 9 -

m

ia

0 .2 2 6

- 0 .2 2 6 -

- 0 .6 7 9 -

- 1 .1 3 1 0 0 0 1 3 3 3 1 6 6 7 1 9 9 9

(999, -0.0492188)

|Tlme

Lin lAuto Scale

received signal

69

,, -, 0 .0 5 0 0

% »-- --J

0 .0 3 0 0 -

0 . 0100 - 0 . 0100 0 .0 3 0 0 -

- 0 .0 5 0 0 j 0 3 3 3 6 6 7 1 0 0 0 1 3 3 3 1 6 6 7 1 9 9 9

(999, -0.0492188)

ifime

Lin Auto Scale

error signal Figure 7.9 Non-convergence, in-band signaling, and continuity check tones Far end/near end Input 2400/2400 Hz Variation Requirement ±2dB Result (NLP E n a b le# ^ ^ meet req.

Table 7.7 Non-convergence, in-band signaling, and continuity check tones test results

7.3 Real time simulation summary Test 1: Steady state residual and residual echo level test Input -10 dBmO Output Req. -37 dBmO Result -44 dBmO Matlab Result -46 dBmO

Test 2C: Convergence test in the presence o f background noise Input j -10 dBmO Noise -30 dBmO Output Req. -30 dBmO Matlab Result -46 dBmO Result -44 dBmO

Test 3: Performance under conditions of double talk Test 3 A Input -10 dBmO Near end -25 dBmO Output Req. -25 dBmO Matlab Result -34dBmO Result -33dBmO

Test 3B Input -10 dBmO Near end -10 dBmO Output Req. -27 dBmO 70 Matlab Result -35 dBmO Result -30 dBmO

Test 6: Non-divergence on narrow-band signals Input -10 dBmO Output Req. -27 dBmO Matlab Result -32 dBmO

-34 dBmO

Test 7: Stability test Input -20 dBmO Output Req. -47 dBmO Matlab Result -48 dBmO @ -10 dBmO input Result -58 dBmO

Test 8; Non-convergence, in-band signaling, and continuity check tones end/near end Input 2400/2400 Variation Requirement ±2dB Result (NLP Enabled) meet req.

Table 7.8 Real time simulation summary

71

Chapter 8 Conclusion
In this project, four adaptive algorithm LMS, NLMS, Fast Block LMS and RLS are investigated and simulated using AEC Analysis and Design program in Matlab for echo cancellation. Comparing these algorithms, NLMS is finally selected as the best algorithm for the real time echo cancellation systems. In double talk detection, the Geigel algorithm and the normalized cross-correlation DTD algorithm are separately integrated with NLMS FIR filter against double talk and are studied in NLMS & DTD Analysis and Design program in Matlab. The normalized cross-correlation DTD algorithm is selected for double talk detection, since the results are much better. Through testing with ITU G.168 standard, the performance o f the adaptive echo cancellation system conforms with the standard. In addition, the real time adaptive echo cancellation simulation by TI TMS320C6711 also proves the selected algorithms and their settings are correct.

72

Chapter 9 Further Work
There are some possibilities for further development in this project, some o f these are as follows. · The double talk detection algorithm still can be done further studies in the simplified smoothing estimation algorithm area to improve the alarm accuracy and reduce the computation complexity. · The real time echo cancellation system is successfully developed using the TI TM S320C6711 DSK. However, since this system is code in C language, if it is in assembler, the system performance will be much improved and If the TI C5000 DSP using Fixed-Point Digital Signal Processor, the same performance can be achieved with the lower cost. · Instead o f the DSK board, the adaptive echo cancellation system can use the TM S320C6711 digital signal processor in a custom designed circuit by which will also improve the whole system performance.

73

References

[1] C.F.N. Cowan, P.M. Grant, Adaptive Filters, Prentice-Hall, New Jersey, 1985. [2] Paulo S.R. Diniz, Adaptive Filtering, Algorithms and Practical implementation, Kluwer Academic Publishers, Boston, 1997. [3] D. P. Mandic, "A Generalized Normalized Gradient Descent Algorithm," IEEE Signal Processing Letters, vol. 11, pp. 115-118, February 2004. [4] D. L. Duttweiler, "A twelve-channel digital echo canceler," IEEE Trans. Com munication, vol. 26, pp. 647-653, May 1978. [5] J. Benesty, D. R. Morgan, and J. H. Cho, "A new class o f doubletalk detectors based on cross-correlation," IEEE Trans. Speech Audio Processing, vol. 8, pp. 168172, M arch 2000. [6] J. H. Cho, D. R. Morgan, and J. Benesty, "An objective technique for evaluating doubletalk detectors in acoustic echo cancelers," IEEE Trans. Speech Audio Processing, vol. 7, pp. 718-724, Nov. 1999. [7] P. Ahgren, "A new doubletalk detection algorithm with a very low computational complexity," Submitted to IEEE Trans. Speech Audio Proc., December 2003. [8] J. Benesty, D. R. Morgan, and J. H. Cho, "A new class o f doubletalk detectors based on cross-correlation," IEEE Trans. Speech Audio Processing, March 2000.

[9] H. Ye and B.-X. Wu, "A new double-talk detection algorithm based on the orthogonality theorem," IEEE Trans. Commun., vol. 39, pp. 1542-1545, Nov. 1991. [10] T. G'ansler, M. Hansson, C.-J. Invarsson, and G. Salomonsson, "A double-talk detector based on coherence," IEEE Trans. Commun., vol.44, pp. 1421-- 1427, Nov. 1996.

[11] Michael L. Honig, David G. Messerschmitt, Adaptive Filters, Structures, Algorithms and Applications, Kluwer Academic Publishers, Boston, 1984. [12]C. Antweiler and M. Dorbecker, "Perfect sequence excitation o f the NLMS algorithm and its application to acoustic echo control," Annales des Telecommunications, no. 7-- 8, pp. 386-397, July-August 1994. [13] Chassaing, Rulph, DSP applications using C and theTMS320C6x DSK, John W iley and Sons, New York, 2002.

74

[14] P. Heitkamper, "An adaptation control for acoustic echo cancellers," IEEE Signal Processing Lett., v o l., pp. 170-172, June 1997. [15] B. Farhang-Boroujeny, Adaptive Filters, Theory and Applications, John W iley & Sons, 1998. [16] Texas Instruments: Code Composer Studio/ TMS320C6711, Documentation CD accompanying theTM S320C6711 DSP Starter Kit, 2002. [17] Dave Bell, "How to Begin Development With the TMS320C6711 DSP," Texas Instruments Application Notes, Available: http;//focus.ti.com/lit/an/spra522/spra522.pdf, M arch 1999.

75

APPENDIX A: MATLAB CODE
Im sJ'unction.m

function [error_signal,desired_signal,filter_output,filter_current,nise,db] =lnis_function(input_signal,filter_size,step_size,impulse)
desired_signal = conv(input_signal, impulse); % initialise adaptive filter filter current = zeros(filter_size,l); mput_vector = zeros(filter_size, 1); iterations=length(input_signal); q = waitbar(0,'LMS Filtering...'); for i= l iterations input_vector( 1)=input_signal(i) ; filter_output(i)=dot(filter_current, input vector); error= desired_signal(i)-filter_output(i) ; filter current = filter_current + 2*step size*error*mput_vector; for j=filter_size;-1:2 input_vector(j)=input_vector(j-l); end error_signal(i)=error; cost(i)=error*error; waitbar( i/iterations, q); end close(q); ql = waitbar{0,'LMS Caculating MSB...'); for i= 1:iterations-100 mse(i)=mean(cost(i:i+100)); waitbar( i/iterations, ql); end

close(ql);
q2 = waitbar(0,'LMS Caculating attenuation in dB...'); for i=l:iterations-2500

db(i)=-20*logl0(mean(abs(desired_signal(i:i+2500)))'./mean(abs(error_8ignal(i:i+2500)))); waitbar( i/iterations, q2); end

close(q2);

76

nlm s_Junction.m function [errcr_signal,desired_signal,filter_output,filter_current,inse,db]

=nlms_function(input_signal,filter_size,mq)ulse)
iterations = length(inputsignal); desired signal = conv(input_signal, impulse); % initialise adaptive filter filtercurrent = zeros(filter_size,l); inputvector = zeros(filter_size, 1); q = waitbar(0,'Filtering...'); for i= l; iterations input_vector( 1)=input_signal(i); fIlter_output(i)=dot(filter_current, input vector); error= desiredsignal(i)-fllteroutput(i) ; step_size=1/(dot(input_vector, input_vector)+0.00001) ; filtercurrent = filtercurrent + step_size*error*input_vector; for j=filter_size:-1:2 input_vector(j )=input_vector(j -1 ) ; end error_signal( i)-error; cost(i)=error*error; ss(i)=step_size; waitbar( i/iterations, q ); end close(q); ql = waitbar(0,'Caculating MSE...'); for i=l:iterations-100 mse(i)=mean(cost(i:i+100)); waitbar( i/iterations, ql); end close(ql); q2 = waitbar(0,'Caculating attenuation in dB...'); for i= l :iterations-2500

db(i)=-20*logl0(mean(abs(desired_signal(i;i+2500)))'./mean{abs(error_signal(i:i+2500)))); waitbar( i/iterations, q2); end
close(q2);

77

flm s_function.m fiinction[en-or_signal,desired_signal, filter output,mter_coeff,mse,db]= flnis_function(input_signal,filter_si2e,step_size,estimated_power,m]pulse,lambda) % initialization FILTER COEFF = zeros(2*filter_size,l); inputlength = length(input_signal); desired_signal = conv(input_signal, impulse); block_length = floor(input_length/filter_size)*filter_size; inputsignal = input_signal(l;block_length); desired_signal = desired_signal( 1:block_length); inputsignal = input_signal(:); desired signal = desired_signal(;); errorsignal = desiredsignal; Blocks = block length/filter size; q = waitbar(0,'Fast LMS Filtering...'); % loop, FLMS for k=l;B locks-l

IN PU TSIG N A L = fft([input_signal{(k-l)*filter_size+l:(k+l)''`filter_size)],2*filter_size); filter_output = ifft(INPUT_SIGNAL.*FILTER_COEFF); filteroutput = filter_output(filter_size+l:2*filter_size,l); desired_vec = desired_signal(k*filter_size+l :(k+l)*filter_size); error_signal(k*filter_size+l ;(k+l)*filter_size,l) = desired_vec-filter_output; ER R O R V EC = fft([z e r o s(filte r _ siz e ,l);e r r o r _ sig n a l(k * filte r _ siz e + l:(k + l)* filte r _ siz e )],2 '''filte r _ siz e );
estim a ted _ p o w er = la m b d a * estim a te d _ p o w er + (l-la m b d a )* a b s(IN P U T _ S IG N A L ),^ 2 ;

DESIRED VEC = l./{l+estimated_power); phivec = ifft(DESIRED_VEC.*conj(INPUT_SIGNAL).*ERROR_VEC,2*filter_size); phivec = phivec(l:filter_size); FILTERCOEFF = FILTER_COEFF+step_size*fft([phivec;zeros(filter_size, 1)],2'*filter_size); error signal = real(error signal(:)); filte r c o eff = ifft(FILTER_COEFF); filte r c o eff = real(filter_coeff(l:length(FILTER_COEFF)/2)); filter_output=real(filter_output(;)); waitbar(k/(Blocks-l), q); end close(q);

78

cost=error_signal.*error_signal; q l = waitbar(0,'Fast LMS Caculating MSE...'); iterations=length(cost); for 1= 1iterations-100 mse(i)=mean(cost(i;i+100)); waitbar( i/iterations, ql); end close(ql); q2 = waitbar(0,'Fast LMS Caculating attenuation in dB...'); iterations=length(desired_signal); for i= l :iterations-2500 db(i)=-20*logl0(mean(abs(desired_signal(i:i-i-2500)))'./mean(abs(error_signal(i;i+2500)))); waitbar( i/iterations, q2); end close(q2);

79

risJ'unction.m fimction[error_signal,desired_sigiial,filter_output,fîIter_current,mse,db] =rls_function(input_signal,fi]ter_size,lambda,inçulse) desired signal = conv(input_signal, impulse); iterations=length(input_signal) ; % initialise adaptive filter filter__prev --zeros(filter_size, 1); input_vector = zeros(filter_size, 1); psi_inv_prev = eye(fîlter_size); intermediate= zeros(filter_size, 1); gain = zeros(filter_size, 1); q = waitbar(0,'RLS Filtering...'); for i=l: iterations input vector( 1)=input_signal(i); intermediate = psi_inv_prev*input_vector; gain = (l/(lambda+dot(input_vector, inteimediate)))*intermediate; fïlter_output(i)=dot(filter_prev, input vector); error= desired_signal{i)-filter_output(i); filter_prev = fîlter_prev + gain*error; psi_inv_prev = (l/lambda)*(psi_inv_prev - gain*((input_vector')*psi_mv_prev)); for j=fîlter_size;-l -.2 input_vector(j )=input_vector(j -1 ) ; end error_signal(i)=error; cost(i)=error*error; waitbar( i/iterations, q); end close(q); ql = waitbar(0,'RLS Caculating MSE...'); for i= 1:iterations -100 mse(i)=mean(cost(i:i+100)); waitbar( ^iterations, ql); end close(ql); q2 = waitbar(0,'RLS Caculating attenuation in dB...'); for i= l :iterations-2500 db(i)=-20*logl0(mean(abs(desired_signal(i:i+25G0)))'./mean(abs(error_signal(i:i+2500)))); waitbar( ^iterations, q2); end close(q2); db_avg=mean(db) end

80

nlm sG eigel_function.m function [e,xF,xE,v,y,s,th,db,holdRec]=nlmsGeigel_flmction(L,TG,geigLen,hold_time) farendThres = 3.5e6; hstart=0; thold=0; isHold=0; stillHold=0;

% Load data files. xF = readData{ 'Far.pcm' ); xE = readData( 'FarEcho.pcm' ); V = readData( 'Near.pcm' ) ; y = xE + v; xF=xF( 1Oe+4 :end) ; y=y(10e+4:end); % Initialize adaptive filter e = zeros( size(xF) ); % Error signal. s = zeros( size(xF) ); % Estimated echo signal. state = eps*ones(L,l); th = state; thO = state; dG = zeros( size(xF) ); % show if last sample was detected as DT. wasDT = 0 ; noDTcounter = 0; loopLen = length(xF); holdRec = zeros{ size(xF) ); q = waitbar(0,'NLMS & Giegel DTD Filtering...'); for k=l:loopLen, % Update the filter state. ifk>L, state(l:end) = flipud(xF(k-L+l:k)); end s(k) = state' * thO; % Estimated echo value. e(k) = y(k) - s(k); % Prediction error. if(k -2 0 0 0 0 )> L % Geigel DTD. dG(k) = abs( y(k) )/ max( abs(xF(k-geigLen:k) ) ); end

ifd G (k )> T G hstart=l; stillHold=l; else stillHold=0; end

81

if h sta rt= l thold=thold+l; if thold < hold time isHold =1; ifstillH old thold=0; end

else hstart=0; thold=0; isHold=0; stillHold=0; end end if isHold ~=1 % Update the step-size parameter using NLMS. norrnState = state'*state; mu = l/( normState + le3 ); end if( normState > farendThres & isHold ~=1) th = th + mu * e(k) * state; end if isHold th = thO; else thO = th; end holdRec(k)=isHold; waitbar( k/loopLen, q ); end close(q); q l = waitbar(0,'NMLS & Giegel DTE calculating REL...'); for i= l :loopLen-2500 db(i)=-20*logl0(mean(abs(y(i;i+2500)))'./mean(abs(e(i:i+2500)))); waitbar( i/(loopLen-2500), ql ); end close(ql); end

82

nlm sN C C ^function. m function [e,xF,xE,v,y,s,th,db,holdRec]=nlmsNCC_function(L,dt_low,dt high,cv L = 1024; ~ farendThres = 3.5e6; % Load data files. xF = readData( 'Far.pcm' ); xE = readData( 'FarEcho.pcm' ); V = readData( 'Near.pcm' ); y = xE+v; % Initialize adaptive filter e = zeros( size(xF) ); % Error signal. s = zeros( size(xF) ); % Estimated echo signal. state = eps*ones(L, 1); th = state; thO = state; dG = zeros( size(xF) ); % show if last sample was detected as DT. wasDT = 0 ; noDTcounter = 0; loopLen = length(xF); dtm=zeros(size(xF)); rxy=zeros(L,l); isD T -0; dv=l; converge Counter=zeros( 1000,1) ; convergeFlag=0; rxy=0; i=0; startFlag=0; isCoverge=0; wasCoverge=0; hstart=0; thold=0; isHold=0; holdRec = zeros( size(xF) ); stillHold=0;

hold,dt hold)

q = waitbar(0,'NMLS & NCC: Filtering...'); for k=l :loopLen, % Update the filter state. ifk>L, state(l:end) = flipud(xF(k-L+l:k)); end s(k) = state' * thO; e(k) = y(k) - s(k); if k>2*L & r x y = 0 for m =0:L-l, % Estimated echo value. % Prediction error.

83

rxy=rxy+flipud(xF(k-m-L+l:k-m)).*y(k); end ss=rxy'*th;

end if k > 2 * L rxy=0.9*rxy+0.1 *state(l :end).*y(k); ss=0.9*ss+0.1*y(k)*y(k); ak2=rxy'*th; akl=ss;

dv=ak2/akl; dNCR(k)=dv; if convergeFlag ~=1 if dv > dt low & dv < dt high isCoverge=l; startFlag=l; else isCoverge=0; end

if startFlag & i = 0 i=i+l; end if StartFlag & wasCoverge & isCoverge i=i+l; if i>cv_hold convergeFlag=l k for m =0:L-l, rxy=rxy+flipud(xF(k-m-L+1:k-m)). *y(k); end ss=rxy'*th; end else start=0; i=0; end wasCoverge=isCoverge; end

84

if convergeFlag if (dv <(dt_low-0.15) I dv > (dt high+0.25)) hstart=l; stillHold=I; else stillHold=0; end end end % Update the step-size parameter using NLMS.

ifh s ta r t= l thold=thold-H; if thold < dt hold isHold =1; if stillHold thold=0; end

else hstart=0; thold=0; isHold=0; stillHold=0; end end if isHold ~=1 normState = state'*state; mu = l/( normState 4- le3 ); end if( normState > farendThres & isHold ~=1) th = th + mu * e(k) * state; end

if isHold th = thO; else thO = th; end holdRec(k)=isHold;

waitbar( k/loopLen, q );

85

end close(q); ql = waitbar(0,'NLMS & NCC: calculating ERLE...'); for i= l :loopLen-2500

db(i)=-20*logl0(mean(abs(y(i:i+2500)))'./mean(abs(e(i:i+2500)))); waitbar( i/(loopLen-2500), q l ); end close(ql);

86

APPENDIX B: TI CCS CODE
nlms_ adfilt_ result, c
#include #include #include #include <math.h> <stdio.h> <stdlib.h> "filter.h"

// Defines #define LOOP_LENGTH 2000 #define FILTER LENGTH 100

// Declare variables float input, echoed, af output, error signal; float input_signal[LOOP_LENGTH]; float echoed signal[LOOP LENGTH]; float error_signal_array[LOOP_LENGTH] ; //int dtd_array[LOOP_LENGTH]; float input vector[FILTER LENGTH] ; float input vector_c[FILTER_LENGTH]; float filter[FILTER_LENGTH]; float filter_hold[FILTER_LENGTH]; float rxy [FILTERLENGTH] ; float nstep size; short output; short i, j, k,m;

//Declare variables for double talk detection float tmp, sd=0.0, ak2=0.0, dv=0.0; int hstart=0, stillHold=0,isHold=0, thold=0, isNLP=0;

// Procedure for determining dot product o f two arrays float dotp (float a[], float b[])

{
float suml, sumh; suml=0; sumh=0; for(j=0; j<FILTER_LENGTH; j+=2)

{
suml += a[j] * b[j]; sumh += a[j+l]*b[j+l];
}

return (suml+sumh);

}
//Procedure for determining dot product o f one array and one value void dotpv(float a[], float b)

87

forG=0; j<FILTER_LENGTH; j+ = l)

{

aD']=aD] *b;
}

}
void dotVectorSum(float a[], float b[])

{
forO=0; j<FILTER_LENGTH; j+ = l)

{
a[j]= a[j] +b[j];

}

void copyVector(float a[], float b[]){ for(j=0; j<FILTER_LENGTH; j+ = l)
{

a|j]=b[j];

}

void decideDTD(){ copyVector(mput_vector_c,iQput_vector); dotpv(input_vector_c,echoed); dotpv(iiiput_vector_c,0.1) ; dotpv(rxy, 0.9); dotVectorSum(rxy, input_vector_c); sd=0.9*sd+0.1 *echoed*echoed; ak2=dotp(rxy, filter); dv=ak2/sd; if(dv<0.75 I I dv>1.35){ hstart=l; stillHold=l; }else{ stillHold=0;

}
if (h s ta r t= l){

88

thold=thold+l ;
if (thold < 80) { isHold =1; if( s tillH o ld = l){ thold=0;

}
}
else{ hstart=0; thold-0; isHold=0; stillHold=0;

doFilteringO

{
for(k=0;k<LOOP_LENGTH;k++) {

input=input_signal[k]; input_vector[G] = input; echoed=echoed_signal[k] ;

/ / newest input cast to float // put sample

//calculate output o f adaptive filter af_output=dotp(filter, input vector) ; // calculate error value errorsignal = echoed-af_output; if(is N L P = l){ error_signal= error signal*0.01;
}

error_signal_array[k]=error_signal; decideDTD(); //dtd_array[k]=isHold; if(isH old!=l){ // calculate variable step size nstep_size=l/(dotp(input_vector, mput_vector)+0.0001); //update tap weights for (i=0; i<FILTER_LENGTH; i++) ^ filter[i] = filter[i] + nstep_size*error_signal*input_vector[i]; //calculate taps

89

}
for (i=FILTER_LENGTH-l; i>=l; i - )

{
input_vector[i]=mput_vector[i-l]; //shift vector

}
if(is H o ld = l){ for(m=0; m<FILTER_LENGTH;m-H-){ filter[m]=filter_hold[m];

}
}else{ for(m=0; m<FILTER_LENGTH;m++) { filter_hold[m]=filter[m] ;

}

}
}//for loop end

// This is main procedure executed on start up of program main()

{
// Initialise variables error_signal=0.0; echoed=0.0; af_output=0.0; nstep_size=0; isNLP=0; for (1=0; i<FILTER_LENGTH; i++) // initialise filter, input vector

{
input_vector[i]=0.0; rxy[i]=0.0;

}

for (i=0; KFILTER LENGTH; i++) // initialise filter, input vector

{
filter[i]=filter_current[i] ;

}
doFilteringO;

}

90


