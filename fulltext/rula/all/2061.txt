D igital Filter D esign Package (DFP) Extension
by Hongbo Sun

A Project Presented to Ryerson University in partial fulfillment of the requirements for the degree of Master of Engineering in the department of Electrical and Computer Engineering

Toronto, Ontario, Canada, 2003 Â© Hongbo Sun 2003
PPCPEi^/O? pypRSO N UNlVtRSl l Y LIBRARY

UMI N um ber: EC 53452

INFORMATION TO USERS

The quality of this reproduction is dependent upon the quality of the copy submitted. Broken or indistinct print, colored or poor quality illustrations and photographs, print bleed-through, substandard margins, and improper alignment can adversely affect reproduction. In the unlikely event that the author did not send a complete manuscript and there are missing pages, these will be noted. Also, if unauthorized copyright material had to be removed, a note will indicate the deletion.

UMI
UMI Microform EC53452 Copyright2009 by ProQ uest LLC All rights reserved. This microform edition is protected against unauthorized copying under Title 17, United S tates Code.

ProQ uest LLC 789 East Eisenhower Parkway P.O. Box 1346 Ann Arbor, Ml 48106-1346

Author's Declaration:
I hereby declare that I am the sole author of this Research Paper. I authorize Ryerson University to lend this Research Paper to other institutions or individuals for the purpose of scholarly research.

I further authorize Ryerson University to reproduce this Research Paper by photocopying or by other means, in total or in part, at the request of other institutions or individuals for the purpose of scholarly research.

1 1

Borrow List
Ryerson University requires the signatures of all persons using or photocopying this thesis. Please sign below, and give address and date.

Ill

Digital Filter Package (DFP) Extension
Abstract
In this study, we present an integrated approach to the design of digital filters using the Digital Filter Package (DFP). We added four new features to DFP: multi-band filter design, adaptive filter design, two-dimensional filter design and TMS320 code generation. We discuss each of these new features from design consideration to realization. We present design examples and demonstrate the design results generated by DFP. We also discuss GUI design in MATLAB, the DFP GUI design structure and the data transition structure from one DFP function to another. We show that DFP can allow efficient design of the following filter structures: low pass filter, high pass filter, band pass filter, band stop filter, multi band filter, differentiator, Hilbert Transformer, adaptive and 2D filters. DFP allows the use of a variety of FIR and HR design methods as well as hardware implementation structures; it provides a useful tool to quickly examine a variety of filters and understand the tradeoffs involved in varying the characteristics of the filter.

K e y w o r d s ! digital signal processing, DFP, adaptive filter design, two-dimensional digital filter design, multi-band digital filter design, TMS320 code generation

IV

Acknowledgement
I would like to thank Mehmet Zeytinoglu, my supervisor, for his patient support and advice.

Contents
1 Introduction 1 2 Digital Filter Design Principles 5 2.1 Digital Filter Specifications.........................................................................................5 2.2 Digital Filter Approximation Method.......................................................................... 9 2.3 Realization of FK. and HR Filters..............................................................................10 2.4 Implementation Consideration................................................................................... 15 2.5 DFP Digital Filter Design Capability.........................................................................16 3 Multi-Band Filter Design 18 3.1 Filter Specifications..................................................................................................18 3.2 Multi-band Target Region Design Consideration......................................................20 3.3 Multi-band Data Structure and Design Example.......................................................24 4 Adaptive Digital Filter Design 29 4.1 Least Mean Square Algorithm (LMS)...................................................................... 30 4.2 Recursive-Least-Square Algorithm (RLS)................................................................31 4.3 Using DFP Design Adaptive Filter Applications.......................................................32 5 2-Dimensional Digital Filter Design 42 5.1 Separable-Denominator 2DDF.................................................................................43 5.2 2DDF Design in DFP................................................................................................44 6 DFP GUI Design and TMS320 CodeGeneratrion 51 6.1 DFP GUI Structure and Design Program.................................................................51 6.1.1 Type and specifications window....................................................................... 52 6.1.2 Design method window.................................................................................... 56 6.1.3 Display window................................................................................................57 6.2.TMS320 Code Generation........................................................................................58

7

Conclusions and Future Research

67 69

Bibliography

VI

List o f Figures
2.1 Four Types of Ideal Filters: LPF, HPF, BPF, BSF.......................................................... 6 2.2 Target Regions of LPF, HPF, BPF, BSF.......................................................................... 8 2.3 Transversal Structure of FIR filter................................................................................... 10 2.4 FIR Filter Cascade Structure............................................................................................ 11 2.5 Direct Form I Structure of HR filter................................................................................ 12 2.6 Direct Form II Structure of HR filter............................................................................... 13 2.7 Cascade Second Order Structure of HR filter...................................................................13 2.8 The Basic section of a FIR Lattice Filter..........................................................................14 2.9 The General Form of the HR Lattice Filter.......................................................................14 2.10 DFP GUI Structure........................................................................................................ 17 3.1 Flow Chart of Target Region Design Program................................................................ 21 3.2 Target Region if First Band is a Pass-hand..................................................................... 21 3.3 Target Region if First Band is a Stop-hand..................................................................... 21 3.4 Part of Target Region Design Code................................................................................ 23 3.5 Target Region of Logarithm Case................................................................................... 26 3.6 Filter Design Result of Logarithm Case if First Band is a Pass-hand.............................. 27 3.6 Filter Design Result of Phase response............................................................................ 27 3.7 Pole/Zero Distribution of Designed Multihand Filter.......................................................28 4.1 System Identification.......................................................................................................33 4.2 LMS Learning Curve for System Identification...............................................................35 4.3 RLS Learning Curve for System Identification................................................................35 4.4 Inverse System Identification..........................................................................................36 4.5 LMS Learning Curve for Inverse System Identification..................................................38 4.6 RLS Learning Curve for Inverse System Identification...................................................38 4.7 Noise Cancellation...........................................................................................................39 4.8. De-noised Signal Using LMS Algorithm....................................................................... 40 4.9. De-noised Signal Using RLS Algorithm........................................................................ 41 4.10. Adaptive Filter Coefficient Using LMS Algorithm......................................................41 5.1 Separahle-Denominator 2DDF Design Flow-Chart..........................................................44 5.2 2DDF with two low-pass IDDF specifications................................................................46 5.3 2DDF with low-pass and high-pass IDDF specifications................................................47 5.4 2DDF with high-pass and low-pass IDDF specifications................................................48 5.5 2DDF with two high-pass IDDF specifications...............................................................49 5.6 2DDF with multi-hand IDDF specifications....................................................................50 6.1 Design Procedure ior DFP-Type and Specifications window.......................................... 53 6.2 Display Window Layout of Original.............................................................................. 58 6.3 Display Window Layout of New Display....................................................................... 58 6.4 Program Flow-Chart to Generate Test File and Subroutine Assembly Code................... 65

Vll

List o f Tables
2.1 Pass-band and Stop-band Region for LPF, HPF, BPF, and BSF.................................... 6 2.2 Pass-band and Stop-band Region for LPF, HPF, BPF, and BSF.................................... 7 3.1 Specifications for LPF and HPF...................................................................................... 18 3.2 Specifications for BPF and BSF...................................................................................... 18 3.3 Specification Vectors for Multi-band Filter......................................................................19 3.4 DFP Data Structure......................................................................................................... 24 5.1 DFP Design Type of 2DDF............................................................................................ 44 6.1 DFP Windows................................................................................................................ 51 6.2 Sample Code to Determine Window Frame and TEXT Objects.....................................52 6.3 Sample Code to Prepare Window Frame and TEXT Objects..........................................53 6.4 Sample code to create callback function for the APPLY pushbutton.............................. 53 6.5 Sample Code to Check Multi-band Input Data............................................................... 54 6.6 Sample Code for Adaptive Filter Design Method...........................................................56 6.7 Comparison of Code Generation Considerations........................................................... 59 6.8 Sample Program for TMS320C67x Code Generation.....................................................61 6.9 Filter Type and Code Type Value...................................................................................64 7.1 New DFP features..........................................................................................................66

Vlll

Chapter i
Introduction
In many applications, it is desirable that the frequency spectrum of a signal to be modified, reshaped, or manipulated according to a desired specification. The process may include attenuating a range of frequency components and rejecting or isolating one specific fi-equency component. Any system or network that exhibits such frequency-selective characteristics is called a filter. Several types of filters can be identified: low-pass filter (LPF) that passes only low fi*equencies, high-pass filter (HPF) that passes high frequencies, band-pass filter (BPF) that passes a band of fi-equencies, and band-stop filter (BSF) that rejects certain fi-equencies. Filters are used in a variety of applications, such as removing noise fi-om a signal, removing signal distortion due to the transmission channel, separating two or more distinct signals that were mixed in order to maximize communication channel utilization, demodulating signals, and converting discrete-time signal into continuous-time signals. Digital filters are used extensively in applications, such as digital image processing, pattern recognition, and spectrum analysis. [1]

In many signal- processing applications, it is advantageous to use digital filters in place of analog filters. Digital filters can meet tight specifications on magnitude and phase characteristics and eliminate voltage drift, temperature drift, and noise problems associated with analog filter components. Another important advantage of digital filters when implemented with a programmable processor is the ease of changing filter parameters to modify the filter characteristics. This feature allows the design engineer to effectively and easily update the characteristics of the designed filter due to changes in the application environment.

Quantization is a natural outgrowth of digital filtering and digital signal processing development. Also, there is a growing need for fixed-point filters that meet power, cost, and size restrictions. In applications where power limitations and size constraints drive the filter design, we use fixed-point filters. When we convert filter coefficients fi'om floating-point to fixed-point, we use quantization to perform the conversion [2]. The Digital Filter Package (DFP) [27] is a user- friendly GUI front-end filter design toolbox implemented in the MATLAB environment. In its original implementation it allows the design of LPF, HPF, BPF, BSF, Differentiator and Hilbert Transform filters. Filter design methods include FIR (Remez equiripple FIR design, windowed linear phase FIR digital filter design and least squares linear phase FIR filter design) and HR (Butterworth, Chebychev-I, Chebyshev-II and Elliptic design). DFP also extends the basic digital filter design functionality of MATLAB in two important ways: (1) The filter coefficients can be quantized. This feature is of particular importance if the filter will eventually be implemented

on a fixed point DSP. (2) DFP can also generate assembler code for the Motorola DSP56k family of fixed-point processors.

The desirable features of an adaptive filter, namely, the ability to operate satisfactorily in an unknown environment and also track time variations of input statistics, make the adaptive filter a powerful device for signal processing and control applications [3], By integrating adaptive filter design methods into DFP, the designer can use the DFP graphic user interface to design adaptive filter with Least Mean Square (LMS) algorithm and Recursive Least Square (RLS) algorithm instead of trying to design these complicated algorithms by themselves. Two- dimensional digital filters are also widely used in many fields. Therefore, extending DFP to include 2D filter design capability makes DFP stand out from other digital filter design packages by providing an easy way to design 2D filters. We also enhanced the digital filter design ability of DFP by adding multi-band filter design capability and code generation feature for the TMS320 family of digital signal processors. The design of digital filters involves the following steps: approximation, realization, study of arithmetic errors, and hardware implementation steps. Approximation is the process of generating a transfer function that satisfies a set of desired specifications, which may involve the time-domain response, frequency-domain response, or some combination of both responses of the filter. Realization consists of the conversion of the desired transfer function into a filter network. Approximation and realization assume an infinite-precision device for implementation. However, implementation is concerned with the actual hardware or software coding of the filter using a programmable processor. Since many practical devices are of finite precision, it is necessary to study the effects of arithmetic errors on the filter response.

The organization of this project report is as follows. Chapter 2 introduces digital filter design principles including specification analysis, approximation methods, realization structures, and implementation in hardware and software. Chapter 3 illustrates multi-band filter design results. In Chapter 4 we present the application of adaptive filters and adaptive filter realization algorithm (LMS and RLS) design procedures, then introduce how to design an adaptive filter using the DFP. Chapter 5 presents the separable two- dimensional digital filter design theory and design examples. We also discuss how to design multi-band twodimensional digital filters. Chapter 6 addresses DFP GUI design and TMS320 code generation. Chapter 7 summarizes the contributions of this project and discusses future directions of research.

Chapter 2
D igital Filter Design Principles
The design of a digital filter involves the following five steps: 1. Specification of the filter requirements. 2. Selection of the approximation methods. 3. Realization of the filter by a suitable structure. 4. Analysis of finite wordlength effects on the filter performance. 5. Implementation of filter in software and/or hardware.

2.1 D igital Filter Specifications
The frequency responses of the four popular types of ideal digital filters with real impulse response coefficients are shown in Figure 2.1. All frequency values in this figure are normalized frequency values, i.e., suppose A is defined as sampling frequency, then the normalized upper frequency limit f , 12 becomes 0.5. The frequencies / ., , / ^ 2 &re called the

cutoff frequencies of their respective filters. An ideal filter has a magnitude response equal to unity in the pass-band and zero in the stop-band everywhere [1]. Table 2.1 shows the passband and stop-band region for LPF, HPF, BPF and BSF.

LPF HPF BPF BSF

Pass-band Region 0^1 / N / c fc ^ f ^0.5 fcA f\^fc2 0 < | / | < / ,, a nd/ , 2 < | / 20.5

Stop-band Region /c^l / 1^0.5 0^ f \ ^ f c o< / l s / ,, and s] / jso.5 fc^^ f \ ^ f c 2

Table 2.1: Pass-band and Stop-band Region for LPF, HPF, BPF, and BSF

1

-0.5

/
- fc fc

0.5

-0.5

- fc

fc

0.5

(a) Ideal LPF

(b) Ideal HPF

I I

I I

>

/

A 4-----0.5
-fc 2 -fc \ fc \

----- !-
fc l

/

-0.5 -- fc 2

fc \

fc \

fc 2

0.5

0.5

(c) Ideal BPF

(d) Ideal BSF

Figure 2.1: Four Types of Ideal Filters: LPF, HPF, BPF, and BSF

In practice, it is impossible to realize a finite dimensional Linear Time Invariant (LTI) filter with the ideal "brick wall" characteristics of Figure 2.1 as the corresponding impulse response is not causal and is of doubly infinite length. Moreover, the impulse response is not

absolutely summable, and hence, the corresponding transfer function is not Bounded-Input, Bounded-Output (BIBO) stable.

In order to develop stable and realizable transfer functions, the ideal frequency response specifications of Figure 2.1 are relaxed by including a transition band between the pass-band and the stop-band to permit the magnitude response to decay more gradually from its maximum value in the pass-band to the zero value in the stop-band. Moreover, the magnitude response is allowed to vary by a small amount both in the pass-band and the stop-band. Typical magnitude specifications used for the design of LPF, HPF, BPF, and BSF are shown in Figure 2.2. Note the magnitude response used in this figure is logarithm.

The cutoff fi-equencies are listed in Table 2.2. a and j3 are pass-band and stop-band attenuation in dB. Max and Min are maximum and minimum target region limit in dB.

LPF HPF BPF BSF

Pass-band Cutoff Frequency fx h Lower cutoff fi-equency is/^ Upper cutoff fi-equency is f^ U`: Upper cutoff frequency is /g 2"**: Lower cutoff fi-equency is / , 2

Stop-band Cutoff Frequency fi h 1 Â® `: Upper cutoff frequency is / j 2"``: Lower cutoff frequency is /g Lower cutoff frequency is /,o Upper cutoff frequency is /,,

Table 2.2: Pass-band and Stop-band Region for LPF, HPF, BPF and BSF For multi-band digital filter specifications and target regions, we can extend the specifications and target regions of BPF and BSF. Most multi-band filter design techniques depend on the specification of these parameters: pass-band and stop-band cutoff frequencies, pass-band and stop-band attenuation factors.

(dB)
Max Max

(dB)

0.5

0.5

Min

Min

(a) LPF ^g f(g '^)(dB )

(b) HPF

Max

Max

a
0.5

a /
0
> /

0

a

 a

-B
Min

-B
Min

(c) BPF

(d) BSF

Figure 2.2: Target Regions of LPF, HPF, BPF, and BSF

2.2 D igital Filter Approxim ation M ethod
Digital filter design requires the use of both frequency domain and time domain techniques. This is because filter design specifications are often given in the frequency domain, but filters are usually implemented in the time domain. Typically, fi-equency domain analysis is done using the Z-transform and the discrete-time Fourier Transform (DTFT).

In general, a linear and time-invariant digital filter with input x(n) and output y(n) may be specified by its difference equation [4]. M M N y(^) =^ f ^ A n - i ) +^aky( n- k) 1 = 0 A = 1
(0

where b/ and a* are coefficients which parameterize the filter. This filter is said to have M zeros and N poles. Each new value of the output signal, y (n), is determined by past values of the output, and by the present and past values of the input. There are two general classes of digital filters: infinite impulse response (HR) and finite impulse response (FIR). The FIR case occurs when where =0, for all k. Such a filter is said to have no poles, only zeros. In the case the difference equation usually represents an HR filter.

There are several FIR and HR filter approximation methods. The most frequently used approximation methods for FIR filter design are the Remez exchange approximation method (using the Parks McClellan algorithm), the windowing method and the least-mean-square approximation method [2]. Approximation methods for HR filter design include the widely used transformation of analogue filters design methods such as the Butterworth approximation method, the Chebyshev approximation method, and the elliptic approximation

method. Solving the approximation problem using HR filters require smaller order than using FER filters. The penalty is non-linear phase response and potential instability.

2.3 R ealization Structure o f FIR and HR Filters
The Z-transform is the major tool used for analyzing frequency response of filters. The realization of the filter by a suitable structure corresponding to a selected finite length representation, is the next step before implementation. For hardware realization, the most commonly used structures are the direct, cascade and parallel forms. For FIR filters the most widely used structure is the direct form. Figure 2.3 (1) shows the transversal or direct form structure realization [18]. The Z-transform of FIR non-recursive filter is shown as equation (2.3) w h e r e a n d Y(z) are the Ztransforms ofx(n) snÃ»y(n) [5].
(I) Y{z)

M = % b{i)z-`X{z)
1=0

(2.3)

x(ri)
b(0) b(l) b(2) b(M-l) b(M)

y(n) Figure 2.3: Direct Form FIR Filter Structure Another FIR filter structure is cascade structure. The cascade structure converts the transfer function into a product of second-order functions, as shown in equation (2.4) [17]:
/7 (z ) --h o J ^ (l+ ]Z

+ b/^ 2 ^

)

(2.4)

*= i This leads to the cascade form shown in Figure 2.4 [18].

(') In the figures of this report we use the convention that two branches merging at a node represents that the node output is the sum of the branch signal.

10

x(n)

y(n)

0,2

Figure 2.4: FIR Filter Cascade Structure There are many different methods for implementing recursive HR filters. Equation (2.5) shows the Z-transform of the impulse response of an HR filter, where H(z), Y(z), and X(z) are the Z-transforms of h(n), y(n), snÃ x(n), respectively. M Yiz) *= i Three different structures often used to implement digital filters are the direct form (I and II), the cascade form and the lattice form. Figure 2.5 and Figure 2.6 show the system diagrams known as direct form I and direct form II implementation, respectively [18]. Direct form II structure is also called Canonical form. Note that the left half of Figure 2.5 implements the numerator (zeros) of H(z), while the right half implements the denominator (poles) o f H(z). When the order of the numerator and the order of the denominator are the same (N=M), the delay lines can be combined in a single one as shown in Figure 2.6. The two forms require the same number of arithmetic operations, but the direct form II can require as few as half the number of memory registers for storing the past values of the inputs and outputs. Although direct form I and direct form II have the same transfer (2.5)

11

function H(z), the corresponding difference equations are not the same. The difference equation of the direct form I structure is as equation (2.6), while that of direct form II is as equation (2.7).

yin) = X 4 4 Â» - 0 + X ^yyi' ^ ~ ^) 1 = 0 i=I
d{n) = ^ a ^ d ( n - k ) + x(n) ; y(n) = ^ b , d { n - i )

(2.6)

(2.7)

The implementation of a cascade-form HR filter is an extension of the results of the implementation of the direct-form HR filter. The Z-transform equation of the impulse response of an HR filter (2.5) may be written in the equivalent form (2.8) where the filter is realized as a biquads [5].
-2
-1

(2.8)

x(n)

'0

y(n)

Figure 2.5: Direct Form I Structure of HR filter Therefore, this realization is referred to as the cascade form. Figure 2.7 shows the HR filter implemented in cascade structure [18], where each sub-block corresponds to one of the terms in the product (2.8). Note that any single cascade section is identical to the second-order direct-form II HR filter.
12

d(n) x(n)

K vM

Figure 2.6: Direct Form II Structure of HR filter
Â·'01

fioN >  y(n)

x(n)

Pin

Figure 2.7: Cascade Second Order Structure of HR filter

In the direct form realization shown in Figure 2.6, the variation of one parameter will affect the locations of all the poles of H(z). In a cascade realization shown in Figure 2.7, the variation of one parameter will affect only poles in that section. Therefore the cascade realization is less sensitive to parameter variation (due to coefficient quantization, etc.) than the direct form structure. In practical implementations of digital HR filters, the cascade form is preferred.

13

Equation (2.9) displays the relations between f(n) and g(n) for the m'* stage of an FIR lattice filter, where Km, f(n) and g(n) represent the reflection coefficient, the forward and backward prediction residuals respectively.
fm ( Â« ) = / m - l W + ^ m g m - l ( Â« " b .
-1

(2.9)

Figure 2.8 shows the basic section of an FIR lattice filter.
/m(")

Km

Km 1/z  gm(Â«)

Figure 2.8: The basic section of a FIR lattice filter The general form of an HR lattice filter is shown in Figure 2.9. x(n) Km
Km-1

-Km 1/z
Cm

-Ki 1/z

y(n)

Figure 2.9: The general form of the HR lattice filter

14

The K m and Cm coefficients can be obtained fi'om a direct form filter by using MATLAB function:
[ K ,C ]

= tf21atc(B,A) where B, A are direct form coefficients . Lattice structure is

less sensitive to parameter variation and has the advantage of easily expending the filter order without fully re-design the lattice filter.

2.4 Im plem entation C onsiderations
The cascade form is most often employed in practical applications for reasons concerning quantization effects and DSP implementation. There are four types of quantization effects in digital filters - input quantization, coefficient quantization, roundoff errors, and overflow [4]. Representing instantaneous values of a continuous-time signal in digital form introduces errors that are associated with I/O quantization. Input signals are subject to A/D quantization noise while output signals are subject to D/A quantization noise. The input A/D quantization noise is the more dominant factor due to the fact that input noise circulates within HR filters and can be regenerative while output noise normally just propagates off-stage. Digital filters are designed with the assumption that the filter will be implemented on an infinite precision device. However, since all processors are of finite precision, it is necessary to approximate the ideal filter coefficients. This approximation introduces coefficient quantization error. The effect of coefficient quantization is highly dependent on the structure of the filter and the wordlength of the implementation hardware. Since the poles and zeros of a filter implemented with finite wordlength arithmetic are not necessarily the same as the poles and zeros of a filter implemented on an infinite precision device, the difference may affect the performance of the filter.

15

Truncation or rounding off the products formed within the digital filter is referred to as correlated roundoff noise. The result of correlated roundoff noise, including overflow oscillations, is that filters suffer from "limit-cycle effect". For system with adequate coefficient wordlength and dynamic range, this problem is usually negligible. Overflows are generated by additions resulting in undesirable large amplitude oscillations. Both limit cycles and overflow oscillations force the digital filter into nonlinear operations. Although limit cycles are difficult to eliminate, saturation arithmetic can be used to reduce overflow oscillations. The overflow mode of operation on the TMS320 family is accomplished with set overflow mode instruction, which sets the accumulator to the largest representable 32-bit positive or negative number according to the direction of overflow.

2.5 DFP D igital Filter D esign Capability
DFP is developed using Graphic User Interface (GUI) design technique. It integrates all steps needed to design a digital filter, i.e., defining filter specifications (different filter type corresponding to different specifications), choosing approximation methods (FIR and HR), selecting realization structures (Direct form. Cascade Second-Order Section, Lattice), DFP quantization consideration (fixed point or floating point) and generating DSP assembly code working with the Motorola 56000, TMS32010/TMS32020, TMS320C54x, TMS320C67x DSP families. The DFP GUI structure is shown in Figure 2.10. In Figure 2.8, the IMPLEMENTATION branch is for selecting realization structures (Direct form, Cascade Second-Order Section form, Lattice form), while the OUTPUT FORMAT branch is to generate assembly code for Motorola56000, TMS32010/TMS32020, TMS320C54X, TMS320C67x series of DSP processors.

16

DFP: Navigator

Type and Specifications

Design Methods

Implementation Structures

Display Windows

Low-Pass High-Pass Band-Pass Band-Stop Differentiator Hilbert Transform Multi-Band Adaptive 2-D

FIR; Remez Windows Least Square HR: Butterworth Chebyshev I Chebyshev II Adaptive: LMS RLS

1.Magnitude 2.Phase 3.Group Delay 4.1mpulse Response 5. Learning Curve 6. Pole-Zero

Figure 2.10: DFP GUI Structure

17

Chapter 3
Multi-Band Filter Design
The goal of adding multi-band filter design to DFP is to increase the band design ability to more than three. A multi-band filter has the combined functions of LPF, HPF, BPF, BSF and exhibits more than three filter bands. In multi-band filter design, we consider the following questions:

Â· Â· Â·

How to define multi-band digital filter specifications? How to design target region to meet the required specifications? How are the data information passed from one window to the other?

3.1 Filter Specifications
Table 3.1 and Table 3.2 list the specifications needed to enter DFP for designing two bands digital filters such as LPF and HPF and three bands digital filters such as BPF and BSF.

18

LPF Sampling Frequency Pass-band Frequency Edge Pass-band Attenuation (dB) Stop-band Frequency Edge Stop-band Attenuation (dB)

HPF Sampling Frequency Stop-band Frequency Edge Stop-band Attenuation (dB) Pass-band Frequency Edge Pass-band Attenuation (dB)

Table 3.1: Specifications for LPF and HPF

BPF Sampling Frequency First Stop-band Frequency Edge First Stop-band Attenuation (dB) First Pass-band Frequency Edge Pass-band Attenuation (dB) Second Pass-band Frequency Edge Second Stop-band Frequency Edge Second Stop-band Attenuation (dB)

BSF Sampling Frequency First Pass-band Frequency Edge First Pass-band Attenuation (dB) First Stop-band Frequency Edge Stop-band Attenuation (dB) Second Stop-band Frequency Edge Second Pass-band Frequency Edge Second Pass-band Attenuation (dB)

Table 3.2: Specifications for BPF and BSF

By analyzing Tables 3.1 and 3.2, we observe the need to increase the number of design parameters if we want to extend the design capability of DFP to beyond 2 filter bands. We consider a vector-input idea so that design specifications can be entered into the DFP workspace in a more efficient way. In the multi-band Type and Specification Window, we specify the frequency-edge, the weight and the attenuation vectors as the multi-band filter design parameters. In DFP we support three input modes: the normalized frequency input, the frequency input in Hz and strings. If we choose to use strings to specify the firequency parameter, this string has to be defined in the MATLAB workspace.

19

3.2 Target Region D esign
The objective of designing the target region is to make DFP possess self-test ability. Original DFP has designed the target regions for LPF, HPF, BPF and BSF, Differentiator, and Hilbert Transform filter. Using filter specification parameters, i.e., frequency edge vector

(fre_vector), weight vector (wgt_vector), and attenuation vector (dev_vector), we can determine the target region coordinate matrix and plot the corresponding target region in DFP.

There are two possibilities for the design of multi-band target region: the first band is pass-band or stop-band. Figure 3.1 shows the program flow chart to design multi-band target region. Figure 3.2 shows the coordinate diagram to design target region when the first band is pass-band. When the first band is stop-band, the target region coordinate diagram is shown in Figure 3.3. In these two figures, we use a,b,c,d to determine each rectangular target region. Ymax and Ymin represent maximum and minimum target region limit values. A^ and X; represent the pass-band and the stop-band attenuation values in Figure 3.2, and the stop-band and the pass-band attenuation values in Figure 3.3. Figure 3.4 shows part of design code in MATLAB when the first band is pass-band as shown in Figure 3.2. Table 3.3 summarizes the specification vectors corresponding to Figure 3.2 and Figure 3.3.

The First Band is Pass-band fre_vector wgt vector dev_vector \.f\ [
/2 1

The First Band is Stop-band [yi fi\ fii fi\ fyi Â·Â·Â·Â·] [ 0 1 0 1 ....1 [Ai A Aj A Af ....]
2 2

fn fi\ Â·Â·Â·Â·] [ 1 0 1 0 1 ....1 A A Aj ....]
2 2

Table 3.3: Specification Vectors for Multi-band Filter

20

Get filter specifications: fire_vector, wgt_vector and dev_vector Determine Ymax and Ymin of target region No. Then first band is stop-band
W gt_vector(l)=l?

Decide target region according to Figure 3.3

Yes. Then first band is pass-band Decide target region according to Figure 3.2 Figure 3.1: Flow chart of target region design program
a A b d c a d a b d c

2
A
' b b a c d A c b a c d

-----

2

fi

fix

^22

/ji

fyi

Figure 3.2: Target Region if the First Band is a Pass-band. Ymax
a d a b b c b c d d c b c b a c d a d a b d c

-----

A2
2 a

A,
2

Ymin
f\ fix fn

/31

/s z

Figure 3.3: Target Region if the First Band is a Stop-band

21

elseif ( FILTtypeNumber = 7 ) % Multi-band Case % D eterm ine Ym in Y m inl = -fix(abs(-dev_vector(l) + DFP_Targetmin)/10)*10; for i = 1: length(dev_vector) dev_vectorl(i) = -fix(abs(-dev_vector(i)+DFP_Targetmin)/iO)*IO; Y m inl = min (Y m inl, dey_vectorl(i)); end Ymin = Y m inl; % D eterm ine Y m ax Y m axl = fix(abs(dev_vector(l) + DFP_T argetmax)/10) * 10 + dev_vector(l)/2; for i = 1: length(dev_vector) dev_vectorl(i) = fix(abs(dev_vector(i)+DFP_Targetmax)/10)*10 + dev_vector(i)/2; Y m axl = max( Y m axl, dev_vectorl(i)); end Ymax = Y m axl; if (wgt_vector(l) = 1 ) for i = l:length(dev_vector) bandn = length(dev_vector); % This is the case o f first b and is pass b an d %

% How m any b and it has? %

if (rem (b an d n ,2 )= l) ynumber = (3*bandn +l)/2; % num ber of colum n in x vector (x coordinate) % Initial m atrix ( x and x l = zeros(l,ynumber); x2 = zeros(l,ynumber); x3 = zeros(l,ynumber); x4 = zeros(l,ynumber); X = zeros(4,ynumber); yLO G l yL 0G 2 yL 0G 3 y L 0G 4 yyLOG = = = = = y coordinate) %a %b %c %d % x coordinate m atrix of targ e t region

zeros(l,ynumber); zeros(l,ynumber); zeros(l,ynumber); zeros(l,ynumber); zeros(4,ynumber);

% y coordinate of targ e t region

for i = 3:ynumber if ( re m (i,3 )= 0 ) k = i/3 *2; yLO G l (i) = Ymax; yL 0G 4(i) = Ymax; yL 0G 2(i) = -dev_vector(k); yL 0G 3(i) = -dev_vectorOc); elseif (rem(i,3) = 1 ) k = (((i+2)/3)*2)-l; yLO G l (i) = Ymax; if ( i= (y n u m b e r-l) ) yL0G 4(ynum ber-l) = dev_vector(bandn)/2; else _________________________________________________ ________

22

yL0G 4(i) = Ymax; end yL0G 2(i) = dev_vector(k)/2; yL 0G 3(i) = dev_vector(k)/2; elseif (rem(i,3) = 2 ) k = (((i+ l)/3 )* 2 )-l; yLO G l (i) = Ymin; if ( i = ynumber ) yL0G4(ynumber) = -dev_vector(bandn)/2; else yL0G 4(i) = Ymin; end end x l(i) = fre_vector(2*(k-2)+2); x2(i) = fre_vector(2*(k-2)+2); if ( ( i == ynumber )|( i = (ynumber-1) )) x3(i) = fs/2;x4(i) = fs/2; else x3(i) = fre_vector(2*(k-2)+3); x4(i) = fre_vector(2*0c-2)+3); end x l ( l ) = 0; x l(2 ) = 0; x 2 (l) = fre_vector(l); x2(2) = fre_vector(l) x 3 (l) = fre_vector(l) x3(2) = fre_vector(l) x 4 (l) = fre_vector(l) x4(2) = fre_vector(l);

X=

[x 1;x2;x3 ;x4] ;

%

x coordinate of target region

y L O G l(l) = dev_vector(l)/2; yLO G l (2) = -dev_vector(l)/2; y L 0 G 2 (l) = dev_vector(l)/2; yLOG2(2) = -dev_vector(l)/2; y L 0 G 3 (l) = Ymax; yLOG3(2) = Ymin; y L 0 G 4 (l) = Ymax; yLOG4(2) = Ymin; yyLOG= [yLOGl;yLOG2;yLOG3;yLOG4]; yLOG = yyLOG; end % y

coordinate of target region

Figure 3.4: Part of Target Region Design Code

23

3 3 M ulti-band Data Structure and D esign Exam ple
We have introduced multi-band specifications in DFP and target region determination. In DFP, data is entered using the DFP-Type and Specifications Window. After multi-band specifications values are entered, they are passed to the DFP-Design Method Window and are processed based on the various filter approximation algorithms (FIR Remez, FIR Windows, FIR Least Square, HR Butterworth, HR Chebyshev and HR Elliptic). DFP adopts the Userdata object property associated with MATLAB GUI elements to transfer data among DFP windows. The Userdata of the DFP-Design Method Window combines all filter specifications. This data is first parsed, then used to estimate filter order, normalize the input and transfer the newly computed Userdata to the DFP-Display Window. The results of different approximation algorithms become the Userdata transferred to the DFP-Display Window. Finally, the DFP-Display Window receives this Userdata and plots the corresponding filter magnitude response, phase/group delay/impulse responses, displays the filter coefficients resulting from the current design, the pole/zero diagram and the target region. Table 3.4 shows the data structure in the DFP-Type and Specifications Window, the DFP-Design Method Window and the DFP-Display Window. It also shows the data flow direction among the DFP windows.

24

Input Data "Type and Specifications Window"
Â· Â· Â· Â· Frequency vector: fre_vector Weight vector: wgt_vector Attenuation vector: dev_vector Sampling frequency: fs Userdata 1 Input Received Userdatal. Need to do following process: Â· Separate Userdatal Â· Order estimation: N Â· Data normalization. Suppose normalization results: N, f, w, d Â· Calculate target region coordinate matrix Userdata2 Input

Output Data
Userdatal = [fs, fre_vector, wgt_vector, dev_vector]

Userdatal Output

"Design Method Window"

U serdatal = remez (N, f, w, d) or = firl(N , f, w, d) or =firls (N, f, w, d) or =butter(N, f, w, d) or =chebyl(N , f, w, d) or =cheby2(N, f, w, d) or =ellip(N, f, w, d) U serdatal Output

"Display Window"

Filter coefficients are according to Userdata2

determined

Display the following results: Â· Magnitude Response Â· Phase Response Â· Coefficients Â· Target Region

Table 3.4: DFP data structure.

Example: Target rÃ©gion if the first band is a pass-band
Suppose filter specifications are given as following:

Sampling Frequency: 48000(Hz) Frequency Edge Vector: [ 8000 10000 13000 15000 18000 20000 ] Weight Vector: [ 1 0 1 0 ] Attenuation Vector: [ 3 50 3 50 ](dB)

Figure 3.5 shows the target region generated by DFP.

25

80

60

-

20

g
-Ã«
-20 cd
-40

-60

0.5

1.5
XlO

Frequency [Hz] Figure 3.5: Target Region of Logarithm Case

In the DFP-Design Method window, if we choose Remez FIR digital filter design algorithm to realize this specification, the filter order estimate is 36. Figure 3.6 displays the corresponding filter magnitude response. Analyzing the target region and the filter design, we observe that this filter design result meets target requirements. If the filter design result does not meet the target requirements, we can interactively change the filter order until we obtain a filter design that satisfies target requirements.

26

lO P

Â·20

Â·30

(D

Â·40

1

-60

-80

Â·90 0.5

1 .6

Frequency [Hz] Figure 3.6: Filter Design Result of Logarithm Case if First Band is a Pass-band

e

-15

0.5

Frequency [Hz] Figure 3.7: Filter Design Result of Phase Response

27

2.5

1.5

0.5

-

0.5

-

1.5

-

2.5 1
-

0.5

0

0.5

1

1.5

2

2.5

Figure 3.8: Pole/Zero Distribution of the Designed Multiband Filter

28

Chapter 4
Adaptive Digital Filter Design
Filtering refers to the linear process designed to alter the spectral content of an input signal in a specified manner. Conventional FIR and HR filters are time-invariant. They perform linear operations on an input signal to generate an output signal based on constant coefficient values. Adaptive filters are time varying, their characteristics such as bandwidth and firequency response change with time. The coefficients of the adaptive filter are adjusted automatically by an adaptive algorithm based on the incoming signal. This feature enables adaptive filters to be used in areas where the requirements of the filtering operation are unknown or non-stationary [23]. Adaptive filtering problems do not have unique solutions. There are a variety of recursive algorithms, each of which offers desirable features and respective limitations. One approach is based on the Wiener filter theory which uses the Least-Mean-Square (LMS) algorithm. The LMS algorithm is simple and capable of achieving satisfactory performance under right conditions. Its major limitations are a relatively slow rate of convergence and sensitivity to variations in the number of the correlation matrix of the tap inputs.

29

Another approach based on the Kalman filter theory which uses the Recursive-LeastSquare (RLS) algorithm. The RLS algorithm can provide a much faster rate of convergence than that attainable by the LMS algorithm. The RLS algorithm is robust in the sense that its rate of convergence is essentially insensitive to the eigenvalue-spread problem. Moreover, we may utilize the Kalman filtering algorithm to deal with non-stationary environments. The basic limitation of this RLS algorithm is its computational complexity [3].

4.1 Least M ean Square Algorithm (LMS)
There are 5 steps in the implementation of the LMS algorithm. Let tap weight vector, x(hj the input signal, represent the filter

the filter output signal, d('nj the desired signal,

g(h) the error signal, U the step size of LMS algorithm [26]. 1. 2. Select an initial tap-weight vector at time n=0 using W(0) = 0; Receive an input sequence x(n) and for each time sample n = 1, 2, 3 ...N compute the filter output. y{n) = W^ (ft)x(n) or y(ri) = x(n)W^ (n) 3. Compute the estimation error defined as the difference of the desired value and the filter output value. e(hj = d(n) -y(n ) 4. Update the tap-weight vector W(n+1) = W(n) + jue(n)x(n) 5. Repeat steps 2 through 4 until n = N (sample length).

30

The choice of step size // must make algorithm always convergence. To guarantee this, jj. must be selected on the basis of maximum eigenvalue of autocorrelation matrix. Let ^m ax represent the maximum eignvalue of the autocorrelation matrix x^(n)x{n) such that 0</ / ^ 7^ 5-- X (n)x{n) (4.1)

In some instances, the denominator in equation (4.1) can equal zero due to machine precision or signal fading. To avoid this a small positive constant Cis added to the denominator as shown in equation (4.2).

^

1
Ã-Â¥x^{n)x{n)

(4.2)

4.2 Recursive-Least-Square A lgorithm (RLS)
Let 0(/i) represent the time-averaged autocorrelation matrix of the input signal as defined in Equation (4.3).

$ (Â» )= l ^ ^ ( Ã® > ( 0
1= 1

(4 3)

LetP(n) = d>"'(/i). The implementation of the RLS algorithm realization consists of the following steps [26]. 1. Compute Kalman gain vector K(ji) . K ij,) ------1+ x (n)P(Â« - l)x(n) (4.4)

2.

Compute P{n) Pin) = Pin -1) - Kin)x^ (Â«)P(n -1) (4.5)

51

PRO PER?/ Cf
UNIVERSITY LlBRArtV

3. 4.

Compute the a priori error a(n) = d(n)~

(n - l)x(n)

(4

6)

Update the tap-weight vector W(n) = W ( n - l) + K{n)a{n) for n = 1,2 ...

The initial conditions for RLS algorithm realization are:
1. Ã(l)=---- -------------

2. P(l) = P(0) - Ã(l)x^(l)f(0) 3. a(l) = c/(l)-ir^(0)x(l) 4. 1T(1) = 1T(0) +AT(l)a(l) with W(0) = 0 and P(0) = 4>"'(0) = < ?"'/ where J Â« 1 and I is the identity matrix.

4 3 D esigning Adaptive Filters U sing DFP
In DFP we first wrote the M-fiinctions a d a p t 1ms .m and a d a p t r l s .m which implement the LMS and RLS algorithms, respectively. In the DFP-Type and Specification window we have three input variables: input signal vector, desired signal vector and filter order. Input signal vector and desired signal vector should be designed in the MATLAB workspace based on the application requirements. In this section, we provide several application examples. After entering the specifications of the adaptive filter, we proceed to the method selection window to choose either one of LMS and RLS algorithms. In the DFP-Display window, we can monitor and compare the learning curves from the LMS and RLS algorithms and the frequency response of the adaptive filter. We can also monitor the resulting filter impulse response and transfer adaptive filter coefficients to the MATLAB workspace.

32

Examplel: System Identification
In this class of applications, an adaptive filter is used as a linear model that represents the best fit to an unknown system. The unknown system and the adaptive filter are driven by the same input x(n). The unknown system supplies the desired response for the adaptive filter. Figure 4.1 presents this approach, [l]

Adaptive

 e(n) x(n) Unknown system

dCn)

Figure4.1: System Identification We observe that when e(n) is very small, the adaptive filter response is close to the response of the unknown system. To use the adaptive filter functions in DFP, we need to provide three design parameters. First we need to generate the signal input x(n) to both the unknown system and the adaptive filter as shown in Figure 4.1. Then we generate the desired signal d(n). Finally we specify the tap length N of the adaptive filter. In this example, we have 500 points of the random input signal x(n). The desired signal d(n) is the output fi-om a known LPF. If the tap length N of adaptive filter we want to design is the same as known LPF order 13, then after we enter the three design parameters (tap

33

length, input signal and desired signal) into the DFP-Adaptive Filter Design window, DFP generates as one output the adaptive filter coefficients. According to Figure 4.1 system identification analysis, the filter coefficients of this unknown system should be the same as designed adaptive filter eoefficients. In this way, we ean identify unknown system characteristic in term of known system characteristic. Another output from DFP is the squared error. Using this parameter, we can plot the learning curve of the adaptive filter.

The following MATLAB sample code is used to generate the input and the desired signal vectors in the base MATLAB workspace.

input_signal = 0.1 * randn(l,500); b = remez(12,[0 0.4 0.5 1], [1 1 0 0], [1 0.2]); % b is LPF coefficients desired_signal = filter(b,l,input_signal);

Figure 4.2 shows the LMS algorithm learning curve. Figure 4.3 shows the RLS algorithm learning curve. From the learning curve displayed in DFP, we observe that the RLS algorithm has a faster convergence speed than the LMS algorithm.

34

1 0

1 0

I
i

10Â®

-

1 0 *

1 0 * 1 0 *
100 150 200 250 300 350 400 450 600

Sample Points (n) Figure 4.2: LMS Learning Curve for the System Identification Example

10

I
I

10

10
50

100

150

200

250

3 00

350

400

450

500

Sample Points (n) Figure 4.3: RLS Learning Curve for the System Identification Example

35

Example 2: Inverse System Identification
In this class of applications, the function of the adaptive filter is to provide an inverse model that represents the best fit to an unknown system. Ideally, the inverse model has a transfer function equal to the reciprocal of the unknown system's transfer function. A delayed version of the system input constitutes the desired response for the adaptive filter. Figure 4.4 represents this approach. Let x(n) = input applied to the adaptive filter y(n) = output of the adaptive filter d(n) = desired response e(n) = d(n) - y (n) = estimation error s(n) = system input

Delay xM
y(n)

dM

s/h)

Unknown system

Adaptive filter

_
e(n)

Figure4.4: Inverse System Identification Figure 4.4 shows that the process requires a delay element inserted in the desired signal path to keep the data at the summation point synchronized. The delay element keeps the system causal. Without the delay element, the adaptive filter algorithm tries to match the output fi-om the adaptive filter to input data x(n) that has not yet reached the adaptive

elements because it is passing through the unknown system. Therefore, the filter cannot

36

compensate for the unknown system response. Including a delay equal to the delay path caused by the unknown system prevents this condition.

Adaptive channel equalization is an application example of the inverse system identification problem. Let us consider a digital communication channel. s(n) is an uncorrelated random sequence of binary values -1 and +1 with zero mean. In this example, the unknown system is the transmission channel. The additive channel noise is uncorrelated with mean 0 and variance 0.001. Therefore, x(n) is the sum of s(n) and the noise. In order to eliminate Inter-Symbol Interference (ISI), a seven order adaptive filter is used. The

following MATLAB sample code is used to generate x(n) and d(n) in the base MATLAB workspace. % Channel parameter W=2.9; % Variance of noise nvari = 0.001; % System input s = fix(rand(l,700)+0.5)*2-l; % Random Noise V = fix(randn(l,700)+0.5)*2*sqrt(nvari)-sqrt(nvari); for k= 1:3 % Channel Impulse Response h(k)= l/2*(l+cos(2*piAV*(k-2))); end % Channel output XX = conv(s,h); % Adapt filter input inp = xx(l:700)+v; % Desired signal ref = [0 0 0 s(l :697)]; % as contrast, if we input not delay variable. % Adapt filter input inpl =xx(l:700)+v(l:700); % Desired signal refl = s; % Then it is difficult to converge.

We first enter the input x(n) and d(n) vectors and the adaptive filter order into DFP, we then obtain the adaptive filter coefficients and the learning curves from the LMS and RLS algorithms. Figures 4.5 and 4.6 show respectively the learning curves corresponding to the LMS and the RLS algorithms.

37

I I

I

Sample Points (n) Figure 4.5: LMS Learning Curve for Inverse System Identification

1
I
600 700

Sampling Points (n) Figure 4.6: RLS Learning Curve for Inverse System Identification

38

Example 3: Noise Interference Cancellation
In this example, the adaptive filter is used to cancel the interference contained in the primary signal. Here we use the same notation as in the previous example. The primary signal s(k)+n(k) serves as the target response of the adaptive filter. An auxiliary noise signal n '(k) is the input to the adaptive filter. As long as the input noise to the filter remains correlated with the unwanted noise accompanying the target signal, the adaptive filter adjusts its coefficients to reduce the difference between y(k) and d(k), thus removing the noise and generating the clean signal in e(k). Notice that in this application, the error signal actually converges to the input data signal, rather than converging to zero.

sHcl+ndc)
y(k)

dHc)
x(Tc)

nW

Adaptive filter

e(k)

Figure 4.7: Noise Cancellation

To realize this application in DFP, we use the following sample code. We use the notation where: the system signal s(k) is a sinusoid, n '(k) is the noise to be eliminated. In adaptive noise cancellation system, n '(k) is the signal input to the adaptive filter, d(k)=

s(k)+n(k) is the target signal for the adaptive filter desired. In order to make n(k) correlated with n '(k), we pass n '(k) through a low-pass FIR filter. Then, we define n(k) as the output of this low-pass FIR filter.
39

Once we enter the input and the target signal vector to DFP, we obtain the de-noised signal and the adaptive filter coefficients. De-noised signal results obtained using the LMS and RLS algorithm are shown in Figures 4.8 and 4.9. Adaptive filter coefficients using LMS algorithm is shown in Figure 4.10.

s = sin(2*pi*0.055*[0:1000-l]'); X = randn(ljlOOO); nfilt = firl(l 1,0.4); n = filter(nfilt,l, x); d = s.'+ n;

% System Input Signal % Adaptive Filter Input Signal. % LPF Coefficients % Correlated Noise Data. % Adaptive Filter Desired Signal

.1 C /)

Q

Ã
1000

Sampling Points Figure 4.8: De-noised Signal Using LMS Algorithm

40

1.5



0.5



I
00

-05

1
Q

-

1.5

-2 L

_i_
100 200 300 400

_ L _
500

_L_

600

700

800

900

1000

Sampling Points (n) Figure 4.9: De-noised Signal Using RLS Algorithm
0.6
0.5 0.4 0.3 0.2 0.1

-

0.1 0.2 0 . 3,

-

-

Figure 4.10: Adaptive Filter Coefficients Using LMS Algorithm

41

Chapter 5
2-Dimensional Digital Filter Design
As a result of rapid increase in the demand and development of video consumer products, high performance 2-D digital filters have become an important component of digital signal processing. 2-D digital filters can be found in diverse applications such as image/video processing, image restoration and noise reduction. They represent one of the most basic and important processing techniques in image and data processing. Typically, a recursive 2DDF (2D Digital Filter) has better magnitude response than a nonrecursive 2DDF of the same order. However, since a non-recursive, i.e., an FIR, filter is stable, realizable and always can be designed to have linear phase response, non-recursive 2DDF has been proved to be much easier for hardware implementation. The main approach used in this project is based on separable 2-D digital filter design method. The sq>arable-denominator 2DDF is a very important filter class because its design and analysis are easy and any arbitrary fi-equency response can be approximated [6].

42

5.1 Separable-Denom inator 2DDF
Equation (5.1) gives the transfer function of a separable-denominator 2DDF.

If the numerator polynomial N{z ^, ) can be factored as = (5.2)

then/f(Z],Z 2 ) can be decomposed into a product of two 1-DDF transfer functions /fy(z,) and H g (zj ) as shown ff(z ,, z ,) = /f/(z ,)-W ,(z ,) (5.3)

where u ,

Dz(zJ

(5.4b)

The flow-chart for designing separable-denominator 2DDF based on the reduced dimensional decomposition is shown in Figure 5.1. By means of the reduced-dimensional decomposition, the design problem of the separable 2DDF is simply reduced to the problem of designing two IDDF.

43

START 2DDF SPECIFICATION DECOMPOSITION IDDF SPECIFICATION IDDF DESIGN IDDF SPECIFICATION IDDF DESIGN

SEPARABLE- DENOMINATOR 2DDF END

Figure 5.1: Separable-Denominator 2DDF Design Flow-Chart

5.2 2DDF D esign in DFP
The MATLAB Image Processing Toolbox provides several two dimensional digital filter design methods such as 1-D window method, 2-D window method, two-dimensional fi-equency response method, and firequency transformation method. FWIND 1 and FWIND2 2DDF design functions in the Image Processing Toolbox can be used to design an approximately circularly symmetric 2-D FIR filter by using 1-D window method. If we enter just one IDDF specification, then we obtain the resulting 2DDF, which assumes that the two-dimensional filter will have the same specifications in both dimensions. The only difference between FWIND 1 and FWIND2 is that FWINDl works with one dimensional windows, while FWIND2 works with two-dimensional windows. By using this method we cannot design 2DDF with two distinct one-dimensional specifications.

44

FTRANS2 designs a 2-D FIR filter using firequency transformation. It is based on the same assumptions as FWINDl and FWIND2. They all cannot design 2DDF with distinct one-dimensional specifications. FSAMP2 designs two-dimensional FIR filters according to a desired two-dimensional fi-equency response. For those users who cannot access Image Processing Toolbox, they cannot design 2-D digital filters directly by using these 2-D design methods.

In Chapter 3, we introduced the design of one-dimensional multi-band digital filters in DFP. For the 2DDF case, we use the separable 2DDF design mechanism. Our design objective for the 2DDF is to have flexible multi-band two- dimensional digital filter design ability. So the idea of designing 2D filters in DFP is that we do not want to depend on builtin 2D filter design functions in the Image Processing Toolbox. We integrated separable 2D filter design method into DFP package. The advantage over using Image Processing Toolbox 2D filter design functions lies in that we can design multi-band 2D filter, which can have different IDDF specifications. The 2DDF we designed can have one of the four possibilities listed in Table 5.1.

Dimension 1 Specification LPF HPF Dimension2 Specification LPF HPF 2-D L-L 2-D H-L 2-D L-H 2-D H-H

Table 5.1: DFP Design Type of 2DDF The display window provides a 3-dimensional fi-equency and impulse responses of the 2-D filter. We can interactively change the filter order we design and obtain the desired filter design. If we want to identify two IDDFs, which are design elements of 2DDF, we can use

45

IDDF design display windows to verify whether the filter order can meet the target requirements. Example 1: Design L-L mode 2DDF Figure 5.2 presents the resulting design corresponding to the following 2DDF specifications. DFP-Type and Specification

X : Frequency Edge Vector: [1200015000] Weight Vector: [1 0] Attenuation Vector: [3 50] y: Frequency Edge Vector: [12000 15000] Weight Vector: [1 0] Attenuation Vector: [3 50] Sampiing Frequency: 48000

Figure 5.2: 2DDF with two low-pass IDDF specifications

46

Example 2: Design L-H mode 2DDF Figure 5.3 presents the resulting design corresponding to the following 2DDF specifications. DFP-Type and Specification

x: Frequency Edge Vector: [12000 15000] Weight Vector: [1 0] Attenuation Vector: [3 50] y: Frequency Edge Vector: [12000 15000] Weight Vector: [01] Attenuation Vector: [50 3] Sampling Frequency: 48000

-1

-1

Figure 5.3:2DDF with low-pass and high-pass IDDF specifications

47

Example 3: Design H-L mode 2DDF Figure 5.4 presents the resulting design corresponding to the following 2DDF specifications. DFP-Type and Specification

x: Frequency Edge Vector: [12000 15000] Weight Vector: [01] Attenuation Vector: [50 3] y: Frequency Edge Vector: [12000 15000] Weight Vector: [1 0] Attenuation Vector: [3 50] Sampiing Frequency: 48000

I

Â·1

-1

Figure 5.4:2DDF with high-pass and low-pass IDDF specifications

48

Example 4: Design H-H mode 2DDF Figure 5.5 presents the resulting design corresponding to the following 2DDF specifications. DFP-Type and Specification

x: Frequency Edge Vector: [12000 15000] Weight Vector: [01] Attenuation Vector: [50 3] y: Frequency Edge Vector: [12000 15000] Weight Vector: [01] Attenuation Vector: [50 3] Sampling Frequency: 48000

1 .4
1.2

-

0.6 S* 0.6 0.4 0.2

0.5 0.5
- 0.5

- 0.5

F

Â·1

1

F

Figure 5.5 2DDF with two high-pass IDDF specifications

49

Example 5: Design multi-band mode 2DDF Figure 5.6 presents the resulting design corresponding to the following 2DDF specifications. DFP-Type and Specification

x: Frequency Edge Vector: [10000 11000 13000 14000 16000 17000] Weight Vector: [ 1 0 1 0 ] Attenuation Vector: [3 50 3 50] y: Frequency Edge Vector: [1200013000 15000 16000 18000 19000] Weight Vector: [ 1 0 1 0 ] Attenuation Vector: [3 50 3 50] Sampling Frequency: 48000

2-D Finer Frequency Response

Figure 5.6:2DDF with multi-band IDDF specifications

50

Chapter 6
DFP GUI Design and TMS320 Code G eneration
Graphical User Interface (GUI) is a user interface built with graphical objects, such as buttons, text fields, sliders, and menus. In general, these objects already have meanings to most computer users. For example, when you move a slider, a value changes; when you press a CLOSE button, your settings are applied and the dialog box is dismissed [10].

Applications that provide GUIs are generally easier to learn and use. The action that results fi-om a particular user action can be made clear by the design of the interface.

6.1 DFP GUI Structure and D esign
The original DFP package has 14 windows. Table 6.1 provides an overview of the DFP windows. These windows are designed using GUI objects built into MATLAB.

51

Original DFP Windows
DFP: Navigator DFP: Type and Specifications DFP: Design Method DFP: Display DFP: Implementation DFP: Output Format DFP: File I/O DFP: Properties DFP: About DFP: Magnitude Axes DFP: Phase Axes DFP: Group Delay DFP: Impulse Response DFP Table 6.1: DFP Windows

New Windows
'DFP: Display Window'
Note: This window is used to plot adaptive filter learning curve, adaptive/2-D filter magnitude response, impulse response and display filter coefficients.

'DFP: Magnitude 15 Axes'
Note: This is the snapshot window for 2-D filter magnitude response

'DFP: Learning Curve Axes'
Note: This is the snapshot window for adaptive filter learning curve and magnitude response

6.1.1 Types and Specifications W indow
For this part, the design programs were modified in order to extend the DFP design capability to include multi-band, adaptive and 2-D filters. The main modifications lie in the size and the position modifications for the fi-ame object, text object and editable text object so that the layout is suitable for all filter types. The design procedure for the DFP-Types and Specifications window is shown in Figure 6.1. Tables 62-6.5 provide commented code samples.

52

1. Create and initialize the window and its children. The sample code to determine window frame and TEXT objects is shown in Table 6.2.

2. Prepare the window for different filter types. The sample code to design Multi-band filter is shown in Table 6.3.

3. Create callback function for the APPLY pushbutton in the DFP-Type and Specifications window. The sample code to determine Userdata is shown in Table 6.4.

4. Check the values entered to the editable fields of the DFP-Type and Specifications window. If the entered values have problems, the error or warning message will give out to indicate the existed problem and provide hints helping user to solve this problem. The sample code to check multi band input data is shown in Table 6.5 Figure 6.1: Design Procedures for the DFP-Type and Specifications window

Table 6.2: Sample Code to Determine Window Frame and TEXT Objects
% FRAME objects
% Upper program has defined FRx, FRyl, FRy2, FRy3, FRy31, Fryp. DimI = l;Dim2 = l;Dim5=0; % FRx is X coordinate o f frame. FRyl is y coordinate with one frame wide. FRy2 is y coordinate with % two fram e wide. FRy3 is y coordinate with three frame wide. FRy31 is y coordinate with three frame % wide fo r 2-D filter. FRyp is y coordinate with push button wide. DimS = 0; % Then we can determine Frame Position in "Type and Specifications Window"
FRpos=[Dim l D im l D im l D im l D im l D im l D im l Dim2+FRyp+Dim8+2*FRy2+3*Dlm5+FRy3 Dim2+FRyp+Dim8+FRy2+2*Dim5+FRy3 Dim2+FRyp+Dim8+FRy2+Dim5+FRy3 Dim2+FRyp+Dim8+FRy2+Dim5+FRy3-FRy2 Dim2+FRyp+Dim8+FRy2+Dim5 Dim2+FRyp+Dim8 Dim2 FRx FRx FRx FRx FRx FRx FRx FRyl; FRy2; FRy31; FRy2; FRy3; FRy2; FRyp; ];

% The first two dimensions in each row indicate the frame x and y coordinate position relative to left % lowest window point The next two dimensions indicate the frame length and wide. Here we defined

53

% 7fram e positions.

% TEXT objects
% This part defines text object size and position. TXx is text object wide, TXy is text object height % Dim 3 is button to left/right Frame edge. Dim4 is button to bottom/top Frame edge. Dim? is the % separation between buttons within the Frame
TXpos = [ FR pos(l,l)+D im 3 FRpos(l,2)+Dim4 TXx TXy;

FRpos(2,l)+Dim3 FRpos(2,2)+Dim4+ TXy+ Dim? TXx TXy; FRpos(2,l)+Dim 3 FRpos(2,2)+Dim4 TXx TXy; FRpos(5,l)+Dim3 FRpos(5,2)+Dim4+2*TXyf2*Dim7 TXx TXy; FRpos(5,l)+Dim3 FRpos(5,2)+Dim4+ TXy+ Dim? TXx TXy; FRpos(5,l)+Dim3 FRpos(5,2)+Dim4 TXx TXy; FRpos(6,l)+Dim3 FRpos(6,l)+Dim3 FRpos(6,2)+Dim4+ T X yf Dim? TXx TXy; FRpos(6,2)+Dim4 TXx TXy;

];
TX str = str2mat( ", ...
");

% Text string matrix

% POP-UP MENU objects
D im l 1 = (FRx-PUx)/2; % PUx is popup menu x coordinate. PUy is y coordinate. PUpos = [D im II FRpos(l,2)+FRpos(l,4)+3*Dim21 PUx PU y]; PUstr = [ 'Low Pass|High Pass|Band Pass|Band Stop|Differentiator|' ________ 'Hilbert Transform|Multiband|Adaptive|2-D' 1; % Popup menu string _________________

Table 6.3: Sample Code to Prepare Window Frame and TEXT Objects
% This part code is used to define which frame and text objects are active according to sample code in % Table 6.1
elseif ( FiltTypeNumber -- ? ) % Multiband FRindex = [ 1 2 0 4 0 0 ? ] ; % Refer to FRpos, the 1,2,4,7frames are active TXindex = [ 1 2 3 4 0 0 0 0 ] ; % Refer to T7Q)os, the 1,2,3,4 text position are active ETindex = [ 1 2 3 4 0 0 0 0 ] ; % The 1,2,3,4 editable text position are active TXstr = str2m at(... 'Sampling Frequency ', 'Frequency Edge Vector', 'Weight V ector',. 'Attenuation Vector(db)' ); % Define the text String name

54

Table 6.4; Sample code to create callback function for the APPLY pushbutton
elseif ( FILTtypeNumber = 7 )

% Multiband call hack function sample code % This code is used to prepare the Userdata to transfer to "Design Method iVindow" ss = get(EThan(l),'String'); % get the first editable text object string value
SpecDatal = str2num( ss ); sizel = length(SpecDatai); ss = get(EThan(2),'String'); % get the second editable text object string value i f ( isempty(str2num(ss)) ) % this indicates array name input SpecData2 = evalin( 'base', ss ); else SpecData2 = str2num( ss ); end size2 = length(SpecData2); ss = get(EThan(3),'String'); % get the third editable text object string value if ( isempty(str2num(ss)) ) %this indicates array name input SpecDataS = evalin( 'base', ss ); else SpecDataS = str2num( ss ); end size3 = length(SpecData3); ss = get(EThan(4),'String'); % get the fourth editable text object string value if ( isempty(str2num(ss)) ) %this indicates array name input SpecData4 = evalin( 'base', ss ); else SpecData4 = str2num( ss ); end size4 = length(SpecData4); SpecData = [SpecDatal SpecData2 SpecData3 SpecData4]; % Defined userdata NNN = sizel + size2 + size3 + size4;_________________________________________

Table 6.5: Sample Code to Check Multi-band Input Data
elseif ( FILTtypeNumber = 7 ) %for multi-band

totallength = length(SpecData); % Separate and restore input data according to Userdata bands = (totallength + l)/4; frelength = 2*bands -2; fs = SpecD ata(l); fre_vector = [(SpecData(2:(frelength+l)))];

wgt_vector = [(SpecData((frelength+2):(frelength+l+bands)))]; dev_vector = [(SpecData((frelength+2+bands):totallength))];
for i = l:length(dev_vector) j = rem(i,2);

)

------------------------------------------------

55

devl(i) = dev_vector(i); % odd w gtl(i) = wgt_vector(i); else dev2(i) = dev_vector(i); % even wgt2(i) = wgt_vector(i); end end

% Any intermediate frequencies exceeding (fs/2) ?
if ( any( fre_vector >= fs/2 ) ) d_error( 'ET-02' ) flag = 0; % Give error information and hint to solve this error end

% Are intermediate frequencies non-decreasing?
if ( any( difÃ¯([0 fre_vector]) <= 0 ) ) dLerror( 'ET-03' ) flag = 0; end

% Are Attenuation parameters non-negative ?
if ( any( dev_vector <= 0 ) ) d_error( 'ET-04' ) flag = 0; end

% Are Stopband/Passband Attenuation parameters comparable ?
for i = 2:length(wgt_vector) j = rem(i,2); if ( ( j ~ 1 ) & ( w gtl(i) = 1 ) & ( devl(i) >= dev2(i-l)) ) d_error( 'ET-05' ) flag = 0; elseif ( ( j ~ 0 ) & ( wgt2(i) = 1 ) & ( dev2(i) >= devl(i-l)) ) d_error('E T -05') flag = 0; end

6.1.2 The DFP-Design

Window

In order to design adaptive filter in DFP, I generated adaptive design methods: LMS and RLS algorithms and integrated into DFP. For multi-band and 2-D filter design, I modified the original design program and solved the following problems: 1. How to translate the Userdata coming from DFP-Types and Specifications window? 2. How to prepare the Userdata to be passed to DFP-Display window.

56

Tables 6.6 provides commented code sample used for designing adaptive filters.

elseif (FILTtypeNumber = 8) % Adaptive Filter Design Method totallength --length(FILTdata); % FILTdata is received Userdata from "Types and Specifications ban = (totallength-1)/2; % Window" N N l = FILTdata(l); % First Userdata (It is Filter Order.) input_vector = FILTdata(2:(l+ban)); % Restored input signal; re fv e c to r = FILTdata((2+ban):totallength); % Restored reference signal; RBusr = str2mat(...

['adaptlms([' sprintf('%s ',input_vector) ['adaptrls([' sprintf('%s ',input_vector)

sprintf('%s ref_vector) sprintf('%s refv ecto r)

sprintf('%g ',NN1) ']) ' ],.. sprintf('%g ',NN1) ']) ' ]);

for ii=[8 9] % set(TXhan(ii), 'String', sprintf('%i', N N l)); set( RBhan(ii), 'U serdata', deblank(RBusr(ii,:))); %Prepare the Userdata to "Display Window' set( RBhan(ii), 'U serdata', deblank(RBusr(ii,:)), 'Enable', 'on' ); %set( RBhan(8), 'U serdata', " , 'Enable', 'on' ); %set( RBhan(9), 'U serdata', " , 'Enable', 'on' ); end for ii=[l:7] set(TXhan(ii), 'String', " ); set(EDhan(ii), 'String', ", 'Enable', 'off); set(RBhan(ii), 'Userdata', ", 'Enable', 'off); end set( RBhan(lO). 'U serdata', " . 'Enable', 'off );_____________________________________________

Table 6.6: Sample Code for Adaptive Filter Design Method

6.1.3 DFP-Display window The learning curve is the preferred tool for monitoring results from adaptive filter design techniques. Similarly, a three-dimensional filter response display window is the preferred

method of displaying the results from the 2-D digital filter design. Because it is difficult to use original display window to plot adaptive and 2-D filter design results, we designed a

57

stand-alone display window for adaptive and 2-D digital filters. The new window design is based on the original display window. Some work was needed to prevent transition problems among the new and original DFP-Display windows. Figures 6.2 and 6.3 show respectively the layout of the original and the new display windows.

Magnitude Response for LPF/HPF/BPF/BSF/Differentiator/ Hilbert Transform/Multiband Filters

Magnitude Response for 2-D Learning Curve/Frequency Response for Adaptive Filter

Phase/Impulse/Group Delay Response

Poles/Zeros

Coefficients

Impulse Response

Coefficients

Figure6.2: Display Window Layout of Original

Figure 6.3: Display Window Layout of New Display

The DFP-Display window receives its Userdata from the DFP-Design Method window and plots the magnitude, phase/impulse/group-delay responses, and the learning curve. Filter coefficients are also displayed in the display window.

6.2 TMS320 Code Generation
TMS32010 is the first fixed-point DSP in the TMS320 family. Today, TMS320 DSP family consists of three supported DSP platforms: TMS320C2000, TMS320C5000, and

58

TMS320C6000. The TMS320C2000 DSP platform is frequently used in the digital control industry. This generation of DSPs deliver power and control advantages that allow designers to develop modem and cost-efficient control systems. The TMS320C5000 DSP platform is optimized for the mobile Internet and its convergence with other consumer electronics. The TMS320C6000 DSP platform is optimized for highest performance and ease-of-use in highlevel language programming.

The TMS320 implementation codes integrated with the DFP are collected from a variety of Texas Instrument standard documents [11,12,13, 19,20,21,22, 23, 24,25] and the T.I. BBS site. After classifying and analyzing these codes, we integrated them into the DFP according to different filter design type and realization structures. The current DFP release provides code generation for FIR/IIR direct/lattice structures and HR Second Order Section (SOS) cascade structures for the TMS32067x processor; and FIR/IIR direct structures, HR SOS cascade stmctures for TMS32010/TMS32020/TMS32054x processors. As the code for all different T.I. DSP families are not fully compatible, we were not able to test all TMS320 codes integrated in DFP. The installed TMS320C67x DSK can only test the TMS320C67X code. In order to test the FIR/IIR Direct Form implementation code, we programmed test files writing in C program language. For other implementation structures (FIR/IIR lattice structure and HR SOS), we only provided the complete subroutine assembly codes. Table 6.7 compares the TMS32010/TMS32020, TMS320C54x and TMS320C67x DSP implementation codes.

59

TMS32010/ TMS320C54X TMS320C67X TMS32020 16 bit Hexadecimal 16 bit Hexadecimal word 16 bit Hexadecimal Data Format of word without the without the header Ox, word with the header Filter Coefficients header Ox, such as such as FFC2. Ox, such as 0xFFC2. FFC2. Section The section: The k"` section: The k"' section: Coefficient [ * u *2* b j i - a 2 j c - a ^ ^ ] [ " Ã»'3* ~^2k *3* ^2* b\k ] [ Â· Â« 3 * " ^ 2 * *3* b2k Representation bit] for SOS Structure Addressing Mode Software Pipeline Coding Constraints Â· Â· Direct Mode Indirect Mode No Circular Mode Yes Code for FlR/llR Â· Direct Structure with 32* 16-bit. (Input data are 32 bits, filter Â· coefficients are 16 bits.) Code for HR SOS structure with 16* 16bit. Circular Mode Yes Number of filter coefficients must be a multiple of 4. The size of the block must be a multiple of 2.

Need large program . memory for long filter coefficients.

Â·

Table 6.7 Comparisons of Code Generation Considerations

The Z-transform of the unit-sample response of an HR filter with a SOS has been introduced in Chapter 2 as
(6 . 1)

The difference equation corresponding to equation (6.1) is shown by equation (6.2), where k represents the section number.
N/ 2
3 3 ^

y(n) = ^ \\^ b ik X ( n k=\ /=!

0" ^

1=2

[

"

01

(6.2)

60

In Table 6.7 the representation of section coefficients for the SOS structure is based on Equation (6.2) yet has a separate format for different T.I families.

There

are

direct

addressing

mode

and

indirect

addressing

mode

for

TMS32010/TMS32020. Direct addressing mode uses LTD/MPY instruction pair to implement the multiplications and shifts. If there is a long length of the filter coefficients, the coding program becomes very long for direct addressing mode. We need to use indirect addressing mode to reduce program memory size. Using either of the auxiliary registers along with the auto-increment or auto-decrement feature, the program can be rewritten in looped form or repeat instruction RPTK and MACD (multiply and accumulate with data move) pair. TMS32010/TMS32020 code generated by DFP uses indirect addressing mode. TMS320C54x and TMS320C67x use circular buffer addressing mode to conserve memory and minimize software overhead. Circular addressing uses pointer manipulation to add the new samples to the buffer by overwriting the oldest available samples hence reusing the memory buffer. The pipeline technique has been used in TMS320C54x and TMS320C67x DSP to improve processor performance and reduce the overall instruction execution time. The pipeline execution breaks a sequence of operations into small segments and executes these small pieces in parallel. In DFP, TMS32010/TMS32020, TMS320C54x and TMS320C67x families have their own code generation programs. These code generation programs are also based on the implementation of Motorola 56000 DSP code generator. Table 6.8 shows the sample

61

program for generating TMS320C67x test file and the subroutine assembly code for the FIR direct form.

Table 6.8: Sample Program for TMS320C67x Code Generation
% Now s ta rt generating the filter code if ( FilterType == 0 ) % = FIR Direct Form ===

NN = Options(2); % if NN is not the n u m ber m ultiple o f 4, we m ake it becom e m ultiple o f 4 if ( rem(NN,4) = 1 ) N N = NN + 3; strr = str2num(str); strrr= [strr;0;0;0]; str = num2str(strrr); elseif ( rem(NN,4) --2 ) N N = NN +2; strr = str2num(str); strrr = [strr;0;0]; str = num2str(strrr); elseif ( rem(NN,4) = 3 ) N N = NN +1 ; stiT = str2num(str); strrr = [strr;0]; str = num2str(strrr); end NUM_SAMP = NN+4; if ( CodeType = 1) % This is fo r generate m ain test file

s = [ DFP_TemplatesDir2 'fir_dOO.asm' ]; % D eterm ine w hether fir_dOO.asm tem plate exist. if ( exist(s) ) d_append( Fid, s ); else d_error('EO-06', s, DFP_TemplatesDir2 ); return; end TOT_SAMP= 100; % In p u t num ber fi)rintfi[ Fid,'//Define Circular Block Size (BUF_LEN), Number o f Coefficients (NUM_TAPS) and \n' ); fi)rintf( Fid,'//Block FIR Size (NUM_SAMP). BUF_LEN is defined in bytes \n' ); fprintf( Fid,'#define BUF_LEN 128 \n' ); fi)rintf(Fid,'#defineTOT_SAM P 100 \n' ); fi)rintf(Fid,'#defm eN U M _TA PS% i \n ',N N ); fi)rintf( Fid,'#defme NUM_SAMP %i \n', NUM_SAMP ); fprintf( Fid,'short out_array[TOT_SAMP]; W ); fijrintf( Fid,'short in_array[BUF_LEN/2]; \n' ); fi)rintf( Fid,'short inp_samp[TOT_SAMP+NUM_TAPS-l]; \n' ); fi)rintf( Fid,'static void datalOQ \n' ); fprintf(Fid,'{ \n'); fprintf( Fid,' /* do data 1/0 */ \n' ); fi)rintf( Fid,' return; \n '); lprintf(Fid,'} \n '); N 2 = NN/2; fprintfi Fid.'short coeff_arraylNUM. TARSI = I % s . %s, \n', str(l,Q , str(2,:));_______________________

62

for ii = 2:N2-1 jj = 2 * ii-l;jjl = 2*ii; fprintf( F id; % s , %s, \n', str(ij,:), str(ij 1,:)); end %rintf( F id; % s , % s};\n', str(2*N 2-l,:), str(2*N2,:)); ^ rin tf( Fidj'extem void fir_circ_asm(short *y, short *x, int n, short *h, int s, int m, int size,int indexex); \n' ); Q)rintf( Fid,'void readdata(short *y, short *x, int n, int m); \n' ); ^ rin tf( Fid,'mainO \n' ); ^ rin tf( Fid;{ \n' ); Q)rintf( Fid,' int scale_factor=15; \n' ); %rintf( Fid,' int index=0; \n\n' );

^rintf( Fid,'dataIO0; \n\n');
callnum = floor(TOT_SANfl*/NUM_SAMP)-I; % determine calling subroutine times indexx = NUM_SAMP+NN-1; % the first time input sample length Q)rintf( Fid,'readdata(inp_samp, in_array, 0, %i); \n\n', indexx ); $ rin tf( Fid,'//Call Block FIR algorithm \n' ); fj)rintf( Fid,'fir_circ_asm(out_array, in_array, NUM_TAPS, coefLarray, scale_factor,NUM_SAMP,BUF_LEN,index); \n\n' ); Q)rintf( Fid,'//Compute next INDEX value based on the old INDEX and BLOCK FIR (nor circular \n' ); fprintf( Fid,'//buffer block) size BUFLEN/2 is used since the pointer points to 16 bit data \n\n' ); for ii = 1xallnum %rintf( Fid,'index = (index+NUM_SAMP)-(BUF_LEN/2)*floor((index+NUM_SAMP)/(BUF_LEN/2)); \n \n '); indexx 1 = indexx + (ii-I)*NUM_SAMP; indexx2 = indexx + (ii)*NUM_SAMP; Q)rintf( Fid,'readdata(inp_samp, injarray, %i, %i); \n\n',indexxl, indexx2 ); fprintf( Fid,'fir_circ_asm(&out_array[%i*NUM_SAMP], in_array, NUM_TAPS, coeffjarray, scale_factor,NUM_SAMP,BUF_LEN,index); \n\n',ii ); end Q)rintf( Fid,'void readdata(short init_values[], short array[], int n, int m) \n' ); ^ r in tf ( F id ,'{ V ) ; fyrintf( Fid,' int i, temp; \n' ); ^ rin tf( Fid,' for (i=n;i<m;i++) W ); Q)rintf( Fid,' { \n ',N N ); fprintfC F id ; temp=i-(BUF_LEN/2)*floor(i/(BUF_LEN/2)); \n' ); %rintf( Fid,' array[temp]=init_values[i];\n' ); Q )rintf(Fid; } \n '); f))rintf( Fid,' } \n' ); elseif ( CodeType -- 2) s = [ DFP_TemplatesDir2 'fir_d02.asm' ]; if ( exist(s) ) djappendC Fid, s ); else d_errorCEO-06', s, DFP_TemplatesDir2 ); return; end end

63

The program flow-chart is shown in Figure 6.4.

Get the number of filter coefficients: N No

Make N be a multiple of 4.

Yes Continue decide HR structure type No "4FilterType=0? Yes. Then generate FIR direct form code Yes CodeType=l? No CodeType=2? No END Generate Subroutine Assembly ^ Code of FIR Direct Structure Generate Test File Written in C Program Language

^

Figure 6.4: Program Flow-Chart to Generate Test File and Subroutine Assembly Code

In this flow-chart, Filter Type is used to define which structure code to be generated. Code Type is used to define output code type (test file or subroutine assembly code). Table 6.9 lists the values of these two parameters for different T.I. families.

64

Filter Type TMS32010/TMS32020 TMS320C54X TMS320C67X FIR Direct Form HR Direct Form HR SOS FIR Direct Form FIR Lattice Form HR Direct Form HR Lattice Form HR SOS Table 6.9 Filter Type and Code Type Value

Code Type 1: Macro Code 2:FuIl Code 1: Test File in C Language 2: Subroutine Assembly Code

After we generate test file and subroutine assembly code, we can test these codes on DSP320C6711 DSK and Code Compose Studio software development using the following test procedure.

1. Turn on the power of the DSK. It goes through a Power On Self-Test (POST) procedure first in which the three LEDs count 1-7, and then all LEDs blinks to show that the tests completed successfully. 2. Create a new project called fir.pjt. 3. Create a new DSP/BIOS configuration file called fir.cdb using the dsk6711 .cdb template. Save this file in the same subdirectory. 4. Add the configuration file to the project. This also automatically adds the file fircfg.s62. 5. Also add the linker command file fircfg.cmd automatically generated when we generate DSP/BIOS configuration file. 6. Building the project: In the compiler window, add the new generated FIR subroutine code using assembly language and circular addressing mode as well as parallel instruction execution technique. We also add the C test code consists of filter coefficient array designed from DFP package, circular addressing parameters and a probe point to read

65

input data from computer. After finishing compiling the source files, we build the project by choosing rebuild all. If there is no error occur, an output file is generated. 7. Load and run the program, we can either use an oscilloscope to the DSK output or we use Time/Frequency Graph Display method provided in C6711 DSK to monitor the output waveform.

66

Chapter 7
C onclusions and Future Research
In this study we added multi-band, adaptive and 2-D filter design and some TMS320C54x/TMS320C67x/TMS32010/TMS32020 code generation capability to the DFP. These new features make DFP a powerful digital filter design tool. These new features also make DFP distinct from other digital filter design tools. Table 7.1 provides an overview of the new DFP features developed in this study.

Filter Types Multiband Adaptive 2-D

Filter Design Methods Adaptive LMS Adaptive RLS

Code Generation TMS32010/TMS32020 TMS320C54X TMS320C67X Table 7.1: New DFP features.

Display Option Additional Display Windowfo r Adaptive and 2-D Filter Learning Curve Display

The current DFP depends on significant number of global variables to allow various modules to communicate with each other. Since MATLAB has introduced data structures as part of its programming language, converting DFP such that all global variables are replaced with appropriate structure will be a very desirable enhancement. This will make the entire

67

DFP software package easier to maintain and will allow efficiency in the further development of its capabilities. As part of further development we consider adding interactive pole-zero placement method to be used as a teaching tool. In addition there are other useful digital filter types such as comb filter, notch filter, etc., that can be integrated into DFP.

68

Bibliography
[1]. [2], [3], [4]. Mohamed EL-Sharkawy, Real Time Digital Signal Processing Applications with Motorola' s DSP56000 Family, Prentice-Hall, Englewood Cliffs, New Jersey 07632, Bogner, R.E., Introduction to Digital Filtering, New York, Wiley, London, 1975. Simon Haykin, Adaptive Filter Theory, Prentice Hall Inc., 1984. J.G. Proakis and D.G. Manolakis, Digital Signal Processing: Principles, Algorithms, and Applications, Prentice-Hall, 1996. Sen M. Kuo and Bob H. Lee, Real-Time Digital Signal Processing: Implementations, Applications, and Experiments with the TMS320C55x, John Wiley & Sons, Inc. 2001. Tian-Bo Deng and Masayuki Kawamata, "Design of Separable-Denominator TwoDimensional Digital Filters Based on the REDUCED-Dimensional Decomposition of Frequency Domain Specifications", Electronics and Communications in Japan, Part 3, Vol. 73, No. 9,1990. Y.Kamp and J.P. Thiran, "Chebyshev Approximation for Two-Dimensional Nonrecursive Digital Filters", IEEE Transactions on Circuits and Systems, vol. Cas22, No.3, March 1975. D.G. Manolakis, V.K. Ingle, and S.M. Kogon, Statistical and Adaptive Signal Processing, McGraw Hill, 2000. Filter Design Toolboxfor use with MATLAB, The Mathworks.

[5]. [6].

[7].

[8]. [9].

[10]. MATLAB GUIs, The Mathworks. [11]. Todd Anderson, "The TMS320C2xx Sum-of-Products Methodology", Texas Instruments, SPRA068, May 1996. [12]. "TMS320C4X General-Purpose Applications User's Guide, Digital Signal Processing Solutions," Texas Instruments. [13]. "TMS320C54X DSP Reference Set," Volume 2: Mnemonic Instruction Set, Texas Instrument. [14]. B.C. Ifeachor and B.W. Jervis, Digital Signal Processing: A Practical Approach, Addison Wesley, 1993.

69

[15]. [16]. [17].

Bozic, S. M. (Svetozar Mile), Digital and Kalman filtering: an introduction to discrete-timefiltering and optimum linear estimation^ London: E. Arnold, 1979. Hamming, R. W. (Richard Wesley), Digital filters, Englewood Cliffs, N.J.: PrenticeHall, 1977. Naim Dahnonn, DSP implementation using the TMS3206x processors. New York: Prentice Hall, 2000. Digital Signal Processing Applications with the TMS320 Family Algorithms, and Implementations, Texas Instruments, 1986. Theoiy,

[18]. [19].

"TMS320C6000 Code Composer Studio Tutorial", Literature Number: SPRU301C, February 2000. "TMS320C6000 Assembly Language Tools User's Guide", Literature Number: SPRUl 861, April 2001. `TMS320C6000 Programmer's Guide", Literature Number: SPRUl98G, August 2002 . "TMS320 DSP Algorithm Standard Rules and Guidelines", SPRU352D, January 2001. "Extended Precision HR Filter Design on the TMS320C54x DSP", Literature Number: SPRU454, Texas Instruments Europe, June 1998. "Circular Buffering on TMS320C6000", Literature Number: SPRU645A, April 2001. Developer' s Kit for Texas Instruments DSP - for Use with Real - Time Workshop, The Mathworks. Adaptive Digital Signal Processing course notes. Dr. S. Krishnan, Ryerson University, Toronto, Canada. DFP Program, Dr. M. Zeytinoglu, Ryerson University, Toronto, Canada. WWW.TI.COM.

[20]. [21].

[22].

[23]. [24]. [25].

[26]. [27]. [28].

70


