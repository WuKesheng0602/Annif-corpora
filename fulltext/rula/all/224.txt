A Logic of Actions Revisited
Yilan Gu Dept. of Computer Science University of Toronto 10 King's College Road Toronto, ON, M5S 3G4, Canada Email: yilan@cs.toronto.edu Abstract
We propose a theory for reasoning about actions based on order-sorted predicate logic where one can consider an elaborate taxonomy of objects. We are interested in the projection problem: whether a statement is true after executing a sequence of actions. To solve it we design a regression operator that takes advantage of well-sorted unification between terms. We show that answering projection queries in our logical theories is sound and complete with respect to that of in Reiter's basic action theories. Moreover, we demonstrate that our regression operator based on order-sorted logic can provide significant computational advantages in comparison to Reiter's regression operator.

Mikhail Soutchanski Department of Computer Science Ryerson University 245 Church Street, ENG281 Toronto, ON, M5B 2K3, Canada Email: mes@scs.ryerson.ca
herit from each other and may have non-empty intersections. Hence, we consider formulating the situation calculus in an order-sorted (predicate) logic to describe taxonomic information about objects. We are interested in the projection problem (whether a statement is true after executing a sequence of actions) and we would like to use regression to solve this problem [Reiter, 2001]. Note that even if both many-sorted logic and order-sorted logic can be translated to unsorted, using order-sorted logic can bring about significant computational advantages, for example in deduction. This was a primary driving force for [Walther, 1987] and [Cohn, 1987]. We show that regression in order-sorted SC can benefit from wellsorted unification. One can gain computational efficiency by terminating regression steps earlier when objects of incommensurable sorts are involved. It is well-known that PDDL supports typed (sorted) variables and many implemented planners can take advantage of types [Ghallab et al., 1998]. However, to the best of our knowledge, there is no formal logical foundation for sorted reasoning in planning domains. This paper can be considered as a step towards providing this foundation.

1

Introduction

In his influential paper [Hayes, 1971] titled "A Logic of Actions", Pat Hayes proposed an outline of a logical theory for reasoning about actions based on many-sorted logic with equality. His paper inspired subsequent work on many-sorted logics in AI. In particular, A. Cohn [Cohn, 1987; 1989] developed expressive many-sorted logic and reviewed all previous work in this area. Reasoning about actions based on the situation calculus has been extensively developed in [Reiter, 2001]. However, he considers a logical language with sorts for actions, situations and just one catch-all sort Object for the rest that remains unelaborated. Surprisingly, even if the idea proposed by Hayes seems straightforward, there is still no formal study of logical and computational properties of a version of the situation calculus with many related sorts for objects in the domain. Perhaps, this is because mathematical proofs of these properties are not straightforward. We undertake this study and demonstrate that reasoning about actions with elaborated sorts has significant computational advantages in comparison to reasoning without them. In contrast to an approach to many-sorted reasoning [Schmidt, 1938; Wang, 1952; Herbrand, 1971] where variables of different sorts range over unrelated universes, we consider a case when sorts are related to each other, so that one can construct an elaborated taxonomy. This is often convenient for representation of common-sense knowledge about a domain. Generally speaking, we are usually interested in a comprehensive taxonomic structure for sorts, where sorts may in-

2

Background

In general, order-sorted logic (OSL) [Oberschelp, 1962; 1990; Walther, 1987; Schmidt-Schau , 1989; Bierle et al., 1992; Weidenbach, 1996] restricts the domain of variables to subsets of the universe (i.e., sorts). Notation x : Q means that variable x is of sort Q and VQ is the set of variables of sort Q. For any n, sort cross-product Q1 ×· · ·× Qn is abbreviated as Q1..n ; term vector t1 , . . . , tn is abbreviated as t1..n ; variable vector x1 , . . . , xn is abbreviated as x1..n ; and, variable declaration sequence x1 : Q1 , . . . , xn : Qn is abbreviated as x1..n : Q1..n . A theory in OSL always includes a set of declarations (called sort theory) to describe the hierarchical relationships among sorts and the restrictions on ranges of the arguments of predicates and functions. In particular, a sort theory T includes a set of term declarations of the form t : Q representing that term t is of sort Q, subsort declarations of the form Q1  Q2 representing that sort Q1 is a (direct) subsort of sort Q2 (i.e., every object of sort Q1 is also of sort Q2 ), and predicate declarations of the form P : Q1..n representing that the i-th argument of the n-ary predicate P is of sort Qi for i = 1..n. A function declaration is a special term dec-

laration where term t is a function with distinct variables as arguments: for each n-ary function f , the abbreviation of its function declaration is of the form f : Q1..n  Q, where Qi is the sort of the i-th argument of f and Q is the sort of the value of f . c : Q is a special function declaration, representing that constant c is of sort Q. Arguments of equality "=" can be of any sort. Below, we consider a finite simple sort theory only, in which there are finitely many sorts and declarations, the term declarations are all function declarations, and for each function there is one and only one declaration. For any sort theory T , subsort relation T is a partial ordering defined by the reflexive and transitive closure of the subsort declarations. Then, following the standard terminology of lattice theory, if each pair of sort symbols in T has greatest lower bound (g.l.b.), then we say that the sort hierarchy of T is a meet semi-lattice [Walther, 1987]. Moreover, a well-sorted term (wrt T ) is either a sorted variable, or a constant declared in T , or a functional term f (t1..n ), in which each ti is well-sorted and the sort of ti is a subsort of Qi , given that f : Q1..n  Q is in T . A well-sorted atom (wrt T ) is an atom P (t1..n ) (can be t1 = t2 ), where each ti  is a well-sorted term of sort Q i , and Qi T Qi , given that P : Q1..n is in T . A well-sorted formula (wrt T ) is a formula in which all terms (including variables) and atoms are wellsorted. Any term or formula that is not well-sorted is called ill-sorted. A well-sorted substitution (wrt T ) is a substitution  s.t. for any variable x : Q, x (the result of applying  to x) is a well-sorted term and its sort is a (non-empty) subsort of Q. Given any set E = {(t1,1 , t1,2 ), . . . , (tn,1 , tn,2 )}, where each ti,j (i = 1..n, j = 1..2) is a well-sorted term, a well-sorted most general unifier (well-sorted mgu) of E is a well-sorted substitution that is an mgu of E . It is important that in comparison to mgu in unsorted logic (i.e., predicate logic without sorts), mgu in OSL can include new weakened variables of sorts which are subsorts of the sorts of unified terms. For example, assume that E = {(x, y )}, x  VQ1 , y  VQ2 and the g.l.b. of {Q1 , Q2 } is a non-empty sort Q3 . Then, µ = [x/z, y/z ] (x is substituted by z , y is substituted by z ) for some new variable z  VQ3 is a well-sorted mgu of E . Well-sorted mgu neither always exists nor it is unique. However, it is proved that the well-sorted mgu of unifiable sorted terms is unique up to variable renaming when the sort hierarchy of T is a meet semi-lattice [Walther, 1987]. The semantics of OSL is defined similar to unsorted logic. Note that the definition of interpretations for well-sorted terms and formulas is the same as in unsorted logic, but the semantics is not defined for ill-sorted terms and formulas. For any well-sorted formula , a T -interpretation I = M, I is a tuple for a structure M and an assignment I from the set of free variables to the universe U of M, s.t. it satisfies the following conditions: (1) For each sort Q, QI is a subset of the whole universe U. In particular, I = U, I I = , and QI 1  Q2 for any Q1 T Q2 . (2) For any I predicate declaration P : Q1..n , P I  QI 1 ×· · ·× Qn is a relation in M. (3) For any function declaration f : Q1..n  Q, I I I f I : QI 1 ×· · ·× Qn  Q is a function in M. (4) x = I (x) I I I is in Q for any variable x  VQ , c  Q for any constant
I declaration c : Q, and (f (t1..n ))I = f I (tI 1 , . . . , tn ) for any well-sorted term f (t1..n ). I is not defined for ill-sorted terms def

and formulas. (5) If T includes a declaration for equality symbol "=", then =I must be defined as set {(d, d) | d  U}, i.e., the equality symbol is interpreted by the identity relation on the whole universe. For any sort theory T and a wellsorted formula , a structure M is a T -model of , written as M |=os T  iff for every T -interpretation I = M, I , I satisfies . In particular, when  is a sentence, this does not depend on any variable assignment and I = M. Moreover, we say that a T -interpretation I = M, I satisfies , written as I |=os T , if the following conditions (1-7) hold: (1) I |=os P ( t 1..n ) T os I I os iff (tI , . . . , t )  P . (2) I | = ¬  iff I | =  does not n 1 T T hold. (3) I |=os =os =os T 1  2 iff I | T 1 and I | T 2 . (4) I |=os =os =os =os T 1  2 iff I | T 1 or I | T 2 . (5) I | T 1  2 os os iff I |=T ¬1  2 . (6) I |=T x : Q. iff for every d  QI , I |=os T [x/d], where [x/o] represent the formula obtained by substituting x with o. (7) I |=os T x : Q. iff there is some d  QI s.t. I |=os T [x/d]. Given a sort theory T as the background, a theory  including well-sorted sentences only satisfies a well-sorted sentence , written as  |=os T , iff every model of  is a model of . Note that we follow traditional approaches to sorted reasoning, where sort symbols must not occur as predicates in the formulas and there is the closed world assumption about sorts. Alternative approaches, called hybrid, allow to mix sort symbols with application specific predicates (see [Weidenbach, 1996; Cohn, 1989; Bierle et al., 1992]). Due to the space limitations, we skip the background of the situation calculus. Details can be found in [Reiter, 2001] and we refer to this language as Reiter's situation calculus below. Note that in this paper, we use |=os T to represent the logical entailment wrt a sort theory T in order-sorted logic, |=ms to represent the logical entailment in Reiter's situation calculus (a many-sorted logic with one standard sort Object), and |=fo to represent the logical entailment in unsorted predicate logic.

3

An Order-Sorted Situation Calculus

In this paper, we consider a modified situation calculus based on order-sorted logic, called order-sorted situation calculus and denoted as LOS below. LOS includes a set of sorts Sort = Sortobj  {, , Act, Sit}, where  represents the whole universe,  is the empty sort, Act is the sort for all actions, Sit is the sort for all situations, and Sortobj is a set of sub-sorts of Object including sort Object itself. We assume that for every sort (except ) there is at least one ground term (constant) of this sort to avoid the problem with "empty sorts" [Goguen and Meseguer, 1987]. Moreover, the number of individual variable symbols of each sort in Sort is infinitely countable. For the sake of simplicity, we do not consider functional fluents here. In the following, we will define order-sorted basic action theories (order-sorted BATs) and consider dynamical systems that can be described using such order-sorted BATs. An order-sorted BAT D = (TD , D) includes the following two parts of theories. · TD is a sort theory based on a finite set of sorts QD s.t. QD  Sort and {, , Object, Act, Sit}  QD . Moreover, the sort theory includes the following declarations for finitely many predicates and functions: 1. Subsort declarations of the form Q1  Q2 for Q1 , Q2 

QD - {, Act, Sit}, and subsort declarations: Object  , Act  , Sit  .   Act,   Sit. Here, we only consider those sort theories whose sort hierarchies are meet semi-lattices. 2. One and only one predicate declaration of the form F : Q1..n for each n-ary relational fluent F in the system, where Qi T Object and Qi =  for i = 1..(n - 1), and Qn is Sit. 3. One and only one predicate declaration for the special predicate P oss, that is, P oss : Act × Sit. 4. One and only one predicate declaration of the form P : Q1..n for each n-ary situation independent predicate P in the system, where Qi T Object and Qi =  for i = 1..n. 5. A special declaration for equality symbol = : ×. 6. One and only one function declaration of the form A : Q1..n  Act for each n-ary action function A in the system, where Qi T Object and Qi =  for i = 1..n. Note that, when n = 0, the declaration is of form A : Act for constant action function A. 7. One and only one function declaration of the form f : Q1..n  Qn+1 for each n-ary (n  0) situation independent function f (other than action functions), where each Qi T Object and Qi =  for each i = 1..(n + 1). Note that, when n = 0, it is a function declaration for a constant, denoted as c : Q for constant c of sort Q. 8. One and only one function declaration do : Act×Sit  Sit, and S0 : Sit for the initial situation S0 . · D is a set of axioms represented using well-sorted sentences wrt TD , which includes the following subsets of axioms. 1. Foundational axioms  for situations, which are the same as those in [Reiter, 2001]. 2. A set Duna of unique name axioms for actions: for any two distinct action function symbols A and B with declarations A : Q1..nAct and B : Q 1..mAct, we have
(x1..n : Q1..n , y1..m : Q 1..m ). A(x1..n ) = B (y1..m )

where F (x1..n , a, s) is a well-sorted formula uniform in s, whose free variables are at most among x1..n and a, s. Here is a simple example of an order-sorted BAT. Example 1 (Transport Logistics) We present an order-sorted BAT D of a simplified example of logistics. TD includes following subsort declarations:
M ovObj  Object,   City ,   Box,   T ruck, T ruck  M ovObj , City  Object, Box  M ovObj ,

where M ovObj is the sort of movable objects, and other sorts are self-explanatory. The predicate declarations are
InCity : M ovObj × City × Sit, On : Box × T ruck × Sit

for the fluents InCity (o, l, s) and On(o, t, s). The function declarations for actions load(b, t), unload(b, t) and drive(t, c1 , c2 ) are obvious. For instance,
drive : T ruck × City × City  Act

Besides S0 : Sit, the constant declarations may include:
B1 : Box, T2 : T ruck, B2 : Box, P asadena : City , T1 : T ruck, Boston : City .

Axioms in DS0 can be:
x : Box. InCity (x, Boston, S0 ), (x : Box, t : T ruck). ¬On(x, t, S0 ), InCity (T1 , Boston, S0 )  InCity (T2 , Boston, S0 ).

As an example, the precondition axiom for load is:
(x : Box, t : T ruck, s : Sit). P oss(load(x, t), s)  ¬On(x, t, s)  y : City.InCity (x, y, s)  InCity (t, y, s),

and the preconditions for unload and drive are obvious. As an example, the SSA of fluent InCity is:
(d : M ovObj, c : City, a : Act, s : Sit). InCity (d, c, do(a, s))  (t : T ruck, c1 : City ). a = drive(t, c1 , c)  (d = t  b : Box.b = d  On(b, t, s)))  InCity (d, c, s)  ¬(t : T ruck, c1 : City.a = drive(t, c, c1 ) (d = t  b : Box.b = d  On(b, t, s))),

and the SSA of fluent On is obvious.

Moreover, for each action function symbol A, we have
(x1..n : Q1..n , y1..n : Q1..n ). A(x1..n )=A(y1..n ) 

3. The initial theory DS0 , which includes well-sorted (firstorder) sentences that are uniform in S0 . In particular, it includes the unique name axioms for object contants. For clarity, it also includes finitely many axioms of disjointness for basic sorts of the form x : Qi .y : Qj .(x = y ) for all distinct basic sorts Qi and Qj , where Qi , Qj are considered basic sorts if   Qi and   Qj are in TD , and there are no sorts Q = , Q = , such that Q  Qi and Q  Qj . Notice that these conditions actually are consequences of the semantics of the subsort declarations in the sort theory TD . 4. A set Dap of precondition axioms for actions represented using well-sorted formulas: for each action symbol A, whose sort declaration is A : Q1..n  Act, its precondition axiom is of the form
(x1..n : Q1..n , s : Sit).P oss(A(x1..n ), s)  A (x1..n , s), (1)

Vn

i=1

xi = yi

4

Order-Sorted Regression and Reasoning

where A (x1..n , s) is a well-sorted formula uniform in s, whose free variables are at most among x1..n and s. 5. A set Dss of successor state axioms (SSAs) for fluents represented using well-sorted formulas: for each fluent F with declaration F : Q1..n × Sit, its SSA is of the form
(x1..n : Q1..n , a : Act, s : Sit). F (x1..n , do(a, s))  F (x1..n , a, s), (2)

We now consider the central reasoning mechanism in the order-sorted situation calculus. The definition of a regressable formula of LOS is the same as the definition of a regressable formula of Lsc except that instead of being stated for a formula in Lsc , it is formulated for a well-sorted formula in LOS . A formula W of LOS is regressable (wrt an order-sorted BAT D) iff (1) W is a well-sorted first-order formula wrt TD ; (2) every term of sort Sit in W starts from S0 and has the syntactic form do([1 , · · · , n ], S0 ), where each i is of sort Act; (3) for every atom of the form P oss(,  ) in W ,  has the syntactic form A(t1..n ) for some n-ary action function symbol A; and (4) W does not quantify over situations, and does not mention the relation symbols "<" or "=" between terms of sort Sit. A query is a regressable sentence. Example 2 Consider the BAT D from Example 1. Let W be
d : Box. d = Boston  On(d, T1 , do(load(B1 , T1 ), S0 ))

W is a (well-sorted) regressable sentence (wrt D); while
On(Boston, T1 , do(load(B1 , T1 ), S0 ))

is ill-sorted and therefore is not regressable.

The regression operator Ros in LOS is defined recursively similar to the regression operator in [Reiter, 2001]. Moreover, we would like to take advantages of the sort theory during regression: when there is no well-sorted mgu for equalities between terms that occur in a conjunctive sub-formula of a query, this sub-formula is logically equivalent to false and it should not be regressed any further. We will see that this key idea helps eliminate useless sub-trees of a regression tree. In what follows, t and  are tuples of terms,  and  are terms of sort Act,  and   are terms of sort Sit, and W is a regressable formula of LOS . 1. If W is a non-atomic formula and is of the form ¬W1 , W1  W2 , (v : Q).W1 or (v : Q).W1 , for some regressable formulas W1 ,os W2 in LOS , then os
Ros [W1  W2 ] = Ros [W1 ]  Ros [W2 ].

3(d) Otherwise, if atom W has S0 as its only situation term, then Ros [W ] = W . Notice that although the definition seems to depend on syntactic form of a formula, we prove below that for any regressable formulas W1 and W2 in LOS that are logically equivalent, their regressed results are still equivalent wrt D (See Corollary 1). Here are some examples. Example 3 Consider the order-sorted BAT D from Example 1 and the query W from Example 2. Then, it is easy to see that Ros [W ] = f alse, since there is no well-sorted mgu for (d, Boston), where d : Box. Now, let W1 be
¬d : Box. d = Boston  ¬On(d, T1 , do(load(B1 , T1 ), S0 )).

W1 is a sentence that is equivalent to W . It is easy to check R [W1 ] = R [W1 ] for constructor   {¬, (x : Q), (x : Q)} that Ros [W1 ] is a formula equivalent to f alse (wrt D ). Given an order-sorted BAT D = (TD , D) and the ordersorted regression operator defined above, to show the correctness of the newly defined regression operator, we prove the following theorems similar to that of in [Reiter, 2001]. Theorem 1 If W is a regressable formula wrt D, then Ros [W ] is a well-sorted LOS formula (including f alse) that os is uniform in S0 . Moreover, D |=os TD W  R [W ]. Theorem 2 If W is a regressable formula wrt D, then
os D |=os =os TD W iff DS0  Duna | TD R [W ].

2. Else, if W is a non-atomic formula, W is not of the form ¬W1 , W1  W2 , (v : Q)W1 or (v : Q)W1 , but of the form W1  W2  · · ·  Wn (n  2), where each Wi (i = 1..n) is not of the form Wi,1  Wi,2 for some sub-formulas Wi,1 , Wi,2 in Wi . After using commutative law for , without loss of generality, there are two sub-cases: 2(a) Suppose that for some j , j = 1..n, each Wi (i = 1..j ) is of the form ti,1 = ti,2 for some (well-sorted) terms ti,1 , ti,2 , and none of Wk , k = (j + 1)..n, is an equality between terms. In particular, when j = n,
n k=j +1

Wk = true. Then,

def

 is a new formula obtained by applying mgu µ Here, W0 n to k=j +1 Wk and it is existentially-quantified at front for every newly introduced sort weakened variable in µ. Moreover, note that based on the assumption that we consider meet semi-lattice sort hierarchies only, such mgu is unique if it exists. 2(b) Otherwise, Ros [W ] = Ros [W1 ]  · · ·  Ros [Wn ]. 3. Otherwise, W is atomic. There are four sub-cases. 3(a) Suppose that W is of the form P oss(A(t),  ) for an action term A(t) and a situation term  , and the action precondition axiom for A is of the form (1). Without loss of generality, assume that all variables in Axiom (1) have had been renamed (with variables of the same sorts) to be distinct from the free variables (if any) of W . Then,

8 os  > < W1  W2  · · ·  Wj  R [W0 ] if there is a well-sorted mgu µ Ros [W ] = for { t , t | i = 1 ..j }; i, 1 i, 2 > : f alse otherwise.

Hence, to reason whether D |=os TD W is the same as to compute Ros [W ] first and then to reason whether DS0 Duna |=os TD Ros [W ]. Besides, according to Theorem 1, it is easy to see that the following consequence holds. Corollary 1 If W1 and W2 are regressable formulas in LOS os os =os s.t. |=os TD R [W1 ]  R [W2 ]. TD W1  W2 , then D | Intuitively, Corollary 1 states that the regressed results of two logically equivalent regressable formulas (possibly having different syntactic forms only) are still equivalent.

5

Order-Sorted Situation Calculus v.s. Reiter's Situation Calculus

Although BATs and regressable formulas in LOS are based on OSL, they can be related to BATs and regressable formulas in Reiter's situation calculus as stated in Theorem 3. Theorem 3 (Soundness) For any BAT D and any query W in order-sorted situation calculus LOS , there exists a corresponding BAT D and a corresponding query W  in Reiter's situation calculus s.t.
 D |=os =ms W  . TD W iff D |

Ros [W ] = Ros [A (t,  )].

3(b) Suppose that W is of the form F (t, do(,  )) for some relational fluent F . Let F 's SSA be of the form (2). Without loss of generality, assume that all variables in Axiom (2) have had been renamed (with variables of the same sorts) to be distinct from the free variables (if any) of W . Then, Ros [W ] = Ros [F (t, ,  )]. 3(c) Suppose that atom W is of the form t1 = t2 . for some well-sorted terms t1 , t2 . Then,
R [W ] =
os

(

W f alse

if there is a well-sorted mgu µ for t1 , t2 ; otherwise.

Intuitively, we would like to show that the order-sorted situation calculus LOS is correct, or sound, in the sense that for any query in LOS that can be answered in its background BAT in LOS , we always can find a way to represent the BAT and the query in Reiter's situation calculus Lsc s.t. the corresponding query in Lsc can be answered wrt the corresponding BAT in Lsc . It is hard to prove Theorem 3 directly. Inspired by the standard relativization of OSL to unsorted (first-order) logic, our general idea of proving Theorem 3 is as follows. In Step 1,

we prove that there is an unsorted theory D (via strong relativization) and an unsorted first-order sentence W  (via rela tivization) s.t. D |=os =fo W  . In Step 2, we conTD W iff D |  struct a BAT D (called the corresponding Reiter's BAT of D below) and a regressable formula W  (called the translation of W below) in Reiter's situation calculus, s.t. D |=ms W  iff D |=fo W  , for some unsorted theory D (via standard relativization) and sentence W  (via relativization). Finally, in Step 3, we show that D |=fo W  iff D |=fo W  . D |=os TD W D |=ms W 
(Step 1)

Definition 3 For any order-sorted BAT D in LOS , the strong relativization of D, an unsorted theory, is defined as
RELS (D) = rel(D)  SBA(TD ).
def

Consider any BAT D1 in Reiter's situation calculus Lsc , which has a finite set TD1 of function declarations and predicate declarations for all predicates and functions appeared in D1 . The standard relativization of D1 , an unsorted theory, is defined as
REL(D1 ) = rel(D1 )  BA(TD1 ).
def



D |=fo W 
(Step 3)

(Step 2)



D |=fo W 

Fig 1. Diagram of the Outline for Proving Theorem 3 To prove Theorem 3, we first define some concepts and prove Lemma 1 for later convenience. First, for any sort Q in the language of LOS , we introduce a unary predicate Q(x), which will be true iff x is of sort Q in LOS . Definition 1 For any well-sorted formula  in LOS , rel(), a relativization of , is an unsorted formula defined as:
For every atom P (t), rel(P (t)) = P (t); rel(¬) = ¬rel(); rel(   ) = rel()  rel( ) for   {, , }; rel((x : Q)) = (y )[Q(y )  rel([x/y ])]; rel((x : Q)) = (y )[Q(y )  rel([x/y ])].
def def def def def

The reasons for differences between the two cases in Def. 3 are that (1) we include the sort theory in each BAT of ordersorted situation calculus, while Reiter's situation calculus mentions sort declarations generally in the signature of Lsc , and (2) we need strong relativization for order-sorted BATs and only need standard relativization for Reiter's BATs to prove Theorem 3. In comparison to the standard relativization, the strong relativization adds additional axioms of the form (d) and (e) in Def. 2. They are based on the sort theory that includes one and only one declaration for each predicate P or for each function f , respectively. We can also prove a relativization theorem as follows for the strong relativization similar to the Sort Theorem proved in [Walther, 1987] and/or the relativization theorem proved in [Schmidt-Schau , 1989]. Lemma 1 Consider any regressable formula W with a background BAT D in order-sorted situation calculus LOS . Then,
D |=os =fo rel(W ). TD W iff RELS (D ) |

Moreover, for any set Set of well-sorted formulas,
rel(Set) = {rel() |   Set}.

Note that all formulas in Lsc are well-sorted wrt the sort theory of Lsc . Hence, the definition of rel can also be applied to any formula or a set of formulas in Reiter's situation calculus. Definition 2 For any sort theory TD in LOS , the set of bridge axioms of TD , BA(TD ), is a set of the following formulas: (a) (x). Q2 (x)  Q1 (x) for each Q2  Q1  TD ; (b) Q(c) for each c : Q  TD ; V (c) (x1..n ). n i=1 Qi (xi )  Q(f (x1..n )) for each f : Q1..n 
Q  TD .

We therefore can prove Step 1 in Fig. 1 using Lemma 1. Because Reiter's situation calculus is a many-sorted logical language with special formats for precondition axioms and SSAs, we cannot use rel to relate D in LOS with a Reiter's BAT directly. It is also the reason why strong relativization is introduced. To construct a Reiter's BAT D and a regressable formula W  that satisfy the theorem, we first define another translation function tr(W ) as follows. Definition 4 Consider any well-sorted formula  in LOS . A translation of  to a (well-sorted) sentence in Reiter's situation calculus, denoted as tr(), is defined recursively as follows: def def For every atom P (t), tr(P (t)) = P (t); tr(¬) = ¬tr();
tr((x : )) = f alse; tr((x : Q)) = ¬tr((x : Q. ¬)); tr((x : Q)) = (x : Q)tr(), if Q  {Object, Act, Sit}. tr((x : )) = (x : Object)tr()  (x : Act)tr() (x : Sit)tr(); tr((x : Q)) = (y : Object)[Q(y )  tr((x/y ))], if Q {, , Object, Act, Sit}; tr(   ) = tr()  tr( ) for   {, , , , }.
def def def def def def

Moreover, let Sorted(x) be an auxiliary predicate that does not appear in D: it is a purely technical device used for proving Theorem 3. The set of strong bridge axioms of TD , SBA(TD ), is also a set of unsorted axioms BA(TD )  sba(TD ), where sba(TD )V includes the following axioms: (d) (x1..n ).P (x1..n )  n i=1 Qi (xi )  Sorted(xi ) for each P : Q1..n  TD ; V (e) (x1..n ).Q(f (x1..n ))  Sorted(f (x1..n ))  n i=1 (Qi (xi )  Sorted(xi )) for each f : Q1..n  Q  TD . Intuitively, Sorted(t) means that term t is well-sorted (wrt D). (a functional term is well-sorted and of its own sort, respectively), then all its arguments should be well-sorted and of the corresponding sorts wrt the predicate declaration (the function declaration, respectively). Note that although Sorted may satisfy other characterizing axioms than axioms in (d) and (e) according to its intuitive meaning, but adding axioms in (d) and (e) to the strong relativization theory of D defined below is enough for us to prove Theorem 3.

The translation function tr defined above is a mapping from well-sorted formulas wrt the sort theory of some BAT D (or, wrt D for simplicity) in LOS to well-sorted formulas in Lsc . Moreover, it is easy to prove by structural induction the following lemma for rel and tr, which will be useful for proving Theorem 3. Lemma 2 Consider any well-sorted formula  in LOS . Then, |=fo rel(tr())  rel().

Consider any order-sorted BAT D. We construct the corresponding Reiter's BAT of D, denoted as TR(D), that will be the Reiter's BAT we are looking for in Theorem 3. Notice that in [Reiter, 2001], sorted quantifiers are omitted as a convention, because their sorts are always obvious from context. Hence, when we construct the BAT TR(D) in Reiter's situation calculus below, all free variables are implicitly universally sorted-quantified according to their obvious sorts. The function and predicate declarations are always standard, hence are not mentioned here. · TR(D) includes the foundational axioms and the set of unique name axioms for action functions in Reiter's situation calculus.  , includes the fol· The initial theory of TR(D), say DS 0 lowing axioms. Note that for axioms in items (3)­(5) below, predicate Sorted is auxiliary wrt D and each xi is universally quantified with a default sort Object (Qi itself, respectively) if Qi T Object (Qi T Object, respectively).  . 1. For any well-sorted sentence   DS0 , tr() is in DS 0 2. For each declaration Q2  Q1 in TD , add an axiom tr((x :
).(y2 : Q2 .x = y2 )  (y1 : Q1 .x = y1 )).

in F (x1..n , s). Let D = TR(D), W  = tr(W ), we then can prove Theorem 3 by following the ideas presented in Fig. 1. Details are omitted due to the space limitations. Example 4 Consider the BAT D from Example 1. The axioms in TR(D) are mostly obvious. Due to the space limitations, we just provide examples of a precondition axiom and an SSA in TR(D):
P oss(load(x, t), s)  Box(x)  T ruck(t)  ¬On(x, t, s) (y.City (y )  InCity (x, y, s)  InCity (t, y, s)), InCity (d, c, do(a, s))  M ovObj (d)  City (c) [(t, c1 .T ruck(t)  City (c1 )  a = drive(t, c1 , c) (d = t  b.Box(b)  b = d  On(b, t, s))) InCity (d, c, s) ¬(t, c1 .T ruck(t)  City (c1 )  a = drive(t, c, c1 ) (d = t  b.Box(b)  b = d  On(b, t, s)))].

3. For each declaration f : Q1..n  Q in TD (n  1), add an axiom tr((x1..n : Q1..n ).(y : Q).y = f (x1..n )). We also add an axiom
Q(f (x1..n ))  Sorted(f (x1..n ))  V tr((y1..n : Q1..n ). n i=1 (xi = yi  Sorted(xi ))) if Q T Object and Q = Object, or add an axiom ((y : Q).y = f (x1..n )  Sorted(y ))  V tr((y1..n : Q1..n ). n i=1 (xi = yi  Sorted(xi )))

It is important to notice that all queries LOS have to be well-sorted wrt the given background order-sorted BAT D; while, in general, the queries that can be answered in the corresponding Reiter's BAT of D are not necessarily well-sorted wrt D. Below, Theorem 4 shows that for any query that can be answered in TR(D), it can be answered in D in a "wellsorted way" too. Theorem 4 (Completeness) Let D be an order-sorted BAT in LOS , and TR(D) be its corresponding Reiter's BAT. Then, for any query W in Reiter's situation calculus, W can be translated to a (well-sorted) query wrt D, denoted as os(W ) below, s.t. TR(D) |=ms tr(os(W ))  W . Furthermore, we have TR(D) |=ms W iff D |=os TD os(W ). To prove Theorem 4, we first define some new concepts and prove a lemma. Definition 5 Let D be a BAT in the order-sorted situation calculus LOS , and TR(D) be its corresponding Reiter's BAT. Any term t in Reiter's situation calculus is a possibly sortable term wrt D, if one of the following conditions holds: (1) t is a variable of sort Act, Object or Sit in Lsc ; (2) t is a constant c, and c : Q in TD (we say that the sort of c is Q wrt D); or, (3) t is of form f (x1..n ), function declaration f : Q1..n  Q in TD , for every i (i = 1..n), ti either is a variable or is a non variable term of sort Q i wrt D and Qi T Qi in TD (we say that the sort of f (t1..n ) is Q wrt D). Similarly, any atom P (t1..n ) in Reiter's situation calculus (can be t1 = t2 ), which is well-sorted wrt TR(D), is a possibly sortable atom wrt D, if for every i, ti either is a variable or is a non-variable term s.t.: (a) it is possibly sortable wrt D; and (b) P : Q1..n is in TD (=: ×, respectively), the sort of ti  is Q i wrt D and Qi T Qi wrt D . Given any D in order-sorted situation calculus, it is easy to see that every atom (term, respectively) in TR(D) that can be considered as well-sorted wrt D is always a possibly sortable atom (term, respectively); while a possibly sortable atom (term, respectively) is not necessarily well-sorted wrt D.

F (x1..n , S0 )  tr((y1..n : Q1..n ).

6. For any constant declaration c : Q where Q T Object and Q = Object, add an axiom Q(c). Note that other constant declarations will still be kept in the sort theory of Lsc by default (e.g., S0 : Sit). · For action A(x1..n ) whose precondition axiom in Dap has the form Eq. (1), we replace it with a precondition axiom in the format of Reiter's situation calculus:
P oss(A(x1..n ), s)   A (x1..n , s) (3)

5. For each fluent declaration F : Q1..n × Sit, add an axiom Vn i=1 (xi = yi  Sorted(xi ))).

otherwise. 4. For each situation-independent predicate declaration P : Q1..n , add an axiom V P (x1..n )  tr((y1..n : Q1..n ). n i=1 (xi = yi  Sorted(xi ))).

where  Lsc formula uniform in s, resulting A (x1..n , s) is a V from tr((y1..n : Q1..n ).( n i=1 xi = yi )  A (y1..n , s)). Here, all yi 's are distinct auxiliary variables never appearing in A (x1..n , s). · For each relational fluent F (x1..n , s), whose SSA in Dss is of the form Eq. (2), we replace it with SSA in the format of Reiter's situation calculus:
F (x1..n , do(a, s))
 F (x1..n , a, s)



 (x1..n , a, s) F

(4)

where is a Lsc formula uniform in s, resultV ing from tr((y1..n : Q1..n ). n i=1 xi = yi  F (y1..n , a, s)). Here, all yi 's are distinct auxiliary variables never appearing

Lemma 3 Let D be a BAT in the order-sorted situation calculus LOS , and TR(D) be its corresponding Reiter's BAT. Then, for any atom P (t1..n ) (can be t1 = t2 ) that is wellsorted in Lsc but not possibly sortable wrt D, we have TR(D) |=ms P (t1..n )  f alse. Now we define a function which transforms a formula in Lsc wrt TR(D) to a well-sorted formula in LOS wrt D.

Then, os(W4 ) is s : Sit.o : Object.¬(b : M ovObj.b = o  InCity (b, P asadena, s)), since TR(D) |=ms InCity (o, c, s)  M ovObj (o)City (c). And it is easy to prove that TR(D) |=ms W4  tr(os(W4 )).

6

Computational Advantages of LOS

In this section, we discuss the advantages of using OSL and the order-sorted regression operator based on it. Definition 6 Let D be a BAT in the order-sorted situation calGiven any BAT D in LOS , it is easy to see that Reiter's OS culus L , TR(D) be its corresponding Reiter's BAT and regression operator R [Reiter, 2001] still can be applied to W be a regressable sentence in Lsc wrt the background BAT (well-sorted) regressable formulas (wrt D). Moreover, one TR(D). Then, function os(W ) is defined recursively as folcan prove that R[W ] is a formula in LOS uniform in S0 and lows. D |=os TD W  R[W ]. However, using the order-sorted regression operator Ros sometimes can give us computational ad1. If W is either of the form (x)W1 , (x)W1 , where vantages in comparison to using Reiter's regression operator the default sort of x is Q (either Object, Act or Sit) R. But first of all, we show that the computational complexdef in TR(D), then os((x)W1 ) = (x : Q)os(W1 ), and ity of using Ros is no worse than that of R. def os(x.W1 ) = (x : Q)os(W1 ). For the regression operator R that can be used either in LOS or in Lsc (Ros used in LOS , respectively), we can con2. If W is one of the form ¬W1 , W1  W2 , W1  W2 , then def def struct a regression tree rooted at W for any regressable query os(¬W1 ) = ¬os(W1 ), os(W1  W2 ) = os(W1 )  os(W2 ), W in either language. Each node in a regression tree of def os(W1  W2 ) = os(W1 )  os(W2 ). R[W ] (Ros [W ], respectively) corresponds to a sub-formula def computed by regression, and each edge corresponds to one 3. If W is atomic and not possibly sortable, then W = step of regression according to the definition of the regression f alse. operator. In the worst case scenario, for any query W in LOS , 4. If W is atomic and possibly sortable, assume that the regression tree of Ros [W ] will have the same number of var(W ) = x1 , · · · , xn is the vector of free varinodes as the regression tree of R[W ] (and linear to the numables appeared from left to right in W (including reber of nodes in the regression tree of R[tr(W )] wrt TR(D)). peated ones). For each i = 1..n, suppose that xi apMoreover, based on the assumption that our sort theory of D pears as an argument of a function fi in some term or is simple with empty equational theory, whose correspondas an argument of a predicate Pi in W . Let Qi be the ing sort hierarchy is a meet semi-lattice, finding a unique sort appeared in the ki -th position of the declaration (well-sorted) MGU takes the same time as in the unsorted of fi (Pi , respectively), if xi appears in the ki -th pocase [Schmidt-Schau , 1989; Jouannaud and Kirchner, 1991; sition of fi (Pi , respectively) in W . Then, let IW = Weidenbach, 1996]. Hence, the overall computational com{i | xi  var(W ), Qi T Object, Qi = Object}, and plexity of building the regression tree of Ros [W ] is at most linear to the size of Reiter's regression tree. y : Q = {yi : Qi | i  IW }, where yi 's are auxiliary variables never appeared in W and each yi is distinct from Theorem 5 Consider any regressable sentence W with a def others. And, os(W ) = (y : Q)(W0  iIW xi = yi ), background BAT D in order-sorted situation calculus LOS . where W0 is obtained from substituting each xi with yi Then, in the worst case scenario, the complexity of computfor i  IW . ing Ros [W ] is the same as that of computing R[W ], which is also the same as the complexity of computing R[tr(W )] in Proof sketch for Theorem 4. First, for any query W in Rethe corresponding Reiter's BAT TR(D). iter's situation calculus, let W  = os(W ). By using structural  On the other hand, under some circumstances, the regresinduction and Lemma 3, it is easy to prove that W is a wellsion of a query in LOS using Ros instead of R will give us sorted query wrt D in OSL and TR(D) |=ms W  tr(W  ). computational advantages. Consider any query (i.e., a reThen, by Theorem 3 and TR(D) |=ms W  tr(W  ), it is  ms  gressable sentence) W with a background BAT D in LOS . easy to see that D |=os W iff TR ( D ) | = tr ( W ) iff TD ms Then, the computation of Ros [W ] wrt D can sometimes terTR(D) |= W . Proof details are omitted due to the space minate earlier than that of R[W ] wrt D, and also earlier than limitations. But, we provide some examples below to illusthe computation of R[tr(W )] wrt TR(D). In particular, we trate the statement. have the following property. Example 5 Here are simple examples of computing os(W ) from W in Lsc . Consider the TR(D) in Example 4. Let Theorem 6 Let a regressable formula W have the syntacOn(Boston, T1 , S1 ) (denoted as W3 ) be a query in Lsc , tic form t1,1 = t1,2  . . .  tm,1 = tm,2  W1 , with any where S1 is some situation instance. According to the way background order-sorted BAT D in LOS . Let the size of W TR(D) is constructed, we have TR(D) |=ms On(o, t, s)  (including the length of the terms in W ) be n. If there is no Box(o) and TR(D) |=ms ¬Box(Boston). So, TR(D) |=ms well-sorted mgu for equalities between terms, then Computdef ing Ros [W ] runs in time O(n), while computing R[W ] wrt W3  f alse. Hence, os(W3 ) = f alse. D (R[tr(W )] wrt TR(D)) runs in time O(2n ). Moreover, the Let W4 be s.o. ¬InCity (o, P asadena, s), which is also a size of the resulting formula of Ros [W ], which is f alse, is query in Lsc , where o : Object and s : Sit hold by default.

always constant, while the size of the resulting formula using R is in O(2n ). According to the definition of Reiter's regression operator, the equalities will be kept and regression will be further performed on W1 (or on tr(W1 ) in TR(D), respectively), which in general takes exponential time wrt the length of W1 and causes exponential blow-up in the size of the formula. Once Reiter's regression has terminated, a theorem prover will find that the resulting formula is false either because there is no mgu for terms when reasoning is performed in LOS (or, due to the clash between sort related predicates when reasoning in Lsc , respectively). Hence, using the order-sorted regression operator can sometimes prune brunches of the regression tree built by R exponentially (wrt the size of the regressed formula), and therefore save computation time significantly. Example 6 Consider the BAT D from Example 1. Let W5 be a LOS query (i.e., a (well-sorted) regressable sentence) InCity (T1 , P asadena, do(drive(T1 , Boston, P asadena), S1 )), where S1 is a well-sorted ground situation term that involves a long sequence of actions. According to the SSA of InCity , at the branch of computing Ros [b : Box.b = T1  On(b, t, S1 )] in the regression tree, since there is no well-sorted mgu for (b, T1 ), the application of order-sorted regression equals to f alse immediately. However, using Reiter's regression operator (no matter in D or in TR(D)), his operator will keep doing useless regression on On(b, t, S1 ) until getting (a potentially huge) sub-formula uniform in S0 . Once his regression has terminated, such sub-formula will also be proved equivalent to f alse wrt the initial theory (DS0 or TR(D)S0 , respectively) using a theorem prover, for the same reason as above. In addition, since our sort theory of a BAT D in LOS is finite and it has one and only one declaration for each function and predicate symbol, for any query W (wrt TR(D)) in Lsc , it takes linear time (wrt the length of the query) to find a well-sorted formula os(W ) in LOS that satisfies Theorem 4. But, reasoning whether D |=os TD os(W ) (starting from finding os(W )) sometimes can terminate earlier than finding whether TR(D) |=ms W . In particular, we have Theorem 7 Assume that W = F (t, do([1 , · · · , n ], S0 )) is an atomic fluent instance in Lsc that includes an ill-sorted ground term wrt D (e.g., W3 in Example 5). Then, it takes at most linear time to terminate reasoning by computing the corresponding os(W ) (which is false). Observe that reasoning about TR(D) |=ms W directly, for the formula W mentioned in Theorem 7, using regression R could result in a exponentially large regression tree when computing R[W ]. Also, the size of the resulting formula can be exponentially larger than that of W . Moreover, it still needs further computational steps to find whether TR(D)S0  TR(D)una |=ms R[W ].

Bierle et al., 1992; Weidenbach, 1996]. Another possibility is to consider efficient reasoning in our framework by identifying specialized classes of queries or decidable fragments [Abadi et al., 2007]. Finally, we are planning to work on an efficient implementation of our theory.

References
[Abadi et al., 2007] Aharon Abadi, Alexander Moshe Rabinovich, and Mooly Sagiv. Decidable fragments of many-sorted logic. In LPAR, volume 4790 of Lecture Notes in Computer Science, pages 17­31. Springer, 2007. [Bierle et al., 1992] C. Bierle, U. Hedtst¨ uck, U. Pletat, P. H. Schmitt, and J. Siekmann. An order-sorted logic for knowledge representation systems. Artificial Intelligence, 55(2-3):149­191, 1992. [Cohn, 1987] Anthony G. Cohn. A more expressive formulation of many sorted logic. J. Autom. Reason., 3(2):113­200, 1987. [Cohn, 1989] Anthony G. Cohn. Taxonomic reasoning with many sorted logics. Artificial Intelligence Review, 3(2-3):89­128, 1989. [Ghallab et al., 1998] M. Ghallab, a. Howe, C. Knoblock, D. McDermott, A. Ram, M. Veloso, D. Weld, and D. Wilkins. PDDL the planning domain definition language. Technical report, Yale Center for Computational Vision and Control, Technical Report CVC TR-98-003/DCS TR-1165, 1998. [Goguen and Meseguer, 1987] J. A. Goguen and J. Meseguer. Remarks on remarks on many-sorted equational logic. SIGPLAN Notices, 22(4):41­48, 1987. [Hayes, 1971] Patrick J. Hayes. A logic of actions. Machine Intelligence, 6:495­520, 1971. [Herbrand, 1971] Jacques Herbrand. Logical Writings. Harvard University Press, Cambridge, 1971. Warren D. Goldfarb (ed.). [Jouannaud and Kirchner, 1991] Jean-Pierre Jouannaud and Claude Kirchner. Solving equations in abstract algebras: A rule-based survey of unification. In Computational Logic - Essays in Honor of Alan Robinson, pages 257­321. MIT Press, 1991. [Oberschelp, 1962] Arnold Oberschelp. Untersuchungen zur mehrsortigen quantorenlogik (in German). Mathematische Annalen, (145):297­333, 1962. [Oberschelp, 1990] Arnold Oberschelp. Order sorted predicate logic. In Sorts and Types in Artificial Intelligence, volume 418 of Lecture Notes in Computer Science, pages 8­17. Springer, 1990. [Reiter, 2001] Raymond Reiter. Knowledge in Action: Logical Foundations for Describing and Implementing Dynamical Systems. MIT Press, 2001. [Schmidt-Schau , 1989] M. Schmidt-Schau . Computational aspects of an order-sorted logic with term declarations. SpringerVerlag, New York, 1989. ¨ [Schmidt, 1938] Arnold Schmidt. Uber deduktive theorien mit mehreren soften von grunddingen. Mathematische Annalen, (115):485­506, 1938. [Walther, 1987] Christoph Walther. A many-sorted calculus based on resolution and paramodulation. Morgan Kaufmann, San Francisco, 1987. [Wang, 1952] Hao Wang. Logic of many sorted theories. Symbolic Logic, 17(2):105­116, 1952. [Weidenbach, 1996] Christoph Weidenbach. Unification in sort theories and its applications. Annals of Math. and AI, 18(2/4):261­ 293, 1996.

7

Conclusions

We propose a logical theory for reasoning about actions wrt a taxonomy of objects based on OSL. We also define a regression-based reasoning mechanism that takes advantages of sort theories, and discuss the computational advantages of our theory. One possible future work can be extending our logic to hybrid order-sorted logic [Cohn, 1989;

