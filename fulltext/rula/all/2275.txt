Ryerson University

Digital Commons @ Ryerson
Theses and dissertations

1-1-2013

Position Domain Synchronization Control For Robotic Manipulators
Vangjel Pano
Ryerson University

Follow this and additional works at: http://digitalcommons.ryerson.ca/dissertations Part of the Aerospace Engineering Commons Recommended Citation
Pano, Vangjel, "Position Domain Synchronization Control For Robotic Manipulators" (2013). Theses and dissertations. Paper 2049.

This Thesis is brought to you for free and open access by Digital Commons @ Ryerson. It has been accepted for inclusion in Theses and dissertations by an authorized administrator of Digital Commons @ Ryerson. For more information, please contact bcameron@ryerson.ca.

POSITION DOMAIN SYNCHRONIZATION CONTROL FOR ROBOTIC MANIPULATORS
By

Vangjel Pano, B.Eng (Hons.) Ryerson University Toronto, Ontario, Canada, 2011

A thesis presented to Ryerson University in partial fulfillment of the requirements for the degree of Master of Applied Science in the Program of Aerospace Engineering

Toronto, Ontario, Canada, 2013 Â© Vangjel Pano

AUTHOR'S DECLARATION
AUTHORS DECLARATION FOR ELECTRONIC SUBMISSION OF A THESIS I hereby declare that I am the sole author of this thesis. This is a true copy of the thesis including the required final revisions, as accepted by my examiners. I authorize Ryerson University to lend this thesis to other institutions or individuals for the purpose of scholarly research. I further authorize Ryerson University to reproduce this thesis by photocopying or by other means, in total or in part, at request of other institutions or individuals for the purpose of scholarly research. I understand that my thesis may be made electronically available to the public.

ii

Abstract
Position Domain Synchronization Control for Robotic Manipulators

Vangjel Pano A thesis for the degree of Master of Applied Science, 2013 Department of Aerospace Engineering, Ryerson University Developed in this thesis is a new control law focusing on the improvement of contour tracking of robotic manipulators. The new control scheme is a hybrid controller based on position domain control (PDC) and position synchronization control (PSC). On PDC, the

system's dynamics are transformed from time domain to position domain via a one-to-one mapping and the position of the master axis motion is used as reference instead of time. The elimination of the reference motion from the control input improves contouring performance relative to time domain controllers. Conversely, PSC seeks to reduce the error of the systems by diminishing the synchronization error between each agent of the system. The new control law utilizes the aforementioned techniques to maximize the contour performance. The Lyapunov method was used to prove the proposed controller's stability. The new control law was compared to existing control schemes via simulations of linear and nonlinear contours, and was shown to provide good tracking and contouring performances.

iii

Acknowledgements
This thesis would not have been possible without the help, support and patience of my supervisor, Dr. Ouyang. His knowledge and dedication has been invaluable. I also wish to thank my lab mates Mr. Richard P. Mohamed, Mr. Yu Lin and Mr. John Michael Acob for their advice and opinions. Finally, I would like to sincerely thank my parents, my sister, and my relatives, Stefan, Vasilika, Grigor and Maria for their support, encouragement and understanding.

iv

Dedication
To my niece, Lydia

v

Table of Contents
POSITION DOMAIN SYNCHRONIZATION CONTROL ........................................................... i FOR ROBOTIC MANIPULATORS ............................................................................................... i AUTHOR'S DECLARATION ....................................................................................................... ii Abstract .......................................................................................................................................... iii Acknowledgements ........................................................................................................................ iv Dedication ....................................................................................................................................... v Table of Contents ........................................................................................................................... vi List of Tables .................................................................................................................................. x List of Figures ............................................................................................................................... xii List of Symbols ............................................................................................................................. xv Nomenclature ............................................................................................................................... xvi Chapter 1: 1.1 1.2 1.3 Introduction ............................................................................................................... 1

Background ...................................................................................................................... 1 Motivation and Objectives ............................................................................................... 3 Organization of Contents ................................................................................................. 4 Literature Review...................................................................................................... 6

Chapter 2: 2.1

Decentralized Control ...................................................................................................... 7 PID/PD Control ......................................................................................................... 7 PD with Desired Gravity Compensation................................................................... 9 Sliding Mode Control ............................................................................................. 10

2.1.1 2.1.2 2.1.3 2.2

Coordinated Control ....................................................................................................... 11 Master/Slave Control .............................................................................................. 11 Position Domain Control ........................................................................................ 13 Cross-Coupled Control ........................................................................................... 13 Position Synchronization Control ........................................................................... 15 vi

2.2.1 2.2.2 2.2.3 2.2.4

2.2.5 2.3

Event-Based Control ............................................................................................... 16

Other Control Schemes .................................................................................................. 18 Adaptive Control ..................................................................................................... 18 Iterative Learning Control....................................................................................... 19 Repetitive Control ................................................................................................... 21

2.3.1 2.3.2 2.3.3 2.4

Tracking and Contour Error ........................................................................................... 21 Contour Error Calculation for Linear Contours ...................................................... 22 Contour Error Calculation for Circular Contours ................................................... 23 Free-Form Contour Error Estimation...................................................................... 23

2.4.1 2.4.2 2.4.3 2.5

Remarks .......................................................................................................................... 25 Position Domain Synchronization Control ............................................................. 26

Chapter 3: 3.1 3.2

Dynamic Model .............................................................................................................. 26 Position Synchronization Control .................................................................................. 27 The Synchronization Concept ................................................................................. 27 Synchronization Errors ........................................................................................... 29 Model-free Position Synchronization Control ........................................................ 30

3.2.1 3.2.2 3.2.3 3.3

Position Domain Control................................................................................................ 31 Relative Derivative and Position Domain Mapping ............................................... 31 Dynamic Model in the Position Domain ................................................................ 32 Position Domain PID Control law .......................................................................... 34 Position Domain Synchronization Control law ...................................................... 34 Properties and Assumptions of the Dynamic Model .............................................. 38

3.3.1 3.3.2 3.3.3 3.3.4 3.3.5 3.4

Stability Analysis ........................................................................................................... 39

vii

3.4.1 3.4.2 3.4.3 3.4.4 3.5

Theorem .................................................................................................................. 39 Control Gains and Synchronization Matrix ............................................................ 40 Proposition .............................................................................................................. 40 Stability Analysis .................................................................................................... 42

Remarks .......................................................................................................................... 45 Simulation & Results .............................................................................................. 46

Chapter 4: 4.1 4.2

Simulation Setup ............................................................................................................ 46 Trajectory Planning ........................................................................................................ 48 Fifth-Order Polynomial ........................................................................................... 48 Linear Contours ...................................................................................................... 48 Nonlinear Contour .................................................................................................. 54

4.2.1 4.2.2 4.2.3 4.3 4.4 4.5 4.6 4.7

Trajectory Transformation ............................................................................................. 60 Friction Model ................................................................................................................ 63 Gain Effect ..................................................................................................................... 63 Gain Selection ................................................................................................................ 66 Linear Contour Tracking Results ................................................................................... 67 Zigzag Contour ....................................................................................................... 67 Diamond Contour.................................................................................................... 72

4.7.1 4.7.2 4.8

Circular Contour Tracking Control ................................................................................ 77 Circular Contour ..................................................................................................... 77 Epitrochoidal Contour ............................................................................................. 83

4.8.1 4.8.2 4.9

Remarks .......................................................................................................................... 88 Conclusions and Future Work ................................................................................ 91

Chapter 5: 5.1

General Review .............................................................................................................. 91 viii

5.2 5.3

Main Contributions ........................................................................................................ 92 Future Work ................................................................................................................... 92

Bibliography ................................................................................................................................. 94 Appendix ....................................................................................................................................... 99 3R Dynamics and Kinematics ................................................................................................... 99 Forward Kinematics .............................................................................................................. 99 Inverse Kinematics................................................................................................................ 99 Dynamics ............................................................................................................................ 100 MATLAB Functions ............................................................................................................... 102 Master File .......................................................................................................................... 102 Secondary Functions ........................................................................................................... 105

ix

List of Tables
Table 4-1: Structural Parameters of a Serial Robotic Manipulator ............................................... 46 Table 4-2: Initial and Final End-Effector Positions for Linear Contours ..................................... 49 Table 4-3: Initial and Final Joint Position for Linear Contours .................................................... 50 Table 4-4: Task Space Maximum Velocities ................................................................................ 50 Table 4-5: Joint Space Maximum Velocity (in rad/sec) ............................................................... 50 Table 4-6: Circular Contour Parameters ....................................................................................... 54 Table 4-7: Epitrochoidal Contour Parameters .............................................................................. 55 Table 4-8: End-Effector Trajectory for Nonlinear Contours ........................................................ 56 Table 4-9: Joint Space Trajectory for Nonlinear Contours ........................................................... 56 Table 4-10: Friction Parameters.................................................................................................... 63 Table 4-11: Gain Range ................................................................................................................ 64 Table 4-12: Simulation Control Gains .......................................................................................... 66 Table 4-13: Mean and Standard Deviation for the Tracking Error for Zigzag Motion ................ 67 Table 4-14: Mean and Standard Deviation of the Synchronization and Coupled Errors for Zigzag Motion ........................................................................................................................................... 68 Table 4-15: Mean and Standard Deviation of Contour Tracking for Zigzag Motion ................... 71 Table 4-16: Maximum Torque for Zigzag Contour (in Nm) ........................................................ 71 Table 4-17: Mean and Standard Deviation of Axial Tracking Error for Diamond Motion .......... 72 Table 4-18: Mean and Standard Deviation for Synchronization and Coupled Error for Diamond Motion ........................................................................................................................................... 73 Table 4-19: Mean and Standard Deviation for Diamond Contour ............................................... 76 Table 4-20: Maximum Torque for Diamond Contour (in Nm) .................................................... 76 Table 4-21: Mean and Standard Deviation of Axial Tracking Error for Circular Contour .......... 78 Table 4-22: Mean and Standard Deviation of Synchronization and Coupled Error for Circular contour .......................................................................................................................................... 78 Table 4-23: Mean and Standard Deviation of Contour Tracking Error or Circular Contour ....... 82 Table 4-24: Maximum Torque for Circular Contour (in Nm) ..................................................... 82 Table 4-25: Mean and Standard Deviation of Axial Tracking Error for Epitrochoidal Contour . 83

x

Table 4-26: Mean and Standard Deviation of Synchronization and Coupled Error for Epitrochoidal contour.................................................................................................................... 84 Table 4-27: Mean and Standard Deviation of Contour Tracking Error of Epitrochoidal Contour87 Table 4-28: Maximum Torque for Epitrochoidal Contour (in Nm) ............................................. 87

xi

List of Figures
Figure 1-1: A: Unimate (Bayliss, Jones and Bayliss). B: ABB IRB 1520ID (Alliance Communications Inc.). .................................................................................................................... 1 Figure 2-1: Decentralized Control .................................................................................................. 6 Figure 2-2: Coordinated Control..................................................................................................... 7 Figure 2-3: Ideal PID Control (Dean, 2002) ................................................................................... 8 Figure 2-4: PD control with desired gravity compensation (Kelly, 1997) ..................................... 9 Figure 2-5: Sliding surface (Sabanovic, Fridman, & Spurgeon, 2004) ........................................ 10 Figure 2-6: Biaxial Cross-coupled Control (Koren, 1980) ........................................................... 14 Figure 2-7: Event Based Control Scheme (Astrom, 2007) ........................................................... 16 Figure 2-8: Event Based PID Structure (Arzen, 1999) ................................................................. 17 Figure 2-9: Adaptive Control: MARC on left and RTC on the right (Slotine & Li, 1991) .......... 19 Figure 2-10: Iterative Learning Control (Moore, Chen, & Ahn, 2006) ........................................ 20 Figure 2-11: Tracking and Contour Error (Yeh, 2003)................................................................. 22 Figure 2-12: Linear Contour Error (Yeh, 2003) ........................................................................... 23 Figure 2-13: Free-Form Contour Error Estimation (Cheng, 2007)............................................... 24 Figure 3-1: Ideal Position Domain Control .................................................................................. 34 Figure 3-2: Position Domain synchronization control Schematic ................................................ 37 Figure 4-1: 3-DOF Planar Robotic Manipulator ........................................................................... 46 Figure 4-2: Zigzag Contour .......................................................................................................... 51 Figure 4-3: Position and Velocity on Task Space (Zigzag Contour) ............................................ 51 Figure 4-4: Joint Position and Velocity (Zigzag Contour) ........................................................... 52 Figure 4-5: Diamond Contour ....................................................................................................... 52 Figure 4-6: Task Space Position and Velocity (Diamond Contour) ............................................. 53 Figure 4-7: Joint Position and Velocity (Diamond Contour)....................................................... 53 Figure 4-8: Epitrochoid Motion (Hsu, Yan, Liu, & Hsieh, 2008) ................................................ 54 Figure 4-9: Circular Contour ........................................................................................................ 57 Figure 4-10: Task Space Position and Velocity (Circular Contour) ............................................. 57 Figure 4-11: Joint Position and Velocity (Circular Contour) ....................................................... 58 Figure 4-12: Epitrochoidal Contour .............................................................................................. 58 xii

Figure 4-13: Task Space Position and Velocity (Epitrochoidal Contour) .................................... 59 Figure 4-14: Joint Position and Velocity (Epitrochoidal Contour) ............................................... 59 Figure 4-15: Lookup Table (interp1) (The MathWorks, Inc) ....................................................... 60 Figure 4-16: Position Domain Slave Trajectories for Zigzag Contour ......................................... 61 Figure 4-17: Position Domain Slave Trajectories for Diamond Contour ..................................... 61 Figure 4-18: Position Domain Slave Trajectories for Circular Contour ....................................... 62 Figure 4-19: Position Domain Slave Trajectories for Epitrochoidal Contour .............................. 62 Figure 4-20: Variable Kp ............................................................................................................... 65 Figure 4-21: Variable Kd ............................................................................................................... 65 Figure 4-22: Variable ................................................................................................................ 65 Figure 4-23: Zigzag Motion Tracking Error for TD-PD, PSC, PD-PD and PDSC ...................... 69 Figure 4-24: Zigzag Motion Synchronization Error for PSC and PDSC...................................... 69 Figure 4-25: Zigzag Motion Coupled Error for PSC and PDSC .................................................. 69 Figure 4-26: Zigzag Motion Contour Tracking Performance for TD-PD, PSC, PD-PD and PDSC ....................................................................................................................................................... 70 Figure 4-27: Zigzag Contour Torques for PDSC Controller ........................................................ 71 Figure 4-28: Diamond Motion Axial Tracking Error for TD-PD, PSC, PD-PD, PDSC .............. 73 Figure 4-29: Diamond Motion Synchronization Error for PSC and PDSC .................................. 74 Figure 4-30: Diamond Motion Coupled Error for PSC and PDSC .............................................. 74 Figure 4-31: Diamond Motion Contour Tracking Performance for TD-PD, PSC, PD-PD and PDSC............................................................................................................................................. 75 Figure 4-32: Contour Tracking Error for PD-PD and PDSC........................................................ 76 Figure 4-33: Diamond Contour Torques for PDSC Controller .................................................... 77 Figure 4-34: Axial Tracking Error of Circular Contour for TD-PD, PSC, PD-PD, PDSC .......... 79 Figure 4-35: Circular Contour Synchronization Error for PSC and and PDSC ........................... 80 Figure 4-36: Circular Contour Coupled Error for PSC and PDSC ............................................... 80 Figure 4-37: Circular Motion Contour Tracking Performance for TD-PD, PSC, PD-PD and PDSC............................................................................................................................................. 81 Figure 4-38: Circular Contour Torques for PDSC Controller ...................................................... 82 Figure 4-39: Axial Tracking Error of Epitrochoidal Contour for TD-PD, PSC, PD-PD, PDSC . 84 Figure 4-40: Epitrochoidal Contour Synchronization Error for PSC and and PDSC ................... 85 xiii

Figure 4-41: Epitrochoidal Contour Coupled Error for PSC and PDSC ...................................... 85 Figure 4-42: Epitrochoidal Motion Contour Tracking Performance for TD-PD, PSC, PD-PD and PDSC............................................................................................................................................. 86 Figure 4-43: Contour Tracking Error for PD-PD and PDSC........................................................ 87 Figure 4-44: Epitrochoidal Contour Torques (in Nm) .................................................................. 88 Figure 4-45: Contour Tracking Performance Summary ............................................................... 89 Figure 4-46: SPDC Maximum Torque ......................................................................................... 90

xiv

List of Symbols
CCC CNC DOF ILC MRAC P-D PD(C) PD-CCC PDcg PD-PD PDSC PID PSC RC RRR SMC STC TD(C) TD-PD Cross-coupled control Computer numerical control Degrees of freedom Iterative learning control Model-reference adaptive control Proportional-derivative Position domain (control) Position domain cross-coupled control Proportional-derivative control with gravity compensation Position domain proportional derivative Position domain synchronization control Proportional-integral-derivative controller Position synchronization control Repetitive control Three revolute joint configuration Sliding mode control Self-tuning control Time domain (control) Time domain proportional derivative

xv

Nomenclature
Constraint matrix Diagonal gain matrix (synchronization) Offset of ith agent Vector of coriolis and centrifugal forces Common vector (synchronization) Cross-coupled control gains Vector of friction forces Vector of gravity Sum of force vectors on system Inertia of ith link Identity matrix Jacobian matrix User defined gain matrix Derivative gain matrix Inertial gain matrix Proportional gain matrix Inertia Matrix Desired trajectory User defined matrix Radius Schur complement Time-varying desired shape Synchronization matrix Lyapunov candidate function Lyapunov derivative w.r.t master motion Viscous friction parameter PSC constraint Coupling parameter of ith agent Tracking error Velocity error Contour tracking error Relative position error Relative derivative coupled error Coupled error Derivative of coupled error Crossover frequency Coulomb friction force Static friction force Magnitude of Stribeck friction force Length of ith link Joint/Axis (angular) Position Joint/Axis (angular) Velocity Joint/Axis (angular) Acceleration   xvi



or or or

/





 



 

End-effector angular position End-effector angular velocity Relative position velocity Relative position acceleration Subscript indicating master motion Mass of ith link Trajectory polynomial Length from centre of gravity of ith link Horizontal end-effector position Vertical end-effector position Horizontal end-effector velocity Vertical end-effector velocity Sliding surface Subscript indicating slave motion time System input Constant gain Friction parameter Synchronization error Angular trajectory parameter Constant (SMC) Smallest eigenvalue of Larger eigenvalue of State vector Torque Boundary layer Angle of contour

xvii

Chapter 1: Introduction
1.1 Background
The first industrial robotic manipulator, Unimate, was created by George Devol and Joseph Engelberger in 1959. The initial design of the robotic manipulator weighted close to two tons and used hydraulic actuators and was controlled by a program on a magnetic drum. Although the first Unimate cost US$ 65,000, it was sold for only US$18,000 (International Federation of Robotics, 2012). For the next years, robotic manipulators in the industry would not significantly change in size or capabilities. The first robots were used in the metal industry (i.e. metal pipe industry) and were mostly used due to their productivity, since they could operate for more hours than a human worker. However, in the 1970s, the emergence of micro-processors and the use of electrical motors lead to increased performance and versatility for the robotic manipulators. The more precise computer-controlled electrical motors could perform more elegant acts such as assembly, welding, cutting riveting etc. This was translated in an average yearly growth of 30% (Wallen, 2008).

Figure 1-1: A: Unimate (Bayliss, Jones and Bayliss). B: ABB IRB 1520ID (Alliance Communications Inc.). C: DaVinci Surgical System (WINTHROP Inc.)

1

Nowadays, the great precision as well as the increased productivity and lower production costs associated with them has made industrial manipulators a staple in current industrial production, from electrical and electronics production to surgical procedures and space exploration. As an indication, Taiwan's Foxconn Technology Group in 2011 announced that was planning to increase its robot usage from 10,000 to one million by 2014 (Yee, 2011). An important research area of robotics and mechatronics is control. Each control type or control law is introduced to compensate for the innate imprecisions that are present on a system as well as other errors and disturbances which arise depending on the use of the system and usually cannot be calculated or accounted for. The causes of these inaccuracies can be summarized as (Slotine J. W., 1988):      Friction Vibration dynamics Mechanical hardware deficiencies Inaccurate system dynamics Process generated disturbances

Due to the aforementioned factors, many types of control modes have been employed depending on the application and the environment of use. Robot control can be categorized as Free Space or Constrained Space depending on the obstacles present in the path of a manipulator (Dombre E. K., 2007). Another categorization distinguishes between Force and Position control. Force control focuses on regulating the force of a robotic manipulator which comes in contact with objects in applications such as cutting, milling etc. On the other hand, Position control is

2

appropriate when the manipulator should follow a specified trajectory, or at least to reach a set of point in space, in applications such as welding, assembling etc (Craig, 2005). The purpose of this thesis is to introduce position domain synchronization control as a valid and powerful control approach for the minimization of the errors in the dynamic response and the contour tracking of robotic manipulators. This is a critical area of research in the realm of control theory since a core aspect of industrial and technological evolution is the quest for faster and more accurate industrial processes.

1.2 Motivation and Objectives
The main goal of this research is to improve the contour tracking performance of a robotic manipulator. This thesis will propose a new control law based on position domain control (PDC) in order to minimize the tracking error and coordinate the motion of the joints of a serial robot. The use of this control law will result in the reduction of the contour error on the end-effector level and therefore, the ability to increase the speed and efficiency of industrial processes. The overall goals of the proposed controller can be summarized as follows: 1. To provide an alternative to time domain synchronization control laws. 2. To indicate the advantages of position domain control in nonlinear robotic systems. 3. To introduce position domain synchronization control for serial robotic manipulators. 4. To improve contouring performance for robotic manipulators. 5. To allow for faster industrial procedures without loss of accuracy. 6. To offer a simple, easy implementation of feedback control laws.

3

In this thesis, the proposed position domain synchronization control (PDSC) and the existent time domain position synchronization control (PSC) will be simulated for various types of contours. To exhibit the advantages of the synchronization approach, proportional-derivative control will also be simulated both in time domain (TD-PD) and position domain (PD-PD). The results of all simulations will be compared for the purpose of demonstrating the advantages of the PDSC. In summary, the following objectives will be fulfilled: 1. Model the dynamics of a simplified RRR, planar, serial manipulator. 2. Formulate a position domain synchronization controller. 3. Perform a stability analysis for the proposed control law via the Lyapunov method. 4. Compare the performance of the proposed controller and the existing time domain controller as well as well as a PD controller both in time and position domain.

1.3 Organization of Contents
The remaining thesis is organized as follows: Chapter 2: provides a literature review on previous research and control approaches to improve contour tracking performance of robotic systems. The review covers both independent and coordinated control schemes as well as an overview of more advanced types of control. Chapter 3: analyses the concept of position domain control (PDC) and the position synchronization control (PSC) principles. The dynamic model of a robotic system is transformed from time to position domain and a new control law is introduced which combines PDC and PSC. Lastly, a stability analysis is performed for the proposed control law using the Lyapunov method. 4

Chapter 4: includes a performance comparison of time domain and position domain controllers for various linear and nonlinear contours. Chapter 5: concludes the thesis and examines the findings of the simulation results and offers suggestions for further work and development of the position domain control principle.

5

Chapter 2: Literature Review
Although usually assumed to be a single piece of machinery, robotic manipulators can be viewed as a group of devices that cooperate to achieve given tasks. Every robotic manipulator is nothing but a collection of actuators/motors and their respective linkage that are simultaneously used to perform motions that serve certain purposes. In that sense, the various proposed and applied control methods for the control of robotic manipulators can be categorized under two different groups: decentralized controllers (Figure 2-1) and coordinated controllers (Figure 2-2). The former category includes control systems where each actuator (or any other part of the manipulator) is independently controlled by its own designated control loop (controller, sensors, etc). Of course, the constraints, desired trajectories, etc, are provided by the operator but each actuator acts parallel to the others, as an independent unit, without realizing the existence of the rest of the mechanism.

Figure 2-1: Decentralized Control

6

On the other hand, coordinated control systems try to interconnect the motion of each actuator and relate its behaviour with the behaviour of the rest of the system. This coordination can be a simple correlation of the various agents' trajectories or it can take the form of collective influence on each agent's control signal. Robotic manipulators under coordinate control systems are more "conscious" of their whole structure, a fact which affects their performance positively.

Figure 2-2: Coordinated Control

2.1 Decentralized Control
2.1.1 PID/PD Control Inarguably, PID control and its other versions (PI and PD) have been the most popular control schemes for robotic manipulators. In fact with more than 90% of industrial applications incorporating some form of PID control, PID controllers dominate the world of feedback control (Astrom & Hagglund, 2001). For a multi-DOF robotic manipulator, PID control is used independently for each motion axis. For a robotic manipulator with axis takes the following form: axes, the PID controller for





(2-1)

7

where

is the tracking error of the axis motion, and

are constant positive

definite gain matrices as shown in Figure 2-3.

Figure 2-3: Ideal PID Control (Dean, 2002)

The main advantages of the above controller are its simple, linear nature and ease of implementation. In spite of its simplicity, PID control is powerful enough to deal with practical issues such as actuator saturation and integrator windup. Furthermore, a great number of tuning techniques have been developed for PID controllers (Bansal , Sharma, & Shreeraman, 2012). Despite its success, however, PID control is still inappropriate for certain cases due to its inability to adjust to the system's dynamics. The dynamic properties of a robotic manipulator vary with time due to wear, friction, disturbances, damage or simply changes in the conditions of use, i.e. different payloads, tasks or environment, creating a need for controller retuning with each new task.

8

2.1.2 PD with Desired Gravity Compensation

Figure 2-4: PD control with desired gravity compensation (Kelly, 1997)

To improve the stability and robustness of the control system, PD control with desired gravity compensation (PDcg) was developed (Takegaki & Arimoto, 1981). As shown in Figure 2-4, this type of control is based on PID control, specifically PD control, with the addition of a feedforward element called "desired gravity compensation". This new term is nothing but

the gravitational torque vector as it is evaluated at the desired joint position and allows the controller to drive the robot in such a way that its joints can be placed at asymptotically desired trajectories regardless of the dynamic systems initial conditions. Mathematically this control law can be expressed as:  where is the tracking error, is the desired joint position. (2-2)

Unlike PID control, PDgc is globally asymptotically stable. Nonetheless, this type of control features some of the weaknesses of the PID control. Calculating the gravity compensation requires exact knowledge of the dynamic system's parameters and the robotic manipulator's possible payload (Kelly, 1997). 9

2.1.3 Sliding Mode Control

Figure 2-5: Sliding surface (Sabanovic, Fridman, & Spurgeon, 2004)

To counteract the uncertainties of the dynamic system, a sliding mode control (SMC) was proposed (Bartolini, Pisano, Punta, & Usai, 2003). The concept of a sliding mode surface is introduced, based on the tracking error of the system and defined as:

(2-3) where is the tracking error for each joint and is a positive constant. As defined, the sliding

surfaces represent the frequency response of a low-pass first order linear system with the cross over frequency of . Therefore, the objective of this control scheme is to bring the (Dombre & Khalil,

controllable variables as close the sliding surface as possible, i.e.

2006). As seen in Figure 2-5, chattering can be present in the dynamics of the system. To minimize this phenomenon, a boundary layer is defined to smooth out the control discontinuity in the sliding surface (Slotine & Li, 1991). Including the estimated dynamic parameters of the system as feedforward terms, the control law of the SMC becomes:      | | | | (2-4)

10

where  and  are estimated dynamic parameters and

is the boundary layer. This control law

produces good results for varying payloads and unknown dynamics and is far more robust than the aforementioned controllers. Conversely, SMC controllers still experience high chatter and energy losses and are generally harder to realize than PID due to their complexity (Slotine & Li, 1991).

2.2 Coordinated Control
2.2.1 Master/Slave Control The first attempts of coordinated control in robotics focused on master-slave control of two robotic manipulators based on pre-existing bilateral master-slave controls for machine teleoperation (Yokokohji & Yoshikawa, 1994). A master-slave control scheme was proposed in (Arimoto, Miyazaki, & Kawamura, 1987). This control scheme uses the error on the end-effector level between the two manipulators to specify the controller input and can be mathematically expressed as: { { and } }

, where subscripts and

(2-5)

are control gains, and

are Jacobian and stiffness matrices respectively and

are used to indicate the master and slave agents. Despite its efficiency,

this controller has difficulties in realizing complicated contours due to its use of the end-effector error which is hard to estimate efficiently while in motion. On the joint level, a different master-slave controller was introduced (Alford & Belyeu, 1984) where a desired path can be defined for the master motion and a relative position is used

11

for the slave motion. To coordinate the motion, the controller uses the master motion's actual position and via an error prediction matrix defines the change required in the slave motion's command based on a hierarchical system. The coordination of the system is performed by a computer dedicated to that task, which is responsible for receiving the position data from the encoders. A similar approach was followed by (Rodriguez-Angeles & Nijmeijer, 2001) who used a PD + feedforward type controller. Once again, the trajectory of the master motion is freely defined and the slave motion's control input is based on the master's actual position.  where with , (  )   and (2-6) are controller gains

and g are the manipulators dynamic parameters,

being the tracking error, and subscripts

and refer to master and slave motions.

One can see that the actual position of the master motion is incorporated in the feedforward term of the controller and the error of the slave system is used in the PD segment. In cases where the position and error cannot be measured directly, observers can be used to estimate their values (Rodriguez-Angeles & Nijmeijer, 2001). The greatest drawback of the aforementioned controllers is their focus on two robot formations and their complete disregard of the coordination of the joint motions with each other. Additionally, the consideration of the slave motion as relative and proportional to the master motion creates difficulties when it comes to more complicate paths and tasks.

12

2.2.2 Position Domain Control A different approach was used by (Ouyang, Huang, & Zhang, 2011) who proposed a position domain control (PDC) structure. In PDC, the dynamics describing the slave motion are transformed from time domain to position domain using the position of the master axis as reference. The trajectories and dynamics of the slave axes are therefore expressed as functions of the master axis trajectory which itself is controlled by an equivalent time domain controller. A PD controller in position domain for the slave axes has the following form: ( ) (2-7)

where the prime superscript indicates the relative velocity with respect to the master axis position. It should be noted that the actual position of each slave motion, , is provided by

the slave motion's encoder or any other type of sensor used as in the case of time domain. PDC completely eliminates the error input of the master axis from the control signal. This way it achieves better contour performance than the controllers in time domain. Additionally, the resulting controller after the transformation is quite similar to its time domain counterpart, a fact which guarantees similar dynamic behaviour and stability for both controllers (Ouyang & Dam, 2011). 2.2.3 Cross-Coupled Control Another family of coordinated control schemes was created in the form of cross-coupled control (CCC) (Koren, 1980). Although each axis of the CCC system has its own feedback loop which is capable of detecting and eliminating the axis' disturbance, the error that occurs on each axis will affect the control input of both axes. As seen in Figure 2-6, this controller cross-couples 13

the error in its dynamics and coordinate the motion of all axes with each other. The CCC controller uses the tracking error of each axis to derive the contour tracking error for the whole system. Thus, the CCC control loop is based on the task space error for its control input.

Figure 2-6: Biaxial Cross-coupled Control (Koren, 1980)

The CCC scheme was able to outperform more conventional controllers like PID, but it was not able to produce satisfactory results for non-linear contours. To overcome this drawback, Koren and Lo (1991) introduced a variable-gain CCC control structure. Variable gains were added to the pre-existing controller which had the ability to change in value depending on the desired contour. Mathematically the variable gains were expressed as:

{

(2-8)

14

where

is the tracking erro, and

and

are functions of the desired contour.This made the CCC

controller capable of estimating the contour tracking error for nonlinear contour based on the radius of curvature with significant accuracy (Koren & Lo, 1991). A position domain approach to the CCC structure (PD-CCC) was introduced by (Dam & Ouyang, 2012). Through a transformation of the system dynamisc from the time domain to position domain, this CCC controller can be defined as:

 where is the contour gain defined as in the time domain CCC case and



(2-9)

is the contour error.

Similar to PID, position domain the CCC in position domain is defined on a master-slave basis for the axes. The performed simulations showed that PD-CCC had a better contour tracking performance than the time domain CCC, even in cases where the CCC performed better in the tracking errors. Despite its success, the design of the CCC controller limits it when it comes to the structure to be controlled. The more complicate the kinematics and dynamics of the system to be controlled the harder the estimation of the contour error, a fact which makes the implementation of CCC controllers in serial or parallel manipulators highly difficult or unwise. 2.2.4 Position Synchronization Control To sidestep the problem of complicated contour estimation and bring the problem back to the joint space level, position synchronization control (PSC) was developed (Sun, 2003). This control concept introduced the notion of synchronization error, defined as the differential position error between the tracking errors of each axes pair, and coupled position error, defined 15

as a function of both position and synchronization errors. The coordination strategy is to bring each axis tracking error in a stable state and cause the position errors between the axes to converge to zero, i.e. (2-10) Where is the tracking error and is the coupling parameter stemming from the constraints for

each motion. Although this controller had an adaptive structure with feedforward, a model-free scheme was later suggested with a structure similar to a proportional-derivative controller (Sun, Shao, & Feng, 2007). The position synchronization control loop has been proven to be quite versatile for various situation besides robotic manipulators and it has been used from CNC machines (Sun & Tong, 2009) to groups of synchronized mini helicopters (Shan, Liu, & Notwotny, 2005). Another great advantage of this control is that it allows for the cross-coupling of multiple axes, and therefore the improvement of contour tracking, without having to deal with the kinematics of the manipulator to be controlled. Since this thesis expands on the concept of position synchronization, a more detailed description of this controller follows in later sections. 2.2.5 Event-Based Control

Figure 2-7: Event Based Control Scheme (Astrom, 2007)

16

Finally, an alternative to periodic sensor sampling for dynamic systems is event based control. Event based systems, instead of sampling the system state on a set time interval, sample the state of the system only when the measurement signal crosses a predefined threshold level. More specifically, during the operation of a system, the even detector generates a signal when an event occurs and sends it to the observer which is responsible for the estimations to be fed on the control signal generator (Astrom, 2007). It is obvious that if the measurement signal does not cross the threshold, the feedback does not materialize for that measurement.

Figure 2-8: Event Based PID Structure (Arzen, 1999)

Due to its nature, event based control reacts faster to the changes of a system's change than conventional periodic sampling control. This occurs because even if a change is detected in periodic sampling, the controller will act after the sampling procedure has finished whereas the event based system acts exactly when the change occurs. For the same reason, event based systems require less CPU power than the periodic sampling system, making them quite attractive for situations where high computing powers are required. An event-based PID structure can be seen in Figure 2-8 (Arzen, 1999).

17

2.3 Other Control Schemes
Sections 2.1 and 2.2 dealt with the fundamental control concepts for robotic manipulators. Yet more complex concepts of robot control exist which can be applied on the aforementioned controllers in order to enhance their performance in different ways. This section will examine some of multipart control techniques and more specifically will cover the concepts of adaptive control, iterative learning control, repetitive control and event based control. 2.3.1 Adaptive Control Adaptive control was developed to compensate for the time-varying parameters of the control system, i.e. system dynamics, payload, operating environment. The main idea behind adaptive control is the use of a method to adjust the parameters of a controller online, based on the signals in the system. The sum of adaptive control systems can be categorized as modelreference adaptive control laws (MRAC) or self-tuning controllers (STC), both schematically represented in Figure 2-9 (Slotine & Li, 1991). On the MRAC the model to be controlled (plan) is assumed to have a known structure but some of its parameters are unknown. A reference model is employed to indicate the ideal response of the adaptive control system to external signals and an adaptation law is used to adjust the controller based on the difference between the reference model output and the actual output. Clearly, MRAC is centered on the adaptation law and the objective of each adaptation control design effort is to create an adaptation law which would minimize the tracking error to zero and bring the system to stability.

18

Figure 2-9: Adaptive Control: MARC on left and RTC on the right (Slotine & Li, 1991)

Self-tuning controllers, on the other hand, employ a simpler architecture. The estimator of the system produces a set of estimated parameters based on the past plant inputs and outputs which the controller uses in order to produce the current control input for the plant. Both types of adaptive control feature come with various pros and cons, however, MARC systems have been more successful in the control of robotic manipulators, mostly due to their usually guaranteed stability and tracking error convergence (Slotine & Li, 1991). Adaptive control laws have been flexible enough to be employed in a various control structures, from PID loops (Kuc & Han, 2000) to SMC loops (Zhao, Li, Gao, & Zhu, 2008). Additionally, the time domain synchronization control was initially proposed as an adaptive control system (Sun, 2003). 2.3.2 Iterative Learning Control While adaptive control laws try to produce more flexible and versatile robot behaviours, the iterative learning control (ILC) is to refine the performance of the robotic manipulator for a specific task through repetition. ILC stems from the fact that the majority of industrial systems are to repeatedly perform the same or similar tasks. 19

Figure 2-10: Iterative Learning Control (Moore, Chen, & Ahn, 2006)

During the process, the input and output signals of the system are being saved in the memory of the system. The error between the two signals is used to construct the input signal for the new cycle. In contrast to conventional controllers which try to decrease the error of the system as time increases, ILC decreases the system error as the number repetition increases. A basic ILC algorithm can be expressed as:

(2-11) where is the system input and is the error of the system output. The above equation

also shows the main advantage of ILC. The initial conditions of the system are reset with each cycle, but the new input signal is created based on the previous cycle's data. This allows for a "non-causal" processing on the errors and therefore ILC can anticipate and proactively respond to repeated disturbances (Moore, Chen, & Ahn, 2006). Due to its nature as a control algorithm and not a singular controller, ILC has been easily implemented on conventional controllers for the control of robotic manipulators used for various processes (Bristow, Tharayil, & Alleyne, 2006).

20

2.3.3 Repetitive Control Quite similar to the ILC, repetitive control (RC) also uses repetition of the process to achieve the stabilization of the system's performance. Proposed by (Inoue, Nakano, Matsumoto, & Baba, 1981), RC can be mathematically expressed as: (2-12) where is the system input and is the error of the system output. In contrast to ILC, RC

is used in continuous, periodical processes for tracking or rejecting exogenous signals. For this reason, the RC system does not maintain the original initial conditions as the new cycle as the ILC does. Instead, the final values of the previous cycle are set as the new initial conditions for the new iteration (Wang, Gao, & Doyle, 2009).

2.4 Tracking and Contour Error
Two important parameters of the dynamic response, and therefore the industrial performance of an industrial manipulator are the axial tracking of each motor and the contouring performance of the end effector. In control theory, these parameters take the form of the tracking error and contour error, respectively. Both errors result from phenomena such as backlash, friction, difference in actuator dynamics, disturbance loads, the contour shape itself, etc. (Koren & Lo, 1991).

21

Figure 2-11: Tracking and Contour Error (Yeh, 2003)

The tracking error is defined as the difference between the desired trajectory of an axis of the robotic manipulator and the actual trajectory followed. In other words it is the measurement of the performance of the individual actuator and can be numerically defined as: (2-13) where is the desired postion and the actual position.

Alternatively, the contour error is the actual difference in distance between the desired path of the end effector and the actual path resulting from the actuated system (Ramesh, 2005). Obviously, for a robotic manipulator the contour error refers to the global coordinates of the en effector. Additionally, due to the nature of the contour error, different methods of must be employed for its calculation or estimation, depending on the path. 2.4.1 Contour Error Calculation for Linear Contours For linear contours, the contour error can be calculated as (Yeh, 2003): (2-14)

22

Where

and

are the tracking errors for the actual point is the angle formed by the desired point

in the x-axis and y-axis

respectively, and

, in the desired linear contour and

the x-axis, as shown in Figure 2-12

Figure 2-12: Linear Contour Error (Yeh, 2003)

2.4.2 Contour Error Calculation for Circular Contours For a circular contour, the contour error can be easily calculated based on the Cartesian equation of a circle as (Yeh, 2003):  where are the coordinates of the circular contour, are the coordinates of the actual point . 2.4.3 Free-Form Contour Error Estimation In the case of a contour shape that cannot be classified as one of the above, the contour error cannot be easily calculated, in real-time or otherwise. In this report, the contour error estimation algorithm proposed by Cheng and Lee (2007). Although this algorithm is designed for real-time error estimation, it is also practical for off-line calculations. (2-15) is the radius of the circle, and

23

Figure 2-13: Free-Form Contour Error Estimation (Cheng, 2007)

Consider two position vectors

and

indicating the desired and actual positions and are

of the end effector for each time instant . The unit tangent vectors at points given as:  

 

(2-16) (2-17)

where instant



is the magnitude of the position vectors. Hence at time

the distance between the two position vectors is given as:    (2-18)

and the length of the projection of the distance (i.e. tracking error) can be calculated by:  

  Now assume that a point this point and

(2-19)

exists on the desired contour and the distance between

is the real contour error. Assuming that the end effector has a desired can be found to be:

velocity  the time required to cover the distance 24

| | which is also the required time to travel from point unknown point can be found to be: and

(2-20) . Hence the previously

(2-21) Therefore, the contour can be calculate in a similar manner to the linear contour, (2-22) Where and are the tracking errors in the Cartesian axes and is the reference angle

between the vector  and the horizontal x-axis, calculated as:

(

)

(2-23) is equal

Concerning velocity , if the end effector maintains a constant velocity to

. Usually through, the end effector of a robotic manipulator experiences significant

changes in its velocity. Thus, an estimation can be used where the velocity is defined as the average of the desired ( ) and actual velocities ( ) for each time instant . This is, in

fact, the main reason that the resulting contour error value is considered estimation and not an exact calculation (Cheng, 2007).

2.5 Remarks
All of the above control schemes try to improve the contouring performance and dynamic response of a robotic manipulator based on different methodologies. Nevertheless, each control strategy features disadvantages which tend to overshadow its benefits, as is the case for the CCC controllers which are really hard to implement on other manipulators besides CNC. Yet, PSC 25

controllers have proven to quite adaptable when it comes to implementation without losing their effectiveness of characteristics (Sun, 2011) , and PDC controllers have shown superior contour tracking performance (Ouyang, Pano, & Dam, 2012). To further progress the notion of position domain control, a new control law based on the position domain and position synchronization concepts will be introduced in the next chapter. The main incentive of this research it to combine the main advantages of PDC as a master/slave, event-driven control system and the PSC as a coordinated control scheme in order to improve the contour tracking performance of the system.

Chapter 3: Position Domain Synchronization Control
In this section the main principles of position domain control and position synchronization control are explored. The dynamic model of a robotic manipulator is transformed from time to position domain. Furthermore, the position domain synchronization controller is developed and some remarks are made. A stability analysis is performed to study the stability of the system.

3.1 Dynamic Model
The dynamic model of a robotic manipulator relates the torques and forces applied to the manipulator's actuators to the joint positions, velocities and accelerations (Dombre & Khalil, 2006). On mathematical terms, the dynamic model takes the following form:  where:    (3-1)

26

 

and 

are the joint position, velocity and acceleration vectors, defined as

functions of time.      is the symmetric and positive-definite inertia matrix  is the vector of coriolis and centrifugal forces is the vector of gravity terms  is the vector of friction forces, and is the vector of joint torques/forces.

3.2 Position Synchronization Control
3.2.1 The Synchronization Concept Assume a multiagent system with n agents given to perform a task that requires the coordination of each agent's motion, i.e., an n-DOF robotic manipulator following a defined contour. The goal of synchronization control is to regulate and synchronize the motion of all agents so that a certain kinematics relationship is maintained for the agents as is required by the coordination task. Not unlike a sliding surface, the regulation of the agents to maintain a kinematic relationship can be understood as guiding the agents along the boundary of multidimensional a compact set. A time-varying desired shape in such a compact set can be introduced as with being a state vector and the time. Then the boundary of the shape .

can be parameterized by a curve, denoted as

Therefore, the synchronization of a system of multiple entities requires two main tasks to be performed. The first one is the classic control goal of bringing the state error of each agent as close to zero as possible as time increases, i.e., as . The second task requires

27

maintaining each agent on the desired curve so that

. Both tasks are equally

important and should be achieved simultaneously in order to achieve system synchronization. Although the constraints for the second synchronization task can take various forms, depending on the system's nature and purpose, the following mathematical expression can be used without loss of generality: { where is the state of the ith agent, }, (3-2)

is a constraint matrix based on the desired is a common vector of is

boundary, which on itself depends on the agent's characteristics ;

characteristics that are applicable on the whole system but not on individual agents , and an offset of the ith agent.

The above equation indicates that all agents of the system can be related through the common vector which requires a linear mapping from to denoted as { } must

. For the existence of this unique linear mapping to exist, the constraint matrix be invertible. It should be noted that because

is based on the desired boundary, it is mainly

determined by the topology of the given formation task. Assuming the existence of the inverse of matrix ( However, , it follows that: ) (3-3)

is a common vector for every agent. Hence for a system of n agents: ( ) ( ) (3-4)

Eq. (3-4) is expressed in terms of the actual state expressed in terms of the desired state , 28

of the ith agent, but it can also be

(

)

(

)

(3-5)

Subtracting Eq (3-4) from Eq (3-5), (3-6) where is the tracking error. can be defined as the coupling parameter of the ith agent, leading to: (3-7) The above equation is ultimately the synchronization control goal which all position error must satisfy in order for system to meet the coordination requirements (Sun, 2011). It should be noted that the coupling parameters do not always take the form of mathematical expressions, but they can simply be constants or identity matrices. Additionally, depending on the nature and purpose of the system, all the agents might have the same coupling parameter. In that case, the synchronization goal becomes: (3-8) Obviously, such is the case for a serial robot described by Eq. (3-1). 3.2.2 Synchronization Errors With its introduction in control terms, a measure of synchronicity should be also introduced and employed in the control of the system. This measure, taking the form of synchronization error should satisfy the following criteria: 1. The synchronization error should be defined according to the synchronization concept (i.e. Eq (3-8)) 29

Lastly,

2. The differential state error concepts in cross-coupling controllers can be used for the definition of synchronization error. 3. The synchronization error should be independent of the agent population. 4. The definition of the synchronization error should also include factors that produce constraints to the states in synchronization. With the above consideration, the synchronization error of a system can be defined as:

[

]

(3-9)

[

]{

}

(3-10)

Furthermore, a coupled error is introduced in order to make the tracking error synchronization error converge to zero, defined as:

and

(3-11) where is a positive definite diagonal gain matrix and is called the synchronization

matrix. With the existence of

, the convergence of the synchronization error to zero

implies that the tracking error also converges to zero and vice versa. Therefore, the control gain should be properly chosen so that the is positive definite with full rank.

3.2.3 Model-free Position Synchronization Control With the theoretical background established and the required entities developed, a PD-type synchronized controller was proposed by (Sun, Shao, & Feng, 2007) as:

30

 where and

{

} 

(3-12)

are diagonal positive gain matrices. It should be noted that the last term on

the right-hand side was introduced for stability purposes and does not have significant contribution on the control input.

3.3 Position Domain Control
In position domain control, an n-DOF system is discretized between master and slaves agents. The motion of the master agent is sampled equidistantly and used as an independent reference, in the same manner as time is used in time domain control. The motions of the slave agents are defined as functions of master motion and the contouring requirements of the system. The formulation of these functions necessitates the development of the system's dynamic model on the position domain through a one-to-one transformation from the time domain as well as its representation as a master-slave system. The great advantage of position domain control is the elimination of the tracking error from the reference model, which minimizes the contribution of the master agent to the contour error of the system. Hence, in order for the position domain model to be effectively utilized, the master motion should be measured with as high precision as possible. 3.3.1 Relative Derivative and Position Domain Mapping The first step for transforming a dynamic system to position domain is to develop a relation which relates the position domain to time domain. This is done by introducing the relative derivate of the ith slave agent's motion with respect to the master agent's motion
 

:

(3-13)

31

From Eq. (3-13) it can be easily understood that

is the speed ratio between the slave and

master agent's motions and it describes a synchronized motional relationship between the two motions. This relative derivative is called relative position velocity of agent with respect to the master agent. In the same manner, the relative position acceleration can be defined as the second relative derivative,

(3-14) From Eq. (3-14), the velocity of axis i can be defined as:  Hence, Eq. (3-15) can be expressed as    (3-16)  (3-15)

The above equations show the relationship between absolute and relative motions. Eq. (3-15) relates the absolute velocity in the time domain with the relative derivative in the position domain, whereas Eq. (3-16) relates the absolute acceleration with the relative acceleration. Both equations are used to transform the dynamic model from time domain to position domain. 3.3.2 Dynamic Model in the Position Domain The dynamic model of Eq (3-1) can be de expressed in a master-slave structure as:    

[

][

]

[

][

]

[

]

[

]

*

+

(3-17)

32

The dynamic model in Eq. (3-17) is a reinterpretation of Eq. (3-1) (3-17)as a master slave system in time domain. Subscript m refers to the master agent/motion and subscript s refers to the slave agents/motions. Therefore is the reference position and is used as the reference for

tracking a defined contour. Consequently, the dynamic model for the slave agents can be rewritten in position domain as a function of the reference time domain to position domain ). through a transformation from

Substituting Eqs (3-15) and (3-16) to Eq. (3-17) for the slave motions, a dynamic model for the position domain slave motions is derived in the following form:



(



)





(3-18)

Remark 1: The above equation represents the dynamic relationship between the master motion, indicated by subscript m, and the slave motions, indicated by subscript , in the position domain via the transformation described by Eqs (3-15) and (3-16). Clearly the nonlinearity of the time domain model in Eq. (3-17) is maintained in the potion domain. Remark 2: From the above dynamics equation it can be deduced that the position of the master motion has greater influence on the system's control than the master motion tracking error. Therefore, in order to achieve accurate contour performance, high precision measurement of the master motion's position is required. Nonetheless, a high tracking precision of the master motion is not required for the position domain control since the master motion's error is not to be included in the position domain controller. Therefore, a low cost actuator can be used for the master motion.

33

Remark 3: It is understood that the position domain control structure requires the master motion control to operate in the time domain. In that sense then PDC is the combination of two different controllers running in sequence as shown in Figure 3-1.

Figure 3-1: Ideal Position Domain Control

3.3.3 Position Domain PID Control law Following the position domain mapping described above, the PID control law described in Eq. (2-1) can be used to control the slave motions of Eq. (3-18) .This position domain PID control law is expressed as:

 The stability of this controller was proven by (Ouyang, Pano, & Dam, 2012). 3.3.4 Position Domain Synchronization Control law

(3-19)

In order to take advantage of the synchronization control properties and the improved contour tracking performance of position domain control, a new control law is introduced for the slave motions of a multi-DOF robotic manipulator described in Eq. (3-18). First, the new error concepts have to be defined. 34

The tracking position error and relative derivative error in the position domain are defined as:

[ [

] ]

[ [

] (3-20) ]

Similarly, the synchronization error is expressed as:

[

]

[

]

(3-21)

And the coupled error is:

{

(3-22)

It should be noted that the coupling terms have been reduced to unit values. This happened because the agents of the robotic manipulator are just the joints and are not restricted by anything more than just the predefined path their have to follow and their kinematics, which are expressed by parameter in Eq. (3-7) which is not present in the synchronization control goal.

Having defined the errors in the position domain, the position domain synchronization control law can be defined as: (3-23) with being constant diagonal gain matrices. The third term in Eq. (3-12) is not included

in the new controller. This is because the third term was introduced to stabilize the system and 35

due to the presence of contribution in the control input.

, which of a small vale, it does not have a significant

Taking into account the error definitions above, the control law in Eq. (3-23) can also be expressed in the following form:  where  and  .  (3-24)

Remarks 4: The position domain control law in Eqs (3-23) and (3-24) is similar to its counterpart in time domain shown in Eq. (3-12) with three essential differences. Firstly, the two control laws function in different domains. Furthermore, due to the different natures of the derivative coupled errors for each system (  and ), the derivative gains of each controller have different

physical meanings. Lastly, the controller in Eq (3-24) lacks the third term of the right-hand side of Eq. (3-12). The inverse term is present for the stability of the system and does not affect its performance. As it will be seen in later sections, the new controller does not require that feature for the stability of the system. Hence the third term was removed from the controller altogether. The new control law can be expressed in time domain terms by simply substituting Eqs (3-15) and (3-16) into (3-24):   . 

 where  and 

(3-25)

Remark 5: Eq. (3-25) shows that the derivative term of the position domain synchronization controller is variable in nature with its value depending on the value of the master motions speed. 36

If the master motion has a constant speed and is sampled equidistantly, the position domain controller can be viewed as a constant gain controller similar to the time domain PSC controller with similar stability properties. Remark 6: It should be noted that the PDSC controller is used for the synchronization of the slave motions and the master motion does not participate. This is because the master to slave synchronization is already achieved by the position domain structure itself. Consequently, the synchronization error for the master motion is eliminated and the master motion controller it reduced to a simple PD controller as visualized in Figure 3-2.

Figure 3-2: Position Domain synchronization control Schematic

Remark 7: Due the elimination of time from the control, Eqs (3-18) and (3-23) constitute an event-driven system.

37

3.3.5 Properties and Assumptions of the Dynamic Model For the new control law, a list of properties of a rigid robotic manipulator described by Eqs (3-1) and (3-17) are used in the stability analysis (Kelly, 1997). These properties are described as follows: P1: The inertia matrix is symmetric and positive definite. can be also be proven to

be symmetric and positive definite without great difficulty. P2: The matrix   is skew symmetric and consequently,  

is skew symmetric as well. P3: The inertia and centrifugal-coriolis matrices must satisfy the following: ,  P4: i. ii. iii. iv.  and  (3-26)    are all bounded. From P4 it can also be deduced that:   for a normal operation condition and represent the  

is bounded with  is bounded with  is bounded with   is bounded with  

Additionally, the following notation is introduced:

smallest and largest eigenvalues of a positive definite matrix M. If a square M matrix is positive definite, then it is denoted as denoted as . . If a square matrix is positive definite, then it is

For positive definite matrices, the following properties will be used (Arendt & Schleuch, 2009): 38

P5: If P6: If P7: If P8: If

, then , then and and

. . is a real number, then , then , . , and

Finally, the following reasonable assumptions are used. A1: The master motion derivative for A2: The velocity  trajectory region. A3: The desired contour trajectory is second order continuous for . . and acceleration  of the master motion are bounded in the desired is a monotonically increasing function with the second order

3.4 Stability Analysis
3.4.1 Theorem Theorem: For a rigid robotic manipulator described in the position domain by Eq. (3-18), if the position domain synchronization control law in Eqs (3-23) and (3-24) is applied to control a contour tracking of the robotic manipulator, and the following conditions in Eq. (3-27) are satisfied, then the controlled robotic manipulator is globally asymptotically stable for contour tracking.

39

  ( )  ( ) { where    

 (3-27)   and    .

is a user defined constant matrix, 

3.4.2 Control Gains and Synchronization Matrix The synchronization matrix can be proven to be positive definite as follows:

[

](

,

(3-28)

where Therefore,  and 

are positive nonzero elements. is positive definite. By also choosing , and to be positive definite,

are also positive definite as products of positive definite matrices.

3.4.3 Proposition Assume a matrix is a symmetric matrix expressed as:

* Let be the Schur complement of a matrix in

+

(3-29) (Arendt & Schleuch, 2009), that is: (3-30)

40

Then the matrix and 2009). , then

is positive definite if and only if

and

are both positive definite, i.e. if

. The proof of this proposition can be found in (Arendt & Schleuch,

To prove the stability of the new control law, the following matrix, , has to be proven to be symmetric positive definite.    

*

+

(3-31)

Proof: The synchronization control gains are symmetric diagonal matrices with positive constant elements. From Eq. (3-27), it is known that  and  and . From P1, we know that . Therefore, is a symmetric positive definite matrix,

is a symmetric positive definite, i.e.

is a symmetric matrix.

From conditions (3-27), we have: ( )  From Eq. (3-32) , it can be concluded:   to P5-P7, we have: As and
, according

(3-32)

(3-33)

 

(3-34)

According to the definition of a positive definite matrix, Eq. (3-34) can be rewritten as:   Furthermore, based on Eq. (3-35) and 41 , according to P8, we have: (3-35)



 

(3-36)

Then, according to P1 and reorganizing Eq. (3-36) :     (3-37) is proved to be symmetric

Hence, according to the Proposition and Eq. (3-37), matrix and positive definite. 3.4.4 Stability Analysis

Using the definition of the tracking error in Eq. (3-20), the dynamic model in Eq. (3-18) can be rewritten in an error function format as follows:         

,

(3-38)

According to the properties and the assumptions, we have:          

 

  



   is bounded.

  

 

(3-39)

Eq. (3-39) indicates that parameter

For the dynamic system defined in position domain in Eq.(3-18), we define the following Lyapunov function:   (3-40)

( *    

) ( ) +( )

From the above discussion, we know that Q is symmetric positive definite. Therefore the Lyapunov function in Eq. (3-40) is a positive definite function: 42

(3-41) In position domain control, the reference angular position is an independent variable that with the same characteristics and use as t in time domain (monotonically increasing or decreasing, etc). and are functions of the independent variable. Therefore, the derivative in this stability analysis.

of V is related to variable

From Eq. (3-40), the derivative of V along the contour tracking errors of the system is given by:    *  (      Considering P2 and P3, and applying Eq.(3-26), (3-38), (3-39) to (3-42):  ) 

*

+(  

*   (  +( )

 (3-42)
 

)

   Since   



(3-43)

is positive definite from Eq. (3-27), we have:









(3-44)

Applying Eq. (3-44) to Eq. (3-43):

  (

 

   

(  

  *

*

(3-45)

Now, it is assumed: 43

{

(   and ( 

 

* (3-46)  *

The according to Eq. (3-27), we have as:

. Then Eq. (3-45) can be rewritten

  Applying another inequality:

  





 



(3-47)

for we get:

and

(3-48)

     

   

   

    (3-49)

{

Applying Eq. (3-49) to Eq. (3-47) we finally derive:

 





 

(3-50)

Based on the Lyapunov theorem, we conclude that the robotic system controlled by the position domain synchronization control law is globally ultimately bounded. The bounded errors for the tracking error and the relative derivative of the tracking error can be obtained as follows:

 



  (3-51)

 {





 

44

From Eq. (3-51), it can be seen that the tracking errors can be controlled in a very small boundary layer through proper selection of the proportional and derivative gains. It is shown that the two eigenvalues in Eq. (3-46), associated with the two control gains, have significant contributions in the control of tracking errors. From Eq. (3-46), one can see that a large gain will increase the value of , while a large control gain will increase the value of . From

Eq. (3-51), we conclude that the increase in both gains will reduce the tracking errors. Such a conclusion is very similar with the synchronization control in the time domain.

3.5 Remarks
In this section the position domain concept and the synchronization principle were explored. A new control law was introduced as a position domain alternative to the time domain PSC control law. The new control law is also based on the synchronization and coupling of the errors of the agent of the system and was proven to be stable in Section 3.4. However, the performance of this control law should be studied and compared to existing control schemes.

45

Chapter 4: Simulation & Results
4.1 Simulation Setup
A virtual robotic manipulator composed of a planar 3 revolute joints is used for the simulation. The manipulator is assumed to be composed of links of different sizes which are actuated with same type of actuators. This type of configuration was chosen because it was complex enough to show the capabilities of the proposed control law. A spatial or more complex planar configuration was not considered since it would not provide significant indications of the proposed controller's efficiency. The structural parameters of the robotic manipulator are listed on Table 4-1.

Figure 4-1: 3-DOF Planar Robotic Manipulator

Table 4-1: Structural Parameters of a Serial Robotic Manipulator

Link 1 2 3

Mass mi (kg) 1.00 1.00 0.50

Length li (m) 0.50 0.50 0.30

Center ri (m) 0.25 0.25 0.15

Inertia Ii (kgm2) 0.10 0.10 0.05

46

For the given manipulator, the control scheme is defined as follows: 

,

(4-1)

Clearly, the first axis motor is used as the master motion, which is controlled with a conventional PD type controller as described in Eq (2-1) (with set to zero). The rest of the motors are

considered the slave motions of the system for which the proposed controller is used as shown in Eq. (4-1). Also, the coupled and synchronization error of the slave motions were defined based on Eqs (3-21) and (3-22). A number of different contours will be simulated, both linear and nonlinear. For the linear contour types, zigzag and diamond contour motions will be simulated, and for the nonlinear types, the simulation will consist of a circular and epitrochoidal contour. For all the contours, PID and PSC controllers will be used both in the time and position domains in order to compare their performances. For the time domain controllers, a sampling frequency of was used for the

simulations. Due to the complicated kinematics of the robotic manipulator the trajectories of the master and slave motions are nonlinear. Therefore, even with an equidistantly sampled master motion, the speed of the master motion still varies nonlinearly; making it very hard for the sampling frequency of the slave motion's to be constant. Hence, the position domain controllers use variable sampling frequencies based on the master motion's position.

47

4.2 Trajectory Planning
4.2.1 Fifth-Order Polynomial To guarantee smooth trajectories for all the joints of the manipulator, a fifth-order polynomial is used to define each contour's position, velocity and acceleration (Dombre & Khalil, 2006). The fifth-order polynomial is defined with respect to time as:

( * where is time and are given as:

( *

( *

(4-2)

is the total time duration of the motion. Then, the velocity and acceleration

  4.2.2 Linear Contours

, ,

( * ( *

( * ( *

( * ( * -

(4-3) (4-4)

With Eqs (4-2)-(4-4), a linear contour on the end-effector level (task space coordinates) can be defined as follows: ( where ) , and (4-5) and are

, is the desired contour expressed in Cartesian coordinates

final and initial points in the contour. Both zigzag and diamond contours are composed of four linear contours defined by equation (4-5). The transition from one segment to the other is a stop-and-go motion and not continuous as is usually the case for these types of contours. 48

The direction (

) of the end effector is kept constant for each segment. The inverse

kinematics equations of the robotic manipulator (found on the appendix) are used to calculate the joint position and velocity required to follow the defined contours. Figure 4-2 to Figure 4-4 show the zigzag contour along with the end-effector and joint level trajectories. Figure 4-5 to Figure 4-7 show the same information for the diamond contour.
Table 4-2 and

Table 4-3 show the final and initial positions on the end-effector and joint space level respectively. Table 4-4 and Table 4-5 indicate the maximum velocities for each segment and once again for the end-effector and joint space respectively. One can see that the end-effector values are similar because the segments were set to be equal in distance and time duration. On the other hand, the joint space values are quite different due to the kinematics of the robotic manipulator.
Table 4-2: Initial and Final End-Effector Positions for Linear Contours

Segment 1 Zigzag Contour

Segment 2

Segment 3

Segment 4

Diamond Contour

49

Table 4-3: Initial and Final Joint Position for Linear Contours

Segment 1 Zigzag Contour

Segment 2

Segment 3

Segment 4

Diamond Contour

Table 4-4: Task Space Maximum Velocities

Segment 1 Zigzag Contour    Diamond Contour   

Segment 2

Segment 3

Segment 4

Table 4-5: Joint Space Maximum Velocity (in rad/sec)

Segment 1 Zigzag Contour    Diamond Contour  

Segment 2

Segment 3

Segment 4

50


Zizag Contour 0.4

0.35

0.3

Y-axis (m)

0.25

0.2

0.15

0.1

0.05 0.5

0.55

0.6

0.65

0.7 X-axis (m)

0.75

0.8

0.85

0.9

Figure 4-2: Zigzag Contour
Task Space Position 1.4 x ef 1.2 y ef qef 1
Velocity (m/s) Position (m)

Task Space Velocity 0.6

0.4

0.2

0.8

0

0.6

-0.2

0.4

-0.4

0.2

-0.6

0

0

1

2 Time (s)

3

4

-0.8

0

1

2 Time (s)

3

4

51

Figure 4-3: Position and Velocity on Task Space (Zigzag Contour)
Joint Position in Time Domain 2.5 2 1.5 1 0.5 0 -0.5 -1 -1.5 -2 -1 q1 q2
Joint Velocity (rad/s)

Joint Velocity in Time Domain 2

1.5

1

Joint Position (rad)

q3

0.5

0

-0.5

0

1

2 Times (s)

3

4

-1.5

0

1

2 Time (s)

3

4

Figure 4-4: Joint Position and Velocity (Zigzag Contour)

52

Diamond Contour

0.65 0.6 0.55

Y-axis (m)

0.5 0.45 0.4 0.35 0.3 0.5

0.55

0.6

0.65

0.7 X-axis (m)

0.75

0.8

0.85

0.9

Figure 4-5: Diamond Contour
Task Space Position 1.2 1.1 1 0.9
Position (m)

Task Space Velocity 0.25 0.2 0.15 0.1
Velocity (m/s)

x ef y ef qef

0.8 0.7 0.6 0.5 0.4 0.3 0.2 0 2 Time (s) 4

0.05 0 -0.05 -0.1 -0.15 -0.2

6

-0.25

0

2 Time (s)

4

6

Figure 4-6: Task Space Position and Velocity (Diamond Contour)

53

Joint Position in Time Domain 2.5 1 0.8 0.6 1.5
Joint Velocity (rad/s) Joint Position (rad)

Joint Velocity in Time Domain

2

0.4 q1 q2 q3 0.2 0 -0.2 -0.4 -0.6

1

0.5

0

-0.5

-0.8 0 2 4 Times (s) 6 -1 0 2 Time (s) 4 6

-1

Figure 4-7: Joint Position and Velocity (Diamond Contour)

4.2.3 Nonlinear Contour To define nonlinear contour, an angular parameter has to be introduced: ( where and ) (4-6)

are the final and initial values for the parameter. This parameter is used to define

the nonlinear contours which are expressed by different equations based on the contour. The circular contour is defined as follows: ( ( is radius. ) )

, with are the centre of the circle and

(4-7)

Table 4-6: Circular Contour Parameters

54

Figure 4-8: Epitrochoid Motion (Hsu, Yan, Liu, & Hsieh, 2008)

On the other hand, the epitrochoidal contour is defined based on the epitrochoidal parametric function:

( (

) )

( (

+ (4-8) + is the radius of the

{ where is the origin of symmetry,

is the radius of the large circle,

small circle and

is the distance of the trajectory's points from the centre of the smaller circle

as shown in Figure 4-8. The smaller circle moves around the larger circle, translating rod d in the process which creates the resulting contour. The parameters used to form the desired contour are listed in the following table.
Table 4-7: Epitrochoidal Contour Parameters

55

Both nonlinear contours are performed on their whole and are not segments. For the circular contour, the direction ( ) of the end-effector was kept constant, but for the

epitrochoidal contour Eq.(4-6) was used to define the end effector direction. As in the linear contour case, the joint trajectories are calculated based on the manipulators inverse kinematics equations which can be found in the appendix. Figure 4-9 to Figure 4-14 display the contours and trajectories for both circular and epitrochoidal contour. Table 4-8 and Table 4-9 show the initial and final positions and the maximum velocity for each contour on the end-effector level and joint space level, respectively. Once more the two tables feature significantly different values due to the robotic manipulator's kinematics.
Table 4-8: End-Effector Trajectory for Nonlinear Contours

Initial Position Circular contour

Final Position

Max velocity / / / / / /

Epitrochoidal contour

Table 4-9: Joint Space Trajectory for Nonlinear Contours

Max Velocity (rad/s) Circular contour

Epitrochoidal contour 56

Circular Contour 0.5 0.4 0.3 0.2
Y-axis (m)

0.1 0 -0.1 -0.2 -0.3 -0.4 -0.5 -0.5 -0.4 -0.3 -0.2 -0.1 0 0.1 X-axis (m) 0.2 0.3 0.4 0.5

Figure 4-9: Circular Contour

57

Task Space Position 1.2 1 0.8 0.6
Position (m)

Task Space Velocity 0.8 x ef y ef qef
Velocity (m/s)

0.6 0.4 0.2 0 -0.2 -0.4 -0.6 -0.8 -1

0.4 0.2 0 -0.2 -0.4 -0.6

0

2

4 Time (s)

6

8

0

2

4 Time (s)

6

8

Figure 4-10: Task Space Position and Velocity (Circular Contour)
Joint Position in Time Domain 6 2.5 2 4 1.5 1 Joint Velocity in Time Domain

Joint Velocity (m/s)
8

Joint Position (m)

2

0.5 0 -0.5 -1 -1.5 -2

0

q1 q2 q3

-2

-4

-6

0

2

4 Time (s)

6

-2.5

0

2

4 Time (s)

6

8

Figure 4-11: Joint Position and Velocity (Circular Contour)

58

Epitrochoidal Contour 0.8 0.7 0.6 0.5
Y-axis (m)

0.4 0.3 0.2 0.1 0 -0.1 -0.2 -0.2 -0.1 0 0.1 0.2 0.3 X-axis (m) 0.4 0.5 0.6 0.7

Figure 4-12: Epitrochoidal Contour
Task Space Position 0.8 0.7 0.6 0.5
Velocity (m/s) Position (m)

Task Space Velocity 2 1.5 1 0.5 0 -0.5 -1

0.4 0.3 0.2 0.1 0 -0.1 -0.2 0 1 x ef y ef qef 2 Time (s) 3 4

-1.5 -2 -2.5

0

1

2 Time (s)

3

4

Figure 4-13: Task Space Position and Velocity (Epitrochoidal Contour)

59

Joint Position in Time Domain 6 6

Joint Velocity in Time Domain

4

4

2 q1 q2 -2 q3
Joint Velocity (m/s) Joint Position (m)

2

0

0

-2

-4 -4

-6

-8

0

1

2 Time (s)

3

4

-6

0

1

2 Time (s)

3

4

Figure 4-14: Joint Position and Velocity (Epitrochoidal Contour)

4.3 Trajectory Transformation
As mentioned in Section 3.3, in position domain control the slave motion has to be transformed from the time domain to position domain. This means that the desired trajectory of the slave axes has to be also transformed from functions of time to functions of the master axis position. For the purposes of the following simulations, lookup tables are used for the transformation of the desired axis trajectories. More specifically, the desired trajectory of each axis is initially defined as a function of time as explained in Section 4.2. Afterwards, the resulting trajectories are linearly interpolated with respect to the master axis' real trajectory, as shown in Figure 4-15. This way the desired slave axes position is found for the equivalent master

60

axis real trajectory. This procedure was easily performed in the simulations by using the intep1 in MATLAB.

Figure 4-15: Lookup Table (interp1) (The MathWorks, Inc)

The resulting contours derived from the above procedure can be seen in the following figures. Figure 4-16 to Figure 4-19 contain in sequence the resulting trajectories for the zigzag, diamond, circular and epitrochoidal contours respectively.

Joint Position in Position domain 2 q2 1 0 -1.6 -1.4 -1.2 -1 q1 (rad) -0.8 q3
Joint Velocity (rad/s) Joint Position (rad)

Joint Velocity in Position Domain 1 0 -1 -1.6 -1.4 -1.2 -1 q1 (rad) -0.8

Task Space Position in Position Domain 1.5
Task Space Position

1 y ef 0.5 qef

0 0.5

0.55

0.6

0.65

0.7 x ef (m)

0.75

0.8

0.85

0.9

Figure 4-16: Position Domain Slave Trajectories for Zigzag Contour

61

Joint Position in Position domain
Joint Position (rad)

Joint Velocity in Position Domain 1
Joint Velocity (rad/s)

2 1 0 -1 -1 q2 q3

0.5 0 -0.5 -1 -1 -0.5 q1 (rad) 0

-0.5 q1 (rad)

0

Task Space Position in Position Domain 1.2
Task Space Position

1 0.8 0.6 0.4 0.2 0.5 0.55 0.6 0.65 0.7 x ef (m) 0.75 0.8 0.85

y ef qef

0.9

Figure 4-17: Position Domain Slave Trajectories for Diamond Contour
Joint Position in Position domain 1
Joint Position (rad)

Joint Velocity in Position Domain
Joint Velocity (rad/s)

2 0 -2 -4 -6 -2 0 q2 q3 2 q1 (rad) 4

0 -1 -2 -2 0 2 q1 (rad) 4

Task Space Position in Position Domain
Task Space Position

1 0.5 0 -0.5 -1 -0.8 -0.6 -0.4 -0.2 x ef (m) 0 0.2 0.4 y ef qef 0.6

Figure 4-18: Position Domain Slave Trajectories for Circular Contour

62

Joint Position in Position domain

Joint Velocity in Position Domain

Joint Velocity (rad/s)
6

5

Joint Position (rad)

2 0 -2 -4 -6 0 2 q1 (rad) 4 6

0

q2 q3

-5 0 2 q1 (rad) 4

Task Space Position in Position Domain

Task Space Position

0.6 0.4 0.2 0 -0.2 -0.2 -0.1 0 0.1 0.2 0.3 x ef (m) 0.4 0.5 0.6 y ef qef 0.7

Figure 4-19: Position Domain Slave Trajectories for Epitrochoidal Contour

4.4 Friction Model
In an effort to make a realistic simulation and demonstrate the robustness of the new controller, the friction of the robotic manipulators joints is added to the simulated model. The friction was modeled based on the following equation:
 | |

 where

{

}





(4-9) is the

is the Coulomb friction force,

is the magnitude of the Stribeck friction,

viscous friction parameter, parameter.

is the static friction coefficient and

is an empirically determined

63

The model of Eq (4-9) predicts the static, viscous and break-away friction values for the joint actuators of the robotic manipulators (Armstrong-Helouvry, Dupont, & Canudas De Wit, 1994). Table 4-10 shows the friction parameters used for the simulations. Since the joint actuators are assumed to be of the same type, the same parameters are used for each joint.
Table 4-10: Friction Parameters

Parameter Coulomb friction ( Stribeck friction Static friction Viscous friction

Value

/

4.5 Gain Effect
As with every controller, the gains of the proposed control law in Eq (3-23) affect the behaviour of the system in different ways. Simulations for a linear contour were performed with the values of the gains changing with each one. The gain matrices are diagonal and for simplicity all the non-zero entries have the same value for each gain. Three sets of simulations are performed with the value of only one gain varying on each set while the other ones remain the same. The mean of the absolute of each error is used to compare the performance of each gain value. The range of values of the gains can be seen in Table 4-11.
Table 4-11: Gain Range

Gain

Min. Value

Max Value

Increment

Figure 4-20 shows the effects of

on the systems performance. Increasing the , a trend which is also

proportional gain matrices value led to decrease in the contour error ( 64

followed by the synchronization ( ) and the coupled error the second axis reached a minimum with decreases only slightly.

. However, the tracking error of

, while the tracking error for the third axis

On the other hand, Figure 4-21 shows that an increase in the derivative gain

results in

increasing contour, synchronization and coupled errors. Conversely, the second axis tracking error decreases as the derivative gain grows in value. An increasing value leads to decreases in the value of the contour error but increases the

synchronization and coupled errors. The tracking error of the second axis decreases with the first changes in the value of but then it increases again while the third axis maintains a slight should be

decrease. The high increase of the coupled error indicates that the value of maintained low enough in order for the error to be maintained low in value as well.
-5 -4 -3 -3

4

x 10

4 3.5

x 10

2 1.8 1.6 e2 e3 1.4 1.2 1

x 10

3.5

x 10

3.5 3 3
e (m) e (rad)
c

2 3
* (rad)

3

2.5

2 1.5

 (rad)

2.5

2.5

* 2 * 3

2

2 1 1.5 0.5 0.8 0.6

1.5

0

5000

10000

0

5000

10000

0

5000

10000

1

0

5000

10000









Figure 4-20: Variable Kp

65

4.1

x 10

-5

x 10

-4

2.2 e2 e3 2 1.8 1.6

x 10

-3

3.4 3.2 3

x 10

-3

4.05 3 4

2 3

2.8 2.6

* 2 * 3

c

3.95

2

1.4 1.2

* (rad)
0 5000 10000

e (m)

e (rad)

 (rad)

2.4 2.2 2

3.9 1 3.85

1 1.8 0.8 1.6 1.4 0 5000 10000

3.8

0

5000

10000

0

0

5000

10000

0.6









Figure 4-21: Variable Kd
3.9 3.8 3.7 3.6
e (m)

x 10

-5

4 3.5 3 2.5 2 1.5 1 0.5

x 10

-4

2 e2 e3 1.8 1.6 1.4 1.2 1 0.8 0.6

x 10

-3

0.04

2 3
*  (rad)

0.035 0.03 0.025 0.02 0.015 0.01 0.005

* 2 * 3

c

3.5 3.4 3.3 3.2 0 10 20

e (rad)

 (rad)

0

10

20

0

10

20

0

0

10

20









Figure 4-22: Variable

4.6 Gain Selection
Based on the observations in Section 4.5, a simple algorithm was used to select the gains of the controller. The algorithm is composed of the following steps: 1. Set 2. Tune , making the PDSC controller similar to a proportional-derivative controller. and via a trial-and-error until a desired performance is achieved. until desired performance due to synchronization is achieved. if needed. 66

3. Increase the value of 4. Further adjust and

The above algorithm is quite similar to the one used by (Sun, 2011) to tune the PSC controller, an algorithm which was also used to determine the simulations in the later sections can be seen in Table 4-12.
Table 4-12: Simulation Control Gains

gain. The gain used for the

Controller Type Time Domain PD Controller Position Synchronization Controller Position Domain PD Controller Position Domain Synchronization Controller

Linear Contour { { { { { { { { { { { } } } } } } } } } } }

Nonlinear Contour { { { { { { { { { { { } } } } } } } } } } }

4.7 Linear Contour Tracking Results
4.7.1 Zigzag Contour All the simulated control schemes, TD-PD, PDSC, PD-PD and PDSC achieved good axial tracking performance for a zigzag motion with the control gains of Section 4.6. As seen in Table 4-13 the position domain controllers were able to produce less tracking error than the time domain controllers with the PDSC controller being approximately more exact that then

PD-PD controller. All the tracking errors are also displayed in Figure 4-23. Concerning synchronization and coupled errors, PDSC outperformed the PSC controller by achieving 67

(axis 2) and

(axis 3) lower synchronization error with equally lower standard

deviations. Similar results were produced for the coupled error, where the PSC exhibited higher that the PDSC values by and Figure 4-25. It should be noted that for the position domain controllers (PD-PD and PDSC), the first axis is the master axis and its position acts as the reference for the motion of the rest axis. Hence the first axis yields zero tracking, synchronization and coupled error in the case of the position domain controllers.
Table 4-13: Mean and Standard Deviation for the Tracking Error for Zigzag Motion

(axis 2) and

(axis 3), as seen also in Table 15, Figure 4-24

Axis 1 Mean (rad) S.D. (rad) TD-PD PSC PD-PD PDSC N/A N/A N/A N/A

Axis 2 Mean (rad) S.D. (rad)

Axis 3 Mean (rad) S.D. (rad) 0.00013 0.00013

Table 4-14: Mean and Standard Deviation of the Synchronization and Coupled Errors for Zigzag Motion

Axis 1 Mean (rad) S.D. (rad) Synchronization Error ( ) 0.00030 0.00030 PSC N/A N/A PDSC Coupled Error ( ) 0.00217 0.00208 PSC N/A N/A PDSC

Axis 2 Mean (rad) S.D. (rad) 0.00032 0.00028 0.00232 0.00184 0.00039 0.00206 0.00062

Axis 3 Mean (rad) S.D. (rad) 0.00058 0.00029 0.00519 0.00272 0.00040 0.00362 0.00088

68

10
q (rad)

x 10

-4

-4 x 10 TD-PD

5 0 0 x 10 2 Time (s)
-4

6 4 2 0 0 x 10 2 Time (s)
-4

4 2 0 -2

x 10

-4

q (rad)

4

4

q (rad)

1

2

3

0 x 10
q (rad)

2 Time (s)
-4

4

PSC 4 2 0

q (rad)

q (rad)

5

5

1

2

0

0

2 Time (s)

4

0

0

2 Time (s)

4

3

0 x 10

2 Time (s)
-4

4

1
q (rad) q (rad)

-4 x 10 PD-PD

0 -1 -1.5 -1 q1 (rad)

0 -2 -1.5 -1 q1 (rad)

q (rad)

2

4 2 0 -1.5 x 10
-4

1

2

3

-1 q1 (rad)

1
q (rad) q (rad)

0 -2 -4

-4 x 10 PDSC

q (rad)

0 -1 -1.5 -1 q1 (rad)

4 2 0 -1.5 -1 q1 (rad)

1

2

-1.5

-1 q1 (rad)

Figure 4-23: Zigzag Motion Tracking Error for TD-PD, PSC, PD-PD and PDSC

69

3

5 0

x 10

-4

1 0.5

x 10

-3

PSC 2 1

x 10

-3

1 (rad)

2 (rad)

-5 -10 -15 0 2 Time (s) 4

0 -0.5 -1 0 2 Time (s) -4 x 10 PDSC 4

3 (rad)

0 -1 -2 0 x 10 4 2 Time (s)
-4

4

1 0.5 0

1 (rad)

2 (rad)

3 (rad)
-1.5 -1 q1 (rad)

0 -0.5 -1

2 0 -2 -1.5 -1 q1 (rad)

-5 -10

-1.5

-1 q1 (rad)

Figure 4-24: Zigzag Motion Synchronization Error for PSC and PDSC
-3 -3

5

x 10

10

x 10

PSC 0.02 0.01

e* (rad)

e* (rad)

e* (rad)

0 -5 -10

5 0 -5

0 -0.01 -0.02 0 x 10 4 2 Time (s)
-3

1

2

0

2 Time (s)

4

0

1 0.5

2 Time (s) -3 x 10 PDSC

4

3

4

2 0

e* (rad)

e* (rad)

0 -0.5 -1 -1.5 -1 q1 (rad)

-2 -4 -6 -8 -1.5 -1 q1 (rad)

e* (rad) 3

2 0 -2 -1.5 -1 q1 (rad)

1

Figure 4-25: Zigzag Motion Coupled Error for PSC and PDSC

2

70

Regarding contour tacking accuracy, the position domain controllers were able to perform better than the time domain controllers, as previous research had also demonstrated (Ouyang, Dam, Huang, & Zhang, 2012). The PD-PD controller produced and lower contour

error than the TD-PD and PSC controllers, respectively, but the PDSC controller outperformed the PD-PD by as seen in Table 4-15. Hence, it is clear that the PDSC controller achieved

the best contour performance with the least deviation from the desired path, something also supported evident by Figure 4-26.

x 10 8 7 6 5
e (m)

-4

TD-PD PSC PD-PD PDSC

4 3 2 1 0 -1 -2 0.5 0.55 0.6 0.65 0.7 X-axis (m) 0.75 0.8 0.85 0.9

Figure 4-26: Zigzag Motion Contour Tracking Performance for TD-PD, PSC, PD-PD and PDSC

c

71

Table 4-15: Mean and Standard Deviation of Contour Tracking for Zigzag Motion1

Mean (m) TD-PD PSC PD-PD PDSC

S.D. (m)

As shown in Table 4-16, the position domain controllers produced higher maximum values for the second axis while the maximum torque for the third axis remained essentially the same. This was expected as the trajectories on the position domain are rather different than the time domain ones and create different values in the required torques. The torques produced by the PDSC controller can be seen in Figure 4-27.
Table 4-16: Maximum Torque for Zigzag Contour (in Nm)

TD-PD PSC PD-PD PDSC

15

1 2 3

10
Torque (Nm)

5

0

-1.6

-1.5

-1.4

-1.3

-1.2

-1.1 q1 (rad)

-1

-0.9

-0.8

-0.7

Figure 4-27: Zigzag Contour Torques for PDSC Controller
1

Contour Error calculated with Eq (2-14)

72

4.7.2 Diamond Contour Similar to the zigzag motion, the diamond contour simulations produced good axial tracking results for all the controllers. Still, the PDSC controller yielded better results than the rest of the controllers as it can be seen in Figure 4-29. More specifically, Table 4-17 shows that the PDSC controller produced approximately approximately less error than the PSC controller and

error from the PD-PD controller. The standard deviation of the mean error

followed in the same trend, with the standard deviation of the PDSC controller being an order of magnitude lower than the rest of the controllers. On the other hand, the PSC controller outperformed the PDSC controller on the synchronization error of the second axis by and produced only higher error than the

PDSC on the third axis with the standard deviation following the same trend. Likewise, PSC produced by less coupled error for the second axis but greater error for the third axis as

shown in Table 4-18. The standard deviations of the error had similar terms with the PDSC standard deviations being higher for the second axis but lower than the PSC

standard deviation for the third axis.
Table 4-17: Mean and Standard Deviation of Axial Tracking Error for Diamond Motion

Axis 1 Mean (rad) S.D. (rad) TD-PD PSC PD-PD PDSC N/A N/A N/A N/A

Axis 2 Mean (rad) S.D. (rad)

Axis 3 Mean (rad) S.D. (rad)

73

Table 4-18: Mean and Standard Deviation for Synchronization and Coupled Error for Diamond Motion

Axis 1 Mean (rad) S.D. (rad) Synchronization Error ( ) PSC N/A N/A PDSC Coupled Error ( ) PSC N/A N/A PDSC

Axis 2 Mean (rad) S.D. (rad)

Axis 3 Mean (rad) S.D. (rad)

x 10

-3

x 10 6 4 2 0 -2 0

-4

TD-PD 4 2 0 -2 -4

x 10

-4

q (rad)

q (rad)

1

2

-1

0 Time (s) x 10
-4

5

5 Time (s)
-4

3

0

q (rad)

1

0 Time (s) 5 0 -5 -10 -15 x 10
-4

5

q (rad)

q (rad)

1

2

-20

0 Time (s)

5

0 Time (s) x 10
-4

5 PD-PD 4

3

-10

q (rad)

0

5 0 -5 -10 -15

x 10

PSC

0 Time (s) x 10
-4

5

1

0 -1 -0.8 -0.6 -0.4 -0.2 q1 (rad)

1 0 -1 -2 -3

q (rad)

q (rad)

q (rad)
-0.8 -0.6 -0.4 -0.2 q1 (rad)
-4

2 0 -0.8 -0.6 -0.4 -0.2 q1 (rad) x 10
-4

1

2

1

0

x 10

PDSC

3 3

q (rad)

q (rad)

0 -1 -0.8 -0.6 -0.4 -0.2 q1 (rad)

-1 -2 -0.8 -0.6 -0.4 -0.2 q1 (rad)

q (rad)

2 1 0 -0.8 -0.6 -0.4 -0.2 q1 (rad)

1

Figure 4-28: Diamond Motion Axial Tracking Error for TD-PD, PSC, PD-PD, PDSC

2

74

x 10 5

-4

x 10 5

-4

PSC 5

x 10

-4

1 (rad)

2 (rad)

0

0

3 (rad)
0 Time (s) -4 x 10 PDSC 5

0

-5 0 Time (s) 1 0.5 5

-5

-5 0 Time (s) x 10 4
-4

5

2 0

1 (rad)

2 (rad)

0 -0.5 -1 -0.8 -0.6 -0.4 -0.2 q1 (rad)

-2 -4 -6 -8 -0.8 -0.6 -0.4 -0.2 q1 (rad)

3 (rad)
-3

2 0 -0.8 -0.6 -0.4 -0.2 q1 (rad)

Figure 4-29: Diamond Motion Synchronization Error for PSC and PDSC
-3

x 10 2

x 10 4

PSC 6 4

x 10

-3

e* (rad)

e* (rad)

0 -2 -4 0 Time (s) 1 0.5 5

e* (rad)
0 Time (s) -3 x 10 PDSC 5

2 0 -2 -4

2 0 -2 -4 0 Time (s) x 10 4
-3

1

2

3

5

2 0

e* (rad)

e* (rad)

e* (rad)
-0.8 -0.6 -0.4 -0.2 q1 (rad)

0 -0.5 -1 -0.8 -0.6 -0.4 -0.2 q1 (rad)

1

2

-4

3

-2

2

0 -0.8 -0.6 -0.4 -0.2 q1 (rad)

Figure 4-30: Diamond Motion Coupled Error for PSC and PDSC

75

Once again the position domain controllers performed better than their time domain counterparts, featuring mean errors and standard deviations an order of magnitude lower than the time domain as shown in Figure 4-31. Furthermore, the PDSC controller produced lower mean error than the PD-PD controller with the standard deviation being also lower by as it is indicated in Table 4-19. The contour error results of the position domain controllers can be seen more clearly in Figure 4-32.

x 10 3.5 3 2.5 2
e (m)

-3

TD-PD PSC PD-PD PDSC

1.5 1 0.5 0 -0.5 0.5

c

0.55

0.6

0.65

0.7 0.75 X-axis (m)

0.8

0.85

0.9

Figure 4-31: Diamond Motion Contour Tracking Performance for TD-PD, PSC, PD-PD and PDSC

76

Table 4-19: Mean and Standard Deviation for Diamond Contour2

Mean (m) TD-PD PSC PD-PD PDSC
x 10 4 2 0 -2
-5

S.D. (m)

e (m)

-4 -6 -8 -10 -12 -14 0.5 0.55 0.6 0.65 0.7 X-axis (m) 0.75 0.8 0.85

PD-PD PDSC

c

0.9

Figure 4-32: Contour Tracking Error for PD-PD and PDSC

As exhibited in Table 4-20, the torques of the position domain controllers were once again different than the ones of the time domain. This time the position domain controllers produced lower torque from the time domain by approximately difference between the third axis torques is approximately . for the second axis while the

Table 4-20: Maximum Torque for Diamond Contour (in Nm)

TD-PD PSC PD-PD PDSC
2

Contour error calculated with Eq. (2-14)

77

20 15 10

Torque (Nm)

5 0 -5 -10 -15 -20 -0.9 -0.8 -0.7 -0.6 -0.5 q1 (s) -0.4 -0.3 -0.2

1 2 3

Figure 4-33: Diamond Contour Torques for PDSC Controller

4.8 Circular Contour Tracking Control
4.8.1 Circular Contour The circular contour simulations also yielded good tracking error results. On the second axis TD-PD produced lower mean error than PDSC, the second lowest and on the third axis

PSC had the lowest error with PDSC coming second. Similar comments can be made for the standard deviation of the tracking errors of the controllers which are included in Table 4-21. The PSC controller was proven to produce the more stable tracking error having and

lower standard deviation for the second and third axis when compared with the TD-PD controller which was second best. On the contrary, the PDSC controller proves more efficient in the synchronization errors since its mean error and their standard deviations are lower than the PSC's by and for

the second and third axis respectively. This trend continued to the coupled error results in Table

78

4-21 and Figure 4-36 where the mean error and standard deviation of PDSC for the third axis is lower than the ones of the PSC controller by featured less error deviation.
Table 4-21: Mean and Standard Deviation of Axial Tracking Error for Circular Contour

but for the second axis the PSC controller

Axis 1 Mean (rad) S.D. (rad) TD-PD PSC PD-PD PDSC N/A N/A N/A N/A

Axis 2 Mean (rad) S.D. (rad)

Axis 3 Mean (rad) S.D. (rad)

Table 4-22: Mean and Standard Deviation of Synchronization and Coupled Error for Circular contour

Axis 1 Mean (rad) S.D. (rad) Synchronization Error ( ) PSC N/A N/A PDSC Coupled Error ( ) PSC N/A N/A PDSC

Axis 2 Mean (rad) S.D. (rad)

Axis 3 Mean (rad) S.D. (rad)

79

5 0 -5 -10 -15

x 10

-4

2
q (rad)

x 10

-4

TD-PD 6
q (rad)

x 10

-4

q (rad)

0 -2 0 x 10
-4

4 2 0 0 x 10 2
-4

1

2

0 x 10
-4

5 Time (s) 2
q (rad)

5 Time (s) PSC
q (rad)

3

5 Time (s)

2
q (rad)

0 -2 0 5 Time (s)

0 -2 0 5 Time (s)

0 -2 0 x 10 4 2 0 0 x 10
-4 -4

1

2

3

5 Time (s)

1
q (rad) q (rad)

-4 x 10 PD-PD

0 -1 0 2 q1 (rad) 4

0 -5 0 x 10
-4

2 q1 (rad) PDSC

4

q (rad)

5

1

2

3

2 q1 (rad)

4

1
q (rad) q (rad)

0 -1 0 2 q1 (rad) 4

6 4 2 0

2 0 -2 -4 -6

0

2 q1 (rad)

4

q (rad)

1

2

3

0

2 q1 (rad)

4

Figure 4-34: Axial Tracking Error of Circular Contour for TD-PD, PSC, PD-PD, PDSC

80

x 10 0

-4

x 10 0

-4

PSC 2

x 10

-3

1 (rad)

2 (rad)

3 (rad)
0 5 Time (s) -4 x 10 PDSC

-5 -10

1.5 1 0.5

-5

-10 0 5 Time (s) 0

0

0 x 10

5 Time (s)
-4

1 0.5

8

1 (rad)

2 (rad)

0 -0.5 -1 0 2 q1 (rad) 4

-5

3 (rad)
0 2 q1 (rad) 4

6 4

-10

0

2 q1 (rad)

4

Figure 4-35: Circular Contour Synchronization Error for PSC and and PDSC
-3 -3 x 10 PSC

x 10 0 -5
e* (rad)

0
e* (rad)

1

2

3

-10 -15 0 5 Time (s)

-5 -10 0 5 Time (s) -3 x 10 PDSC

e* (rad)

0.02 0.01 0

0 x 10

5 Time (s)
-3

1 0.5
e* (rad) e* (rad)

0 -5 -10 -15

10
e* (rad)

0 -0.5 -1 0 2 q1 (rad) 4

8 6 4

1

2

0 2 q1 (rad)

4

3

0 2 q1 (rad)

4

Figure 4-36: Circular Contour Coupled Error for PSC and PDSC

81

As presented in Figure 4-37, the PSC and PDSC controllers generated lower mean contour error than the rest of the controllers. Nonetheless, PDSC yielded than PSC while having a lower mean contour error

difference from the mean error of PD-PD which was the lowest

performer. Additionally, the standard deviation of the error was equally small for all the controllers as shown in Table 4-23, but the PDSC controller yielded the TD-TD controller which was the second best in that category. lower deviation than

x 10 2

-4

1

TD-PD PSC PD-PD PDSC

e

c

(m)

0

-1

-2

-3 -0.4 -0.2 0 X-axis (m) 0.2 0.4 0.6

Figure 4-37: Circular Motion Contour Tracking Performance for TD-PD, PSC, PD-PD and PDSC

82

Table 4-23: Mean and Standard Deviation of Contour Tracking Error or Circular Contour 3

Mean (m) TD-PD PSC PD-PD PDSC

S.D. (m)

As with the other cases, the torques of the slave motions on the position domain were different from the ones in the time domain. As presented in Table 4-24 this time the PD-PD and PDSC controllers produced and lower torques in the second axis than the time

domain controllers while the differences in the third axis torque are negligible.
Table 4-24: Maximum Torque for Circular Contour (in Nm)

TD-PD PSC PD-PD PDSC
10

5

Torque (Nm)

0

-5

1
-10

2 3
-1 0 1 q1 (s) 2 3 4

Figure 4-38: Circular Contour Torques for PDSC Controller
3

Contour error calculated with Eq (2-15)

83

4.8.2 Epitrochoidal Contour Interestingly, the time domain controllers, TD-PD and PSC, performed better than the position domain controllers. Particularly, the TD-PD controller featured error than the PDSC for the second axis, and the PSC controller achieved lower tracking lower error than

the PDSC for the third axis. Similarly, the standard deviation of TD-PD for the second axis was lower than the standard deviation of PDSC with the equivalent standard deviation for the PSC being Figure 4-39. In terms of the synchronization and coupled errors, the PDSC controller outperformed the PSC controller. For the second axis, the mean synchronization and coupled error were approximately lower for the PDSC than the PSC controllers. Similarly, the third axis lower than the errors of lower. The rest of the tracking performance can be seen in Table 4-25 and

synchronization and coupled error for PDSC were approximately

the PSC. As presented in Table 4-26, the standard deviations of the errors followed the same trend, with the PDSC providing a more stable error performance in synchronization. As an indication, the standard deviation of the synchronization error for the third axis was for the PDSC controller than the PSC.
Table 4-25: Mean and Standard Deviation of Axial Tracking Error for Epitrochoidal Contour

lower

Axis 1 Mean (rad) S.D. (rad) TD-PD PSC PD-PD PDSC N/A N/A N/A N/A

Axis 2 Mean (rad) S.D. (rad)

Axis 3 Mean (rad) S.D. (rad)

84

Table 4-26: Mean and Standard Deviation of Synchronization and Coupled Error for Epitrochoidal contour

Axis 1 Mean (rad) S.D. (rad) Synchronization Error ( ) PSC N/A N/A PDSC Coupled Error ( ) PSC N/A N/A PDSC

Axis 2 Mean (rad) S.D. (rad)

Axis 3 Mean (rad) S.D. (rad)

x 10 8 6 4 2 0 -2 0

-4

6

x 10

-4

TD-PD

x 10

-4

q (rad)

q (rad)

4 2 0 0 x 10 5
-4

q (rad)
2 Time (s) PSC 4

4 2 0 0 x 10
-4

1

2

2 Time (s)
-4

4

3

2 Time (s)

4

x 10

q (rad)

q (rad)

q (rad)
0 0 x 10 6 4 2 0 0 x 10 6 4 2 0 0 2 4 q1 (rad)
-3 -3

4 2 0 0 2 Time (s) 4

4 2 0 0 x 10 0 -2 -4 -6 0 x 10 0 -2 -4 -6 0 2 4 q1 (rad)
-3 -3

1

2

2 Time (s) PD-PD

4

3

2 Time (s)

4

1

q (rad)

q (rad)

0 -1 0 2 4 q1 (rad)

2 4 q1 (rad) PDSC

q (rad)

1

2

3

2 4 q1 (rad)

1

q (rad)

q (rad)

0 -1 0 2 4 q1 (rad)

Figure 4-39: Axial Tracking Error of Epitrochoidal Contour for TD-PD, PSC, PD-PD, PDSC

85

q (rad)

1

2

3

x 10 0

-3

x 10 0

-3

PSC 4

x 10

-3

1 (rad)

2 (rad)

-1 -2 -3 0 2 Time (s) 4

3 (rad)
0 2 Time (s) -4 x 10 PDSC 4

-1 -2 -3

3 2 1 0 0 x 10 2 Time (s)
-4

4

1 0.5

0 -5 -10

10 8

1 (rad)

2 (rad)

3 (rad)
0 2 4 q1 (rad)

0 -0.5 -1 0 2 4 q1 (rad)

6 4 2 0 2 4 q1 (rad)

Figure 4-40: Epitrochoidal Contour Synchronization Error for PSC and and PDSC
PSC 0
e* (rad) e* (rad)

0 -0.02 -0.04 0 2 Time (s) 4 0 2 Time (s) -3 x 10 PDSC 4 0 0 2 Time (s)
-3

1

2

3

-0.02 -0.03 -0.04

e* (rad)

-0.01

0.04 0.02

4

1 0.5
e* (rad) e* (rad)

0 -5 -10 -15 0 2 4 q1 (rad)

14 12
e* (rad)

x 10

10 8 6 4

0 -0.5 -1

1

2

0

2 4 q1 (rad)

3

0

2 4 q1 (rad)

Figure 4-41: Epitrochoidal Contour Coupled Error for PSC and PDSC

86

Despite the PDSC controller being overtaken by the other controllers on the tracking error, Figure 4-42 shows that it still ouperformed the other controllers in terms of contour tracking. In particular the contour error of PDSC was lower than the error of the second best

controller, PSC. Comparing it with the lower contour error performer, the PDSC produced lower mean error than the PD controller. The standard deviation follows idential trends as it can be seen in Table 4-27. The contour error results of the position domain controllers more clearly presented in Figure 4-43.

x 10 8 6 4 2
e (m)

-4

TD-PD PSC PD-PD PDSC

0 -2 -4 -6 -8 -10 -0.1 0 0.1 0.2 0.3 X-axis (m) 0.4 0.5 0.6

Figure 4-42: Epitrochoidal Motion Contour Tracking Performance for TD-PD, PSC, PD-PD and PDSC

c

87

Table 4-27: Mean and Standard Deviation of Contour Tracking Error of Epitrochoidal Contour4

Mean (m) TD-PD PSC PD-PD PDSC
x 10 8 6 4 2
-4

S.D. (m)

PD-PD PDSC

e (m)

0 -2 -4 -6 -8 -10 -0.1 0 0.1 0.2 0.3 X-axis (m) 0.4 0.5 0.6

c

Figure 4-43: Contour Tracking Error for PD-PD and PDSC

In this case, the position domain trajectories led to similar second axis for all the controllers simulated. Still, Table 4-28 shows that the third axis maximum torque was increased by for the position domain.
Table 4-28: Maximum Torque for Epitrochoidal Contour (in Nm)

TD-PD PSC PD-PD PDSC

4

Contour Calculated with method explained in Section 2.4.3

88

10

Torque (Nm)

5

0

-5

1 2 3
0 1 2 q1 (s) 3 4 5

-10

Figure 4-44: Epitrochoidal Contour Torques (in Nm)

4.9 Remarks
The simulations results demonstrate a general improvement of performance for the tracking and contour tracking error of the proposed PDSC control law. For linear contours, the position domain controllers yielded to lower mean contour error when compared to

the time domain controllers. For the same contours the standard deviation of the error was improved by the position domain control in an amount ranging from indicates also that the PDSC controller produced and to . Figure 4-45

lower mean error than the

PD-PD controller for the zigzag and diamond contours, respectively. The standard deviation was also improved by approximately the same percentages. The lower contour performance of the controller in the zigzag contour, when compared with the diamond motion, can be attributed to the lower time allowed for the motion to be performed, which led to higher trajectories and therefore higher required torque (also see Table 4-16 and Table 4-20). 89

Figure 4-45: Contour Tracking Performance Summary

For the circular contours, the controllers employing the synchronization principle achieved higher contour tracking performance than the independent PD controllers. With synchronization the contour error was improved by to with the standard deviation following similar

improvement. The superior performance of the synchronization controllers can be explained by considering the nonlinearity of the contours and the robotic manipulator which also led to varying sampling distance for the position domain controllers. The innate coordination of the agents that is achieved with the synchronization controllers compensates the nonlinearity of the motion in a way which the independent controllers cannot do. Between the two synchronization controllers, PDSC yielded and lower mean contour error than the PSC for the and

circular and epitrochoidal contours with the standard deviation being improved by correspondingly.

90

Figure 4-46: SPDC Maximum Torque

Figure 4-46 presents the maximum torque values of the robotic manipulators axes, as produced by the PDSC controller for all the simulated contours. Since the maximum torques of the slave axes ( and ) does not exceed the maximum values of it can be easily deduced

that the proposed controller comes with the similar power requirements as conventional time domain controllers.

91

Chapter 5: Conclusions and Future Work
5.1 General Review
Robotic manipulators have many applications from electrical and electronics production to surgical procedures and space explorations. An important research area for robotics is the development of advanced control systems for the purpose of improving tracking or contour performance, and that is the main goal of this research presented in this thesis. In this thesis, a new model-free position domain synchronization control law was proposed for the control of multi-DOF robotic manipulators. The new control law uses the principles of the position domain and synchronization to improve the contour tracking performance in the endeffector level. In position domain, the dynamics of the system are transformed from time domain to position domain via a oneÂ­to-one mapping and one the system's axis is used as the reference instead of time for the slave axes. The addition of the synchronization principles incorporates the synchronization of each slave axis' error in order to further coordinate the motion of the whole system. The stability of the proposed controller was established with the Lyapunov method where the error was proven to be bounded. The new controller was used for a planar RRR robotic manipulator and tested via linear and nonlinear contour simulations. The new controller's performance was also compared with the performances of time domain PD, time domain PSC, and position domain PD controllers. In terms of tracking error, the newly introduced controller was shown to be on par with the other controllers and in the case of linear contours it produced mean errors and standard deviation of one magnitude lower. Similarly, the mean and standard deviation of the synchronization and

92

coupled errors of the new controller were frequently lower than the ones of its time domain counterpart. Regardless of the tracking error results, the contour tracking performance of the new control law was consistently superior to the other controllers with the mean contour error and standard deviation of the PDSC controller steadily an order of magnitude lower than the contour errors of the rest of the controllers for all the contour cases.

5.2 Main Contributions
A number of the contributions are made in this thesis: o Position domain was introduced as a control alternative for nonlinear robotic systems o The principle of synchronization was introduced to position domain controllers allowing for better coordination of the slave systems. o A new and simple control law for nonlinear system was introduced which is able to provide high contour tracking performance. The new control is not limited to robotic manipulators or CNC machines but can also be used for robotic swarms, multi-agent systems and any other configuration that required high coordination. o Better contour tracking performance can be obtained by using the developed position domain synchronization control.

5.3 Future Work
Although this thesis has successfully introduced the notion of position domain synchronization control, more work can be done the further improve and expand the new control

93

concept. First of all, experiments should be performed to validate the simulations and study any unforeseen difficulties. The controller should also be used in different robot configurations (parallel, spatial, etc) as well as robot swarms and coordinated robotic groups. Lastly, position domain controllers use different trajectories than their time domain counterparts. Therefore, a path planning optimization technique should be developed in order to define position domain trajectories that would yield the best performances for the position domain controller.

94

Bibliography
Alford, C., & Belyeu, S. (1984). Coordinated control of two robot arms. Proceedings of IEEE International Conference in Robotics and Automation, 468-473. Alliance Communications Inc. (n.d.). Lean Arc Welding Lowers Cost per Weld. Retrieved March 16, weld/ Arendt, W., & Schleuch, W. P. (2009). Mathematical Analysis of Evolution, Information and Complexity. Wiley-VCH. Arimoto, S., Miyazaki, F., & Kawamura, S. (1987). Cooperative Motion Control of Multiple Robot Arms or Fingers. Proceedings of IEEE International Conference on Robotics and Automation, 1407-1412. Armstrong-Helouvry, B., Dupont, P., & Canudas De Wit, C. (1994). A Survey of Models, Analysis Tools and Compensation Methods for the Control of Machines with Friction. Automatica, 1083-1138. Arzen, K. E. (1999). A Simple Event-Based PID Controller. Procceedings of 14th IFAC World Congress, 423-428. Astrom, K. J. (2007). Event Based Control. Analysis and Design of Nonlinear Control Systems: In Honor of Alberto Isidori, 127-147. Astrom, K. J., & Hagglund, T. (2001). The Future of PID Control. Control Engineering Practice, 1163-1175. Bansal , H. O., Sharma, R., & Shreeraman, P. R. (2012). PID Controller Tuning Techniques: A Review. Journal of Control Engineering and Technology, 168-176. Bartolini, G., Pisano, A., Punta, E., & Usai, E. (2003). A Survey of Applications of SecondOrder Sliding Mode Control to Mechanical Systems. International Journal of Control, 875-892. Bayliss, Jones and Bayliss. (n.d.). Retrieved March 16, 2012, from History Website: http://www.historywebsite.co.uk/Museum/OtherTrades/BCN/BJB.htm Bristow, D. A., Tharayil, M., & Alleyne, A. G. (2006). A Survey o Iterative Learning Control. IEEE Control Systems, 96-114. 95 2013, from Fabricating and Metal Working: http://www.fabricatingandmetalworking.com/2012/11/lean-arc-welding-lowers-cost-per-

Cheng, M. L. (2007). Motion Controller Design for Contour-Following Tasks Based on RealTime Contour Error Estimation. IEEE Transactions on Industrial Electronics, 16861695. Cominos, P., & Munro, N. (2002). PID controllers: Recent Tuning Methods and Design to Specification. Control Theory and Applications, IEEE Proceedings . Craig, J. (2005). Introduction to Robotis: Mechanics and Control. Upper Saddle River: Peason Prentice Hall. Dam, T., & Ouyang, P. R. (2012). Position Domain Controur Tracking with Cross-Coupled Control. 21st IEEE International Symposium on Industrial Electronics, 1303-1308. Dean, T. (2002, May). Sensors and Sensing. Retrieved February 22, 2012, from http://cs.brown.edu: http://cs.brown.edu/~tld/courses/cs148/02/sensors.html Dombre, E. K. (2007). Robot Manipulators: Modeling, Performance Analysis and Control. Newport Beach: ISTE USA. Dombre, E., & Khalil, W. (2006). Robot Manipulators: Modeling, Performance Analysis and Control. Newport Beach: Wiley Publishing. Hsu, M. H., Yan, H. S., Liu, J. Y., & Hsieh, L. C. (2008). Epicycloid (Hypocycloid) Mechanisms Design. Proceedings of the International MultiConference of Engineers and Computer Scientics, 2. Inoue, T., Nakano, M., Matsumoto, S., & Baba, H. (1981). High Accuracy Contour Control of Proton Synchroton Magnet Power Supply. Proceeding of the 8th World Conference of IFAC, 216-221. International Federation of Robotics. (2012). History of Industrial Robots. Retrieved February 9, 2012, from International Federation of Robotics: http://www.ifr.org/fileadmin/user_upload/downloads/forms___info/History_of_Industrial _Robots_online_brochure_by_IFR_2012.pdf Kelly, R. (1997). PD Control with Desired Gravity Compensation of Robotic Manipulators: A Review. The International Journal of Robotics Research, 660-672. Kennedy, J., & Eberhart, R. (1995). Particle Swarm Optimization. Proceedings of IEEE International Conference in Neural Networks, 1942-1948. Koren, Y. (1980). Cross-Coupled Biaxial Computer Control for Manufacturing Systems . ASME Journal of Dynamic Systems, Measurement, and Control, 265-272. 96

Koren, Y., & Lo, C.-C. (1991). Variable-Gain Cross-Coupling Controller for Contouring. ASME Journal of Dynamic Systems, Measurement, and Control, 40(1), 265-272. Kuc, T. Y., & Han, W. G. (2000). An Adaptive PID Learning Control of Robot Manipulators . Automatica, 717-725. Moore, K. L., Chen, Y., & Ahn, H. S. (2006). Iterative Learning Control: A Tutorial and Big Picture View. 45th IEEE Converence on Decision and Control, 2352-2357. Ouyang, P. R., & Dam, T. (2011). Position Domain PD Control: Stability and Comparison. The 6th IEEE Conference on Industrial Electronics and Applications, 962-976. Ouyang, P. R., Dam, T., Huang, J., & Zhang, W. J. (2012). Contour Tracking Control In Position Domain. Mechatronics, 934-944. Ouyang, P. R., Huang, J., & Zhang, W. J. (2011). Position Domain Contour Control for Robotic System. 6th IEEE Conference on Industrial Electronics and Applications (ICIEA), 962967. Ouyang, P. R., Pano, V., & Dam, T. (2012). PID Contour Tracking Control in Position Domain. 21st IEEE International Symposium on Industrial Electronics, 1297-1302. Ramesh, R. M. (2005). Tracking and Contour Error Control in CNC Servo Systems . International Journal of Machine Tools and Manufacture, 301-326. Rao, R. S. (2009). Engineering Optimization: Theory and Practice. New Jersey: John Wiley & Sons, Inc. Rocco, P. (1996). Stability o PID Control for Industrial Robot Arms. IEEE Transactions on Robotics and Automation , 606-614. Rodriguez-Angeles, A., & Nijmeijer, H. (2001). Coordination of two robot manipulators based on position measurements only. International Journal of Control, 1311-1323. Sabanovic, A., Fridman, M., & Spurgeon, S. (2004). Variable Structure Systems, from principles to implementation. London, UK: The Institution of Engineering and Technology. Shan, J., Liu, H. T., & Notwotny, S. (2005). Synchronized Trajectory-Tracking Control of Multipled 3-DOF Experimental Helicopters. IEEE Proccedings in Control Theory and Applications, 683-692. Slotine, J. E., & Li, W. (1991). Applied Nonlinear Control. New Jersey: Prentice Hall. Slotine, J. W. (1988). Adaptive Manipulator Control: A Case Study. IEEE Transactions on Automatic Control , 995-1003. 97

Sun, D. (2003). Position Synchronization of Multiple Motion Axes with Adaptive Coupling Control. Automatica, 15(5), 997-1005. Sun, D. (2011). Synchronization and Control of Multiagent Systems. Boca Raton, FL: CRC Press. Sun, D., & Tong, M. C. (2009). A Synchronization Approach for the Minimization of Contouring Error of CNC Machine Tools. IEEE Transactions on Automation Science and Engineering, 720-729. Sun, D., Shao, X., & Feng, G. (2007). A Model-Free Cross-Coupled Control for Position Synchronization of Multi-Axis Motions: Theory and Experiment. IEEE Transactions on Control Systems Technology, 306-314. Takegaki, M., & Arimoto, S. (1981). A new Feedback Method for Dynamic Control of Manipulators. ASME Journal of Dynamical Systems, Measurements and Control, 119125. The MathWorks, Inc. (n.d.). MathWorks Documentation Centre. Retrieved March 13, 2013, from www.mathworks.com: http://www.mathworks.com/help/matlab/ref/interp1.html?searchHighlight=interp1 Wallen, J. (2008). The History of the Industrial Robot. Linkoping, Sweden: Linkopings Universitet: Department of Electrical Engineering. Wang, Y., Gao, F., & Doyle, F. J. (2009). Survey on Iterative Learning Control, Repetitive control, and Run-to-Run Control. Journal of Process Control, 1589-1600. WINTHROP Inc. (n.d.). The DaVinci Si HD Surgical System at Winthrop-University Hospital. Retrieved March 16, 2013, from Winthrop University Hospital: https://www.winthrop.org/departments/institutes/family/ob-gyn/robotic-surgery/daVinciSi-HD-Surgical-System/ Yee, L. L. (2011, August 1). Foxconn to rely more on robots; could use 1 million in 3 years. Retrieved February 9, 2012, from www.reuters.com: http://www.reuters.com/article/2011/08/01/us-foxconn-robotsidUSTRE77016B20110801 Yeh, S. H. (2003, May). Yeh, S. S., & Hsu, P. L. (2003). Analysis and design of integrated control for multi-axis motion systems. Control Systems Technology, IEEE Transactions on, 11(3), 375-382. IEEE Transactions on Control Systems Technology, 375-382. 98

Yokokohji, Y., & Yoshikawa, T. (1994). Bilaterl Control of Master-Slave Manipulators for Ideal Kinesthetic Coupling-Formulation and Experiment. IEEE Transactions on Robotics and Automation, 605-620. Zhao, D., Li, S., Gao, F., & Zhu, Q. (2008). Robust Adaptive Terminal Sliding-Based Synchronised Position Control For Multiple Motion Axes Systems. IET Control Theory and Applications, 136-150.

99

Appendix
3R Dynamics and Kinematics
Forward Kinematics (1) (2) (3) Inverse Kinematics Position:

(4) (5) (6)  Then, (7)

(8) (9) (10) 100

Velocity:

 

  



 

(11)

(12)







(

) 

(13)

Dynamics Inertia Matrix

(14)

(15)

(16)

(17)

(18)

(19)

Coriolis-Centrifugal Forces

101

Define,

 [ ] {  }   [  [ ] {  }   [  [ ] {  }   [ ] {  }    ] { }  [  [ ] {  }  Gravity Vector   ] { }  ] {  }  ] {  } 

(20)

(21)

(22)

(23)

(24)

(25)

[

(26)

(27)

(28)

{

}

(29)

102

{

}

(30)

(31)

MATLAB Functions
Master File This is the Master controlling the secondary functions and defining the variables of the system. In this case a linear contour is executed. Declaration of variables
global mass I l r tspan dt global global global global global global Pi Pf tf Pd dPd ddQd dQd Qd Kp Kd Ki kp kd ks beta N dp pq vq aq rvq raq alpha b fc fs ft delta dxs eta deta star dstar peta pdeta pstar pdstar

Friction Parameters
b =1.5; fc = 3; fs =5; ft =100; delta = 2;

Gain Definition
kp = kd = ks = beta [9.088240799499298; [9.871988565005141; [0.009597076721277; = [0.006550083466772; 8.304024394997082; 6.717464827016674]*1e3; 7.900803640707129; 7.476418888180112]*1e3; 0.004867545399102; 0.001182615747053]*1e3; 0.006691256417746; 0.008477182028822]*1e3;

% TD-PD and PD-PD gains Kp = kp; Kd = kd;

103

Ki = [0;0;0]; % PDSC and PSC gains kp = diag(kp); kd = diag(kd);ks = diag(ks);beta=diag(beta); % Robotic Manipulator Parameters mass = [1 1 0.5]; l = [0.5 0.5 0.3]; r = l/2; I = [0.1 0.1 0.05];

Trajectory Planning
% Sampling and time definition N =1500; tf = 1.5; dt = tf/(N-1); tspan = 0:dt:tf; %Definition of trajectory function tr = 10*(tspan/tf).^3-15*(tspan/tf).^4+6*(tspan/tf).^5; dtr = (30*(tspan/tf).^2-60*(tspan/tf).^3+30*(tspan/tf).^4)/tf; ddtr = (60*(tspan/tf)-180*(tspan/tf).^2+120*(tspan/tf).^3)/tf^2; % Definition of end-effector trajectory Pi = [0.5;0.5;pi/3]; Pf = [0.7;0.7;pi/3]; th = atan2(Pf(2)-Pi(2),Pf(1)-Pi(1)); Pd = bsxfun(@plus,bsxfun(@times,(Pf-Pi),tr),Pi)'; dPd = bsxfun(@times,(Pf-Pi),dtr)'; % Inverse kinematics for the joint trajectory [Qd,dQd] = inverse_3dof_matrix(Pd,dPd); ddQd = [ 0 0 0; diff(dQd)/dt];

TD-PID Controller
p0 = [Qd(1,1) dQd(1,1) Qd(1,2) dQd(1,2) Qd(1,3) dQd(1,3)]; opts = odeset('RelTol',1e-5,'AbsTol', 1e-5*ones(6,1)); [t,x] = ode15s('system_time_PID',tspan,p0,opts); error = [Qd(:,1) dQd(:,1) Qd(:,2) dQd(:,2) Qd(:,3) dQd(:,3)] - x;

TD-PSC Controller
p0 = [Qd(1,1) dQd(1,1) Qd(1,2) dQd(1,2) Qd(1,3) dQd(1,3)]; opts = odeset('RelTol',1e-5,'AbsTol', 1e-5*ones(6,1)); [ts,xs] = ode15s('system_time_synchro2',tspan,p0,opts); errors = [Qd(:,1) dQd(:,1) Qd(:,2) dQd(:,2) Qd(:,3) dQd(:,3)] - xs;

104

Position Domain Trajectory definition
pq = zeros(N,3);vq = zeros(N,3); aq = zeros(N,3); dp = (x(end,1)-x(1,1))/(N-1); pq(1,:) = Qd(1,:); vq(1,:) = dQd(1,:); accel = [0 0 0; diff(x(:,2)) diff(x(:,4)) diff(x(:,6))]/dt; % Trajectory transformation from time to position domain % as a function of master motion pq(:,1) = x(1,1):dp:(x(end,1)); pq(:,2) = interp1(Qd(:,1),Qd(:,2),pq(:,1)); pq(:,3) = interp1(Qd(:,1),Qd(:,3),pq(:,1)); vq(:,1) = interp1(Qd(:,1),x(:,2),pq(:,1)); vq(:,2) = interp1(Qd(:,1),dQd(:,2),pq(:,1)); vq(:,3) = interp1(Qd(:,1),dQd(:,3),pq(:,1)); aq(:,1) = interp1(Qd(:,1),accel(:,1),pq(:,1)); aq(:,2) = interp1(Qd(:,1),accel(:,2),pq(:,1)); aq(:,3) = interp1(Qd(:,1),accel(:,3),pq(:,1));

pq = [smooth(pq(:,1)) smooth(pq(:,2)) smooth(pq(:,3))]; vq = [smooth(vq(:,1)) smooth(vq(:,2)) smooth(vq(:,3))]; aq = [smooth(aq(:,1)) smooth(aq(:,2)) smooth(aq(:,3))]; rvq = [ 0 0; bsxfun(@rdivide,diff(pq(:,2:3)),diff(pq(:,1)))]; rvq(1,:) = rvq(2,:); raq = bsxfun(@rdivide,bsxfun(@minus,aq(:,2:3),bsxfun(@times,aq(:,1),rvq)),rvq(:,1).^2); Pdq = forward_3dof(pq); vq(end,:) = [ 0 0 0];

PD-PID Controller
pp0 = [pq(1,2) rvq(1,1) pq(1,3) rvq(1,2)]; popts = odeset('RelTol',1e-5,'AbsTol', 1e-5*ones(4,1)); [px, xp] = ode15s('system_position_PID',pq(:,1),pp0,popts); errorp = [pq(:,2) rvq(:,1) pq(:,3) rvq(:,2)]-xp;

PD-PDSC Controller
pp0 = [pq(1,2) rvq(1,1) pq(1,3) rvq(1,2)]; popts = odeset('RelTol',1e-5,'AbsTol', 1e-5*ones(4,1)); [pxs, xps] = ode15s('system_position_synchro2',pq(:,1),pp0,popts); errorps = [pq(:,2) rvq(:,1) pq(:,3) rvq(:,2)]-xps;

105

Sum and calculations Error
% Resulting trjectories c = forward_3dof([x(:,1) x(:,3) x(:,5)]); cs = forward_3dof([xs(:,1) xs(:,3) xs(:,5)]); cp = forward_3dof([pq(:,1) xp(:,1) xp(:,3)]); cps = forward_3dof([pq(:,1) xps(:,1) xps(:,3)]); % Resulting contour error ER = Pd-c; ERp = Pdq-cp;ERs = Pd-cs; ERps = Pdq-cps; E = -ER(:,1)*sin(th)+ER(:,2)*cos(th); Es = -ERs(:,1)*sin(th)+ERs(:,2)*cos(th); Ep = -ERp(:,1)*sin(th)+ERp(:,2)*cos(th); Eps = -ERps(:,1)*sin(th)+ERps(:,2)*cos(th); % Synchronization and coupled errors synchro_error=eta;synchro_derror=deta;coupled_error=star;coupled_derror=dstar; synchro_perror=peta;synchro_pderror=pdeta;coupled_perror=pstar;coupled_pderror=pdstar; time = tspan;pos = sort(px);

Published with MATLABÂ® R2012b Secondary Functions System Dynamics and PDSC Controller This MATLAB function calculates the system's dynamics and control input. Then it calculates the state derivative Input: x - vector of state variables t Â­ time

Output: xdot Â­ derivative of vector of state variables
%Output: xdot - derivative of state variable function xdot = system_position_synchro2(t,x)

Declaration of variables
global global global global mass I l r kp kd ks beta T ksii2 pq vq aq rvq raq b fc fs ft friction

106

global peta pdeta pstar pdstar

m1=mass(1); m2=mass(2); m3=mass(3); r1=r(1); r2=r(2); r3=r(3); I1=I(1); I2=I(2); I3=I(3); l1 = l(1); l2=l(2); l3=l(3);

% % % %

Masses for each link Centres of gravity Inertia of each link Length of each link

Identification of desired and actual state
dd = abs(bsxfun(@minus,pq(:,1),t)); j = find(dd == min(dd)); qd = pq(j,:)'; dqd = [vq(j,1) rvq(j,:)]'; ddqd = aq(j,:)'; dqp = rvq(j,:)'; ddqp = raq(j,:)'; % % % % % % % Desired position Desired velocity Desired acceleration Desired position relative velocity Desired position relative acceleration

q = [pq(j,1); x(1); x(3)]; dq = vq(j,1)*[1; x(2); x(4)];

% Actual position % Actual velocity

Cosines & Sines
c1=cos(q(1)); s1=sin(q(1)); c2=cos(q(2)); s2=sin(q(2)); c3=cos(q(3)); s3=sin(q(3)); c12=cos(q(1)+q(2)); c123=cos(q(1)+q(2)+q(3)); c23=cos(q(2)+q(3)); s23=sin(q(2)+q(3));

Matrix M
M(1,1)=I1+I2+I3+m1*r1^2+m2*(l1^2+r2^2+2*l1*r2*c2); M(1,1)=M(1,1)+m3*(l1^2+l2^2+r3^2+2*l1*l2*c2+2*l2*r3*c3+2*l1*r3*c23); M(1,2)=I2+I3+m2*(r2^2+l1*r2*c2)+m3*(l2^2+r3^2+l1*l2*c2+2*l2*r3*c3+l1*r3*c23); M(2,1)=M(1,2); M(1,3)=I3+m3*(r3^2+l2*r3*c3+2*l1*r3*c23); M(3,1)=M(1,3); M(2,2)=I2+I3+m2*r2^2+m3*(l2^2+r3^2+2*l2*r3*c3); M(2,3)=I3+m3*(r3^2+l2*r3*c3); M(3,2)=M(2,3);

107

M(3,3)=I3+m3*r3^2;

Matrix C
t11(1)=0; t11(2)=-m2*l1*r2*s2-m3*(l1*l2*s2+l1*r3*s23);t12(1)=t11(2); t11(3)=-m3*(l2*r3*s3+l1*r3*s23);t13(1)=t11(3); t12(2)=-m2*l1*r2*s2-m3*(l1*l2*s2+l1*r3*s23);t12(3)=-m3*(l2*r3*s3+l1*r3*s23); t13(2)=t12(3);t13(3)=-m3*(l2*r3*s3+l1*r3*s23); t21(1)=m3*(l1*r2*s2+l1*r3*s23)+m2*l1*r2*s2;t21(2)=0;t22(1)=0;t21(3)=-m3*l2*r3*s3; t23(1)=t21(3);t22(2)=0;t22(3)=-m3*l2*r3*s3;t23(2)=t22(3);t23(3)=t23(2); t31(1)=m3*(l2*r3*s3+l1*r3*s23);t31(2)=m3*l2*r3*s3;t32(1)=t31(2);t31(3)=0; t33(1)=0;t32(2)=m3*l2*r3*s3;t32(3)=0;t33(2)=0;t33(3)=0; C(1,1)=t11*dq;C(1,2)=t12*dq;C(1,3)=t13*dq; C(2,1)=t21*dq;C(2,2)=t22*dq;C(2,3)=t23*dq;C(3,1)=t31*dq;C(3,2)=t32*dq;C(3,3)=t33*dq;

Matrix G
G(1,1)=9.8*(m1*r1*c1+m2*(l1*c1+r2*c12)+m3*(l1*c1+l2*c12+r3*c123)); G(2,1)=9.8*(m2*r2*c12+m3*(l2*c12+r3*c123)); G(3,1)=9.8*m3*r3*c123;

Friction Matrix F
f = -(fc+(fs-fc)*exp(-(dq/ft).^2)).*sign(dq)+b*dq;

Matrices for PDC
A = [ M(2,2) M(2,3); M(3,2), M(3,3)]; B = [M(2,2)*ddqd(1)+C(2,2)*dq(1), M(2,3)*ddqd(1)+C(2,3)*dq(1);M(3,2)*ddqd(1)+C(3,2)*dq(1), M(3,3)*ddqd(1)+C(3,3)*dq(1)]; D = [M(2,1) C(2,1); M(3,1) C(3,1)]*[ddqd(1); dq(1)]; E = [G(2); G(3)]; F = [f(2);f(3)];

Controller
% Gains pkp = kp(2:3,2:3);

108

pkd= kd(2:3,2:3); pks= ks(2:3,2:3); % Tracking Error e = qd-q; de = [0 ;dqp-[x(2);x(4)]]; % Sychronization Error Tau = [1 -1 0; 0 1 -1; -1 0 1]; epsilon = Tau*e; depsilon = Tau*de; peta(j,:) = epsilon(2:3)'; pdeta(j,:) = depsilon(2:3)'; ksii2(:,j) =Tau'*epsilon; % Coupled position error es = e+beta*epsilon; des = de+beta*depsilon; pstar(j,:) = es(2:3)'; pdstar(j,:) = des(2:3)';

% Position error % Derivative of position error

% % % %

Synchronization Matrix Synchronization error Derivative of synchronization error

% Coupled error % Derivative coupled error

Control Input
if vq(j,1) ~=0 s = sign(vq(j,1)); elseif vq(j,1)==0 s = 1; end tau = pkp*es(2:3)+pkd*s*des(2:3); % A logic function to signify % direction

% PDSC controller

Derivative of State
xx = [0;0]; if vq(j,1)~=0 xx = A\(tau-B*[x(2);x(4)]-D-E-F)/vq(j,1)^2; end T(j,2:3) = vq(j,1)^2 *A*xx+B*[x(2);x(4)]+D+E+F; xdot = [x(2);xx(1);x(4);xx(2)]; end

Published with MATLABÂ® R2012b

109

Inverse Kinematics of Robotic Manipulator This MATLAB function calculates the joint angular position and velocities based on the end effector task space coordinates and velocities Inputs: pos - End-effector task space position vel - End-effector task space velocity Outputs: angle- Joint angular position dangle - Joing angular velocity
function [angle,dangle]=inverse_3dof_matrix(pos,vel)

Variable declaration and definition
global l N population size from master file x = pos(:,1);y=pos(:,2); q = pos(:,3); dx = vel(:,1); dy=vel(:,2); dq = vel(:,3); l1=l(1); l2=l(2);l3=l(3); function % Renaming length links for use on this % Apprehending link lengths and

Angular position calculations
x2=x-l3*cos(q); y2=y-l3*sin(q); cq2=(x2.^2+y2.^2-l1^2-l2^2)/(2*l1*l2); sq2=sqrt(1-cq2.^2); angle(:,2)=atan2(sq2,cq2); angle(:,1)=atan2(y2,x2)-atan2(l2*sq2,l1+l2*cq2); angle(:,3)=q-angle(:,1)-angle(:,2); % Small logic algorithm for eliminating trajectory discontinuities A = diff(angle); if max(abs(diff(angle(:,1))))>=pi k = find(abs(A(:,1))==max(abs(A(:,1))))+1; nk = round(max(abs(A))/pi).*( A(k,:)./abs(A(k,:))); angle(k:end,:) = angle(k:end,:) + [ones(N-k+1,1)*nk(1)*pi ones(N-k+1,1)*nk(2)*pi ones(Nk+1,1)*nk(3)*pi]; end

110

Calculating joint velocities
q1=angle(:,1); q2=angle(:,2); q3=angle(:,3); s1=sin(q1); s2 = sin(q2); s3 =cos(q3);s12=sin(q1+q2); s123=sin(q1+q2+q3); s23 = sin(q2+q3); c1=cos(q1); c2 = cos(q2); c3 = cos(q3);c12=cos(q1+q2); c123=cos(q1+q2+q3); c23 = cos(q2+q3); dangle(:,1) dangle(:,2) (l3*(l1*s23 dangle(:,3) end = = + = (c12./(l1*s2)).*dx+(s12./(l1*s2)).*dy + ((l3*s3)./(l1*s2)).*dq; (-(l2*c12 + l1*c1)./(l1*l2*s2)).*dx + (-(l2*s12 + l1*s1)./(l1*l2*s2)).*dy + (l2*s3))./(l1*l2*s2)).*dq; (c1./(l2*s2)).*dx+(s1./(l2*s2)).*dy+((l3*s23)./(l2*s2) + ones(N,1)).*dq;

Published with MATLABÂ® R2012b Forward Kinematics of Robotic Manipulator This MATLAB function calculates the end-effector task space position based on the joint angular positions Inputs: q - Joint angular position Outputs: pos - End-effector task space position
function pos=forward_3dof(q)

Variable declaration and definition
global l N l1=l(1); l2=l(2);l3=l(3); % Apprehending link lengths and population size from master file % Renaming length links for use on this function

End-effector position calculations
pos(:,1)=l1*cos(q(:,1))+l2*cos(q(:,1)+q(:,2))+l3*cos(q(:,1)+q(:,2)+q(:,3)); pos(:,2)=l1*sin(q(:,1))+l2*sin(q(:,1)+q(:,2))+l3*sin(q(:,1)+q(:,2)+q(:,3)); pos(:,3)=q(:,1)+q(:,2)+q(:,3);

Published with MATLABÂ® R2012b

111

Nonlinear Contour Error Estimation This function calculates the error for nonlinear contours Inputs: C - desired contour C2 - actual contour t-time Output: Contour error
function Ec = contour_error(t,C,C2) C = C(:,1:2); C2 = C2(:,1:2); t=t(:); V = [0 0;bsxfun(@rdivide,diff(C(:,1:2)),diff(t))]; V2 = [0 0;bsxfun(@rdivide,diff(C2(:,1:2)),diff(t))]; E = C-C2; dC = [0 0 ;diff(C)]; dC2 = [ 0 0;diff(C2)]; ds1 = sum(dC.^2,2); ds2 = sum(dC2.^2,2); L = (dC2(:,1)./ds2).*E(:,1)+(dC2(:,2)./ds2).*E(:,2); dT = L./sum(V.^2,2); Cr = C - bsxfun(@times,0.5*(V+V2),dT); phi = atan((Cr(:,2)-C(:,2))./(Cr(:,1)-C(:,1))); j = find(isnan(phi)); phi(j) = pi/2; Ec = E(:,1).*sin(phi)-E(:,2).*cos(phi); end

Published with MATLABÂ® R2012b

112

