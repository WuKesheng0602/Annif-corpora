Ryerson University

Digital Commons @ Ryerson
Theses and dissertations

1-1-2011

Wind Turbine Sound Propagation Using A FiniteDifference Time-Domain Method
Daniel Wrobel
Ryerson University

Follow this and additional works at: http://digitalcommons.ryerson.ca/dissertations Part of the Aerospace Engineering Commons Recommended Citation
Wrobel, Daniel, "Wind Turbine Sound Propagation Using A Finite-Difference Time-Domain Method" (2011). Theses and dissertations. Paper 1636.

This Thesis is brought to you for free and open access by Digital Commons @ Ryerson. It has been accepted for inclusion in Theses and dissertations by an authorized administrator of Digital Commons @ Ryerson. For more information, please contact bcameron@ryerson.ca.

Wind Turbine Sound Propagation using a Finite-Difference Time-Domain Method

by

Daniel Wrobel Bachelor of Engineering - Aerospace Engineering, Ryerson, 2009

A thesis presented to Ryerson University

in partial fulfillment of the requirements for the degree of Master of Applied Science in the Program of Aerospace Engineering

Toronto, Ontario, Canada, 2011 Â©Daniel Wrobel 2011

I hereby declare that I am the sole author of this thesis. I authorize Ryerson University to lend this thesis to other institutions or individuals for the purpose of scholarly research.

I further authorize Ryerson University to reproduce this thesis by photocopying or by other means, in total or in part, at the request of other institutions or individuals for the purpose of scholarly research.

iii

Wind Turbine Sound Propagation using a Finite-Difference Time-Domain Method Master of Applied Science 2011 Daniel Wrobel Aerospace Engineering Ryerson University

Abstract
Energy usage is on the rise in both Canada and the United States. Because of this, there is a growing demand and strain on the current infrastructure. More importantly though, there is a strong demand for the use of renewable energy sources to meet this demand. One of the most popular renewable energy sources at this time is the wind turbine. In Ontario, there are plans to implement a significant number of them throughout the province. There are concerns though from residents in the vinicity of them that they cause too much noise, as well as health issues. However, some argue that these complaints stem from incorrectly calculated setback distances due to the lack of use of a detailed sound propagation model. In this study, a sound propagation model was developed using a Finite-Difference Time-Domain method, for a three dimensional computational domain, and simulated using data for a Siemens SWT2.3-101 wind turbine. The simulations produced data of the sound propagation characteristics of each emitted wave, for each tested case. The model was developed as a starting point and building block for the eventual use in simulations of large domains and complex flow phenomena.

v

Acknowledgements
Most importantly, I would like to thank my advisor, Jason Lassaline, whose guidance and support throughout this project helped me develop a greater understanding of the subject area. Without his assistance, this project would not have been possible. My sincere thanks to those who have taught and helped me throughout my undergraduate and graduate degrees; your unique approaches to many of the courses I studied assisted me in developing an appreciation and understanding of the fundamentals, which helped me immensely while working on this project. Computations were performed on the gpc supercomputer at the SciNet HPC Consortium. SciNet is funded by: the Canada Foundation for Innovation under the auspices of Compute Canada; the Government of Ontario; Ontario Research Fund - Research Excellence; and the University of Toronto [43]. Computations were also performed on the orca supercomputer at the SHARCNET HPC Consortium. SHARCNET is a partner of the Compute Canada national HPC platform, and is the largest high performance computing consortium in Canada, including 17 universities, colleges and research institutes across southwestern, central and northern Ontario.

vii

Dedication
To my parents, Bob and Vicky, who encouraged me to continue my education and who helped me get through a difficult time after completing my undergraduate degree. Also to my friends, who have given me support and have been there for me.

ix

Contents
Declaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Abstract . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Dedication . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . iii v ix

Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . vii List of Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiii List of Figures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xv List of Appendices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xvii 1 Introduction 1.1 1.2 Organization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Background . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1.2.1 1.2.2 1.2.3 1.2.4 1.2.5 IESO and its role in Ontario . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Wind Turbine Development . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Development Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ISO Sound Propagation Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 2 2 3 3 7 8

Past development . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 15

2 Methodology 2.1 2.1.1 2.1.2 2.1.3 2.1.4 2.2 2.2.1 2.2.2 2.2.3 2.2.4 2.3

Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 Domain Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 Boundary Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 Absorbing Boundary Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 Implementation Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 Noise Model Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 Solutions of Wave Equation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 Noise Sources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 Noise Emission Estimation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36

Sound Generation Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

Workflow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 xi

3 Results 39 3.1 Validation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 3.2 3.3 Grid Convergence Study . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 Test Cases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44

4 Conclusion 57 4.1 Recommendations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 References Acronyms 218 219

xii

List of Tables
1.1 1.2 1.3 1.4 1.5 1.6 2.1 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 Installed Wind Farms in Ontario. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Wind Farm Development Projects in Ontario. . . . . . . . . . . . . . . . . . . . . . . . . . Octave Bands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 6 9

ISO 9613-2 Attenuation Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 ISO 9613-2 Conditions for Propagation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 Ontario Wind Turbine Installation Sound Power Limits . . . . . . . . . . . . . . . . . . . 11 Ground Condition Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 Grid Convergence Study Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41 Grid Spacing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 Sound Pressure Levels at Varied Grid Spacing . . . . . . . . . . . . . . . . . . . . . . . . . 43 Grid Spacing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 Tested Flow Conditions - Constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 Tested Flow Conditions - Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46 Estimated Propagation Distances - Monopole, Uniform Flow . . . . . . . . . . . . . . . . 49 Estimated Propagation Distances - Monopole, Power Law Flow . . . . . . . . . . . . . . . 53

xiii

List of Figures
1.1 1.2 1.3 1.4 1.5 2.1 2.2 2.3 2.4 2.5 2.6 3.1 3.2 3.3 3.4 3.5 3.6 3.6 3.7 3.8 3.8 3.9 IESO Boundaries and Partner Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . Future Renewable Energy Production in Ontario . . . . . . . . . . . . . . . . . . . . . . . A Sound Wave . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Erie Shores Wind Turbine Farm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Sound Power Level Measurement Curves . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 5 7 8 9

Control Volume Cross-Section . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16 Staggered Grid Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21 Dipole Directivity Pattern . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 Noise components on an airfoil . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 Noise Sources of a NACA 632xx Turbine Blade (Bonus 300 kW) . . . . . . . . . . . . . . 36 ParaView Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 Low-Resolution 2-D Validation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 High-Resolution 2-D Validation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 Wilson and Liu Solution of Emitting Monopole Source . . . . . . . . . . . . . . . . . . . . 41 Grid Convergence Study Plot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 Sound Pressure Level vs. Distance from Source - Monopole, Uniform Flow . . . . . . . . . 47 Uniform Flow Monopole, Rigid/Water (left) and Asphalt (right) . . . . . . . . . . . . . . 48 Uniform Flow Monopole, Forest (left) and Snow (right) . . . . . . . . . . . . . . . . . . . 48 Sound Pressure Level vs. Distance from Source - Dipole, Uniform Flow . . . . . . . . . . 49 Uniform Flow Dipole, Rigid/Water (left) and Asphalt (right) . . . . . . . . . . . . . . . . 50 Uniform Flow Dipole, Forest (left) and Snow (right) . . . . . . . . . . . . . . . . . . . . . 50 Sound Pressure Level vs. Distance from Source - Monopole, Power Law Flow . . . . . . . 51

3.10 Power Law Flow Monopole, Rigid/Water (left) and Asphalt (right) . . . . . . . . . . . . . 52 3.10 Power Law Flow Monopole, Forest (left) and Snow (right) . . . . . . . . . . . . . . . . . . 52 3.11 Sound Pressure Level vs. Distance from Source - Dipole, Power Law Flow . . . . . . . . . 54 3.12 Power Law Flow Dipole, Rigid/Water (left) and Asphalt (right) . . . . . . . . . . . . . . . 55 3.12 Uniform Flow Monopole, Forest (left) and Snow (right) . . . . . . . . . . . . . . . . . . . 55

xv

List of Appendices
1 FD Approximations 1.1 1.1.1 1.1.2 1.1.3 1.1.4 1.2 1.2.1 1.2.2 1.2.3 1.2.4 59

Sound Propagation Equations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 Equation 2.25 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 Equation 2.26 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 Equation 2.27 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 Equation 2.28 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62 Equation 2.37 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63 Equation 2.38 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63 Equation 2.39 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63 Equation 2.40 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64 65

Absorbing Boundary Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63

2 Sample Submission Scripts 2.1 2.2 2.3

SHARCNET . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65 SCINET . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66 Local Cluster . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66 69

3 Source Code 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 3.9

main.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 bc.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77 bc.h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80 io.h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82 io.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 mean.h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106 mean.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108 ode.h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117 ode.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122

3.10 param.h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158 3.11 param.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160 3.12 setup.h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163 xvii

3.13 setup.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164 3.14 source.h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172 3.15 source.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175 3.16 timemarch.h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196 3.17 timemarch.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196 3.18 ts.h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208 3.19 ts.c . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208

xviii

List of Symbols
The following nomenclature is used throughout this text with common S.I. units given if applicable. Alphanumeric Symbols A amplitude a b c ~ c x y y F f f1 f2 f3 Fs g GCI k k0 k1 k2 kc L LP M m N Nx Ny order of convergence mass bouyancy speed of sound ambient speed of sound mesh spacing in x mesh spacing in y mesh spacing in z force acting on medium frequency fine grid sound power level normal grid sound power level coarse grid sound power level safety factor gravity grid convergence index wave number wave number incidence wave number transmission wave number complex wavenumber length variation in density sound power level mach number grid convergence ratio number of grid nodes per wavelength number of nodes in x number of nodes in y xix

Nz ~ P P p Pref

number of nodes in z pressure ambient pressure pressure perturbation reference pressure

PRM S root mean square pressure  Q monopole strength per unit volume q  Q q r ~ S S s sc t v ~ v w wi xmax xmin xi ymax ymin zmax zmin Zc monopole strength in-flow rate density volumetric flow rate grid spacing medium entropy ambient entropy entropy perturbation structure constant/effective density factor time ambient velocity medium velocity vector velocity perturbation acoustic wave velocity maximum domain dimension in x minimum domain dimension in x position of observer in space maximum domain dimension in y minimum domain dimension in y maximum domain dimension in z minimum domain dimension in z characteristic impedance

Greek Symbols  heat capacity ratio e p   p  i t   effective bulk modulus bulk modulus of air in pores wavelength porosity density of air in pores static flow resistivity angle of incidence angle of transmission turbulent eddy size angular frequency xx

  1 2     ~

source term retarded time angle of incidence transmission angle density perturbation vector gradient ambient density density

xxi

Chapter 1

Introduction
The energy demands of Canada and the United States are increasing every year. To alleviate the increasing demand, there are a number of traditional methods to produce energy on a mass scale. These include oil, gas, and coal burning plants, as well as nuclear power. However, in recent years, there has been a strong push towards to use of renewable energy sources. Perhaps the most familiar renewable energy source in Canada, and in particular Southern Ontario, is Niagara Falls. Nevertheless, there are other potential sources of energy which can utilized. In Ontario, solar energy appears to have a bright future. However, wind energy has seen a significant increase in use as well. Being a renewable energy resource relying on wind, it has a significant potential in Ontario. The use of wind turbines has caused some controversy though, in the form of complaints from residents living in the vicinity of them. Many of these residents have complained that the turbines produce too much noise, and that they also cause health problems. Nonetheless, the amount of noise produced by the turbines has been decreased since their inception with design changes. Further, to alleviate the noise issues, setback distances have been established by governing bodies to aid builders in positioning the turbines in relation to homes. Using the setback distances however, residents still complain of noise and health issues. Therefore, it would be logical to assume that perhaps the setback distance is not quite adequate. In addition, the methods used to calculate the setback distance may also need to be re-evaluated. Hence, it was worthwhile to consider a more complex model to examine the sound propagation characteristics of wind turbines. Work has been done in these areas, but the methods used to obtain the results (Finite Volume Method (FVM) and Finite Element Method (FEM)) have not always been satisfactory, according the respective authors. Therefore, this study considered the use of a FiniteDifference, Time-Domain (FDTD) method for developing a sound propagation model to predict noise from wind turbines. From past studies, several authors have metioned that this method is recommended for complex and detailed simulations, and that future work is recommended to be done using it in wave propagation situations. Hence, to aid in the development of the model, it was subdivided into two separate areas: the development of the domain and sound propagation model with absorbing boundaries (using the FDTD method), and the development of the sound generation model. 1

1.1. ORGANIZATION

CHAPTER 1. INTRODUCTION

To explore the applicability of the FDTD method to wind turbine applications, geometrical data was obtained for a Siemens SWT-2.3-101 wind turbine; this turbine is the most commonly installed in Ontario. Simulations were performed by using a variety of different ground conditions, as well as source and flow situations. The results that were obtained clearly showed the effects varying ground conditions and flow profiles on absorption and the propagating sound wave from the source, as well as on the differences in propagation between using a monopole and dipole to model a wind turbine. As expected, the ground conditions with lower porosity values tended to be absorbed less, in comparison to those with higher porosities. As well, it was determined that the monopole sources were less effective at radiating sound away in comparison to the dipoles. The dipole was able to maintain a Sound Pressure Level (SPL) which was less affected by the absorption characteristics, in comparison to the monopole. Finally, in using differing flow conditions, it was determined that the effects of the flow profile affected the SPL of the sound being emitted; that is, for a uniform flow, the SPL tended to be higher at the ground, in comparison to a power law flow. As well, it was evident that the flow velocity had an effect on the sound propagation.

1.1

Organization

This document has been divided into four chapters, which contain the main matter of the study. The first chapter is the introduction and outlines the current energy situation in Ontario, as well as some of the issues relating to the development of wind turbines in the province. The section concludes by introducing the current method of calculating setback distances used in Ontario, as well as discussing existing developments in sound propagation models for wind turbines. The second chapter introduces the methodology which was used to develop a new sound prediction model. It outlines the configuration of the sound propagation, boundary condition, and sound generation models which were used to produce data. The third chapter provides an analysis of the results which were obtained from the study. The chapter also includes the validation which was performed to test the correct operation of the model. The fourth chapter concludes the document with a discussion of the results. It also provides a discussion of how the results and study itself could be improved upon.

1.2

Background

Energy production is a very important topic in engineering. Research is constantly being carried out to develop new forms of energy production, as the worlds energy needs are changing every year [9]. In using renewable energy sources such as wind turbines however, there are some compromises; perhaps the most significant of these is annoyance [3], which tends to spread a negative general perception of the technology. The numerical sound propagation model which was developed in this paper can be used to alleviate the adverse effects and potentially solve the issues relating to noise around turbine installations. In Ontario, there is currently an installed capacity of approximately 36,000 Megawatts (MW), with 2

CHAPTER 1. INTRODUCTION

1.2. BACKGROUND

4,600 MW [24] of potentially imported power being available. Of this energy reserve, the largest contribution is from nuclear power. Although this reserve can definitely supply Ontario with an abundance of electricity, some significant usage milestones have been reached in the last decade; in August 2006 a record summer peak need of 27,005 MW was reached, and in December 2004 a record winter peak of 24,979 MW was reached [24]. To deal with current and future demand, Ontario has proposed to put into effect 5,000 MW of additional renewable energy production. This would be comprised of solar, hydro, wind, biomass, biogas, and landfill gas derived energy [24]. It should be noted that a significant amount of energy is produced in the United States as well; this amount is expected to increase to meet demand [47]. One can therefore logically conclude that the future demand for energy is a significant issue in both the United States and Canada. It is logical to assume that as demand increases in Canada, the United States follows, or vice versa, which can lead to supply and demand issues.

1.2.1

IESO and its role in Ontario

The governing body of energy production standards in the province is known as the Independant Electricity System Operator (IESO) (originally known as the Independant Electricity Market Operator (IMO) until 2005). A not-for-profit organization, it was initially put into place in 1998 following the deregulation of the electricity market in Ontario [7]. Before the de-regulation, the provinces electricity needs were handled by Ontario Hydro. Furthermore, with the establishment of the IMO, Ontario followed suite with other power providers in North America to establish an integrated energy network composed of several different independent operators (ie. Hydro Quebec, New York Indepedant System Operator, Indepedant System Operator of New England, etc, each comprising a part of the North American power grid) (Fig. 1.1) [8]. In this province, IESO essentially oversees Ontario Power Generation (OPG), Hydro One (HO), and other local distribution companies. To handle the research and analysis required to assess system performance and determine future demand, in 2004, with the introduction of Bill 100 Electrical Restructing Act in Ontario, the Ontario Power Authority (OPA) was created [14]. It essentially oversees long term power supply needs and is also in place to ensure that an energy conservation culture in Ontario is followed.

1.2.2

Wind Turbine Development

The use of wind turbines to produce energy is seen as a very promising technology now and into the future [36]; this is largely because wind is a renewable resource. In Ontario, there is a very strong demand for wind turbines. In fact, a mandate has been set by the IESO and the government for the future of energy production in the province. In this mandate, the IESO states that the goal of it and the government are to eliminate coal-fired power plants, and to focus significant efforts on producing substantially more power through more environmentally-friendly means [2]. Further, this `green' energy plan calls for exceptional developments in wind turbines; by 2025, the country alone could have wind turbines produce nearly 20 percent of all energy [61]. Ontario has indeed already seen a small increase in wind turbine development, increasing from approximately one percent in 2007, to three percent of all renewable energy produced in 2009 [39]. Shown in Figure 1.2 below is one of the projected amounts of 3

1.2. BACKGROUND

CHAPTER 1. INTRODUCTION

Figure 1.1: IESO Boundaries and Partner Operators [12]

development set to take place into the future. Clearly, the province of Ontario is focused on harnessing renewable energy into the future. Throughout the province there are currently approximately 1,100 MW of installed capacity, with about 475 MW being produced at a given time on average [10]. The locations in Ontario which have had installations take place and which are producing energy are listed in Table 1.1. Two projects in Ontario which are currently drawing ongoing attention are those proposed by Southpoint Wind. Both of the projects would be a first in Ontario, developing an offshore wind turbine farm, along the shorelines of Lake Erie and Lake St. Clair. The first project, slated to generate 30 MW of electricity, was to be developed between the Leamington and Kingsville townships in Essex county. Although there was no specific location determined, there were several proposed to the residents in the area [5]. The second project, slated to generate a significantly larger 1,400 MW of electricity, has potentially more locations due to the amount of power being generated. The areas proposed included sites near Leamington, Amherstburg, Lakeshore, and Chatham-Kent counties [4]. However, it should be noted that at the time of publication of its report, the projects had not yet been approved by the 4

CHAPTER 1. INTRODUCTION

1.2. BACKGROUND

Figure 1.2: Future Renewable Energy Production in Ontario [39]

Name/Location Amaranth I - Township of Melancthon Amaranth II - Township of Melancthon Kingsbridge I - Huron County Port Alma- Port Alma Port Burwell - Norfolk and Elgin Counties Prince I - Sault Ste. Marie Prince II - Sault Ste. Marie Ripley - Township of Huron-Kinloss Underwood - Bruce County Wolfe Island - Township of Frontenac Islands

Capacity [MW] 67.5 132 39.6 101.2 99 99 90 76 181.5 197.8

Operational Date March 2006 November 2008 March 2006 October 2008 May 2006 September 2006 November 2006 December 2007 February 2009 June 2009

Table 1.1: Installed Wind Farms in Ontario [10].

government and Southpoint Wind was still waiting for approval to proceed [11]. Some other projects being developed are listed in Table 1.2. However, Ontario is not the only region which is taking advantage of renewable energy production through wind turbines. Projects have been developed across the United States. As well, in Europe, wind turbines have become a significant source of energy production [47]. As a further incentive for those who have turbines installed nearby their homes, compensation is usually offered [28]. There are drawbacks however to the development of wind turbines. Some of the strongest issues that have been proposed by critics of the technology deal with the effects of the turbines on their surroundings; namely, the wildlife and the general publics health. Studies have suggested that although the energy production aspect would not affect the local surroundings, there could potentially be an effect from vibrations due to the spinning blades [5]. Furthermore, although not stated in the SouthPoint study, residents have complained in various installation locations that they have become ill and that there are 5

1.2. BACKGROUND Name/Location Bow Lake Phase I Chatham Wind Project Comber East Wind Project Comber West Wind Project Conestoga Wind Energy Centre I Greenwich Wind Farm Gosfield Wind Project McLean's Mountain Wind Farm I McLean's Mountain Wind Farm II Pointe Aux Roche Wind Raleigh Wind Centre Summerhaven Wind Energy Centre Talbot Wind Farm Capacity [MW] 20 99.4 82.8 82.8 69 98.9 50.6 50 10 48.6 78 125 98.9

CHAPTER 1. INTRODUCTION Operational Date Q2 2012 Q1 2011 Q3 2011 Q3 2011 Q4 2011 Q3 2011 Q4 2011 Q3 2011 Q3 2011 Q3 2011 Q1 2011 Q1 2012 Q1 2011

Table 1.2: Wind Farm Development Projects in Ontario [10].

adverse health effects from turbines; at this time however, studies have been performed which state there are no health effects, but rather a potential annoyance to residents [3]. Another effect, although mentioned that it would not be a factor in the development plan drafted by SouthPoint Wind, is in regards to bird strikes. They can potentially fly into the spinning blades; however, the birds learn to recognize that a new structure has been erected in a certain place and tend to avoid it after that [4]. A potential hazard also exists with bats; it has been suggested that their fatalities near turbines may be related to barotrauma that occurs to their being in close proximity to the blades when hunting for insects. As the bats approach the blades, they enter a region of low pressure which causes a significant pressure drop inside their lungs, leading to internal haemorrhaging [18]. From the issues which have been bought forth in regards to wind turbines, unwanted noise is one of the strongest complaints because sound plays an important role in the lives of many people everyday. Sound itself can be seen described as a pressure wave causing a perturbation in a medium at rest. To interpret sound, a vibration in our ear drum occurs which is then recognized by the brain as what we `hear'. How `loudly' one perceives that sound can be described by an amplitude, and its pitch by a frequency [54]. As seen below (Fig. 1.3), the frequency is related to the compression or expansion of the wave. Compressed regions (compression) signify an increase in density, while expanded regions (rarefaction) show a decrease in density. In relation to wind turbines, a general negative perception of noise from them tends to increase complaints and annoyance in comparison to those who take a positive outlook on the technology [3]. Turbines themselves are made up of several different components and typically have a lifespan of 20 to 30 years; these main components include the rotor and shaft, gearbox, generator, control system, tower, support, and foundation. An example of an installation at Erie Shores is shown in Figure 1.4. In its entirety, the completed assembly weighs approximately 200 tonnes. The turbine works by converting wind (kinetic) energy to electrical energy; the amount of available energy depends on the wind speed 6

CHAPTER 1. INTRODUCTION

1.2. BACKGROUND

Figure 1.3: A Sound Wave [15]

and density of the air. A significant advantage of using wind energy is essentially that it is a pollution free alternative to other energy sources, is a renewable resource in abundance, and typically caries a financial incentive for the land owner on which the turbine is installed. For the turbines installed at Erie Shores, a cut-in speed of approximately nine kilometres per hour at the rotor hub is needed to generate a usable amount of electricity [13].

1.2.3

Development Issues

Before wind turbine development takes place, a build site will undergo different assessments to try to minimize the impact on the surroundings and determine the benefits of installing in that location [28]. In Ontario, upon completing the assesments, a setback distance is used to determine how far away the turbine is to be built from any nearby receiver. The currently established setback distance is 550 m [6]; the value has been established by the government depending on what type of renewable energy project is installed [6](Table 1.6). This is seen by some as being too small; a recently settled case in such a dispute involved the Ontario provincial government vs. Ian Hanna (March 2011). Hanna objected to the established setback distance. He claimed that medical studies show that there are ill-health effects from the low-frequency noise turbines emit (causing issues such as sleep deprivation, stress, and depression). In addition, Hanna also went as far as saying that Ontario's environment minister ignored scientific evidence of such issues resulting from turbine installations [30]. Upon going to court however, Hanna's claim was dismissed. The established panel of judges claimed that, "The ministerial review included science-based evidence, such as reports of the WHO and the opinions of acoustical engineering experts". Despite the outcome, Hanna and his group of supporters pledge to focus efforts on challenging other newly developing wind farms. In particular, Chatham-Kent, an installation of eight turbines rated to produce 20 MW total output at peak capacity [30]. Nevertheless, wind turbine installations may face continued opposition due to the negative perception of the technology by many people. In addition, in a recent announcement of new subsidized wind farm projects, the government only approved four out of a potential forty development projects [30]. 7

1.2. BACKGROUND

CHAPTER 1. INTRODUCTION

Figure 1.4: Erie Shores Wind Turbine Farm

1.2.4

ISO Sound Propagation Model

The noise issues brought forth earlier are a consequence of a loaded rotating blade in a moving fluid; the problem however exists in that the currently available tools are not always able to accurately and effectively determine the sound propagation characteristics from an installation. Therefore, the distances currently used for separating the turbines from residences may not be sufficient [33]. The method currently used in determining turbine placement and setback distances in Ontario is performed by using International Organization for Standardization (ISO) 9613-2: Acoustics - Attenuation of sound during propagation outdoors and the Environmental Protection Act - 359/09. These documents are used as a guideline when developing new turbine farms in Ontario; the former containing guidelines for determining setback distances and sound characteristics at a receiver location, and the latter containing additional guidelines for receiving approval for a renewable energy project. The ISO document was developed as a summary of the standards ISO 1996 and ISO 3740 to produce a comprehensive method of describing noise in outdoor environments as a result of various sources. ISO 9613-2 can be applied to a variety of general situations and it determines sound pressure levels based on octave bands [1]. The octave bands are defined as the space between frequencies; the upper limit of a band is two times the lower limit. The 8

CHAPTER 1. INTRODUCTION bands that are considered are shown below (Table 1.3). Octave 1 2 3 4 5 6 7 8 Frequency [Hz] 63 125 250 500 1000 2000 4000 8000

1.2. BACKGROUND

Table 1.3: Octave Bands

To measure sound, different weighting schemes are used; this is because our perception of sound is not linear. By using a particular weighting scheme, a different range of frequencies are considered to better approximate the perception of sound. Because a sound can be percieved differently, there are multiple weighting schemes that can be used (Fig. 1.5). In Figure 1.5, each of the weighting schemes are labelled 'A', 'B', 'C', and 'D'. For humans ears, sounds can be perceived from approximately 16 Hertz (Hz) to 16 Kilohertz (kHz) [46]. The A-weighted scheme (dB(A)) measures sound in a range which humans ears are most accustomed to [36].

Figure 1.5: Sound Power Level Measurements Curves [56]

ISO 9613-2 relies on point sources to determine predictions of noise levels. If one encounters a variety of point sources within an area however, it is acceptable to combine these points into a cell. These combined sources can then be represented as an individual point which can be used for analysis. To determine the amount of noise at the receiver, it is necessary to calculate each of the individual octave bands. A directivity correction is also applied based on how much deviation takes place in the 9

1.2. BACKGROUND

CHAPTER 1. INTRODUCTION

direction of propagation. An attenuation value is applied based on the amount of sound lost between the source and receiver. The different types of attenuation used are listed in Table 1.4. Attenuation Type Divergence Atmospheric Ground (limited to flat ground, horizontally oriented or sloped) Barrier Description Accounts for the spherical spreading from the source. Results due to absorption of sound from the atmosphere. Sound reflections and absorption takes place depending on the type of surface over which it propagates. The attenuation resulting from barriers in place between the source and receiver. The sound is assumed to travel either through a vertically or horizontally oriented edge. Defines additional attenuation criteria in addition to the primary ones; consists of attenuation from foliage, industrial sites, and housing.

Miscellaneous

Table 1.4: ISO 9613-2 Attenuation Types [1]

Upon determining the attenuation, it is then possible to calculate the true sound pressure level for a given octave; these bands are combined to form a sound. This process needs to be completed for each point source. Furthermore, corrections can be performed which allow one to encompass a wide variety of meteorological conditions. However, there are several constraints on the use of the ISO method: 1. The sound propagation from the noise source take place under a ground-based temperature inversion. 2. It is not possible to take into account sound attenuation over water. 3. The method cannot be expected to work on any given day; the conditions for which it encompasses are averaged over independent situations. 4. The estimated errors in the average receiver sound pressure levels and pure tone levels maybe larger than for A-weighted levels of broadband noise sources. There are specific conditions which must be satisfied when using the ISO model. If the ambient conditions differ from those listed in Table 1.5, then the results of the sound propagation model may not be as accurate as one would hope. To obtain the most accurate results, one should ensure the testing conditions satisfy those defined in the ISO model as close as possible. Condition Wind Direction Wind Speed Height of Measurement Limits Must be within 45 degrees of a line connecting the point source and the receiver. 1 to 5 m/s 3 to 11 m

Table 1.5: ISO 9613-2 Conditions for Propagation [1]

10

CHAPTER 1. INTRODUCTION Class 1 Location At a location where no part of a wind turbine is located in direct contact with surface water other than in a wetland. At a location where no part of a wind turbine is located in direct contact with surface water other than in a wetland. At a location where no part of a wind turbine is located in direct contact with surface water other than in a wetland. At a location where no part of a wind turbine is located in direct contact with surface water other than in a wetland. At a location where one or more parts of a wind turbine is located in direct contact with surface water other than in a wetland. Capacity [kW] <= 3

1.2. BACKGROUND Greatest Sound Power [dB(A)] Any output

2

>3, <50

Any output

3

>=50

<102

4

>=50

>= 102

5

Any output

Any output

Table 1.6: Ontario Wind Turbine Installation Sound Power Limits [6]

One of the largest disadvantages of the ISO method, is it does not give a detailed visualization or description of the overall noise produced from the source as it is geometrically based and does not rely on any type of CFD code. It is a rather simple method of obtaining a general prediction of sound propagation under favourable propagation conditions. It is an emperical method based on emperical data, which have been developed for a set of particular situations. In dealing with noise propagation in a real-world scenario, distance and noise emission standards have been established by governments as to how much of a buffer zone can exist between the source and receiver. In Ontario, guidelines have been established based on the type of installation to be put into effect based on the facility location, capacity, and sound power level output (Table 1.6). These guidelines exist in the Environmental Protection Act - 359/09. Further, based on the established classifications, setback distances have also been set. A setback distance of 120 m exists for Class I and II installations, while 550 m is used for Classes III,IV, and V [6].

1.2.5

Past development

Significant research has been performed in developing sound propagation models to be used in situations where wind turbines are in place. Below are some methods which have been developed using different techniques to predict sound. In `A 3D Parabolic Equation Method for Wind Turbine Noise Propagation in Moving Inhomogenous Atmosphere' [22], a Parabolic Equation (PE) method was developed using the Helmholtz equation in an inhomogenous atmosphere with rigid boundaries. Although the equation is developed in cartesian coordinates, it was reformulated in the cylindrical domain and then solved using the Crank Nicholson (CN) time marching scheme, while assuming incompressible flow. The PE method however required a 11

1.2. BACKGROUND

CHAPTER 1. INTRODUCTION

significant amount of computational resources in three dimensions. In addition, several simplifications were introduced into the setup to simplify the problem to allow only the use of symmetry, a single test frequency, and not including a density gradient for the domain. A study was performed in `An Aerodynamic Noise Propagation Model for Wind Turbines' [65], on turbines which are installed offshore and in open/flat ground conditions. The analysis involved using varying ground conditions as well as air attentuation effects. A detailed noise generation model was used, describing the noise of the airfoil/blade. It took into account geometrical spreading, sound directivity, air absorption, effects of terrain, temperature, and the effects of wind. However, geometrical sound ray theory was used as the propagation model which is not as accurate as the FDTD method, as mentioned by the author in their work; the developed method is better suited for quick and simple simulations. Finite element methods were used in `Finite Element Simulation of Sound Propagation Concerning Meteorological Condition' [49]. The study was useful in that it presented situations in which propagation was coupled with atmospheric effects such as wind and temperature gradients. Further, two different solution methods were considered (using a Fast Fourier Program (FFP) or a PE solver). While the FFP was considered, it is normally used for oceanic studies as it is able to deal with multiple frequency bands with ease, but only works for situations entailing a homogenous domain. The PE method was considered to be a better choice, but was said to be computationally expensive. As well, propagation characteristics were only calculated in one direction as opposed to both. Nevertheless, the methods employed are more accurate then employing a simple ray theory method. Ultimately, the method of solution used the Galerkin finite element spatial discretization and backward Euler time marching technique, with a focus on analysis of low frequency propagation. The final results produced were in a two dimensional domain, using a flat plate oscillator as a source. The results also assumed the wind profile did not change during propagation. The methods used in `Integrated Numerical Method for the Prediction of Wind Turbine Noise and the Long Range Propagation' [58], utilized a considerably detailed model for sound generation, taking in account each of the specific noise mechanisms along a rotating blade (though mechanical noise was not considered, aerodynamic sources included low frequency, turbulent in-flow, and airfoil self-noise). As well, a spherical oscillator was used for the noise source. Unlike other models, the authors proposed using a database of pre-determined values for the sound generation model, to reduce the amount of computational time. The sound generation model data would then be fed into the propagation model, which would apply any type of attenuation or dispersion effects. Although the other considered studies in this paper utilized flat surfaces, tests using GIS data from a complex terrain mesh were tested. With the use of the complex terrain, the author made mention that it would be beneficial to test in the future using an FDTD setup. Unfortunately, this study used a propagation model utlizing ray theory, leading to a very simplified analysis despite the accurate source data. In addition, the model did not include any wind or a temperature gradient. Ray theory was used again in `Noise Propagation Issues in Wind Energy Applications' [53] to simplify analysis. Validation was performed against real-world turbine data for a specific ground condition (wet grass). It was concluded that for complex terrains, simple models of propagation cannot be used to obtain accurate and detailed results. 12

CHAPTER 1. INTRODUCTION

1.2. BACKGROUND

In `Wind Turbine Noise Propagation over Flat Ground: Measurements and Predictions' [26], several different models were examined to see how they compared to empirical data using different solution methods (geometrical ray theory, and using a PE solver with the CN time marching method). The study also considered varying ground conditions based on different values of a ground resistivity coefficient. The author went on to mention the potential significant benefits of using a FDTD in comparison to others for future work. In considering the work of previous authors, several of the studies indicate that the use of the FDTD method would indeed produce the most accurate results and would be of benefit to study. Furthermore, by implementing rigid and absorbing boundary conditions in a three dimensional setting, as well as a detailed sound generation model, one could develop a detailed model for noise propagation downstream from a source.

13

Chapter 2

Methodology
This section was divided into three subsections for convenience; the first section considers the sound propagation model, the second considers the sound generation model, while the third goes over the code implementation and development. The three steps led to the development of the completed prediction model. Before introducing the main matter however, a brief overview of the FDTD method is given. The FDTD method was developed in 1966 by Kane Yee; it was originally formulated to solve the Maxwell equation. Over the years, the use of the FDTD method has been increasing; this is in part due to the increasing amount of computing power available. It is seen as a fast method of solving equations of N Degrees of Freedom (DOF), where each iteration requires a number of operations of order O(N). Futhermore, the method is able to accurately solve problems involving models such as those involving inhomogenous media, as well as those using an unbounded domain requiring the implementation of absorbing boundary conditions (from absorbing media to Perfectly Matched Layers) [27]. Nevertheless, there are some shortcomings to using the FDTD method. Gedney [27], presents a comprehensive list of the drawbacks. Perhaps the largest of the disadvantages involves the need to discretize the entire domain in question. The entire discretization may result in extra computational effort being exhausted, instead of focusing on the area under study; if using a three dimensional domain (which increases DOF significantly) with a highly accurate model and small timestep, the computational expense in terms of memory will be drastic. Another disadvantage of using a FDTD method deals with the broadband solution it gives; this may be of issue if limited information is only available about a narrowband, potentially requiring an estimate. As well, when using the method in particular with a large source strength, lengthy run times may result as narrowband resonances may take a significant period of time to decay, or may not decay at all. Finally, it should be mentioned that the use of a FDTD method requires the use of an orthogonal grid to encompass the domain. 15

2.1. IMPLEMENTATION

CHAPTER 2. METHODOLOGY

2.1

Implementation

It was necessary to specify a volume in which the domain of the problem being solved would be defined (Fig. 2.1). For the purposes of this study, a rectangular-prism shaped Control Volume (CV) was used, being represented by a structured staggered grid. The grid itself could be varied based on the users desire; however, it was advisable to keep the spacing between nodes equal in all three coordinate directions (ie. x = y = z ) to maintain equivalent spatial accuracy in all directions.

Figure 2.1: Control Volume Cross-Section

As a real world example, the setup used was such that it resembled a space of air, where the ground plane was defined as being rigid or semi-permeable, while the other boundaries of the cube were taken as being absorbing.

2.1.1

Domain Configuration

In Ostashev et al. [50], a method of modelling the sound propagation from a source was discussed. That method was expanded upon in this paper. The use of a FDTD technique is emphasized over that of parabolic or frequency domain equations, due to their simpler solution, yet more accurate results and wider range of applications. In the two final sets of equations developed, the first makes no assumptions, while the second ignores terms proportional to the divergence of the medium velocity and the gradient of the ambient atmospheric pressure (as the change in the medium velocity and ambient pressure is not significant). 16

CHAPTER 2. METHODOLOGY

2.1. IMPLEMENTATION

The development of the algorithm begins with the fundamental equations of fluid dynamics: the continuity equation, momentum equation, adiabatic equation of motion, and equation of state, respectively, ( )  ~Â·  ~= +v ~+ ~ Â· v ~Q t (2.1)

(

) ~ P F  ~Â· v ~+ +v -g = t  ~  ~ ( )  ~=0 ~Â· S +v t ~=P ~ (~ ~) P , S

(2.2)

(2.3)

(2.4)

~ is the pressure,  ~ is the entropy. A In the above equations, P ~ is density, v ~ is the velocity, and S perturbation method is used to linearize the above equations, where ~ = P + p, P (2.5)

 ~ =  + ,

(2.6)

~ = v + w, v

(2.7)

~ = S + s. S

(2.8)

The P, , v, and S represent the values of the ambient conditions. The variables p,  , w, and s respresent the perturbations due to a propagating sound wave. It should be noted that the term `perturbation' has the same meaning as an `acoustic' quantity; they can both be used interchangeably. Substituting the above into the fundamental equations of fluid dynamics, applying an argument of scale  d to eliminate higher order terms, and setting ( t + v Â· ) = dt , one would obtain d + (w Â· ) +  Â· w +   Â· v = Q, dt dw p  P F + (w Â· )v + - 2 = , dt    ds + (w Â· )S = 0, dt p = c2 + hs. 17 (2.9)

(2.10)

(2.11)

(2.12)

2.1. IMPLEMENTATION

CHAPTER 2. METHODOLOGY

(,S ) . The above equations describe the most general case of sound The h term above is defined by PS propagation in a moving inhomogenous medium with only one component; one should note, however,

that the above equations do differ from those used for aeroacoustics by way of the sound sources used. In the equations above, the F and Q terms represent known sources of force and in-flow rate density respectively, where in aeroacoustics the sources have to be calculated from the flow functions and are part of the ambient flow. Finally, in some cases it may be desirable to assume that the entropy is constant throughout the medium under study. This may not be done if one considers a stratified medium where the ambient density varies such that it is smaller than the acoustic wavelength or varies significantly c with a change in height; the wavelength can be defined as  = f , with frequency f. Continuing with the derivation, a set of three coupled equations were produced to solve for velocity, pressure, and density, in a moving medium with an arbitrary equation of state. Hence, first using the equation of state and applying an operator to both sides  ~ Â· . +v t Using the adiabatic equation of motion, one can then obtain ( ( ) )   ~=c ~Â· P ~Â·  ~2 +v +v ~. t t )  ~ +c ~Â· P ~=c +v ~2  ~ Â· v ~2  ~Q. t (2.14) (2.13)

Finally, applying the continuity equation, ( (2.15)

Now, it is necessary to perform linearization on the above, but due to the sound speed term, it is necessary to perform several intermediary steps before proceeding. It is first required to determine the value of the speed of sound with first order accuracy using the perturbations defined earlier to bring it into line with acoustic quantities. Defining the speed of sound term as c ~2 = ~ (~ ~) P , S .  ~ (2.16)

Then, proceeding to decompose the sound speed into a Taylor series while keeping the perturbations of density and entropy in the first order c ~2 =  P (, S )  2 P (, S )  2 P (, S ) P ( + , S + s) = + + s. 2    S (2.17)

One can take notice that the first term on the right, c2 , is equal to the ambient sound speed. The second and third term can be taken as the perturbations in the sound speed. These assumptions, and using  and  as placeholders, lead to the development of c ~2 = c2 + ( + s). (2.18)

Now, using the above and isolating the second term on the right, one can substitute for the entropy 18

CHAPTER 2. METHODOLOGY perturbation s, using the linearized equation of state developed earlier s= p - c2  . h

2.1. IMPLEMENTATION

(2.19)

Upon performing the substitution, one obtains a formula for the sound speed perturbation (c2 ) = ( - c2 p ) + . h h (2.20)

The linearization of equation 2.15 can now take place, noting that c ~2 = c2 + (c2 ) . This is done using the same perturbations used for the linearization of the equations of fluid dynamics earlier. Upon completing the linearization, one would find that [ ( (  ) dp  )] + c2  Â· w + w Â· P +  + c2 1 - + p Â· v = c2 Q dt h h (2.21)

The above equation 2.21 as well as 2.9 and 2.10 make a set of three coupled equations with no approximations. This set of equations can be used for sound propagation prediction in a moving inhomogenous atmosphere using FDTD techniques. The equations themselves are used to solve for perturbations in pressure, velocity, and density. The three coupled equations produced above however, can be reduced to a simpler set of two coupled equations if the ambient velocity is taken to be less than the sound speed. This is done by using the linearized momentum equation and equation 2.21, in terms of pressure change with time. This allows one to obtain two equations, one to solve for pressure perturbations, the other for velocity perturbations. However, some assumptions must be made. Using [41], it can be shown that Â·v  v3 , c2 L (2.22)

Where L represents the variation in density. Using the above, the terms proportional to  Â· v can be 2 eliminated to the order of v c2 . The terms which are proportional to P , can also be eliminated as they are proportional to v c . Finally, because the developed equations for this paper are used with acoustic quantities, the effects of gravity can be omitted. Therefore, the equation for pressure equation above (eq. 2.21) and the linearized momentum equation can be written as ( )  + v Â·  p + c2  Â· w = c2 Q, t (2.23)

(

)  p F + v Â·  w + (w Â·  )v + = . t  

(2.24)

The two above equations are coupled and can be used to solve for the acoustic pressure and velocity. They are simpler and require less information (no need for P, ,  , and h) to use in comparison to the three coupled equations presented earlier. They can be solved using FDTD techniques and can be used for predicting sound in a moving inhomogenous atmosphere. Before the equations could be solved 19

2.1. IMPLEMENTATION

CHAPTER 2. METHODOLOGY

numerically however, it was necessary to isolate the partial derivatives with respect to time; the terms on the right of the equality could then be approximated using finite-differences. In total, there are four equations to solve due to the three dimensional nature of the problem at hand p = c2 Q - c2 t ( wx wy wz + + x y z ) ( ) p p p - vx + vy + vz , x y z (2.25)

( ) ( ) wx px wx wx wx vx vx vx = Fx b x - bx - vx + vy + vz + wy + wz - wx , t x x y z x y z ( ) ( ) py wy wy wy vy vy wy vy = Fy by - b y - vx + vy + vz + wy + wz - wx , t y x y z x y z ( ) ( ) pz wz wz wz wz vz vz vz = Fz bz - b z - vx + vy + vz - wx + wy + wz . t z x y z x y z

(2.26)

(2.27)

(2.28)

The b term above represents the mass bouyancy. To solve the above equations, finite differences were applied to the spatial derivatives; the approximations to each of the derivatives are provided in Appendix A. Grid Configuration The grid configuration and subsequent spatial finite-differences were setup in a staggered configuration. Using this setup, there were essentially multiple grids in use at once; the acoustic pressure values (p) were calculated and stored at whole integer nodes (x = ix,y = j y ,z = k z ), while the acoustic velocity values were calculated and stored at offset nodes (x = (i + 1 2 )x,y = j y ,z = k z for wx ;
1 1 x = ix,y = (j + 2 )x,z = k z for wy ; and x = ix,y = j y ,z = (k + 2 )z for wz ). In addition to the acoustic pressure being stored at the pressure nodes, the mass buoyancy b, bulk modulus , and

source Q were stored there as well. The ambient flow velocity vx and source term Fx were stored at the velocity perturbation wx nodes in the x-direction. The flow velocity vy and source term Fy were stored at the velocity perturbation wy nodes in the y-direction, while the flow velocity vz and source term Fz were stored at the velocity perturbation wz nodes in the z-direction. An example of a staggered grid configuration for the main quantities of pressure and velocity perturbation is shown below for a two dimensional case (Fig. 2.2). It should be noted that the staggered grid configuration is typically used in wave propagation problems in non-moving media, and also provides a convenient way of applying finite-differences [63]. Although the figure illustrates an example in two dimensions, the developed approximations for this study were solved in three dimensions. Further, due to the use of a computer code array (which is unable to specify `half' nodes), values were stored internally
1 at regular indices. For example, the variable wx stored at i + 2 on the Wilson and Liu grid, appears at 1 i on this study's array. Likewise wy and wz , stored at j + 2 and k + 1 2 on the Wilson and Liu grid, were

20

CHAPTER 2. METHODOLOGY

2.1. IMPLEMENTATION

Figure 2.2: Staggered Grid Configuration [63]

stored at j and k. The approximations given in Appendix A to the equations of sound propagation take into account the change in indicies between the method used by Wilson and Liu, and the one used in the development of this studies computer code.

2.1.2

Boundary Conditions

In this study, two different types of boundaries were considered, a rigid boundary and an absorbing boundary. The absorbing boundaries represented each of the outer faces of the domain, while the remaining ground layer could be varied between being absorbing or fully rigid. A thorough analysis was done by Wilson and Liu [63] and was used as a starting point in this implementation. A rigid boundary can be represented by a hard surface such as a wall, barrier, or building. In terms of acoustics, using a rigid boundary causes the acoustic particle velocity to disappear perpendicular to the hard surface. To implement the rigid boundary condition, the following were ensured 1. The medium below the rigid boundary was made the same as that above. 2. The same source as above the rigid boundary was used below; because the two sources are equal and emitting in opposite directions, they should cancel at the boundary (the acoustic particle velocities should vanish). For example, taking into account a rigid surface in place at the ground boundary, one needs to ensure that any vertical velocity components on the grid along the boundary are zero (wy and vy ). In terms of the x-components of velocity, above the boundary they are reflected (wx and vx ). The pressure values 21

2.1. IMPLEMENTATION

CHAPTER 2. METHODOLOGY

stored at the nodes are defined slightly differently; along the boundary a single value is defined, while above and below the values mimic each other; that is, if the surface is defined at y = (j-1/2)y, the pressure values at (j - 1)y were set equal to those at (j )y . For the developed solver, the appropriate steps were taken to ensure that components and derivatives perpindicular to the boundary were made zero as required, otherwise, mirroring was used. Rarely can outdoor ground surfaces be taken as being ideally rigid. Further, from a numerical standpoint it is difficult to represent something as being `somewhat' absorbing or reflecting. For example, sound energy can propagate quite well and once it reaches the ground, depending on the type of surface, the energy is dissipated by viscosity and thermal conduction. With snow, much of the energy is absorbed because of the large pores that type of surface has. With a surface such as cement or asphalt, most of the energy is reflected. For a surface such as soil, the amount of reflection and absorption can vary. To define sound propagation through porous media, equations have been developed by Morse and Ingard [45]. Of note is the use of the static flow resistivity factor. It essentially keeps the static pressure gradient from accelerating the fluid to infinite speed; instead, the velocity of the fluid will approach a finite constant value determined by the viscous drag of the porous material over which it passes [63]. p p = -( )  Â· w t  p w +  w = -p t (2.29)

(2.30)

In the equations above, p is the bulk modulus of air in the pores of the permeable material, p is the density of the air in the pores,  is the static flow resistivity, and  is the porosity. Briefly considering the bulk modulus of the air, two different values are used to bound its range, those for the isothermal and adiabatic cases, respectively, where  is the heat capacity ratio. p = c2  (2.31)

p = c2

(2.32)

For situations involving small pores and/or low frequencies, isothermal conditions typically exist. Further, at low frequencies [17], p = sc .  (2.33)

The structure constant (effective density factor), sc , is related to the tortuosity factor q by 1/cos  (for a fixed angle). The tortuosity is used to describe the geometry of the pores. In idealized cases, it is possible to determine the structure constant through its relation to tortousity. For example, Attenborough [17] has shown that for cylindrical pores sc = 4 q4 . 3 (2.34)

22

CHAPTER 2. METHODOLOGY

2.1. IMPLEMENTATION

Nevertheless, the relationship between sc and q depends strongly on the pore geometry. If one is doing analysis entailing isothermal conditions and using the lower end of the frequency spectrum, which results in the density of the air in the pores being constant and the bulk modulus being isothermal, the initial equations defined Morse and Ingard can be rewritten as shown below. p = -e  Â· w t w +  w = -p t

(2.35)

e

(2.36)

The effective bulk modulus and density in the pores are introduced above. They are defined as 2 sc  e = c   and e =  . To implement the equations numerically, one can follow a similar procedure as was done for the equations of sound propagation earlier. To simplify the equations, be = p = -e t ( wx wy wz + + x y z ) (2.37)
1 e .

( ) wx px = -bex  x wx + t x ( ) wy py = -bey  y wy + t y ( ) wz pz = -bez  z wz + t z

(2.38)

(2.39)

(2.40)

The finite-difference approximations to the spatial derivatives in the boundary condition equations are provided in Appendix A. Based on testing the developed method for this study, the size of a single absorbing layer should be set to a minimum of five times the source wavelength for optimal results. In addition to the developed equations for the porous boundary condition, shown below is a table of different ground conditions provided by Wilson and Liu (Table 2.1). The values have been arranged from least absorbing (asphalt), to most absorbing (forest/snow). Material Asphalt Sand Grass Forest Snow Flow Resistivity 3 x 107 5 x 104 2 x 105 1 x 105 1 x 103 ( P a- s )
m2

,

Porosity,  0.1 0.35 0.5 0.6 0.6

Tortuosity, q 3.2 1.6 1.4 1.3 1.7

Table 2.1: Ground Condition Parameters [63]

23

2.1. IMPLEMENTATION

CHAPTER 2. METHODOLOGY

2.1.3

Absorbing Boundary Conditions

Around the edges of the control volume, absorbing boundary conditions were put in place to avoid spurious numerical reflections. These absorbing boundaries however, were artificial. However, it is of interest to determine if a porous layer implementation (as developed above) can be used as an absorbing boundary. Hence, one can first consider the equation for the reflection coefficient of waves impacting a solid surface, as defined by Kinsler et al. [40] R= Zc cos i - c cos t . Zc cos i + c cos t (2.41)

In the above, the angles of incidence and transmission, i and t , are measured with respect to a normal to the surface, while Zc defines the characteristic impedance of the wave propagating through the absorbing layer. In addition, the transmission angle is normally complex and is associated with waves that exponentially decay from the boundary at which they form. Because one is to consider a truly absorbing boundary, the reflection coefficient is taken to be zero. Therefore, the above equation becomes Zc cos t = . c cos i (2.42)

By considering Snell's Law, one can eliminate cos t with sin 1 k2 = . sin 2 k1 (2.43)

This is done by first substituting the incident wave number k1 with wave number k , the transmission wave number k2 with complex wave number kc , the incident angle 1 with i , and transmission angle 2 with t ; the wave number being defined by, k =  c , where  is angular frequency. Rearranging in terms of transmission angle t , one can obtain [ t = arcsin sin i ( k kc )] . (2.44)

The rearranged Snell's Law for t , can then be substituted into equation 2.42 to yield ( Zc c )2 cos2 i + ( k kc )2 sin2 i = 1. (2.45)

To replace the remaining coefficients of Zc and kc , one can obtain plane-wave solutions for equations 2.35 and 2.36 provided by Morse and Ingard. Hence, as was solved by Wilson and Liu [63], for a wave propagating in the positive x-direction P = Aei(kc x-t) , wx = Bei(kc x-t) , wy = wz = 0. 24 (2.46) (2.47) (2.48)

CHAPTER 2. METHODOLOGY

2.1. IMPLEMENTATION

A , from which useful quantities Upon performing substitution, one can obtain a solution for coefficients B can be determined; the newly appearing term below is the complex density, c .

A kc e c = = B  kc c = e +  kc =  Zc = i  c e

(2.49)

(2.50) (2.51) (2.52)

 e c

Substituting kc and Zc into equation 2.45, one obtains c e e cos2 i + sin2 i = 1. 2 c2 c c2 (2.53)

One may now test whether the use of a porous layer will suffice as an absorbing boundary. To do so, it is necessary to determine the real and imaginary components of equation 2.53. ( ) ( ) e + i e - i 2   ( )  cos  + sin2 i = 1 e i 2 2 2 c2 2 + c e 2
 

(2.54)

Hence, one may set set the bulk modulus to e = c2 and e = , if

is small compared to e . This

condition will be satisfied and can be applied for all of i , if there is any kind of weakening of the incident  wave. Therefore, it should be noted that if  << 1 over the desired range of analysis, a porous layer may be used as an absorbing boundary condition.

2.1.4

Implementation Considerations

Wilson and Liu [63], provide details of considerations to take into account when implementing a numerical method. To ensure that a numerical simulation is stable, the timestep and grid spacing are defined as t = r = r , v ~ (2.55) (2.56)

 x2 + y 2 + z 2 .

As a result of defining stability with the timestep, and when solving problems in general, it is also beneficial to define the Courant number C= v ~t . r (2.57)

For numerical stability, C  1. One should note that although the above can be satisfied, it does not mean that numerical accuracy will be guaranteed. In the case of a uniform flow, it is also possible to 25

2.2. SOUND GENERATION MODEL

CHAPTER 2. METHODOLOGY

define grid spacing in terms of Mach number, M, and the number of grid nodes, N. r =  (1 - M ) N (2.58)

Observing the above, one should keep in mind that r should be much smaller than the wavelength for accuracy. At minimum, the chosen grid spacing should contain five nodes per wavelength for a sinusoidal signal to resolve correctly. To determine the correct direction to determine the wavelength, one should consider that the wavelength in the downwind direction of propagation will be shorter. Hence, the
~-v ~ downwind wavelength is taken as a reference ( = c f ). Substituting this result into the previously defined timestep and using the downwind propagation speed, one obtains

t <

1 1-M Nf 1 + M

(2.59)

As can be seen in the above formula, as the flow Mach number increases, the timestep must decrease, and resulting in more computational time is required. Therefore, the timestep must be chosen correctly, as it also controls the convergence of the solution. As t is made larger, convergence tends to decrease [60]. Conversly, as t is decreased, one would expect the convergence rate to increase, but the amount of computing time needed to increase. One should also note that decreasing the timestep to a value below the minimum for convergence may not result in a suitable solution. For the purposes of this study, it was necessary to choose a time-marching method to develop a solution to the equations for sound propagation, as well as those for the boundaries developed earlier. Several different time-marching methods were considered by Wilson and Liu. They concluded that although different methods may have the same order of accuracy, they may not produce the same results. Based on the trials there were performed in their study, the unstaggered `leap-frog', Aldrige, and fourth-order Runge-Kutta methods were determined to be best, as "they all provide good accuracy and stability for a similar level of computational effort" [63]. The actual time-marching of the solution for this study was performed with the assistance of the Portable Extensible Toolkit for Scientific Computation (PETSc) library, which can provides access to different implementations (Euler, CN, Runge-Kutta, etc).

2.2

Sound Generation Model

There are different types of sound generation source patterns which exist. These are the monopole, dipole, and quadrapole sources. Each of these sources is an elementary solution to the inhomogenous wave equation. As demonstrated by Blake [19], to develop the equation, one can begin with the continuity equation   ~ + (~ v ~i ) = 0. (2.60) t xi Taking the time derivative of the above yields 2 ~ 2 + (~ v ~i ) = 0. 2 t txi 26 (2.61)

CHAPTER 2. METHODOLOGY

2.2. SOUND GENERATION MODEL

Proceeding further, one can then consider the momentum equation in the form ~   P (~ v ~i ) + (~ v ~i v ~ = 0. j) + t xj xi Taking the divergence of the momentum equation produces ~ 2 2 2P (~ v ~i ) + (~ v ~i v ~ = 0. j) + xi t xi xj x2 i Now, by subtracting equation 2.63 from 2.61, one can eliminate the term  ~v ~i , giving ~ 2P 2 ~ 2 (~  v ~ v ~ ) - - = 0. i j 2 t xi xj x2 i (2.64) (2.63) (2.62)

Equation 2.64 could then be linearized, using perturbation values which represent acoustic quantities. The variables P and  show below, represent the pressure and density at ambient conditions (the velocity for the ambient atmopshere was taken as being zero). The variables p,  , and w, represent the pressure, density, and velocity perturbations. The equations for the linearization were defined as ~ = P + p, P  ~ =  + , v ~i = vi + wi . Substituting the equations for linearization into equation 2.64 and rearranging yields 2 2p = 0. - 2 t x2 i (2.68) (2.65) (2.66) (2.67)

If one considers the fluid in the domain to be isentropic, the pressure perturbation changes linearly with the density perturbation; Wagner et al. showed it can be represented by p = c2 . (2.69)

In the above, the density perturbation is scaled by the speed of sound, c. To complete the development of the wave equation, one can choose to formulate it with terms of density or pressure; for the purposes of this example, terms are formulated for pressure. Therefore, substituting equation 2.69 into 2.68, one can obtain the inhomogenous wave equation with pressure terms 1 2p 2p - = 0. c2 t2 x2 i (2.70)

27

2.2. SOUND GENERATION MODEL

CHAPTER 2. METHODOLOGY

A similar formulation can be obtained using terms of density for pressure through equation 2.69. Finally, by introducing a source  ( x, t) into the domain, one can write the inhomogenous wave equation as 1  2 p( x, t)  2 p( x, t) =  ( x, t). - 2 2 c t xi 2 (2.71)

In classifying and developing a noise source, there are several different components which need to be considered. Each of these components can be represented by different directivity patterns which are all elementary solutions to the above inhomogenous wave equation. The typical directivity pattern and solution for a wind turbine is given as a dipole shaped pattern [59].

2.2.1

Noise Model Classes

Lowson, through his work in aerodynamics, suggests the use of different classes to specify how detailed a model should be used to solve a particular noise generation problem [44]. These classes can be divided into three levels: Class I - Basic methods which are meant to be used as a quick estimate based on a variety of basic parameters (for example, rotor size and output power, etc). Class II - More advanced methods which use scaling factors based on both theoretical and empirical data. Each of the different causes of noise on a turbine are considered when formulating the model. Class III - The most advanced methods which use detailed data of the wind turbine (such as its geometry and aerodynamic characteristics).

2.2.2

Solutions of Wave Equation

Based on the equations of sound propagation developed earlier, sources of sound are represented as either an in-flow rate density Q or a force F, for a monopole and dipole, respectively. In defining the sources to be used however, it is necessary to correctly scale the source term. The required source term can be calibrated using two different methods. The first involves specifying a Sound Power Level (SWL) value. The SWL is a function of the source characteristics and defines the power of the radiating sound level, measured in dB. The second method of scaling involves the SPL value. The SPL is a function of the receiver's position relative to the source and is also measured in dB. Therefore, the SPL value will change depending on what location it is taken at, while the SWL is characteristic of the source regardless of observer location. Either of these reference values are necessary for the proper scaling to be applied when providing source generation data to the sound propagation model for terms Q and F. Before proceeding further, it is also of benefit to describe the idealogy of a compact source. It is defined as being based on a dimension L, and said to be compact if L is small in comparison to the wavelength of the wave under study; that is, L   1. If this relation is satisfied, the different values of retarded time within the region the source is defined in can be ignored [59]; the retarded time will be defined in 28

CHAPTER 2. METHODOLOGY

2.2. SOUND GENERATION MODEL

the upcoming explanation of the different types of sources. Futher, the assumption of a compact source allows one to define the source at a point. Monopole A monopole source can be described as a source of mass generation. It is axisymmetric and produces the same value at any point on the surface of a sphere of radius r in a quiescent, uniform fluid. As shown by Wagner et al. [59], if the source is distributed throughout the domain and has an inflow-rate density of Q, one can rewrite the continuity equation as   ~ + (~ v ~i ) = Q( x, t). t xi (2.72)

By taking the time derivative of the continuity equation, the divergence of the momentum equation, and then subtracting the former from the latter, a linearization can be performed (using the same linearization terms as was done for the inhomogenous wave equation) where one can obtain 2 2  ( x, t). - c2 2 = Q 2 t xi (2.73)

 represents the mass introduction per unit volume (monopole strength per unit volume). In the above, Q Observing the above, one has obtained an inhomogenous partial differential equation, which cannot be solved easily. To continue the development of the solution, another operation can be performed by replacing the source term spanning the domain with a single point source. This can be done using a Dirac delta function, and by introducing a mass introduction rate (monopole strength), represented by  and q , respectively. 2 2 2  = q (t) Â·  ( x- y) (2.74) - c t2 x2 i To solve the above and determine a solution to the wave equation, one can use Green's functions to obtain q (t - cr0 ) q ( ) [q ] p( x, t) =  (2.75) = = . 4r 4r 4r Within the equation, the r variable can be replaced by | x- y |, and represents the position of an observer  x, in relation to the source  y . In addition, the retarded time is represented by  = t - r c , and is the difference between time t and the interval of time it takes a wave to travel from the source to the observer; essentially, it is the difference between the observer recieving a wave and it actually being emitted. The functions that are evaluated at the retarded time  , are indicated in square brackets (ex. for the source, [q ]). Hence, the resulting solution is based on a point source in space which has a monopole directivity pattern (which is radially symmetric), and can be interpreted as a pulsating sphere. A real-world example of a point monopole is a buzzer or siren. One can develop an expression for the monopole strength; introducing a volumetric sinusoid function that will represent the source q  q (t) = Acos(t). 29 (2.76)

2.2. SOUND GENERATION MODEL Taking the derivative, one can then obtain

CHAPTER 2. METHODOLOGY

q  = -Asin( ) = -Asin(t - k0 r).

(2.77)

Taking the Root Mean Square (RMS) (over the entire period of the waveform) of q , and substituting into the previously found solution of the wave equation p( x, t), the fully developed solution is PRM S  2A . = 8r (2.78)

To utilize the above within the equations of sound propagation, the above expression is rearranged in terms of the source amplitude A. Thus to produce a specific RMS pressure PRM S , at a receiver located distance r from the source, within a uniform, quiescent fluid, requires an amplitude of A= 8rPRM S  . 2 (2.79)

Using an expression for sound pressure level (where Pref is 20 ÂµPa) LP = 10 log
2 PRM S , 2 Pref

(2.80)

and rearranging for RMS pressure, one can make a substitution into equation 2.79 to obtain PRM S = Pref  10(0.1LP ) . (2.81)

Upon making the substitution, the amplitude required for a monopole of a known strength is given by A=  8r(Pref 100.05LP )  . 2 (2.82)

This amplitude value can be used in the coupled equations of sound propagation, to specifiy a magnitude for the mass term Q.

Dipole As was done previously for the monopole, Wagner showed it is necessary to manipulate the continuity and momentum equations to obtain a solution of the wave equation for a dipole [59]. However, the key difference being that for a dipole one is no longer dealing with a source generating mass, but rather a source applying a force on the fluid medium. Hence, rewriting the momentum equation with a forcing term ~  (~ v ~i )  (~ v ~i v ~ P j) + + = Fi ( x, t). (2.83) t xj xi 30

CHAPTER 2. METHODOLOGY

2.2. SOUND GENERATION MODEL

Completing the same steps as before (subtracting continuity from momentum, applying time derivative and divergence, and performing a linearization), one can obtain:
2 2 Fi ( x, t) 2  i ( =- =F x, t). - c 2 2 t xi xi

(2.84)

To represent a compact source it is necessary to rewrite the above as a point source. As was done previously with the monopole inflow rate density, replacing the above with Fi = fi (t) ( x- y ). After making the substitution, one can solve using Greens functions for the pressure to obtain p( x, t) = -  xi ( fi ( ) r ) . (2.86) (2.85)

Taking the above and expanding further by applying the divergence operator, the solution is given by p( x, t) = 1 x i - y i 4 | r| ( ) 1 fi ( ) 1 + 2 fi (  ) . rc t r (2.87)

With the obtained solution, there are two different situations for which it can be used. The first of these situations deals with the near-field solution, represented by r12 term, while the second involves the far-field solution, defined by 1 r . Both of the terms are useful as they indicate that a dipole source does not radiate sound in the same way as does a monopole. That is, the dipole has a strong near-field region, which radiates much more noise away in the near-field in comparison to the monopole; this is in contrast to the far field, which dissipates according to 1 r . To develop the forcing term, one can introduce an oscillating force term and take the derivative of it fi ( ) = Adi cos(t - k0 r), fi ( ) = -Adi sin(t - k0 r). t The derivative of the forcing term can then be put into equation 2.87 above to yield p( x, t) = 1 A (oi di ) 2 (-k0 rsin(tk0 r) + cos(t - k0 r)). 4 r (2.90) (2.88) (2.89)

Because the RMS pressure is required for the sound propagation model, the same method is applied as for a monopole to find it. Taking the RMS value, one can obtain  PRM S =
2 r2 )  2(1 + k0 x- y Adi ( ) 2 . 8 | r| r

(2.91)

31

2.2. SOUND GENERATION MODEL

CHAPTER 2. METHODOLOGY

The variable di , represents the directional unit vector of the dipole. Rearranging to solve for the amplitude and substituting for RMS pressure Pref (100.05LP )(8r2 ) . A=  x- y 2 r 2 )(  2(1 + k0 | r | )di (2.92)

As was done earlier, an equation has been developed for the scaled source amplitude of a specific sound pressure level at a receiver. Further, it is beneficial to mention that due to the nature of a dipole, there will be a region of maximum pressure along the dipole axis at 0 and  , while a region of minimum 3 pressure will exist perpendicular to the dipole axis at  2 and 2 (Fig. 2.3).

Figure 2.3: Dipole Directivity Pattern [59]

2.2.3

Noise Sources

According to Wagner et al. [59], there are various causes of noise being emitted from a turbine (Fig 2.4). In the broadest sense, the two major causes are mechanical noise and noise caused by the flow interacting with the turbine itself. Several different components of the wind turbine are responsible for mechanical noise; they include the gearbox, generator, cooling equipment, and hydraulics for blade pitch control. The actual emission of the noise however, can take place through either the air itself or through the structure of the turbine first and then be emitted through the air. The greatest contributor of mechanical noise from the above components is the gearbox. The component itself consists of several smaller internal parts, of which the gears create most of the noise. The noise results from errors in their manufacturing, leading to issues in the gear meshing. The errors in the meshing then lead to vibration and improper loading. If the errors in the gear manufacturing were to be doubled, a noise increase of approximately 6dB would result. Insulation for the nacelle however, can reduce noise emissions by as much as 15 dB [52]. A further 1dB decrease per degree of angle can be achieved by using helical gears [59]. Aerodynamic noise can be divided into three separate categories; steady thickness and loading noise, inflow turbulence noise, and airfoil self-noise. Primarily, the noise results due to the interactions of the 32

CHAPTER 2. METHODOLOGY

2.2. SOUND GENERATION MODEL

Figure 2.4: Noise components on an airfoil [19]

boundary layer with the surface of the airfoil.

Steady Thickness and Loading Noise The mechanisms responsible for this type of noise, primarily cause low frequency noise when the blades ingest variations in an otherwise uniform flow, such as the wake from an obstacle upstream or a flow gradient. Essentially what takes place, is the disturbed flow enters the region occupied by the spinning turbines blades. When this happens, there is a change in the dynamic pressure and angle of attack resulting in a fluctuation of how much load is applied on the blade. This resulting load change then fluctuates based on the disturbed flow. The amount of sound generated by this specific noise type is typically not of significant issue with wind turbines that have the rotor plane upwind of an obstruction generating a disturbance to the flow (i.e. such as the support tower); however, if the tower is placed upwind of the rotor, noise can result from interaction with the blades. The sound generated by the blades encountering the disturbed flow is tonal and is typically in the range of 1-3Hz. When the rotor experiences an increased rotational speed, the frequency of the sound increases however [32]. The low frequency noise may not seem significant as it is well below the lower range of human hearing. However, it is more perceptible as vibration which can in fact affect humans internally, as well as structures and their components in the immediate vicinity (such as buildings with windows). This low frequency noise is known as infrasound [54]. 33

2.2. SOUND GENERATION MODEL Inflow-Turbulence Noise

CHAPTER 2. METHODOLOGY

Turbulence alone is known to cause broadband noise, and can be encountered throughout the atmosphere. There are two primary causes of it: that due to the interaction of the flow with any kind of surface (aerodynamic) and that due to rising air from heating by the sun (thermal) [44]. To quantify it, typically a turbulence intensity value is used, which compares the standard deviation and mean wind velocity. The noise produced by turbulence can result in both low and high frequency noise. Whether low or high end noise will result however depends on the size of the accompanying turbulent eddy in relation to the turbine blade chord length. If the eddy size is large in comparison to the chord, a dipole noise pattern will result and the blade will experience a change in its loading. If the eddy size is similar or small in comparison to the chord, the noise pattern will depend on the blade geometry and only a local change in loading will result. Based on the wavelength =  , M (2.93)

Where the turbulent eddy size is defined by , and if the ratio of the speed of sound to wavelength is much less than one, the noise source resulting from the blade can be taken as being compact, allowing the use of a point source [19]. If the ratio mentioned above is not satisfied, the source cannot be taken as compact, and a significantly more complex problem results, whereby the noise pattern will depend on the physical characteristics of the blade. The actual noise resulting from inflow turbulence is normally taken as a swishing noise as the blades rotate. It is predominant in noise generation up to a maximum of 1000Hz [59]. It has been said that the shape of the airfoil and its leading edge also play a significant role in the amount of resulting noise [16],[23]. Airfoil Self-Noise The boundary layer of an airfoil plays an important role in airfoil self-noise, regardless if there is a contribution from steady thickness and loading and inflow turbulence noise. The different components producing this noise are

Trailing Edge This type of noise involves the boundary layer encompassing turbulent flow and interacting with the trailing edge. Essentially, the eddys formed in the turbulent layer are able to produce noise as they meet a corner or edge (in contrast to no edges or corners where the eddys would not produce substantial noise). As a result, the emission of noise can be reduced by a significant amount if one uses a swept blade [62] or a serrated shape [38], in effect 'cushioning' the flow off the blade. The wave number, distance of the eddy from the trailing edge, eddy convection speed, and turbulence composition, also play important roles in the amount of noise produced. The sound resulting from the trailing edge is normally perceived as being a swishing noise and exists in the range of 500 to 1500 Hz, depending on the turbine configuration [59].

34

CHAPTER 2. METHODOLOGY Laminar-Boundary-Layer-Vortex-Shedding

2.2. SOUND GENERATION MODEL

The vortex shedding noise results due to certain Reynolds number flows (between 105 and 106 ), as the transition point from laminar to turbulent flow moves significantly downstream towards the trailing edge. As the transition point moves to the end of the blade, an interaction takes place between the trailing edge and turbulent boundary layer. The noise can be decreased or eliminated by causing transition from laminar to turbulent flow to occur much sooner using a vortex generator or by serrating the leading edge [35]. Nevertheless, because the Reynolds number of the flow over most modern large turbines is significantly larger than the conditions mentioned earlier, vortex shedding is not typically an issue. Smaller and older turbine blades however are more susceptible to producing this type of noise. The resulting noise from vortex shedding is tonal in nature [59].

Tip The noise produced from the tip is caused by overflow from the pressure side to the suction side of the airfoil. The noise is a consequence of a vortex forming at the tip and interacting with it [37], as well as and the trailing edge [20],[21]; the amount produced depends on the location, size, and strength of the core, the vortex convection speed, the Reynolds number of the flow, and the loading situation of the blade [59],[21]. The production of noise because of the overflow is similar to how trailing-edge noise takes place, due to interaction with an edge. In addition, because the flow reaches a sharp edge, separation can occur which can further produce more noise, similar to vortex shedding. To reduce the amount of interaction with the tips of the blades, a designer may use a different tip shape similar to winglets used on aircraft. Tip noise is said to be broadband in nature [59].

Separated Flow When the flow separates over an airfoil, it is said to be in a stalled condition. A similar scenario takes place when the flow over a turbine blade separates. The noise itself is only eliminated by preventing the blade from entering a stalled condition [59]. This separated flow interacts with the trailing edge shape of the blade and causes broadband noise which can be in excess of 10dB [25]. If a deep stall takes place, noise is produced from the entire blade and not only from the trailing edge [51].

Blunt Trailing-Edge As the flow passes over the edge of the turbine blade, it may produce vortex shedding in a similar fashion as if it was passing by a cylindrical object. That is, as the flow moves downstream, it would separate from the cylinder. Hence, due to the shape of the trailing edge, vortex shedding can take place and produce a dipole type tonal noise [19]. This tonal noise is controlled by the shape of the trailing edge, Reynolds number, and trailing edge/boundary layer thickness ratio. As the size of the edge decreases, 35

2.2. SOUND GENERATION MODEL

CHAPTER 2. METHODOLOGY

the tone produced moves above the range of perceptible hearing [31].

Blade Imperfection As with anything manufactured, there are always certain defects which can occur to the part, however minor they might be. With the case of an airfoil (or turbine blade), imperfections in the blade can have adverse consequences on noise production. Anything causing physical imperfections or surface contamination leading to an increase in the drag can cause a disturbance to the flow over the blade, potentially leading to a tonal noise issue [48]. Shown below is an example of the different noise source mechanisms and their contribution to the overall noise produced from a wind turbine (Fig. 2.5).

Figure 2.5: Noise Sources of a NACA 632xx Turbine Blade (Bonus 300 kW) [64]
placed on the ground 40 meters downstream of the wind turbine. overall sound power level is found to be 98.06 dBA for case 1 A peak in the sound pressure level was revealed from the mea- and 97.48 dBA for case 2. The measured overall sound power sured noise spectrum at a frequency of about 250 Hz. An expla- level at wind speed 8 m / s is about 99.1 dBA. nation given in 22 was that the peak level originated from me2.2.4 Noise Thus Emission Estimation 3.3 Parametrical Study. To study contributions of various chanical components. this peak value has been removed for rotor parameters to the noise level, we here carry out a parametricomparison purposes. study to a investigate general trends. To To estimate emitted a source simple the method developed by Hau [34] apply the the noisenoise prediction model, from input conditions areturbine ad- cal itself, justed in order to fit to those of the experiments. The incoming 3.3.1 Airfoil Shape . For blade designers, airfoil profiles are was It is defined as a `Class I' power method, being based on empirical data, and only requiring a meanused. wind speed at hub height is found using the law with optimised in order to achieve a high lift coefficient. Looking into the power coefficient  computed from Eq.The 4. IfHau the field is flat was rotor diameter input in metres. model chosen over others Lowson as to it noise generation from variousby airfoil types, it and could Hagg, be possible and covered with grass the mean wind speed at wind turbine hub achieve both high lift and low noise emission. Computations are best modelled higher power turbines 2 MW) in a comparison to wind measured Withofa height 31 meters found to be about 9.4 m / s (approximately corresponds to a still based on Bonus 300 kW turbine; data. the influence wind speed of 8 m / s measured at 10 meters height. This com- airfoil type will be investigated by changing NACA 632xx proputed wind speed is considered as a reference wind speed for the files with NACA 634xx profile that is also widely applied for aerodynamic BEM computations. The BEM computations give36 designing wind turbine blades. Figure 7 gives the result of the detailed information about the local velocity at each blade ele- noise spectra from the new wind turbine. The overall sound power ment. In Fig. 4, computed and measured 23 mechanical power level is found to be 97.18 dBA for case 1 and 96.86 dBA for curves are plotted for the Bonus 300 kW wind turbine with a pitch case 2 which is slightly lower compared with the case using setting of -1 deg. NACA 632xx profiles. It is seen that the change of the overall As a first step, to validate the basic features of the noise pre- sound power level between the two sets of airfoils is small. Howdiction model, computations based on NACA 0012 airfoils are ever, to compare cases 1 and 2 it is indicated that the NACA performed for the Bonus 300 kW wind turbine. The input condi- 634xx series airfoil is less sensitive to the inflow turbulence level.

Fig. 3 Noise spectra of all source mechanisms

CHAPTER 2. METHODOLOGY diameter, one can obtain an A-weighted SWL LW A = 22log10 D + 72.

2.3. WORKFLOW

(2.94)

Before the SWL is of use however, it is necessary to perform a conversion. First, the A-weighting of the SWL must be removed. To do this, one can use the following equation provided by Glenister, and presented in ANSI standards S1.4-1983 and S1.42-2001 [29] [ A(f ) = 2 + 20log10  . (f 2 + 20.62 ) (f 2 + 107.72 )(f 2 + 737.92 )(f 2 + 122002 ) 122002 f 4 ] (2.95)

In the above, the frequency under study is input and a weighting value, A(f), is determined. Upon determing A(f), one can add this to an A-weighted SPL to determine the un-weighted value for SWL. LW = LW A + A(f ) (2.96)

This value was used in the previously developed sound generation model to be able to determine the amplitude of the particular source type.

2.3

Workflow

Due to the nature of the mathematics involved, it was necessary to develop a computer program to solve the sound propagation equations, as well as those for the boundary conditions. The code was developed using the C programming language, utilizing the Portable, Extensible Toolkit for Scientific Computation PETSc library. The library contains specific tools for solving equations, as well as tools to allow the use of parallel processing to significantly improve the computing time. The source code developed for this study is included in Appendix C. However, due to the inherent nature of using an FDTD method, a significant amount of computing power was required. The processing facilities were provided by the Compute Canada High Performance Computing (HPC) consortium cluster of SHARCNET (ORCA), as well as the University of Toronto cluster SCINET; it should also be noted that minor testing initially was also carried out on a small local computing cluster. The use of the HPC clusters significantly reduced the amount of time required to run the code in comparison to a standard desktop computer. To run the code on the clusters, it was necessary to create submission scripts for each job submitted, after the computer code was loaded onto the system. The scripts were created to pass arguments in regards to the specific parameters required, as well as the cluster specific instructions (such as the requested amount of resources - run time, CPU usage, and amount of memory required). Although creating the submission script was trivial, each cluster required a different format. Generic examples are provided in Appendix B for submitting a computing jobs on SHARCNET, SCINET, and the local cluster that was used. During computation, one was able to observe the status of the solver. That is, as the equations were being solved, the time and percentage completed, as well as the time remaining, was presented. 37

2.3. WORKFLOW

CHAPTER 2. METHODOLOGY

Upon completing the computation, data was stored in output files. The output files present both text and graphical information. The text, gave the ground plane maximum and minimum SPL and Sound Intensity Level (SIL), as well as data pertaining to a probe location, if specified by the user. The graphical data, gave a visual representation of SPL, and was presented in the form of a `slice' of the solution taken at the ground plane of the three dimensional domain. To visualize the information, an open-source scientific visualization software was used called ParaView, shown in the figure below (Fig. 2.6).

Figure 2.6: ParaView Interface

38

Chapter 3

Results
The following sections detail both the results of the validation performed as well as the final results obtained from running the solver. To determine that the developed model was working correctly, two separate validation steps were performed. The first dealt with testing against known data that was provided in the Wilson and Liu paper [63]; this was the two dimensional validation. The second case did not compare to any data, but was performed in the form of a grid convergence study; this was the three dimensional validation. For both validation cases, there was no flow.

3.1

Validation

For the first validation case, two separate grid resolutions were considered. A lower resolution case of 600x300 nodes, while the higher resolution case doubled this amount to 1200x600 nodes. The physical dimensions of the domain were setup to be 200 m horizontally and 100 m vertically, with the origin of the domain being at the centre. The boundary conditions for the domain were set such that a rigid ground layer was used, while the absorbing boundaries were set to be 20 m. For the source configuration, its origin was set at x=-60 m and y=-30 m. It was configured to emit as a point source monopole, at a frequency of 100Hz. Finally, the source was scaled such that it would produce a value of 1 dB at 1m away from its origin. This notion was validated later in the Grid Convergence Study (GCS). To generate the results, each of the cases were run with a courant number of 0.8, using a run-time of 0.45 s. As can be seen in both the figures (Fig. 3.1, 3.2), an interference pattern of high and low pressure results due to the reflections from the ground due to the rigid ground boundary. Upon completing the two runs, a comparison could be made to that which was shown by Wilson and Liu, as shown in Figure 3.3. Observing the results in Figures 3.1,3.2, and 3.3, the effects of the absorbing boundaries, as well as the rigid ground layer, are clear. Furthermore, the propagation patterns in both this study and that of Wilson and Liu are nearly identical. 39

3.2. GRID CONVERGENCE STUDY

CHAPTER 3. RESULTS

Figure 3.1: Low-Resolution 2-D Validation

Figure 3.2: High-Resolution 2-D Validation

3.2

Grid Convergence Study

To validate the code and determine whether convergence could be achieved, a GCS was performed (for the purposes of this study, spatial convergence was examined). The method used Richardson Extrapolation, as well as three grids (fine, normal, coarse) to collect data. The general procedure and conditions used to conduct the study are described below (Table 3.1). Using a method shown by Slater [57] based on the work of Roache, a fine grid was first generated based on the ratio of nodes used and size of the domain. The number of nodes was also set to be equal in each cartesian coordinate direction to ensure 40

time, the waves have propagated approximately 150 m from the source in the +x direction. Rapid attenuation of the sound energy is seen in the other directions, where absorbing layers are present. A series of spoke-like pressure minima radiating outward from the source are clearly evident. These are caused by destructive interference between the direct waves and the waves reflected from the rigid lower boundary.
CHAPTER 3. RESULTS 3.2. GRID CONVERGENCE STUDY

Time
50 40 30 20 10

=

0.450 s

I>.

0 -10 -20 -30 -40 -80 -60 -40 -20

o
x (m)

20

40

60

80

100

Figurepressure 3.3: Wilson and 0.450 Liu Solution of initiation Emitting Monopole Source [63] Figure 3. Sound field s after of the 1OO-Hz sound source.

Comparisons of calculated sound transmission loss (TLr to the theoretical result, Eq. 85, are presented in Fig. 4 and 5. These figures show results for the low- and highVariable Value 3 3 Number of Nodes The receiver 651 (fine), 325 1633 (coarse) resolution grids, respectively. in this case is (normal), at the same height as the source, Domain Size 60 m and the TL is plotted for locations increasing in horizontal distance from the source. The Absorbing Boundary Condition 12 m "dips" in the TL result from the interference minima mentioned the preceding paraTime-Marching Method Runge-Kutta (4thin Order) graph. The sound-pressure calculations was determined by Time-Step amplitude needed for the TL 0.0001 s RMS Average Period 0.033 s locating the maximum absolute value of the pressure within the final 30 time steps (one Flow Type Uniform to two wave periods) of the received signal. Very close agreement is obtained between Sound Source Type Mono (Calibrated Point Source - 100 dB at 1m) the theory and theSource high-resolution interference minima in the Sound Frequency FDTD calculations. The 300 Hz Flow Mach Number 0.03 low-resolution calculations are shifted to noticeably smaller ranges than predicted by the theory. Table 3.1: Grid Convergence Study Parameters "'Sound transmission loss is the ratio of the pressure amplitude recorded at the receiver to the hypothetical value that would be observed in free space at a distance of 1 m from the source. The TL is expressed in decibels by taking the base-ten logarithm of the ratio and multiplying by 20.
a structured grid and because the time step is dependant on the shortest grid element. To select the domain size however, it was necessary to determine the wavelength of the sound source to ensure that the coarse grid would not be too widely spaced to encompass the sinusoid of the sound source. x = y = z = 41 xmax - (xmin ) Nx (3.1)

3.2. GRID CONVERGENCE STUDY

CHAPTER 3. RESULTS

=

c f

(3.2)

Above, the xmax and xmin variables represent the domain dimension in the x-direction, while Nx is the number of nodes in the x-direction. Using the given equations above, an arbitrary number of nodes was selected (6513 nodes). To check whether the coarse grid would still be suitable, the node selection was halved twice (once to obtain the normal grid, 3253 nodes, and again to obtain the coarse grid, 1633 nodes). It should be noted however, that one need not half the grids; a value such as 1.5 of the previous grid may be used. Nevertheless, the sizing should not be less than or equal to 1.1 [57]. Finally, the grid spacing was determined for each grid (Table 3.2). Grid Type Fine Normal Coarse Grid Spacing (dx, dy, dz) 0.09231 metres 0.1852 metres 0.3704 metres

Table 3.2: Grid Spacing

To determine the wavelength, a frequency of 300 Hz was selected to reduce computational time (any frequency in the range of a wind turbines nominal output can be used for testing, but higher frequencies require finer grid spacing, requiring an increased compute time, as was noted earlier). To determine the speed of sound, the default parameters of the code were used ( = 1.4, R = 287 J/kg-K, T = 293.15K). Using the chosen parameters, the speed of sound was determined to be approximately 343.202 m/s, yielding a wavelength value of 1.144 m. Comparing to the values of grid spacing, each value was smaller than the wavelength, indicating that the chosen values were satisfactory. Hence, upon determining the validity of the chosen sizes, scripts were written to submit to a computer cluster for processing. Before proceeding further, it was necessary to choose a quantity for which convergence was to be achieved. The maximum sound pressure level at the ground was chosen as this value only appears once in the domain for each grid case. Hence, determining the values resulting the GCS, the first quantity was the order of convergence, which allowed one to determine how closely the exact value was to the numerical solution. Because a fourth order scheme was used, the order of convergence should indicate the same (which it did). However, because of inherent errors in the solution process, one would realistically expect the true order of convergence to be somewhat less. To calculate the order of convergence, a=
3 -f2 ln( f f2 -f1 )

ln(m)

.

(3.3)

In equation 3.3, the f3 variable represents the most coarse grid case, f1 represents the finest, and m is the grid convergence ratio. One can use a Richardson Extrapolation to determine a continuum value to which the solution will appear to converge to with successive grid refinements (the value at zero grid 42

CHAPTER 3. RESULTS spacing). The continuum value can be found using: fh=0 = f1 + f1 - f2 . ma - 1

3.2. GRID CONVERGENCE STUDY

(3.4)

To present the results correctly and to identify any errors in the study, the use of a Grid Convergence Index (GCI) was suggested. The index allows one to determine a percent value of how closely the value to which the successive grids approach compare to the calculated continuum value. The smaller the percentage, the closer the values are to each other, indicating a more desirable solution. To determine the GCI for other (coarser) grids, one can simply scale the value found above using ma . The Fs variable below refers to the safety factor; because three grids were used, a value of 1.25 was adequate (if two grids were used, a recommended value of 3 was to be used) [57]. To calculate the grid convergence,
-f1 | Fs | f2f 1

GCI =

ma - 1

 100%.

(3.5)

The results which were collected from this particular study are shown below; they did appear to converge to the expected value of 100 dB. This is important, as it validates that the solver converged to the value predicted by an analytical solution to a point source monopole of the same strength. The error from the GCI was very small albeit indicates that some very minor improvements could be made to the acquired data by perhaps utilizing a different set of grid sizes or a different flow configuration. Nevertheless, the study did illustrate that the code is able to converge to a single value similar to what was expected, as shown in Table 3.3 and 3.4. Grid Type Fine Normal Coarse Value [dB] 100.017 100.924 107.764 Normalized Grid Spacing 1 2 4

Table 3.3: Sound Pressure Levels at Varied Grid Spacing

Variable Order of Convergence Continuum Value GCI

Value 2.915 99.878 dB 0.173%

Table 3.4: Grid Spacing

After obtaining the data, a plot was produced to display the values as well as to show their convergence to a single point. The plot below (Fig. 3.4) contains both the data values which were computed by the code, as well as the continuum value which was determined with the GCS. It is clear that the numerical data was converging to a value close to that expected as the number of nodes in each case was increased. 43

3.3. TEST CASES

CHAPTER 3. RESULTS

Figure 3.4: Grid Convergence Study Plot

3.3

Test Cases

To test the operation of the developed model and to demonstrate how sound propagates under varying conditions, several different flow situations were formulated. Using the GCS as a guide, the different cases were developed such that a suitable level of detail would be achieved in the mesh, while still achieving convergence. For the purposes of this study, 24 different situations were tested with varying ground parameters, source types, and flow velocity profiles; Table 3.5 below lists the values which were kept constant through the range of tests. These parameters were kept constant to ensure that each of the cases would have the same domain, run-time, and source emission characteristics. A frequency of 100 Hz was chosen as a test frequency in consideration of the total noise spectrum emitted from a turbine, but also to expedite compute times. The SWL value which was used corresponds to a wind turbine with a diameter of 101 m, producing 2.3 MW of energy (Siemens SWT-2.3-101) [55]. It was chosen to represent the most commonly installed turbine at wind farms in Ontario at the time of writing, based on data obtained for the various installation sites [10]. For the problem domain and grid spacing, a conservative spacing of 0.15 was used, in comparison to the grid convergence study. This allowed for a resolution of approximately 22 nodes per wavelength. The physical size of the domain was chosen to help illustrate the effects of propagation and absoption, while again attempting to minimize the amount of computing 44

CHAPTER 3. RESULTS

3.3. TEST CASES

resources used. Finally, to choose the time period of the simulation to capture a useful amount of information, the total simulation time was the sum of the time required for a wave to propagate to the nearest boundary plus an RMS integration interval equal to 10 periods of the source. Parameter Number of Nodes Domain Size (x,y,z) Absorbing Boundary Size (x,y,z) Total Run-time RMS Period Frequency SWL Time-Marching Method Timestep Value 4013 60 m 18 m 0.19 s 0.1 s 100 Hz 97 dB Adaptive 4th-Order Runge-Kutta Variable (approx. 0.0001 s)

Table 3.5: Tested Flow Conditions - Constants

The second table (Table 3.6), lists the values which were varied. The velocities chosen for the flow, were based on tests conducted by Leloudas et al. [42], and collected at a hub height of 80 m, for a turbine similar to the SWT-2.3-101 (93 m diameter SWT-2.3-93). The chosen values compared favourably to the average wind speeds observed in Ontario [28] at the same height. The ground conditions which were chosen, were based on those provided earlier in Table 2.1 - Ground Condition Parameters. The different conditions allowed comparison of a variety of situations which might exist at a potential turbine installation. In addition to the varying absorbing ground conditions, a reflecting (rigid) ground condition was also tested, resembling a water installation. To compute the results, the two largers clusters (SHARCNET and SCINET) were used, requiring approximately 24 hours per case. In addition, each of these cases were run with 16 nodes, utilizing a total of 128 processor cores. From testing the code, it was determined that approximately 1.25 kilobytes of RAM per node would be required for storage; the memory allocated was therefore set at one gigabyte per process, at a minimum. To compare the different cases, a slice of the ground plane for each case was taken to obtain the RMS of the acoustic pressure (SPL), excluding the absorbing boundary regions. From these contour plots, one was able to take a further slice extending from the origin outwards in the positive x-direction (downwind). From the second slice, line plots were produced for the different ground conditions. Visible in both the line and contour plots were the effects of the different ground conditions on sound propagation. In the contour plots below, the maximum values are indicated in dark shading, while the minimum values are indicated in light shading; their magnitudes are based on the values shown in the line plots. The first set of results illustrates sound propagation and absorption quite well. One can see that as the distance from the source increases, the SPL decreases slightly with each wavelength (Fig. 3.5). As well, the amount of absorption between the cases is quite evident. For example, the case which simulates asphalt, is aborbed much less than those simulating grass and a forest. This would be expected, as the porosity  of asphalt is less than that for grass or a forest. The same behaviour can be observed for the 45

3.3. TEST CASES Case Number 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Ground Type Rigid/Water Asphalt Sand Grass Forest Snow Rigid/Water Asphalt Sand Grass Forest Snow Rigid/Water Asphalt Sand Grass Forest Snow Rigid/Water Asphalt Sand Grass Forest Snow Source Type Monopole Monopole Monopole Monopole Monopole Monopole Dipole Dipole Dipole Dipole Dipole Dipole Monopole Monopole Monopole Monopole Monopole Monopole Dipole Dipole Dipole Dipole Dipole Dipole Flow Type Uniform Uniform Uniform Uniform Uniform Uniform Uniform Uniform Uniform Uniform Uniform Uniform Power Law Power Law Power Law Power Law Power Law Power Law Power Law Power Law Power Law Power Law Power Law Power Law

CHAPTER 3. RESULTS Flow Velocity [m/s] 7.9 7.9 7.9 7.9 7.9 7.9 7.9 7.9 7.9 7.9 7.9 7.9 8 @ 80 m 8 @ 80 m 8 @ 80 m 8 @ 80 m 8 @ 80 m 8 @ 80 m 8 @ 80 m 8 @ 80 m 8 @ 80 m 8 @ 80 m 8 @ 80 m 8 @ 80 m

Table 3.6: Tested Flow Conditions - Variables

sand and snow cases, which also clearly show that they are absorbing more than the asphalt. However, the propagation and absorption of the reflecting case (water), appears to do quite the opposite, and falls well below the least absorbing case in terms of propagation; this was also evident in the latter cases for different variations of parameters. A possible explanation for this may be that due to the amount of reflection taking place for a fully reflecting case, the sound waves dissipate sooner in comparison to the other ground conditions; this appears to be evident in the contour plot for water (Fig. 3.6). It was also interesting to take note of the results for the grass and forest cases, where the SPL values were determined to be almost identical, varying slightly from one another. However, this was also expected as both conditions have very similar values of flow resistivity, porosity, and tortuosity. Finally, one would have expected the snow case to be absorbed quite less than it was based on its porosity. However, upon observing its tortuosity value, it is much closer to asphalt. Therefore, it is likely that the tortuosity decreased the amount it absorbed. Considering the contour plots for each of the tested ground conditions (Fig. 3.6), one can confirm the results presented in the line plots; it is clear that for the different cases tested, the ground conditions are able to absorb the waves propagating from the source. The maximum and minimum pattern which 46

CHAPTER 3. RESULTS

3.3. TEST CASES

Figure 3.5: Sound Pressure Level vs. Distance from Source - Monopole, Uniform Flow

exists in each of the plots is a result of reflections from the waves not fully being absorbed by the ground layer. For surfaces which have higher rates of absorption, the plots tend to be lighter; for the surfaces which have lower rates of absorption, the plots are darker. The effects of the flow velocity on the sound propagation are also evident. Each of the sources are shifted slightly to the right, in the direction of propagation. Although at such a low flow velocity the effects on sound propagation are not drastic, the plots demonstrate the ability of the solver to account for a moving flow. Further, each of the contour plots clearly illustrates the proper directivity patterns of a monopole. As was mentioned earlier, the results for rigid/water surface did not produced favourable results (Fig. 3.6 (a)). By using these results, one can also apply a linear trendline to the test cases on the line plots in Figure 3.5, to obtain an estimate of the propagation distance. Using this method, a table of propagation distances was formulated (Table 3.7). Although the method is crude, it does provide a very basic procedure for estimating propagation and absorption for the chosen domain size; a more accurate method would be to increase the domain size and observe the decrease in SPL until it reaches an in-audible level. One should also note that a dipole pattern is typically used for a wind turbine, hence the monopole source may be the cause of the under-prediction of values. Observing the second set of results beginning with Fig. 3.7, one can immediately notice the difference in the amount of sound being radiated away from the source. As was mentioned earlier, this is due to the strong near-field region for dipoles. As a result, the amplitude of the sound being radiated diminishes 47

3.3. TEST CASES

CHAPTER 3. RESULTS

(a)

(b)

Figure 3.6: Uniform Flow Monopole, Rigid/Water (left) and Asphalt (right)

(c)

(d)

Figure 3.6: Uniform Flow Monopole, Sand (left) and Grass (right)

(e)

(f)

Figure 3.6: Uniform Flow Monopole, Forest (left) and Snow (right) 48

CHAPTER 3. RESULTS Ground Type Rigid/Water Asphalt Sand Grass Forest Snow Propagation Distance [m] 1240 298 660 298 298 660

3.3. TEST CASES

Table 3.7: Estimated Propagation Distances - Monopole, Uniform Flow

Figure 3.7: Sound Pressure Level vs. Distance from Source - Dipole, Uniform Flow

much slower than for a monopole source. Another aspect of the plot involves the initial profiles of each of the cases. In comparison to the monopole plots, the dipole initially starts at a much lower SPL value. However, this is due to the phase difference between the monopole and dipole. A monopole is modelled as a single point source in space, that emits sound only from this point. A dipole, works in a similar fashion acting as a point at a single location; however, the emission direction varies and is out of phase by 180 degrees. Therefore, a dipole will emit a wave in one direction (positive x-direction), and then emit in the other (negative x-direction), but not at the same time. Hence, as can be seen on the line plot, the implementation of the dipole does follow that trend in that there is a substantially decreased area of sound emission at the source, which then increases as the distance from the source increases. 49

3.3. TEST CASES

CHAPTER 3. RESULTS

(a)

(b)

Figure 3.8: Uniform Flow Dipole, Rigid/Water (left) and Asphalt (right)

(c)

(d)

Figure 3.8: Uniform Flow Dipole, Sand (left) and Grass (right)

(e)

(f)

Figure 3.8: Uniform Flow Dipole, Forest (left) and Snow (right) 50

CHAPTER 3. RESULTS

3.3. TEST CASES

In comparison to the monopole cases, the effects of the porosity were not as pronounced. It was not immediately clear from both the line or contour plot data, which ground condition was absorbing the wave the most (Fig. 3.8). It was also interesting to note that the cases of 'grass' and 'forest' nearly mimicked what took place for the monopole cases, in that they both produced results that were nearly identical. However, as mentioned earlier, both cases have very similar ground characteristics. Finally, as mentioned for the monopole case, the results for the rigid/water surface did not produce satisfactory results, indicating quite the opposite of what was expected for both the line and contour plots (Fig. 3.8 (a)). The contour plots for the dipole case were shown in Fig. 3.8; although not as clear as in the monopole cases they did give a rough indication of the effects of the ground conditions on propagation from the source, as indicated by the darker plots for the reflecting cases, and the lighter plots for absorbing cases. 3 Further, as briefly mentioned above, for dipoles there is normally a `dead' zone at  2 and 2 , where nearly no propagation exists. These regions are due to interference from the two lobes of the dipole. The region is visible in the contour plots, indicating the two monopole sources making up the dipole are out of phase, and indicating proper operation of the solver in that regard.

Figure 3.9: Sound Pressure Level vs. Distance from Source - Monopole, Power Law Flow

The third set of results shifted focus slightly in comparison to the first two sets. A power law profile resembling a case more indicative of a real-world flow scenario was used beginning with the third set of cases. Beginning with Fig. 3.9, in comparison to the first set of monopole cases with uniform flow, the 51

3.3. TEST CASES

CHAPTER 3. RESULTS

(a)

(b)

Figure 3.10: Power Law Flow Monopole, Rigid/Water (left) and Asphalt (right)

(c)

(d)

Figure 3.10: Power Law Flow Monopole, Sand (left) and Grass (right)

(e)

(f)

Figure 3.10: Power Law Flow Monopole, Forest (left) and Snow (right) 52

CHAPTER 3. RESULTS

3.3. TEST CASES

SPL values decreased slightly, resulting in some decreased amplitudes being produced. This is likely due to the change in flow profile between a uniform flow and power law flow, near the ground. Otherwise, as was observed earlier, the effects of propagation and absorption of the flow are evident. The asphalt case once again is absorbed the least, while the grass and forest cases absorb the most. Of note is the forest ground case, which saw an increase in the peak amplitude values during its propagation in comparison to the uniform flow case. Further, it is also interesting to note that the asphalt propagation is nearly the same as that for the sand; although the values are similar, this is in contrast to the monopole case for which the values were apart from each other. As mentioned earlier, the rigid/water case once again did not perform as expected. Nevertheless, the effects of absorption on propagation were evident. The contour plots produced for the third set of cases were shown in Fig. 3.10. As was indicated in the monopole cases for uniform flow, the effects of sound propagation could be seen on the contour plots. However, for the power law flow, the changes between each of the ground conditions were not as pronounced. Nevertheless, the effects of the flow velocity were evident on the contour plots, as they were for the monopole uniform flow cases. Each of the propagation patterns were modelled correctly, but shifted slightly to the right, in the direction of the flow. Lastly, the rigid/water case again did not appear to generate the expected trend of reflecting the most. Using the same methodology as for the uniform flow case, an estimate of propagation distances was produced (Table 3.8). Ground Type Rigid/Water Asphalt Sand Grass Forest Snow Propagation Distance [m] 1000 540 540 290 248 600

Table 3.8: Estimated Propagation Distances - Monopole, Power Law Flow

The final set of data produced was for a dipole source with a power law flow. Shown in the line plot (Fig. 3.11), and as was mentioned in the results for the monopole power flow above, it was expected that the SPL values and amplitudes would be lower at the ground plane. This was the case with the dipole source as well. Furthermore, due to the strong near-field region, the effects of absorption were much less pronounced in comparison to the monopole cases. However, the values generated did not produced results as expected in the monopole cases; the porosity of the ground layer did not have a discernible effect on the amount of absorption for each case. However, it was of interest to note that as observed with some of the ground situations in the other cases, the asphalt, sand, and snow ground conditions produced nearly the same propagation pattern, while not possessing the same ground parameters; in fact, asphalt and snow were the least absorbing and most absorbing conditions, respectively, with the exception of the rigid/water surface which again did not produce any discernible information in regards to propagation. Based on the results obtained, the grass scenario appeared to have the least amount of 53

3.3. TEST CASES

CHAPTER 3. RESULTS

Figure 3.11: Sound Pressure Level vs. Distance from Source - Dipole, Power Law Flow

absorption, which was clearly not correct. Finally, taking note of the contour plots for the final set of cases (Fig. 3.12), as was shown earlier with the uniform flow dipole, the modelling of the dipole indicated an area of minimum SPL at  2 and As well, the two monopole sources out of phase producing the dipole were clearly visible. However, as was seen in the line plots, the data that was obtained from the cases did not generate a significantly useful amount of information. It was best interpreted as a general case scenario simply indicating the basic propagation pattern resulting from a dipole source.
3 2 .

54

CHAPTER 3. RESULTS

3.3. TEST CASES

(a)

(b)

Figure 3.12: Power Law Flow Dipole, Rigid/Water (left) and Asphalt (right)

(c)

(d)

Figure 3.12: Power Law Flow Dipole, Sand (left) and Grass (right)

(e)

(f)

Figure 3.12: Uniform Flow Monopole, Forest (left) and Snow (right) 55

Chapter 4

Conclusion
The goal of this study was to produce a detailed sound propagation model, that would be used to help predict setback distances in the development of wind turbines. A detailed numerical model was produced, and results were generated to test its operation. It was found that the model was able to show sound propagation from both a monopole and dipole source. Furthermore, it was also able to show the effects of absorption due to varying ground conditions, as well as the effects on sound propagation from using different flow profiles. It should again be emphasized however, that this model is a starting point to a larger development; the framework has been developed for larger and more complex simulations to take place and be tested and is by no means a final build ready to be used for any real-world situation which one may encounter. There are several immediate aspects of this study which could be improved upon.

4.1

Recommendations

Perhaps the largest issue would be the use of larger simulation domains and finer grids to test sound propagation characteristics as the wave moves through a domain and dissipates near the boundaries. In comparison to the domains used for testing in this study, a larger domain would be a much better indicator as to whether the correct sound propagation characteristics are taking place further downstream of the turbine. Furthermore, with larger domain simulations, the area around which a turbine is installed could be used to collected empirical data which would then be used for validation to truly determine whether the current setback distances are adequate for use in Ontario. With the increased and more detailed domain, one may also consider implementing a different set of boundary conditions based on a Perfectly Matched Layer (PML). The PML boundary condition is much more effective at eliminating the reflected wave from the exterior boundary. However, the implementation of PML is not trivial, but could be of interest to implement in a FDTD setting. Although a flat terrain was used for this study, and was because most of the terrain in southern Ontario is, it would be worthwhile to test the implementation of variable terrain. The changing terrain 57

4.1. RECOMMENDATIONS

CHAPTER 4. CONCLUSION

could be obtained from GIS data, collected for a different location in the province, potentially being considered for wind turbine development. Furthermore, with the inclusion of a variable terrain, it would also be beneficial to test the effects of upstream and downstream obstructions on the sound propagation from wind turbines. The obstructions may result in refractions and reflections which may potentially alter the sound characteristics of the turbines due to changes in the incoming flow. In terms of validation, it would be beneficial to obtain the noise profile for the particular turbine under study (SWT-2.3-101). This type of data would allow one to develop a more detailed Class II or III sound generation model. A comparison could then be made to a real-world installation. With a detailed noise model, the entire spectrum of specific noise mechanisms emitted from the turbine could also be captured (steady thickness and loading, inflow, airfoil-self). The noise model used for this study was based upon using a single frequency for the entire spectrum emitted. It should be noted however, that the functionality for testing the entire frequency range was being implemented into the solver at the time of writing, for both monopole and dipole noise sources.

58

Appendix 1

Finite-Differences Approximations
The approximations to the spatial derivatives are provided below (from left to right). Mesh indices are denoted by (i, j, k ) while array indices are denoted by [i, j, k ].

1.1
1.1.1

Sound Propagation Equations
Equation 2.25
(i, j, k ) = [i, j, k ], (1.1)

c(i, j, k ) = c[i, j, k ],

(1.2)

Q(i, j, k ) = Q[i, j, k ], wx wx [i, j, k ] - wx [i - 1, j, k ] (i, j, k ) = , x x wy wy [i, j, k ] - wy [i, j - 1, k ] (i, j, k ) = , y y wz wz [i, j, k ] - wz [i - 1, j, k - 1] (i, j, k ) = , z z vx (i, j, k ) = vx [i, j, k ] + vx [i - 1, j, k ] , 2

(1.3)

(1.4)

(1.5)

(1.6)

(1.7)

P P [i + 1, j, k ] - P [i - 1, j, k ] (i, j, k ) = , x 2x 59

(1.8)

1.1. SOUND PROPAGATION EQUATIONS

APPENDIX 1. FD APPROXIMATIONS

vy (i, j, k ) =

vx [i, j, k ] + vx [i, j - 1, k ] , 2

(1.9)

P P [i, j + 1, k ] - P [i, j - 1, k ] (i, j, k ) = , y 2y vz (i, j, k ) = vx [i, j, k ] + vx [i, j, k - 1] , 2

(1.10)

(1.11)

P [i, j, k + 1] - P [i, j, k - 1] P (i, j, k ) = . z 2z

(1.12)

1.1.2

Equation 2.26
Fx (i, j, k ) = Fx [i, j, k ], 1 bx [i + 1, j, k ] + bx [i, j, k ] bx (i + , j, k ) = , 2 2 Px 1 P [i + 1, j, k ] - P [i, j, k ] (i + , j, k ) = , x 2 x 1 vx (i + , j, k ) = vx [i, j, k ], 2 wx 1 wx [i + 1, j, k ] - wx [i - 1, j, k ] (i + , j, k ) = , x 2 2x 1 vy [i, j, k ] + vy [i + 1, j, k ] + vy [i, j - 1, k ] + vy [i + 1, j - 1, k ] vy (i + , j, k ) = , 2 4 wx 1 wx [i, j + 1, k ] - wx [i, j - 1, k ] (i + , j, k ) = , y 2 2y 1 vz [i, j, k ] + vy [i + 1, j, k ] + vy [i, j, k - 1] + vy [i + 1, j, k - 1] vz (i + , j, k ) = , 2 4 wz 1 wx [i, j, k + 1] - wx [i, j, k - 1] (i + , j, k ) = , z 2 2z 1 wx (i + , j, k ) = wx [i, j, k ], 2 vx 1 (i + , j, k ) = vx [i, j, k ], x 2 60 (1.13)

(1.14)

(1.15)

(1.16)

(1.17)

(1.18)

(1.19)

(1.20)

(1.21)

(1.22)

(1.23)

APPENDIX 1. FD APPROXIMATIONS

1.1. SOUND PROPAGATION EQUATIONS

1 wy [i, j, k ] + wy [i + 1, j, k ] + wy [i, j - 1, k ] + wy [i + 1, j - 1, k ] wy (i + , j, k ) = , 2 4 vx 1 (i + , j, k ) = vx [i, j, k ], y 2 1 vz [i, j, k ] + vz [i + 1, j, k ] + vz [i, j, k - 1] + vz [i + 1, j, k - 1] vz (i + , j, k ) = , 2 4 1 vx (i + , j, k ) = vx [i, j, k ]. z 2

(1.24)

(1.25)

(1.26)

(1.27)

1.1.3

Equation 2.27
Fy (i, j, k ) = Fy [i, j, k ], 1 by [i, j + 1, k ] + by [i, j, k ] by (i, j + , k ) = , 2 2 Py 1 P [i, j + 1, k ] - P [i, j, k ] (i, j + , k ) = , y 2 2y 1 vx [i, j, k ] + vx [i, j + 1, k ] + vx [i - 1, j + 1, k ] + vx [i - 1, j, k ] vx (i, j + , k ) = , 2 4 wy 1 wy [i + 1, j, k ] - wx [i - 1, j, k ] (i, j + , k ) = , x 2 2x 1 vy (i, j + , k ) = vy [i, j, k ], 2 wy 1 wy [i, j + 1, k ] - wx [i, j - 1, k ] (i, j + , k ) = , y 2 2y 1 vz [i, j, k ] + vz [i, j + 1, k ] + vz [i, j + 1, k ] + vz [i, j, k - 1] vz (i, j + , k ) = , 2 4 wy 1 wy [i, j, k + 1] - wx [i, j, k - 1] (i, j + , k ) = , z 2 2z wx [i, j, k ] + wx [i, j + 1, k ] + wx [i - 1, j + 1, k ] + wx [i - 1, j, k ] 1 , wx (i, j + , k ) = 2 4 vy 1 (i, j + , k ) = vy [i, j, k ], x 2 61 (1.28)

(1.29)

(1.30)

(1.31)

(1.32)

(1.33)

(1.34)

(1.35)

(1.36)

(1.37)

(1.38)

1.1. SOUND PROPAGATION EQUATIONS

APPENDIX 1. FD APPROXIMATIONS

1 wy (i, j + , k ) = wy [i, j, k ], 2 vy 1 (i, j + , k ) = vy [i, j, k ], y 2 1 wz [i, j, k ] + wz [i, j + 1, k ] + wz [i, j + 1, k - 1] + wz [i, j, k - 1] wz (i, j + , k ) = , 2 4 1 vy (i, j + , k ) = vy [i, j, k ]. z 2

(1.39)

(1.40)

(1.41)

(1.42)

1.1.4

Equation 2.28
Fz (i, j, k ) = Fz [i, j, k ], 1 bz [i, j, k + 1] + bz [i, j, k ] bz (i, j, k + ) = , 2 2 Pz 1 P [i, j, k + 1] - P [i, j, k ] (i, j, k + ) = , z 2 2z 1 vx [i, j, k ] + vx [i - 1, j, k ] + vx [i, j, k + 1] + vx [i - 1, j, k + 1] vx (i, j, k + ) = , 2 4 wz 1 wz [i + 1, j, k ] - wz [i - 1, j, k ] (i, j, k + ) = x 2 2x 1 vy [i, j, k ] + vy [i, j - 1, k ] + vy [i, j, k + 1] + vy [i - 1, j, k + 1] vy (i, j, k + ) = , 2 4 wz 1 wz [i, j + 1, k ] - wz [i, j - 1, k ] (i, j, k + ) = , y 2 2y 1 vz (i, j, k + ) = vz [i, j, k ], 2 wz 1 wz [i, j, k + 1] - wz [i, j, k - 1] (i, j, k + ) = , z 2 2z wx [i, j, k ] + wx [i - 1, j, k ] + wx [i, j, k + 1] + wx [i - 1, j, k + 1] 1 , wx (i, j, k + ) = 2 4 vz 1 (i, j, k + ) = vz [i, j, k ], x 2 62 (1.43)

(1.44)

(1.45)

(1.46)

(1.47)

(1.48)

(1.49)

(1.50)

(1.51)

(1.52)

(1.53)

APPENDIX 1. FD APPROXIMATIONS

1.2. ABSORBING BOUNDARY CONDITIONS

1 wy [i, j, k ] + wy [i, j - 1, k ] + wy [i, j, k + 1] + wy [i, j - 1, k + 1] wy (i, j, k + ) = , 2 4 vz 1 (i, j, k + ) = vz [i, j, k ], y 2 1 wz (i, j, k + ) = wz [i, j, k ], 2 vz 1 (i, j, k + ) = vz [i, j, k ]. z 2

(1.54)

(1.55)

(1.56)

(1.57)

1.2
1.2.1

Absorbing Boundary Conditions
Equation 2.37
e (i, j, k ) = e [i, j, k ] wx [i, j, k ] - wx [i - 1, j, k ] wx (i, j, k ) = , x x wy wy [i, j, k ] - wy [i, j - 1, k ] (i, j, k ) = , y y wz wz [i, j, k ] - wz [i - 1, j, k - 1] (i, j, k ) = , z z (1.58)

(1.59)

(1.60)

(1.61)

1.2.2

Equation 2.38
1 be [i + 1, j, k ] + be [i, j, k ] be (i + , j, k ) = 2 2  x (i, j, k ) =  x [i, j, k ] 1 wx (i + , j, k ) = wx [i, j, k ] 2 1 px [i + 1, j, k ] - px [i, j, k ] px (i + , j, k ) = , x 2 x (1.62)

(1.63)

(1.64)

(1.65)

1.2.3

Equation 2.39
1 be [i, j + 1, k ] + be [i, j, k ] be (i, j + , k ) = 2 2  y (i, j, k ) =  y [i, j, k ] 63 (1.66)

(1.67)

1.2. ABSORBING BOUNDARY CONDITIONS

APPENDIX 1. FD APPROXIMATIONS

1 wy [i, j, k ] + wy [i + 1, j, k ] + wy [i, j - 1, k ] + wy [i + 1, j - 1, k ] wy (i, j + , k ) = 2 4 py 1 py [i, j + 1, k ] - py [i, j, k ] (i, j + , k ) = , x 2 y

(1.68)

(1.69)

1.2.4

Equation 2.40
1 be [i, j, k + 1] + be [i, j, k ] be (i, j, k + ) = 2 2  z (i, j, k ) =  z [i, j, k ] 1 wz [i, j, k ] + wz [i + 1, j, k ] + wz [i, j, k - 1] + wz [i + 1, j, k - 1] wz (i, j, k + ) = 2 4 pz 1 py [i, j, k + 1] - py [i, j, k ] (i, j, k + , k ) = , z 2 z (1.70)

(1.71)

(1.72)

(1.73)

64

Appendix 2

Sample Submission Scripts
2.1
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31

SHARCNET

#! / b i n / sh . ~/ b i n /common . sh load petsc set work path s q s u b - r 24h --mpp=1.5G -n 128 -m -q mpi -o j o b g c s - j j o b g c s \ acoustic \ -N x 651 -N y 651 -N z 651 \ -x max 150 -x min -150 \ -y max 150 -y min -150 \ -z max 150 - z min -150 \ - x l a y e r 18 - y l a y e r 18 - z l a y e r 18 \ -t max 0 . 4 7 \ -T 0 . 0 3 3 3 3 \ - t s t y p e RK4 \ -dt 1E-4 \ -mean mean uniform \ - s o u r c e monopole \ -mono f 300 \ - m e a s u r e d s w l 97 \ -m o n o o r i g i n x 0 \ -m o n o o r i g i n y 0 \ -m o n o o r i g i n z 0 \ -mean uniform M 0 . 0 2 3 - g r o u n d f l o w r e s i s t i v i t y 3E+7 \ -g r o u n d p o r o s i t y 0 . 1 \ -g r o u n d t o r t u o s i t y 3 . 2 \ - r m s p r o b e 10 \ -log summary

65

2.2. SCINET

APPENDIX 2. SAMPLE SUBMISSION SCRIPTS

2.2
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40

SCINET

#! / b i n / bash # # PBS -N j o b g c s # PBS - l nodes =16: ppn=8 , w a l l t i m e = 2 4 : 0 0 : 0 0 # PBS - j oe . ~/. bashrc echo hosts file load petsc cd $PBS O WORKDIR # Some p a r a m e t e r s e t t i n g s Nx=651 Ny=651 Nz=651 tmax =0.47 T=0.03333 mpirun -np $ {NSLOTS} - h o s t f i l e $ {PBS NODEFILE} a c o u s t i c \ -N x $ {Nx} -N y $ {Ny} -N z $ { Nz } \ -x max 150 -x min -150 -y max 150 -y min -150 -z max 150 - z min -150 \ - x l a y e r 18 - y l a y e r 18 - z l a y e r 18 \ -t max $ { tmax } \ -T $ {T} \ - t s t y p e RK4 \ -dt 1E-4 \ -mean mean uniform \ - s o u r c e monopole \ -mono f 300 \ - m e a s u r e d s w l 97 \ -m o n o o r i g i n x 0 -m o n o o r i g i n y 0 -m o n o o r i g i n z 0 \ -mean uniform M 0 . 0 2 3 \ - g r o u n d f l o w r e s i s t i v i t y 3E+7 \ -g r o u n d p o r o s i t y 0 . 1 \ -g r o u n d t o r t u o s i t y 3 . 2 \ - r m s p r o b e 10 \ -log summary

2.3
1 2 3 4

Local Cluster

#/ b i n / bash # #$ -N j o b g c s #$ -q p a r a l l e l

66

APPENDIX 2. SAMPLE SUBMISSION SCRIPTS
5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #$ -pe mpi 28 #$ - l h vmem=1.4G # . $TMPDIR/ env . sh cd $ {SGE O WORKDIR} mpirun -np $ {NSLOTS} a c o u s t i c \ -N x 651 -N y 651 -N z 651 \ -x max 150 -x min -150 \ -y max 150 -y min -150 \ -z max 150 - z min -150 \ - x l a y e r 18 - y l a y e r 18 - z l a y e r 18 \ -t max 0 . 4 7 \ -T 0 . 0 3 3 3 3 \ - t s t y p e RK4 \ -dt 1E-4 \ -mean mean uniform \ - s o u r c e monopole \ -mono f 300 \ - m e a s u r e d s w l 97 \ -m o n o o r i g i n x 0 \ -m o n o o r i g i n y 0 \ -m o n o o r i g i n z 0 \ -mean uniform M 0 . 0 2 3 - g r o u n d f l o w r e s i s t i v i t y 3E+7 \ -g r o u n d p o r o s i t y 0 . 1 \ -g r o u n d t o r t u o s i t y 3 . 2 \ - r m s p r o b e 10 \ -log summary

2.3. LOCAL CLUSTER

67

Appendix 3

Source Code
3.1
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15

main.c

#include < s t d l i b . h> #include < a s s e r t . h> #include < p e t s c . h> #include "param . h" #include " s e t u p . h" #include " timemarch . h" #include " i o . h" #include "mean . h" #include " s o u r c e . h" /  ! \ mainpage FDTD S o l v e r \ section intro sec Introduction This i s a s o l v e r f o r a c o u s t i c p r e s s u r e and v e l o c i t y u s i n g t h e f i n i t e - d i f f e r e n c e time -domain FDTD method . Various a c o u s t i c s o u r c e models a r e a v a i l a b l e . This code i s experimental . \ section i n s t a l l s e c Installation This s o l v e r u s e s t h e GNU a u t o t o o l s p a c k a g e . I f you have a copy o f t h e s o u r c e code , s i m p l y run : . / c o n f i g u r e ; make ; make i n s t a l l .

16 17 18 19 20 21 22 23 24 25 26 27

/ /   G l o b a l v a r i a b l e t o c o n t r o l e x e c u t i o n o f t h e time marching method .  / char RunSolver =1; /   A f u n c t i o n t o p r i n t u s a g e f l a g s , e x c l u d i n g t h o s e p a r a m e t e r s s t o r e d i n a PetscBag structure .

69

3.1. MAIN.C

APPENDIX 3. SOURCE CODE

28  / 29 void P r i n t U s a g e ( ) 30 { 31 P e t s c P r i n t f (PETSC COMM WORLD, " - a u t o l a y e r N: a u t o m a t i c a l l y s i z e BC l a y e r based upon w a v e l e n g t h . \ n" ) ; 32 P e t s c P r i n t f (PETSC COMM WORLD, " - a u t o s p a n N: a u t o m a t i c a l l y s i z e domain based upon nodes p e r w a v e l e n g t h . \ n" ) ; 33 P e t s c P r i n t f (PETSC COMM WORLD, " - r e s t a r t : l o a d p a r a m e t e r s and s o l u t i o n from p r e v i o u s i n c o m p l e t e run . \ n" ) ; 34 P e t s c P r i n t f (PETSC COMM WORLD, " - l o a d s o l u t i o n : l o a d s o l u t i o n from p r e v i o u s run . \ n" ) ; 35 P e t s c P r i n t f (PETSC COMM WORLD, " - s a v e m a x a b s p r e s s u r e : compute t r a n s m i s s i o n l o s s . \ n" ) ; 36 P e t s c P r i n t f (PETSC COMM WORLD, " - s a v e v t k : l o a d s a v e d s o l u t i o n , and e x p o r t s o l u t i o n a s p . vtk and w . vtk . \ n" ) ; 37 P e t s c P r i n t f (PETSC COMM WORLD, " - s a v e t r a n s i e n t : e x p o r t p r e s s u r e f o r ground p l a n e a s p tsXXXXXXX . vtk . \ n" ) ; 38 P e t s c P r i n t f (PETSC COMM WORLD, " - s a v e i s l i c e N: e x p o r t s o l u t i o n f o r s l i c e p e r p e n d i c u l a r t o i p l a n e a s s l i c e i N . vtk . \ n" ) ; 39 P e t s c P r i n t f (PETSC COMM WORLD, " - s a v e j s l i c e N: e x p o r t s o l u t i o n f o r s l i c e p e r p e n d i c u l a r t o j p l a n e a s s l i c e j N . vtk . \ n" ) ; 40 P e t s c P r i n t f (PETSC COMM WORLD, " - s a v e k s l i c e N: e x p o r t s o l u t i o n f o r s l i c e p e r p e n d i c u l a r t o k p l a n e a s s l i c e k N . vtk . \ n" ) ; 41 } 42 43 /   44  The main f u n c t i o n which p r o c e s s e s a l l command l i n e f l a g s . 45  Based upon t h e command l i n e f l a g s , t h e s o l v e r may : 46  - Load a p r e v i o u s l y s a v e d s o l u t i o n 47  - I n i t i a l i z e the flow f i e l d 48  - Time march t h e i n i t i a l v a l u e problem 49  - Save t h e e n t i r e s o l u t i o n or a s l i c e o f t h e f l o w domain . 50  51  / 52 i n t main ( i n t argc , char  a r g v [ ] ) 53 { 54 const i n t MaxMeanFlowTypeStr =256; /  The maximum l e n g t h o f mean f l o w t y p e name .  / 55 const i n t MaxTSTypeStr =256; /  The maximum l e n g t h o f a time march method name . / 56 PetscErrorCode i e r r ; /  PETSc e r r o r code  / 57 Vec s o l u t i o n ; /  PETSc v e c t o r t o s t o r e c u r r e n t s o l u t i o n  / 58 p a r a m e t e r s  params ; /  Run-time parameter s t o r a g e  / 59 fluid properties  properties ; / G l o b a l f l u i d p r o p e r t i e s / 60 void  sourceparams ,  meanparams ,  bcparams ; /  P t r s t o v a r i o u s parameter g r o u p s  / 61 app ctx context ; /  Run-time c o n t e x t f o r p a s s i n g t o v a r i o u s PETSc f u n c t i o n s / 62 P e t s c I n t i , NWays=1; 63 PetscTruth TSMonitor=PETSC FALSE , HelpRequested=PETSC FALSE , F l a g E x i s t s=PETSC FALSE , DoLoadSolution=PETSC FALSE , DoSaveVTK=PETSC FALSE , DoLoadParameters=PETSC FALSE , AutoLayer=PETSC FALSE , D o S a v e I S l i c e=PETSC FALSE , D o S a v e J S l i c e=PETSC FALSE , DoSaveKSlice=PETSC FALSE ;

70

APPENDIX 3. SOURCE CODE
64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 P e t s c I n t i s l i c e =0 , j s l i c e =0 , k s l i c e =0; char m e a n f l o w t y p e s t r [ MaxMeanFlowTypeStr ] ; char t s t y p e s t r [ MaxTSTypeStr ] ; PetscLogStage P r o f i l e S o l v e , P r o f i l e S a v e ; int s i z e ; /  I n i t i a l i z e PETSc , e x i t i f f a i l .  / i f ( i e r r=P e t s c I n i t i a l i z e (& argc ,& argv , PETSC NULL, PETSC NULL) ) { f p r i n t f ( s t d e r r , " Unable t o i n i t i a l i z e PETSc e n v i ro n m e nt . \ n" ) ; return i e r r ; } MPI Comm size (PETSC COMM WORLD,& s i z e ) ; i f ( s i z e > 1) P e t s c P r i n t f (PETSC COMM WORLD, " Running %d-way \ n" , s i z e ) ;

3.1. MAIN.C

/  Look f o r e x t r a command- l i n e f l a g s .  / DoLoadParameters=PETSC FALSE ; i e r r=PetscOpti onsGetTruth (PETSC NULL, "- r e s t a r t " ,& DoLoadParameters ,& F l a g E x i s t s ) ; i f ( i e r r ) RunSolver =0; i f ( F l a g E x i s t s && DoLoadParameters ) DoLoadSolution=PETSC TRUE ; i e r r=PetscOpti onsGetTruth (PETSC NULL, "- s a v e v t k " ,&DoSaveVTK , PETSC NULL) ; i f ( i e r r ) RunSolver =0; i e r r=P e t s c O p t i o n s G e t I n t (PETSC NULL, "- s a v e i s l i c e " ,& i s l i c e ,& D o S a v e I S l i c e ) ; i f ( i e r r ) RunSolver =0; i e r r=P e t s c O p t i o n s G e t I n t (PETSC NULL, "- s a v e j s l i c e " ,& j s l i c e ,& D o S a v e J S l i c e ) ; i f ( i e r r ) RunSolver =0; i e r r=P e t s c O p t i o n s G e t I n t (PETSC NULL, "- s a v e k s l i c e " ,& k s l i c e ,& DoSaveKSlice ) ; i f ( i e r r ) RunSolver =0; c o n t e x t . r m s s l i c e =0; i e r r=P e t s c O p t i o n s G e t I n t (PETSC NULL, "- r m s s l i c e " ,&( c o n t e x t . r m s s l i c e ) ,& F l a g E x i s t s ) ; i f ( i e r r ) RunSolver =0; c o n t e x t . DoProbe=PETSC FALSE ; c o n t e x t . RMSProbeDistance = 0 . 0 ; i e r r=P e t s c O p t i o n s G e t R e a l (PETSC NULL, "- r m s p r o b e " ,& c o n t e x t . RMSProbeDistance ,& c o n t e x t . DoProbe ) ; i f ( i e r r ) RunSolver =0; i f ( ! c o n t e x t . DoProbe ) { i e r r=P e t s c O p t i o n s G e t R e a l (PETSC NULL, "- probe " ,& c o n t e x t . RMSProbeDistance ,& c o n t e x t . DoProbe ) ; i f ( i e r r ) RunSolver =0; }

71

3.1. MAIN.C
112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156

APPENDIX 3. SOURCE CODE

c o n t e x t . S a v e T r a n s i e n t P r e s s u r e=PETSC FALSE ; i e r r=PetscOptionsGet Truth (PETSC NULL, "- s a v e t r a n s i e n t " ,& c o n t e x t . S a v e T r a n s i e n t P r e s s u r e , PETSC NULL) ; i f ( i e r r ) RunSolver =0; c o n t e x t . S a v e T r a n s i e n t=PETSC FALSE ; i e r r=PetscOptionsGet Truth (PETSC NULL, "- s a v e f u l l t r a n s i e n t " ,& c o n t e x t . S a v e T r a n s i e n t , PETSC NULL) ; i f ( i e r r ) RunSolver =0; i e r r=PetscOptionsGet Truth (PETSC NULL, "- s a v e m a x a b s p r e s s u r e " ,& c o n t e x t . MaxAbsPressure , PETSC NULL) ; i f ( i e r r ) RunSolver =0; i e r r=PetscOptionsGet Truth (PETSC NULL, "- l o a d s o l u t i o n " ,& DoLoadSolution , PETSC NULL) ; i f ( i e r r ) RunSolver =0; /  Check f o r - t s t y p e  / i e r r=P e t s c O p t i o n s G e t S t r i n g (PETSC NULL, "- t s t y p e " , t s t y p e s t r , MaxTSTypeStr ,& F l a g E x i s t s ) ; i f ( i e r r ) RunSolver =0; i f ( FlagExists ) { i f ( ( s t r c a s e c m p ( t s t y p e s t r , " b e u l e r " ) ==0) | | ( s t r c a s e c m p ( t s t y p e s t r , " crank - n i c h o l s o n " ) ==0) ) { P e t s c P r i n t f (PETSC COMM WORLD, " Running i m p l i c i t c o d e s r e q u i r e s u n r e a s o n a b l e amounts o f memory ! Do not u s e . \ n" ) ; RunSolver =1; } } i f (DoSaveVTK | | D o S a v e I S l i c e | | D o S a v e J S l i c e | | DoSaveKSlice ) DoLoadParameters= PETSC TRUE ; /  R e g i s t e r a l l runtime p a r a m e t e r s and command l i n e f l a g s  / /  General p a r a m e t e r s  / i e r r=R e g i s t e r P a r a m e t e r B a g (& c o n t e x t . bag ,& params , DoLoadParameters ) ; i f ( i e r r ) RunSolver =0; c o n t e x t . params=params ; / F l u i d p r o p e r t i e s / i e r r=R e g i s t e r P r o p e r t i e s B a g (& c o n t e x t . pbag ,& p r o p e r t i e s , DoLoadParameters ) ; i f ( i e r r ) RunSolver =0; c o n t e x t . p r o p e r t i e s=p r o p e r t i e s ; /  Source p r o p e r t i e s  / switch ( params-> s o u r c e ) { case SOURCE MONO PING:

72

APPENDIX 3. SOURCE CODE
157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206

3.1. MAIN.C

i e r r=RegisterM on opolePingBag (& c o n t e x t . s o u r c e b a g ,& sourceparams , DoLoadParameters ) ; c o n t e x t . p s o u r c e=s o u r c e p a r a m s ; c o n t e x t . I n i t S o u r c e=I n i t i a l i z e M o n o p o l e P i n g S o u r c e ; c o n t e x t . C a l c u l a t e S o u r c e=MonopolePing ; c o n t e x t . GetSourceLowestFrequency=GetMonopolePingFrequency ; c o n t e x t . G e t S o u r c e H i g h e s t F r e q u e n c y=GetMonopolePingFrequency ; c o n t e x t . G e t O r i g i n=GetMonopolePingOrigin ; c o n t e x t . D e s t r o y S o u r c e=NULL; break ; case SOURCE MONOPOLE: i e r r=Re gisterMonopoleBag (& c o n t e x t . s o u r c e b a g ,& sourceparams , DoLoadParameters ) ; c o n t e x t . p s o u r c e=s o u r c e p a r a m s ; c o n t e x t . I n i t S o u r c e=I n i t i a l i z e M o n o p o l e S o u r c e ; c o n t e x t . C a l c u l a t e S o u r c e=Monopole ; c o n t e x t . GetSourceLowestFrequency=GetMonopoleFrequency ; c o n t e x t . G e t S o u r c e H i g h e s t F r e q u e n c y=GetMonopoleFrequency ; c o n t e x t . G e t O r i g i n=GetMonopoleOrigin ; c o n t e x t . D e s t r o y S o u r c e=NULL; break ; case SOURCE DIPOLE : i e r r=R e g i s t e r D i p o l e B a g (& c o n t e x t . s o u r c e b a g ,& sourceparams , DoLoadParameters ) ; c o n t e x t . p s o u r c e=s o u r c e p a r a m s ; c o n t e x t . I n i t S o u r c e=I n i t i a l i z e D i p o l e S o u r c e ; c o n t e x t . C a l c u l a t e S o u r c e=D i p o l e ; c o n t e x t . GetSourceLowestFrequency=G e t D i p o l e F r e q u e n c y ; c o n t e x t . G e t S o u r c e H i g h e s t F r e q u e n c y=G e t D i p o l e F r e q u e n c y ; c o n t e x t . G e t O r i g i n=G e t D i p o l e O r i g i n ; c o n t e x t . D e s t r o y S o u r c e=NULL; break ; case SOURCE MONOPOLE SERIES : i e r r=R e g i s t e r M o n o p o l e S e r i e s B a g (& c o n t e x t . s o u r c e b a g ,& sourceparams , DoLoadParameters ) ; c o n t e x t . p s o u r c e=s o u r c e p a r a m s ; c o n t e x t . I n i t S o u r c e=I n i t i a l i z e M o n o p o l e S e r i e s S o u r c e ; c o n t e x t . C a l c u l a t e S o u r c e=M o n o p o l e S e r i e s ; c o n t e x t . GetSourceLowestFrequency=G e t M o n o p o l e S e r i e s L o w e s t F r e q u e n c y ; c o n t e x t . G e t S o u r c e H i g h e s t F r e q u e n c y=G e t M o n o p o l e S e r i e s H i g h e s t F r e q u e n c y ; c o n t e x t . G e t O r i g i n=G e t M o n o p o l e S e r i e s O r i g i n ; c o n t e x t . D e s t r o y S o u r c e=D e s t r o y M o n o p o l e S e r i e s S o u r c e ; break ; default : c o n t e x t . p s o u r c e=NULL; c o n t e x t . I n i t S o u r c e=NULL; c o n t e x t . C a l c u l a t e S o u r c e=NULL; c o n t e x t . GetSourceLowestFrequency=NULL; c o n t e x t . G e t S o u r c e H i g h e s t F r e q u e n c y=NULL; c o n t e x t . G e t O r i g i n=NULL; c o n t e x t . D e s t r o y S o u r c e=NULL; }; i f ( i e r r ) RunSolver =0;

73

3.1. MAIN.C
207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254

APPENDIX 3. SOURCE CODE

/  Mean f l o w p a r a m e t e r s  / switch ( params->mean ) { case POWER PROFILE: i e r r=R e g i s t e r P o w e r P r o f i l e M e a n B a g (& c o n t e x t . meanbag ,&meanparams , DoLoadParameters ) ; c o n t e x t . pmean=meanparams ; c o n t e x t . InitMeanFlow=I n i t i a l i z e P o w e r P r o f i l e M e a n ; break ; case MEAN UNIFORM: default : i e r r=RegisterUniformMeanBag(& c o n t e x t . meanbag ,&meanparams , DoLoadParameters ) ; c o n t e x t . pmean=meanparams ; c o n t e x t . InitMeanFlow=I n i t i a l i z e U n i f o r m M e a n ; }; i f ( i e r r ) RunSolver =0; /  BC p a r a m e t e r s  / i e r r=RegisterBCBag(& c o n t e x t . bcbag ,& bcparams , DoLoadParameters ) ; i f ( i e r r ) RunSolver =0; c o n t e x t . pbc=bcparams ; c o n t e x t . InitBC=I n i t i a l i z e B C ; P e t s c I n t NWavesInLayer =5; i e r r=P e t s c O p t i o n s G e t I n t (PETSC NULL, "- a u t o l a y e r " ,& c o n t e x t . params->mesh . NumWavesInLayer ,& F l a g E x i s t s ) ; i f ( i e r r ) RunSolver =0; P e t s c I n t NodesPerWave =10; i e r r=P e t s c O p t i o n s G e t I n t (PETSC NULL, "- a u t o s p a n " ,& c o n t e x t . params->mesh . NodesPerWave ,& FlagExists ) ; i f ( i e r r ) RunSolver =0; /  Check f o r - h e l p  / i e r r=PetscOptionsGet Truth (PETSC NULL, "- h e l p " ,& HelpRequested ,& F l a g E x i s t s ) ; i f ( i e r r ) RunSolver =0; i f ( F l a g E x i s t s && HelpRequested ) { PrintUsage ( ) ; RunSolver =0; } i f ( P a r a m e t e r s A r e I n c o r r e c t ( params ) ) RunSolver =0; / R e g i s t e r p r o f i l i n g e v e n t s / P e t s c L o g E v e n t R e g i s t e r ( " Problem Setup " ,0 ,& c o n t e x t . SetupEvent ) ; P e t s c L o g E v e n t R e g i s t e r ( "Form ODE" ,0 ,& c o n t e x t . FormODEEvent ) ; P e t s c L o g E v e n t R e g i s t e r ( " Calc S o u r c e " ,0 ,& c o n t e x t . C a l c S o u r c e E v e n t ) ; P e t s c L o g S t a g e R e g i s t e r ( " S o l v e S t a g e " ,& P r o f i l e S o l v e ) ; P e t s c L o g S t a g e R e g i s t e r ( " Save S t a g e " ,& P r o f i l e S a v e ) ;

74

APPENDIX 3. SOURCE CODE
255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 i f ( RunSolver ) { /  I f OK t o run t h e s o l v e r . . .  /

3.1. MAIN.C

/  I n i t i a l i z e t h e mean f l o w , i f n e c e s s a r y  / i f ( ! i e r r && c o n t e x t . InitMeanFlow ) i e r r=c o n t e x t . InitMeanFlow(& c o n t e x t ) ; /  I n i t i a l i z e t h e s o u r c e terms , i f n e c e s s a r y  / i f ( ! i e r r && c o n t e x t . I n i t S o u r c e ) i e r r=c o n t e x t . I n i t S o u r c e (& c o n t e x t ) ; /  I n i t i a l i z e t h e boundary c o n d i t i o n s , i f n e c e s s a r y  / i f ( ! i e r r && c o n t e x t . InitBC ) i e r r=c o n t e x t . InitBC (& c o n t e x t ) ; /  A l l o c a t e s t o r a g e f o r v e c t o r s and o t h e r d a t a s t r u c t u r e s .  / i e r r=C r e a t e S t o r a g e (& s o l u t i o n ,& c o n t e x t ) ; if { i f ( DoLoadSolution | | DoSaveVTK | | D o S a v e I S l i c e | | D o S a v e J S l i c e | | DoSaveKSlice ) /  I f we a r e s a v i n g a s o l u t i o n or s l i c e . . .  / L o a d S o l u t i o n ( s o l u t i o n ,& c o n t e x t ) ; e l s e / o t h e r w i s e i n i t i a l i z e t h e s o l u t i o n / I n i t i a l i z e S o l u t i o n ( s o l u t i o n ,& c o n t e x t ) ; i f ( ! DoSaveVTK && ! D o S a v e I S l i c e && ! D o S a v e J S l i c e && ! DoSaveKSlice ) { /  Not s a v i n g a n y t h i n g , so s o l v e t h e i n i t i a l v a l u e problem  / P e t s c P r i n t f (PETSC COMM WORLD, " S o l v i n g t h e i n i t i a l v a l u e problem . \ n" ) ; PetscLogStagePush ( P r o f i l e S o l v e ) ; i e r r=S o l v e (&params->tm,& c o n t e x t , s o l u t i o n ) ; PetscLogStagePop ( ) ; } else { /  Report t h a t we w i l l be s a v i n g a s o l u t i o n / s l i c e  / P e t s c P r i n t f (PETSC COMM WORLD, " E x p o r t i n g s o l u t i o n . \ n" ) ; } } if { PetscLogStagePush ( P r o f i l e S a v e ) ; i f ( ! DoSaveVTK && ! D o S a v e I S l i c e && ! D o S a v e J S l i c e && ! DoSaveKSlice ) { SaveCheckpoint ( s o l u t i o n ,& c o n t e x t ) ; SaveGroundVTK(& c o n t e x t ) ; ReportSoundPowerLevel(& c o n t e x t ) ; } i f (DoSaveVTK) (! ierr ) (! ierr )

75

3.1. MAIN.C
304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 } { SaveVTK ( s o l u t i o n ,& c o n t e x t ) ; } i f ( DoSaveISlice ) { i e r r=S a v e S l i c e ( i s l i c e , X SLICE , s o l u t i o n ,& c o n t e x t ) ; } i f ( DoSaveJSlice ) { i e r r=S a v e S l i c e ( j s l i c e , Y SLICE , s o l u t i o n ,& c o n t e x t ) ; } i f ( DoSaveKSlice ) { i e r r=S a v e S l i c e ( k s l i c e , Z SLICE , s o l u t i o n ,& c o n t e x t ) ; } PetscLogStagePop ( ) ; /  D e s t r o y t h e s o u r c e terms , i f n e c e s s a r y  / i f ( ! i e r r && c o n t e x t . D e s t r o y S o u r c e ) i e r r=c o n t e x t . D e s t r o y S o u r c e (& c o n t e x t ) ;

APPENDIX 3. SOURCE CODE

/ D e s t r o y a l l a l l o c a t e d d a t a s t r u c t u r e s r e l a t e d t o t h e s o l u t i o n / D e s t r o y S t o r a g e ( s o l u t i o n ,& c o n t e x t ) ; } } else { P e t s c P r i n t f (PETSC COMM WORLD, "Not r u n n i n g t h e s o l v e r . \ n" ) ; } /  D e s t r o y a l l parameter s t o r a g e  / P e t s c B a g D e s t r o y ( c o n t e x t . bag ) ; i f ( context . psource ) PetscBagDestroy ( context . sourcebag ) ; i f ( c o n t e x t . pmean ) P e t s c B a g D e s t r o y ( c o n t e x t . meanbag ) ; i f ( c o n t e x t . pbc ) P e t s c B a g D e s t r o y ( c o n t e x t . bcbag ) ; /  E x i t PETSc environment  / i f ( i e r r=P e t s c F i n a l i z e ( ) ) { f p r i n t f ( s t d e r r , " Unable t o i n i t i a l i z e PETSc en v i ro n m e nt . \ n" ) ; return 1 ; } if ( ! RunSolver ) return 1 ;

return 0 ;

76

APPENDIX 3. SOURCE CODE

3.2. BC.C

3.2
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38

bc.c

#include < s t d l i b . h> #include < a s s e r t . h> #include < p e t s c . h> #include " bc . h" #include " ode . h" const char BCFile [ ] = " b c p a r a m e t e r s . dat " ; void SaveBCBag ( PetscBag bag ) { PetscViewer bagviewer ; /  Save t h e runtime p a r a m e t e r s t o a b i n a r y f i l e  / PetscViewerBinaryOpen (PETSC COMM WORLD, BCFile , FILE MODE WRITE,& b a g v i e w e r ) ; PetscBagView ( bag , b a g v i e w e r ) ; PetscViewerDestroy ( bagviewer ) ; } P e t s c E r r o r C o d e RegisterBCBag ( PetscBag  bag , void  pparams , P e t s c T r u t h LoadFromFile ) { PetscErrorCode i e r r ; a s s e r t ( bag ) ; a s s e r t ( pparams ) ; i e r r=P e t s c B a g C r e a t e (PETSC COMM WORLD, s i z e o f ( b c p a r a m e t e r s ) , bag ) ; CHKERRQ( i e r r ) ; i e r r=PetscBagGetData (  bag , pparams ) ; CHKERRQ( i e r r ) ; i e r r=PetscBagSetName (  bag , " Boundary C o n d i t i o n P a r a m e t e r s " , " r u n t i m e p a r a m e t e r s f o r a boundary c o n d i t i o n s " ) ; CHKERRQ( i e r r ) ; b c p a r a m e t e r s  pbc=( b c p a r a m e t e r s  ) (  pparams ) ; /  Porous ground BC p a r a m e t e r s  / i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& pbc->ground . sigma , 1 E3 , " g r o u n d f l o w r e s i s t i v i t y " , " ground r e s i s t i v i t y , sigma ( Pa-s m^ - 2)" ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& pbc->ground . Omega , 0 . 6 , " g r o u n d p o r o s i t y " , " ground p o r o s i t y , Omega" ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& pbc->ground . q , 1 . 7 , " g r o u n d t o r t u o s i t y " , " ground t o r t u o s i t y , q" ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r T r u t h (  bag ,& pbc->R e f l e c t i v e G r o u n d , PETSC FALSE , " g r o u n d r e f l e c t i o n " , " a p p l y ground r e f l e c t i o n " ) ; i e r r=P e t s c B a g R e g i s t e r T r u t h (  bag ,& pbc->NoGround , PETSC FALSE , " no ground " , " no ground layer ( for testing )") ; /  Far- f i e l d ABC p a r a m e t e r s  / i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& pbc-> f a r f i e l d . s i g m a h i , 1 E3 , " f a r f i e l d f l o w r e s i s t i v i t y m a x " , " f a r - f i e l d r e s i s t i v i t y f a r t h e s t from s o u r c e , sigma ( Pa-s m^ - 2)" ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& pbc-> f a r f i e l d . s i g m a l o , 1 E2 , " f a r f i e l d f l o w r e s i s t i v i t y m i n " , " f a r - f i e l d r e s i s t i v i t y c l o s e s t t o s o u r c e , sigma (

39

77

3.2. BC.C

APPENDIX 3. SOURCE CODE

40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85

Pa-s m^ - 2)" ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& pbc-> f a r f i e l d . sc , 1 , " f a r f i e l d s t r u c t u r e c o n s t a n t " , " f a r - f i e l d s t r u c t u r e c o n s t a n t " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& pbc-> f a r f i e l d . Omega , 1 , " f a r f i e l d p o r o s i t y " , " f a r - f i e l d p o r o s i t y , Omega" ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& pbc-> f a r f i e l d . gamma , 1 , " f a r f i e l d g a m m a " , " f a r - f i e l d r a t i o o f s p e c i f i c h e a t s , gamma" ) ; CHKERRQ( i e r r ) ; i f ( LoadFromFile ) { PetscViewer bagviewer ; i f ( i e r r=PetscViewerBinaryOpen (PETSC COMM WORLD, BCFile , FILE MODE READ,& b a g v i e w e r ) ) { P e t s c P r i n t f (PETSC COMM WORLD, " Unable t o l o a d %s . \ n" , BCFile ) ; CHKERRQ( i e r r ) ; } i e r r=PetscBagLoad ( b agv iewe r , bag ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c V i e w e r D e s t r o y ( b a g v i e w e r ) ; CHKERRQ( i e r r ) ; i e r r=PetscBagGetData (  bag , pparams ) ; CHKERRQ( i e r r ) ; P e t s c P r i n t f (PETSC COMM WORLD, " Loaded boundary c o n d i t i o n p a r a m e t e r s : \ n" ) ; i e r r=PetscBagView (  bag ,PETSC VIEWER STDOUT WORLD) ; CHKERRQ( i e r r ) ; } return 0 ; } P e t s c R e a l ABC kappae ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , void  p v o i d ) { a p p c t x  p c t x =( a p p c t x  ) p v o i d ; b c p a r a m e t e r s  pbc=( b c p a r a m e t e r s  ) ( pctx ->pbc ) ; a s s e r t ( pvoid ) ; a s s e r t ( pctx ) ; a s s e r t ( pbc ) ; /  Ground r e g i o n a t l o w e r j end  / i f ( ! pbc->NoGround && j <=pctx -> j l o && j >=0) return pbc->ground . kappae ; return pbc-> f a r f i e l d . kappae ; } P e t s c R e a l ABC be ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , void  p v o i d ) { a p p c t x  p c t x =( a p p c t x  ) p v o i d ; b c p a r a m e t e r s  pbc=( b c p a r a m e t e r s  ) ( pctx ->pbc ) ; a s s e r t ( pvoid ) ; a s s e r t ( pctx ) ; a s s e r t ( pbc ) ; /  Ground r e g i o n a t l o w e r j end  / i f ( ! pbc->NoGround && j <=pctx -> j l o && j >=0) return pbc->ground . be ;

78

APPENDIX 3. SOURCE CODE

3.2. BC.C

86 return pbc-> f a r f i e l d . be ; 87 } 88 89 P e t s c R e a l ABC se ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , void  p v o i d ) 90 { 91 a p p c t x  p c t x =( a p p c t x  ) p v o i d ; 92 b c p a r a m e t e r s  pbc=( b c p a r a m e t e r s  ) ( pctx ->pbc ) ; 93 a s s e r t ( pvoid ) ; 94 a s s e r t ( pctx ) ; 95 a s s e r t ( pbc ) ; 96 97 /  Ground r e g i o n a t l o w e r j end . S e l e c t t h i s o v e r f a r - f i e l d .  / 98 i f ( ! pbc->NoGround && j <=pctx -> j l o && j >=0) 99 return pbc->ground . s e ; 100 /  Within a f a r - f i e l d r e g i o n  / 101 P e t s c R e a l r i =1 , r j =1 , rk =1; 102 P e t s c R e a l s e l o=pbc-> f a r f i e l d . s e l o ; 103 i f ( i <=pctx -> i l o && i >=0) 104 r i =(( P e t s c R e a l ) ( i - 0) ) / ( ( P e t s c R e a l ) ( pctx -> i l o - 0) ) ; 105 e l s e i f ( i >=pctx -> i h i && i <=pctx ->params->mesh . Nx- 1) 106 r i =(( P e t s c R e a l ) ( i -pctx ->params->mesh . Nx- 1) ) / ( ( P e t s c R e a l ) ( pctx -> i h i -pctx ->params-> mesh . Nx- 1) ) ; 107 i f ( j <=pctx -> j l o && j >=0) 108 r j =(( P e t s c R e a l ) ( j - 0) ) / ( ( P e t s c R e a l ) ( pctx -> j l o - 0) ) ; 109 e l s e i f ( j >=pctx -> j h i && j <=pctx ->params->mesh . Ny- 1) 110 r j =(( P e t s c R e a l ) ( j -pctx ->params->mesh . Ny- 1) ) / ( ( P e t s c R e a l ) ( pctx -> j h i -pctx ->params-> mesh . Ny- 1) ) ; 111 i f ( ! TwoDimensional ( p c t x ) ) 112 { 113 i f ( k<=pctx -> k l o && k >=0) 114 rk =(( P e t s c R e a l ) ( k - 0) ) / ( ( P e t s c R e a l ) ( pctx -> k l o - 0) ) ; 115 e l s e i f ( k>=pctx -> k h i && k<=pctx ->params->mesh . Nz - 1) 116 rk =(( P e t s c R e a l ) ( k-pctx ->params->mesh . Nz - 1) ) / ( ( P e t s c R e a l ) ( pctx ->k h i -pctx ->params->mesh . Nz - 1) ) ; 117 } 118 return (1 - r i  r j  rk )  pbc-> f a r f i e l d . s e h i+r i  r j  rk  pbc-> f a r f i e l d . s e l o ; 119 } 120 121 P e t s c E r r o r C o d e I n i t i a l i z e B C ( void  vpctx ) 122 { 123 a p p c t x  p c t x =( a p p c t x  ) vpctx ; 124 PetscInt d ; 125 P e t s c R e a l c , rho , gamma ; 126 PetscReal s c , rho e ; 127 m e a n u n i f o r m p a r a m e t e r s  pmean=( m e a n u n i f o r m p a r a m e t e r s  ) pctx ->pmean ; 128 b c p a r a m e t e r s  pbc=( b c p a r a m e t e r s  ) pctx ->pbc ; 129 130 a s s e r t ( pctx ) ; 131 a s s e r t ( pmean ) ; 132 a s s e r t ( pbc ) ;

79

3.3. BC.H
133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171

APPENDIX 3. SOURCE CODE

c=GetSpeedOfSound ( pctx -> p r o p e r t i e s ) ; rho=GetDensity ( pctx -> p r o p e r t i e s ) ; gamma=G e t R a t i o O f S p e c i f i c H e a t s ( pctx -> p r o p e r t i e s ) ; pctx -> c a l c k a p p a e=ABC kappae ; pctx -> c a l c b e=ABC be ; pctx -> c a l c s e=ABC se ; P e t s c P r i n t f (PETSC COMM WORLD, " I n i t i a l i z i n g boundary r e g i o n : \ n" ) ;

/  Pre-computed ground p a r a m e t e r s  / /  Assuming c i r c u l a r , c y l i n d r i c a l p o r e s  / s c =(4/3)  pbc->ground . q  pbc->ground . q/ pbc->ground . Omega ; r h o e=s c  rho / pbc->ground . Omega ; pbc->ground . kappae=rho  c  c /gamma/ pbc->ground . Omega ; pbc->ground . be =1.0/ r h o e ; pbc->ground . s e=pbc->ground . sigma / r h o e ; i f ( pbc->NoGround ) { P e t s c P r i n t f (PETSC COMM WORLD, "No ground s u r f a c e . \ n" ) ; } e l s e i f ( pbc->R e f l e c t i v e G r o u n d ) { P e t s c P r i n t f (PETSC COMM WORLD, " Using r e f l e c t i v e ground s u r f a c e . \ n" ) ; } else { P e t s c P r i n t f (PETSC COMM WORLD, " ground : s c=%g r h o e=%g . \ n" , s c , r h o e ) ; P e t s c P r i n t f (PETSC COMM WORLD, " ground : ka pp a e=%g b e=%g s e=%g . \ n" , pbc->ground . kappae , pbc->ground . be , pbc->ground . s e ) ; } /  Pre-computed a b s o r b i n g bc r e g i o n p a r a m e t e r s  / r h o e=pbc-> f a r f i e l d . s c  rho / pbc-> f a r f i e l d . Omega ; pbc-> f a r f i e l d . kappae=rho  c  c / pbc-> f a r f i e l d . gamma/ pbc-> f a r f i e l d . Omega ; pbc-> f a r f i e l d . be =1.0/ r h o e ; pbc-> f a r f i e l d . s e l o=pbc-> f a r f i e l d . s i g m a l o / r h o e ; pbc-> f a r f i e l d . s e h i=pbc-> f a r f i e l d . s i g m a h i / r h o e ; P e t s c P r i n t f (PETSC COMM WORLD, " f a r - f i e l d : s c=%g r h o e=%g . \ n" , pbc-> f a r f i e l d . sc , r h o e ) ; P e t s c P r i n t f (PETSC COMM WORLD, " f a r - f i e l d : ka p p a e=%g b e=%g s e=%g t o %g . \ n" , pbc-> f a r f i e l d . kappae , pbc-> f a r f i e l d . be , pbc-> f a r f i e l d . s e l o , pbc-> f a r f i e l d . s e h i ) ;

172 173 return 0 ; 174 }

3.3
1 #i f n d e f 2 #define

bc.h
BC H BC H

80

APPENDIX 3. SOURCE CODE
3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include < p e t s c . h> #include <p e t s c b a g . h> /  ! \ f i l e bc . h \ b r i e f Boundary c o n d i t i o n s p a r a m e t e r s . This h e a d e r f i l e /

3.3. BC.H

d e f i n e s t h e p a r a m e t e r s and f u n c t i o n s f o r a p p l y i n g boundary c o n d i t i o n s .

/  ! \ b r i e f ABC p a r a m e t e r s A b s o r b i n g boundary c o n d i t i o n (ABC) r e g i o n p a r a m e t e r s .  / typedef struct { PetscReal sc ; / !< f a r f i e l d s t r u c t u r e c o n s t a n t / P e t s c R e a l Omega ; / !< f a r f i e l d p o r o s i t y / P e t s c R e a l gamma ; / !< f a r f i e l d r a t i o o f s p e c i f i c h e a t s / P e t s c R e a l s i g m a l o ; / !< f a r f i e l d f l o w r e s i s t i v i t y l o w e r l i m i t / P e t s c R e a l s i g m a h i ; / !< f a r f i e l d f l o w r e s i s t i v i t y h i g h e r l i m i t / P e t s c R e a l kappae ; /  ! < \ f $ \ f r a c {\ rho c ^2 }{\ gamma\ Omega }\ f $  / P e t s c R e a l be ; /  ! < \ f $ \ f r a c { 1 }{\ r h o e }\ f $  / PetscReal s e l o ; /  ! < \ f $ \ f r a c {\ s i g m a { low }}{\ r h o e }\ f $  / PetscReal s e h i ; /  ! < \ f $ \ f r a c {\ s i g m a { h i g h }}{\ r h o e }\ f $  / } absorbing bc parameters ; /  ! \ b r i e f Ground p a r a m e t e r s Porous ground r e g i o n ( s i m i l a r t o ABC) p a r a m e t e r s .  / typedef struct { P e t s c R e a l sigma ; /  ! < ground f l o w r e s i s t i v i t y  / P e t s c R e a l Omega ; /  ! < ground p o r o s i t y  / PetscReal q ; /  ! < ground t o r t u o s i t y  / P e t s c R e a l kappae ; /  ! < \ f $ \ f r a c {\ rho c ^2 }{\ gamma\ Omega }\ f $  / P e t s c R e a l be ; /  ! < \ f $ \ f r a c { 1 }{\ r h o e }\ f $  / PetscReal se ; /  ! < \ f $ \ f r a c {\ sigma }{\ r h o e }\ f $  / } porous ground bc parameters ; /  ! \ b r i e f A l l BC p a r a m e t e r s C o l l e c t i o n o f BC p a r a m e t e r s .  / typedef struct { absorbing bc parameters f a r f i e l d ; p o r o u s g r o u n d b c p a r a m e t e r s ground ; PetscTru th R e f l e c t i v e G r o u n d ; PetscTru th NoGround ; } bc parameters ;

/ !< / !< / !< / !<

Far f i e l d BC p a r a m e t e r s  / Ground BC p a r a m e t e r s  / R e f l e c t i v e ground f l a g  / No ground f l a g  /

/  ! Save BC parameter v a l u e s t o f i l e .  / void SaveBCBag ( PetscBag bag ) ; /  ! R e g i s t e r BC parameters , and o p t i o n a l l y l o a d v a l u e s from f i l e .  /

81

3.4. IO.H
53 54 55 56 57 58

APPENDIX 3. SOURCE CODE

P e t s c E r r o r C o d e RegisterBCBag ( PetscBag  bag , void  params , P e t s c T r u t h LoadFromFile ) ; /  ! I n i t i a l i z e BC parameter v a l u e s .  / P e t s c E r r o r C o d e I n i t i a l i z e B C ( void  vpctx ) ; #endif

3.4
1 2 3 4 5 6 7 8 9 #i f n d e f #define

io.h
IO H IO H

#include < p e t s c . h> / ! \ f i l e i o . h \ b r i e f I n p u t and o u t p u t

D e c l a r e s f u n c t i o n s f o r l o a d i n g and s a v i n g t h e s o l u t i o n , as w e l l as s a v i n g s l i c e s o f t h e domain . 10  / 11 12 /  ! Load t h e s o l u t i o n from f i l e s s o l u t i o n . [ dat , i n f o ]  / 13 P e t s c E r r o r C o d e L o a d S o l u t i o n ( Vec s o l u t i o n , 14 app ctx  pctx ) ; 15 16 /  ! Save t h e s o l u t i o n t o f i l e s s o l u t i o n . [ dat , i n f o ]  / 17 P e t s c E r r o r C o d e S a v e S o l u t i o n ( Vec s o l u t i o n , 18 app ctx  pctx ) ; 19 20 /  ! Save a l l p a r a m e t e r s s t o r e d i n PetscBag  / 21 P e t s c E r r o r C o d e Save Parameters ( a p p c t x  p c t x ) ; 22 23 /  ! Save a s n a p s h o t o f t h e c u r r e n t s o l u t i o n t o a VTK f i l e  / 24 P e t s c E r r o r C o d e Save Checkp oint ( Vec s o l u t i o n , 25 app ctx  pctx ) ; 26 27 /  ! Save t h e s o l u t i o n t o p . v t k and w . v t k  / 28 P e t s c E r r o r C o d e SaveVTK ( Vec s o l u t i o n , 29 app ctx  pctx ) ; 30 31 /  ! Save t h e ground p l a n e s l i c e o f sound p r e s s u r e l e v e l  / 32 P e t s c E r r o r C o d e SaveGroundVTK ( a p p c t x  p c t x ) ; 33 34 /  ! Report t h e t o t a l sound power l e v e l  / 35 P e t s c E r r o r C o d e ReportSoundPowerLevel ( a p p c t x  p c t x ) ; 36 37 /  ! Save t h e s o l u t i o n a t t h i s i t e r a t i o n  / 38 P e t s c E r r o r C o d e SaveVTKByIter ( P e t s c I n t i t e r , 39 PetscReal t ,

82

APPENDIX 3. SOURCE CODE
40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 Vec s o l u t i o n , app ctx  pctx ) ; /  ! Save t h e f u l l s o l u t i o n i n one f i l e a t t h i s i t e r a t i o n  / P e t s c E r r o r C o d e SaveFullVTKByIter ( P e t s c I n t i t e r , PetscReal t , Vec s o l u t i o n , app ctx  pctx ) ; typedef enum { X SLICE=0 , /  ! < A s l i c e p e r p e n d i c u l a r t o x d i r e c t i o n  / Y SLICE=1 , /  ! < A s l i c e p e r p e n d i c u l a r t o y d i r e c t i o n  / Z SLICE=2 / !< A s l i c e p e r p e n d i c u l a r t o z d i r e c t i o n / } slice plane ; /  ! Save a s l i c e o f t h e s o l u t i o n p e r p e n d i c u l a r t o t h e x , y , or z d i r e c t i o n , u s i n g a s p e c i f i c f i l e name .  / P e t s c E r r o r C o d e SaveSliceWithName ( P e t s c I n t s l i c e , s l i c e p l a n e plane , P e t s c I n t d0 , P e t s c I n t dN , Vec s o l u t i o n , a p p c t x  pctx , char  FileName ) ; /  ! Save a g e n e r i c s l i c e o f t h e s o l u t i o n  / PetscErrorCode S a v e S l i c e ( PetscInt s l i c e , s l i c e p l a n e plane , Vec s o l u t i o n , app ctx  pctx ) ; / ! C r e a t e a s c a t t e r / g a t h e r c o n t e x t f o r t h e r e q u e s t e d s o l u t i o n s l i c e / P e t s c E r r o r C o d e C r e a t e S l i c e S c a t t e r ( a p p c t x  pctx , Vec v e c f r o m , PetscInt ilo , PetscInt ihi , PetscInt jlo , PetscInt jhi , PetscInt klo , P e t s c I n t khi , P e t s c I n t dlo , P e t s c I n t dhi , DA  d a t o , Vec  v e c t o , VecScatter  pscatter ) ; void ComputeFFT ( P e t s c I n t NHistory , PetscReal  tHistory , PetscReal  vHistory , P e t s c I n t  NFrequency , P e t s c R e a l  f ,

3.4. IO.H

83

3.5. IO.C
90 P e t s c R e a l  vmag , 91 P e t s c R e a l  vphase , 92 P e t s c I n t  NBands , 93 P e t s c R e a l  fband , 94 P e t s c R e a l  vband ) ; 95 #endif

APPENDIX 3. SOURCE CODE

3.5
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40

io.c

#include < s t d l i b . h> #include < a s s e r t . h> #include < p e t s c . h> #include <ode . h> #include < f l o a t . h> #include <math . h> #include " i o . h" #include " f f t w 3 . h" P e t s c E r r o r C o d e L o a d S o l u t i o n ( Vec s o l u t i o n , app ctx  pctx ) { PetscViewer viewer ; P e t s c P r i n t f (PETSC COMM WORLD, " Loading s o l u t i o n . \ n" ) ; PetscViewerBinaryOpen (PETSC COMM WORLD, " s o l u t i o n . dat " ,FILE MODE READ,& v i e w e r ) ; VecLoadIntoVector ( v i e w e r , s o l u t i o n ) ; PetscViewerDestroy ( viewer ) ; return 0 ; }

P e t s c E r r o r C o d e S a v e S o l u t i o n ( Vec s o l u t i o n , app ctx  pctx ) { PetscViewer viewer ; P e t s c P r i n t f (PETSC COMM WORLD, " S a v i n g s o l u t i o n . \ n" ) ; PetscViewerBinaryOpen (PETSC COMM WORLD, " s o l u t i o n . dat " ,FILE MODE WRITE,& v i e w e r ) ; VecView ( s o l u t i o n , v i e w e r ) ; PetscViewerDestroy ( viewer ) ; return 0 ; } P e t s c E r r o r C o d e Save Parameters ( a p p c t x  p c t x ) { a s s e r t ( pctx ) ; P e t s c P r i n t f (PETSC COMM WORLD, " S a v i n g p a r a m e t e r s . \ n" ) ;

84

APPENDIX 3. SOURCE CODE
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 SaveParameterBag ( pctx ->bag ) ; i f ( pctx ->p s o u r c e ) SaveSourceBag ( pctx ->s o u r c e b a g ) ; i f ( pctx -> p r o p e r t i e s ) S a v e F l u i d P r o p e r t i e s B a g ( pctx ->pbag ) ; i f ( pctx ->pmean ) SaveMeanBag ( pctx ->meanbag ) ; i f ( pctx ->pbc ) SaveBCBag ( pctx ->bcbag ) ; return 0 ; } P e t s c E r r o r C o d e Save Checkpoint ( Vec s o l u t i o n , app ctx  pctx ) { SaveSolution ( s o l u t i o n , pctx ) ; Sa veParameters ( p c t x ) ; return 0 ; }

3.5. IO.C

P e t s c E r r o r C o d e SaveVTK ( Vec s o l u t i o n , app ctx  pctx ) { i f ( TwoDimensional ( p c t x ) ) { PetscErrorCode i e r r ; i e r r=SaveSliceWithName ( 0 , Z SLICE , 0 , 0 , s o l u t i o n , pctx , "p . vtk " ) ; CHKERRQ( i e r r ) ; i e r r=SaveSliceWithName ( 0 , Z SLICE , 1 , 2 , s o l u t i o n , pctx , "w . vtk " ) ; CHKERRQ( i e r r ) ; return 0 ; } PetscViewer viewer ; P e t s c I n t i , j , k , d , sx , sy , sz , mx, my, mz ; DAPeriodicType wrap ; DAStencilType s t e n c i l t y p e ; P e t s c I n t s t e n c i l w i d t h ,M, N, P ,m, n , p ; P e t s c S c a l a r  s ,    pp ,     pw ; DA da1 , da3 ; Vec vp , vw ; p a r a m e t e r s  params=pctx ->params ; a s s e r t ( pctx ) ; a s s e r t ( params ) ; /  Get t h e d i m e n s i o n s o f master DA t o u s e f o r o t h e r DAs  / DAGetInfo ( pctx ->da , PETSC IGNORE, & M,&N,&P , &m,&n,&p , PETSC IGNORE, &s t e n c i l w i d t h , &wrap ,& s t e n c i l t y p e ) ; /  Mesh d i s t r i b u t e d a r r a y f o r d o f=1  / DACreate3d (PETSC COMM WORLD, wrap , s t e n c i l t y p e ,

85

3.5. IO.C
91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 M, N, P , m, n , p , 1, stencilwidth , PETSC NULL, PETSC NULL, PETSC NULL, &da1 ) ; DASetUniformCoordinates ( da1 , params->mesh . xmin , params->mesh . xmax , params->mesh . ymin , params->mesh . ymax , params->mesh . zmin , params->mesh . zmax ) ; /  Mesh d i s t r i b u t e d a r r a y f o r d o f=3  / DACreate3d (PETSC COMM WORLD, wrap , s t e n c i l t y p e , M, N, P , m, n , p , 3, stencilwidth , PETSC NULL, PETSC NULL, PETSC NULL, &da3 ) ; DASetUniformCoordinates ( da3 , params->mesh . xmin , params->mesh . xmax , params->mesh . ymin , params->mesh . ymax , params->mesh . zmin , params->mesh . zmax ) ; DACreateGlobalVector ( da1 ,&vp ) ; DACreateGlobalVector ( da3 ,&vw) ;

APPENDIX 3. SOURCE CODE

/  Get l o c a l g r i d b o u n d a r i e s , which a r e i n d e p e n d e n t o f d o f  / DAGetCorners ( pctx ->da ,& sx ,& sy ,& sz ,&mx,&my,&mz) ; DAVecGetArrayDOF ( pctx ->da , s o l u t i o n ,& s ) ; DAVecGetArrayDOF ( da3 , vw,&pw) ; DAVecGetArray ( da1 , vp ,&pp ) ; f o r ( i=sx ; i <sx+mx ; i ++) f o r ( j=sy ; j <sy+my ; j ++) f o r ( k=s z ; k< s z+mz ; k++) { pp [ k ] [ j ] [ i ]= s [ k ] [ j ] [ i ] [ 0 ] ; f o r ( d=0;d < 3;d++) { pw [ k ] [ j ] [ i ] [ d]= s [ k ] [ j ] [ i ] [ 1 + d ] ; } } DAVecRestoreArray ( da1 , vp ,&pp ) ; DAVecRestoreArrayDOF ( da3 , vw,&pw) ;

86

APPENDIX 3. SOURCE CODE
141 DAVecRestoreArrayDOF ( pctx ->da , s o l u t i o n ,& s ) ; 142 143 /  Save p as VTK f i l e  / 144 P e t s c V i e w e r C r e a t e (PETSC COMM WORLD,& v i e w e r ) ; 145 PetscViewerSe tT ype ( v i e w e r , PETSC VIEWER ASCII) ; 146 P e t s c V i e w e r F i l e S e t N a m e ( v i e w e r , "p . vtk " ) ; 147 PetscViewerSetFormat ( v i e w e r , PETSC VIEWER ASCII VTK) ; 148 DAView( da1 , v i e w e r ) ; 149 VecView ( vp , v i e w e r ) ; 150 PetscViewerDestroy ( viewer ) ; 151 152 /  Save w as VTK f i l e  / 153 P e t s c V i e w e r C r e a t e (PETSC COMM WORLD,& v i e w e r ) ; 154 PetscViewerSe tT ype ( v i e w e r , PETSC VIEWER ASCII) ; 155 P e t s c V i e w e r F i l e S e t N a m e ( v i e w e r , "w . vtk " ) ; 156 PetscViewerSetFormat ( v i e w e r , PETSC VIEWER ASCII VTK) ; 157 DAView( da3 , v i e w e r ) ; 158 VecView (vw , v i e w e r ) ; 159 PetscViewerDestroy ( viewer ) ; 160 161 // DARestoreLocalVector ( da1 ,& vp ) ; 162 // DARestoreLocalVector ( da3 ,&vw ) ; 163 VecDestroy ( vp ) ; 164 VecDestroy (vw) ; 165 166 DADestroy ( da1 ) ; 167 DADestroy ( da3 ) ; 168 169 return 0 ; 170 } 171 172 P e t s c E r r o r C o d e SaveGroundVTK ( a p p c t x  p c t x ) 173 { 174 const P e t s c R e a l p r e f =20E- 6; // Pa 175 const P e t s c R e a l I r e f =1E- 12; // W/m^2 176 const P e t s c R e a l r m s s m a l l e s t = - 10000; 177 const P e t s c R e a l I s m a l l e s t = - 10000; 178 179 PetscViewer viewer ; 180 P e t s c R e a l max , min ; 181 P e t s c I n t imax , imin ; 182 a s s e r t ( pctx ) ; 183 184 b c p a r a m e t e r s  bc=( b c p a r a m e t e r s  ) pctx ->pbc ; 185 a s s e r t ( bc ) ; 186 187 i f ( pctx ->MaxAbsPressure ) 188 { 189 P e t s c V i e w e r C r e a t e (PETSC COMM WORLD,& v i e w e r ) ; 190 PetscVi ew erSetType ( v i e w e r , PETSC VIEWER ASCII) ;

3.5. IO.C

87

3.5. IO.C
191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 P e t s c V i e w e r F i l e S e t N a m e ( v i e w e r , "pmaxabs . vtk " ) ; PetscViewerSet Format ( v i e w e r , PETSC VIEWER ASCII VTK) ; DAView( pctx ->dagp , v i e w e r ) ; VecView ( pctx ->pmaxabs , v i e w e r ) ; PetscViewerDestroy ( viewer ) ;

APPENDIX 3. SOURCE CODE

} /  Save ground - l e v e l sound p r e s s u r e l e v e l (SPL) as VTK f i l e  / /  We need t o c o m p l e t e t h e RMS a v e r a g e by d i v i d i n g by t h e i n t e r g r a t i o n time i n t e r v a l T  / i f ( pctx -> j l o ==0 && ! TwoDimensional ( p c t x ) && ! bc->R e f l e c t i v e G r o u n d ) { P e t s c P r i n t f (PETSC COMM WORLD, "Ground l a y e r i s a t bottom o f mesh . Not s a v i n g s p l . vtk ! \ n" ) ; return 1 ; } i f ( pctx -> t l a s t -pctx -> t s t a r t <=0) { P e t s c P r i n t f (PETSC COMM WORLD, "RMS a v e r a g i n g i n c o m p l e t e ( time i n t e r v a l i s z e r o ) . \ n" ); return 1 ; } if { P e t s c P r i n t f (PETSC COMM WORLD, "RMS a v e r a g i n g was not done . R e s t a r t with t max>=t 0+ T. \ n" ) ; return 1 ; } /  Note : Time a v e r a g e n e e d s t o be d i v i d e d by T t o c o m p l e t e c a l c u l a t i o n  / P e t s c S c a l a r invT =1.0/( pctx -> t l a s t -pctx -> t s t a r t ) ; V e c S c a l e ( pctx ->prms , invT ) ; V e c S c a l e ( pctx ->I , invT ) ; /  p c t x ->prms now c o n t a i n s RMS o f p r e s s u r e  / /  C a l c u l a t e SPL u s i n g 10  l o g 1 0 ( prms ^2/ p r e f ^2)  / /  Avoid - I n f v a l u e s when c a l c u l a t i n g l o g ( 0 ) which can o c c u r i f no wave r e a c h e s ground plane d u r i n g RMS a v e r a g e  / P e t s c S c a l a r v ; P e t s c S c a l a r p s c a l e = 1.0/( p r e f  p r e f ) ; PetscInt i , n ; V e c G e t L o c a l S i z e ( pctx ->prms ,&n ) ; VecGetArray ( pctx ->prms ,&v ) ; f o r ( i =0; i <n ; i ++) { ( ! pctx -> I n t e g r a t i o n S t a r t e d && pctx -> j l o > 0)

88

APPENDIX 3. SOURCE CODE
237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 v [ i ] = p s c a l e ; if (v [ i ]!=0.0) v [ i ] = 10  l o g 1 0 ( v [ i ] ) ; else v [ i ] = rms smallest ; } Ve cRe sto re Arra y ( pctx ->prms ,&v ) ;

3.5. IO.C

P e t s c P r i n t f (PETSC COMM WORLD, "Ground s u r f a c e a v e r a g e d o v e r i n t e r v a l %g s \ n" , pctx -> t l a s t -pctx -> t s t a r t ) ; VecMin ( pctx ->prms ,& imin ,&min ) ; VecMax ( pctx ->prms ,&imax ,&max) ; P e t s c P r i n t f (PETSC COMM WORLD, " Max sound p r e s s u r e l e v e l %g dB \ n" ,max) ; P e t s c P r i n t f (PETSC COMM WORLD, " Min sound p r e s s u r e l e v e l %g dB \ n" , min ) ; /  p c t x ->prms now c o n t a i n s SPL  / P e t s c V i e w e r C r e a t e (PETSC COMM WORLD,& v i e w e r ) ; PetscViewerSe tT ype ( v i e w e r , PETSC VIEWER ASCII) ; P e t s c V i e w e r F i l e S e t N a m e ( v i e w e r , " s p l . vtk " ) ; PetscViewerSetFormat ( v i e w e r , PETSC VIEWER ASCII VTK) ; DAView( pctx ->dagp , v i e w e r ) ; VecView ( pctx ->prms , v i e w e r ) ; PetscViewerDestroy ( viewer ) ; i f ( pctx ->DoProbe ) { P e t s c S c a l a r  prms ; P e t s c I n t sx , sy , sz , mx, my, mz ; /  Get l o c a l g r i d b o u n d a r i e s , which a r e i n d e p e n d e n t o f d o f  / DAGetCorners ( pctx ->dagp ,& sx ,& sy ,& sz ,&mx,&my,&mz) ; DAVecGetArrayDOF ( pctx ->dagp , pctx ->prms ,&prms ) ; PetscReal probe value =0.0; PetscInt i , j ; f o r ( j =0; j < 2; j ++) f o r ( i =0; i < 2; i ++) { i f ( ( pctx -> p r o b e l i+i >=sx && pctx -> p r o b e l i+i <sx+mx) && ( pctx -> p r o b e l j+j >=sy && pctx -> p r o b e l j+j <sy+my) ) { p r o b e v a l u e += pctx ->probe w [ i ] [ j ]  prms [ pctx -> p r o b e l j+j ] [ pctx -> p r o b e l i+i ] [ 0 ] ; } } DAVecRestoreArrayDOF ( pctx ->dagp , pctx ->prms ,& prms ) ; double v a l o u t=p r o b e v a l u e , v a l i n =0; MPI Reduce(& v a l o u t ,& v a l i n , 1 , MPI DOUBLE, MPI SUM, 0 ,PETSC COMM WORLD) ;

89

3.5. IO.C
286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335

APPENDIX 3. SOURCE CODE

P e t s c R e a l probe SPL=v a l i n ; P e t s c P r i n t f (PETSC COMM WORLD, "SPL @ probe : %g dB\ n" , probe SPL ) ; P e t s c R e a l p r o b e r m s=p r e f  pow ( 1 0 . 0 , 0 . 0 5  probe SPL ) ; P e t s c P r i n t f (PETSC COMM WORLD, "RMS o f p r e s s u r e @ probe : %g Pa \ n" , p r o b e r m s ) ; i n t rank ; MPI Comm rank (PETSC COMM WORLD,& rank ) ; /  Compute FFT o f p H i s t o r y  / i f ( ! rank ) { a s s e r t ( pctx -> t H i s t o r y ) ; a s s e r t ( pctx ->p H i s t o r y ) ; PetscInt i ; P e t s c I n t N, NBand ; P e t s c R e a l  f=NULL,  pmag=NULL,  pphase=NULL,  fband=NULL,  pband=NULL; FILE  f p ; f p=f o p e n ( "p . dat " , "w" ) ; f o r ( i =0; i <pctx ->NHistory ; i ++) f p r i n t f ( fp , "%g %g \ n" , pctx -> t H i s t o r y [ i ] , pctx ->p H i s t o r y [ i ] ) ; f c l o s e ( fp ) ; ComputeFFT ( pctx ->NHistory , pctx -> t H i s t o r y , pctx ->p H i s t o r y , &N,& f ,&pmag,& pphase , &NBand,& fband ,&pband ) ; assert ( f ) ; a s s e r t ( pmag ) ; a s s e r t ( pphase ) ; f p=f o p e n ( " s p l . dat " , "w" ) ; i f ( fp ) { f p r i n t f ( fp , "# f ( Hz ) SPL (dBA) magnitude phase \ n" ) ; f o r ( i =1; i <N; i ++) { P e t s c R e a l SPL=(pmag [ i ]==0? - 1000:20.0  l o g 1 0 ( pmag [ i ] / p r e f )+GetAWeighting ( f [ i ] ) ) ; f p r i n t f ( fp , "%g %g %g %g \ n" , f [ i ] , SPL , pmag [ i ] , pphase [ i ] ) ; } } else { P e t s c S y n c h r o n i z e d P r i n t f (PETSC COMM WORLD, " Unable t o open s p l . dat \ n" ) ; } f c l o s e ( fp ) ;

f p=f o p e n ( " s p l o c t a v e . dat " , "w" ) ; i f ( fp ) {

90

APPENDIX 3. SOURCE CODE
336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 f p r i n t f ( fp , "# f ( Hz ) SPL (dBA) \ n" ) ; f o r ( i =1; i <NBand ; i ++) {

3.5. IO.C

P e t s c R e a l SPL=(pband [ i ]==0? - 1000:20.0  l o g 1 0 ( pband [ i ] / p r e f )+GetAWeighting ( fband [ i ] ) ); f p r i n t f ( fp , "%g %g \ n" , fband [ i ] , SPL) ; } } else { P e t s c S y n c h r o n i z e d P r i n t f (PETSC COMM WORLD, " Unable t o open s p l o c a t v e . dat \ n" ) ; } f c l o s e ( fp ) ; PetscFree ( f ) ; P e t s c F r e e ( pmag ) ; P e t s c F r e e ( pphase ) ; P e t s c S y n c h r o n i z e d F l u s h (PETSC COMM WORLD) ; } else { P e t s c S y n c h r o n i z e d F l u s h (PETSC COMM WORLD) ; } } /  R e c y c l e prms f o r c a l c u l a t i n g sound i n t e n s i t y l e v e l /

/  C a l c u l a t e SIL u s i n g 10  l o g 1 0 ( I / I r e f )  / /  Avoid - I n f v a l u e s when c a l c u l a t i n g l o g ( 0 ) which can o c c u r i f no wave r e a c h e s ground plane d u r i n g RMS a v e r a g e  / PetscScalar I ; P e t s c S c a l a r I s c a l e =1.0/ I r e f ; P e t s c I n t nI ; V e c G e t L o c a l S i z e ( pctx ->prms ,&n ) ; V e c G e t L o c a l S i z e ( pctx ->I ,& n I ) ; a s s e r t ( 3  n==nI ) ; VecGetArray ( pctx ->prms ,&v ) ; VecGetArray ( pctx ->I ,& I ) ; f o r ( i =0; i <n ; i ++) { v [ i ] = I s c a l e  s q r t ( I [ i  3+0]  I [ i  3+0]+ I [ i  3+1]  I [ i  3+1]+ I [ i  3+2]  I [ i  3+2]) ; if (v [ i ]!=0.0) v [ i ] = 10  l o g 1 0 ( v [ i ] ) ; else

91

3.5. IO.C
384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 v [ i ] = rms smallest ; } Ve c Resto reArra y ( pctx ->I ,& I ) ; Ve c Resto reArra y ( pctx ->prms ,&v ) ; /  p c t x ->prms now c o n t a i n s SIL  /

APPENDIX 3. SOURCE CODE

P e t s c P r i n t f (PETSC COMM WORLD, "Ground s u r f a c e a v e r a g e d o v e r i n t e r v a l %g s \ n" , pctx -> t l a s t -pctx -> t s t a r t ) ; VecMin ( pctx ->prms ,& imin ,&min ) ; VecMax ( pctx ->prms ,&imax ,&max) ; P e t s c P r i n t f (PETSC COMM WORLD, " Max sound i n t e n s i t y l e v e l %g dB\ n" ,max) ; P e t s c P r i n t f (PETSC COMM WORLD, " Min sound i n t e n s i t y l e v e l %g dB \ n" , min ) ; i f ( pctx ->DoProbe ) { P e t s c S c a l a r  prms ; P e t s c I n t sx , sy , sz , mx, my, mz ; /  Get l o c a l g r i d b o u n d a r i e s , which a r e i n d e p e n d e n t o f d o f  / DAGetCorners ( pctx ->dagp ,& sx ,& sy ,& sz ,&mx,&my,&mz) ; DAVecGetArrayDOF ( pctx ->dagp , pctx ->prms ,&prms ) ; PetscReal probe value =0.0; PetscInt i , j ; f o r ( j =0; j < 2; j ++) f o r ( i =0; i < 2; i ++) { i f ( ( pctx -> p r o b e l i+i >=sx && pctx -> p r o b e l i+i <sx+mx) && ( pctx -> p r o b e l j+j >=sy && pctx -> p r o b e l j+j <sy+my) ) { p r o b e v a l u e += pctx ->probe w [ i ] [ j ]  prms [ pctx -> p r o b e l j+j ] [ pctx -> p r o b e l i+i ] [ 0 ] ; } } DAVecRestoreArrayDOF ( pctx ->dagp , pctx ->prms ,& prms ) ; double v a l o u t=p r o b e v a l u e , v a l i n =0; MPI Reduce(& v a l o u t ,& v a l i n , 1 , MPI DOUBLE, MPI SUM, 0 ,PETSC COMM WORLD) ; P e t s c R e a l p r o b e S I L=v a l i n ; P e t s c P r i n t f (PETSC COMM WORLD, " SIL @ probe : %g dB\ n" , p r o b e S I L ) ; } P e t s c V i e w e r C r e a t e (PETSC COMM WORLD,& v i e w e r ) ; PetscVi ewerSe tT ype ( v i e w e r , PETSC VIEWER ASCII) ; P e t s c V i e w e r F i l e S e t N a m e ( v i e w e r , " s i l . vtk " ) ; PetscViewerSetFormat ( v i e w e r , PETSC VIEWER ASCII VTK) ; DAView( pctx ->dagp , v i e w e r ) ; VecView ( pctx ->prms , v i e w e r ) ; PetscViewerDestroy ( viewer ) ;

92

APPENDIX 3. SOURCE CODE

3.5. IO.C

433 434 435 return 0 ; 436 } 437 438 P e t s c E r r o r C o d e ReportSoundPowerLevel ( a p p c t x  p c t x ) 439 { 440 const P e t s c R e a l Wref=1E- 12; // W 441 442 i f ( pctx -> t l a s t -pctx -> t s t a r t <=0) 443 { 444 P e t s c P r i n t f (PETSC COMM WORLD, "Power i n t e g r a t i o n i n c o m p l e t e ( time i n t e r v a l i s z e r o ) . \ n" ) ; 445 return 1 ; 446 } 447 448 /  Note : Time a v e r a g e n e e d s t o be d i v i d e d by T t o c o m p l e t e c a l c u l a t i o n  / 449 P e t s c S c a l a r invT =1.0/( pctx -> t l a s t -pctx -> t s t a r t ) ; 450 451 pctx -> SWL = invT ; 452 453 P e t s c P r i n t f (PETSC COMM WORLD, "Power : %g W. \ n" , pctx -> SWL) ; 454 455 pctx -> SWL = 10  l o g 1 0 ( pctx -> SWL/ Wref ) ; 456 457 P e t s c P r i n t f (PETSC COMM WORLD, " Sound power l e v e l : %g dB SWL. \ n" , pctx -> SWL) ; 458 P e t s c P r i n t f (PETSC COMM WORLD, " I n t e g r a t e d from %g t o %g s . \ n" , pctx -> t s t a r t , pctx -> t l a s t ) ; 459 460 i n t rank =0; MPI Comm rank (PETSC COMM WORLD,& rank ) ; 461 462 463 /  Compute FFT o f p H i s t o r y  / 464 i f ( ! rank ) 465 { 466 a s s e r t ( pctx -> t H i s t o r y ) ; 467 a s s e r t ( pctx ->Po w e r H i s t o r y ) ; 468 469 PetscInt i ; 470 P e t s c I n t N, NBand ; 471 P e t s c R e a l  f=NULL,  Wmag=NULL,  Wphase=NULL,  fband=NULL,  Wband=NULL; 472 FILE  f p ; 473 474 f p=f o p e n ( " power . dat " , "w" ) ; 475 f o r ( i =0; i <pctx ->NHistory ; i ++) 476 f p r i n t f ( fp , "%g %g \ n" , pctx -> t H i s t o r y [ i ] , pctx ->P o w e r H i s t o r y [ i ] ) ; 477 f c l o s e ( fp ) ; 478 479 ComputeFFT ( pctx ->NHistory , pctx -> t H i s t o r y , pctx ->PowerHistory , 480 &N,& f ,&Wmag,&Wphase ,

93

3.5. IO.C
481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 &NBand,& fband ,&Wband) ; assert ( f ) ; a s s e r t (Wmag) ; a s s e r t ( Wphase ) ; f p=f o p e n ( " s w l . dat " , "w" ) ; i f ( fp ) {

APPENDIX 3. SOURCE CODE

f p r i n t f ( fp , "# f ( Hz ) SPL (dBA) magnitude phase \ n" ) ; f o r ( i =1; i <N; i ++) { double SWL=(Wmag[ i ]==0? - 1000:10.0  l o g 1 0 (Wmag[ i ] / Wref )+GetAWeighting ( f [ i ] ) ) ; f p r i n t f ( fp , "%g %g %g %g \ n" , f [ i ] ,SWL,Wmag[ i ] , Wphase [ i ] ) ; } } else { P e t s c S y n c h r o n i z e d P r i n t f (PETSC COMM WORLD, " Unable t o open s p l . dat \ n" ) ; } f c l o s e ( fp ) ; f p=f o p e n ( " s w l o c t a v e . dat " , "w" ) ; i f ( fp ) { f p r i n t f ( fp , "# f ( Hz ) SWL (dBA) \ n" ) ; f o r ( i =1; i <NBand ; i ++) { P e t s c R e a l SWL=(Wband [ i ]==0? - 1000:20.0  l o g 1 0 (Wband [ i ] / Wref )+GetAWeighting ( fband [ i ]) ) ; f p r i n t f ( fp , "%g %g \ n" , fband [ i ] ,SWL) ; } } else { P e t s c S y n c h r o n i z e d P r i n t f (PETSC COMM WORLD, " Unable t o open s p l o c a t v e . dat \ n" ) ; } f c l o s e ( fp ) ; PetscFree ( f ) ; P e t s c F r e e (Wmag) ; P e t s c F r e e ( Wphase ) ; P e t s c S y n c h r o n i z e d F l u s h (PETSC COMM WORLD) ; } else { P e t s c S y n c h r o n i z e d F l u s h (PETSC COMM WORLD) ; } return 0 ;

94

APPENDIX 3. SOURCE CODE
530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 } P e t s c E r r o r C o d e SaveVTKByIter ( P e t s c I n t s t e p s , PetscReal t , Vec s o l u t i o n , app ctx  pctx ) { char FileName [ ] = " p t s 0 0 0 0 0 0 . vtk " ; PetscViewer viewer ; a s s e r t ( pctx ) ; a s s e r t ( pctx ->params ) ; s p r i n t f ( FileName , " p t s %06d . vtk " , s t e p s ) ; i f ( TwoDimensional ( p c t x ) ) return SaveSliceWithName ( 0 , Z SLICE , 0 , 0 , s o l u t i o n , pctx , FileName ) ; P e t s c V i e w e r C r e a t e (PETSC COMM WORLD,& v i e w e r ) ; PetscViewerSe tT ype ( v i e w e r , PETSC VIEWER ASCII) ; P e t s c V i e w e r F i l e S e t N a m e ( v i e w e r , FileName ) ; PetscViewerSetFormat ( v i e w e r , PETSC VIEWER ASCII VTK) ; DAView( pctx ->dagp , v i e w e r ) ;

3.5. IO.C

V e c S c a t t e r B e g i n ( pctx ->groundp , s o l u t i o n , pctx ->c u r r p , INSERT VALUES ,SCATTER FORWARD) ; VecScatterEnd ( pctx ->groundp , s o l u t i o n , pctx ->c u r r p , INSERT VALUES ,SCATTER FORWARD) ; VecView ( pctx ->c u r rp , v i e w e r ) ; PetscViewerDestroy ( viewer ) ; return 0 ; }

P e t s c E r r o r C o d e SaveFullVTKByIter ( P e t s c I n t s t e p s , PetscReal t , Vec s o l u t i o n , app ctx  pctx ) { char FileName [ ] = " s o l t s 0 0 0 0 0 0 . vtk " ; PetscViewer viewer ; a s s e r t ( pctx ) ; a s s e r t ( pctx ->params ) ; s p r i n t f ( FileName , " s o l t s %06d . vtk " , s t e p s ) ; i f ( TwoDimensional ( p c t x ) ) return SaveSliceWithName ( 0 , Z SLICE , 0 , 2 , s o l u t i o n , pctx , FileName ) ; P e t s c V i e w e r C r e a t e (PETSC COMM WORLD,& v i e w e r ) ; PetscViewerSe tT ype ( v i e w e r , PETSC VIEWER ASCII) ;

95

3.5. IO.C
580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 P e t s c V i e w e r F i l e S e t N a m e ( v i e w e r , FileName ) ; PetscViewerSetFormat ( v i e w e r , PETSC VIEWER ASCII VTK) ; DAView( pctx ->da , v i e w e r ) ; VecView ( s o l u t i o n , v i e w e r ) ; PetscViewerDestroy ( viewer ) ; return 0 ; }

APPENDIX 3. SOURCE CODE

PetscErrorCode S a v e S l i c e ( PetscInt s l i c e , s l i c e p l a n e plane , Vec s o l u t i o n , app ctx  pctx ) { return SaveSliceWithName ( s l i c e , p l a n e , 0 , 3 , s o l u t i o n , pctx ,NULL) ; } P e t s c E r r o r C o d e SaveSliceWithName ( P e t s c I n t s l i c e , s l i c e p l a n e plane , P e t s c I n t dlo , P e t s c I n t dhi , Vec s o l u t i o n , a p p c t x  pctx , char  RequestedFileName ) { PetscErrorCode i e r r ; PetscTru th S l i c e W i t h i n M e s h=PETSC FALSE ; switch ( p l a n e ) { case X SLICE : i f ( s l i c e >=0 && s l i c e <=pctx ->params->mesh . Nx- 1) S l i c e W i t h i n M e s h=PETSC TRUE ; break ; case Y SLICE : i f ( s l i c e >=0 && s l i c e <=pctx ->params->mesh . Ny- 1) S l i c e W i t h i n M e s h=PETSC TRUE ; break ; case Z SLICE : i f ( s l i c e >=0 && s l i c e <=pctx ->params->mesh . Nz - 1) S l i c e W i t h i n M e s h=PETSC TRUE ; break ; }; i f ( SliceWithinMesh ) { i f ( RequestedFileName ) P e t s c P r i n t f (PETSC COMM WORLD, " S a v i n g %s \ n" , RequestedFileName ) ; else { P e t s c P r i n t f (PETSC COMM WORLD, " S a v i n g s l i c e a t " ) ; switch ( p l a n e ) {

96

APPENDIX 3. SOURCE CODE
630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 case X SLICE : P e t s c P r i n t f (PETSC COMM WORLD, " i " ) ; break ; case Y SLICE : P e t s c P r i n t f (PETSC COMM WORLD, " j " ) ; break ; case Z SLICE : P e t s c P r i n t f (PETSC COMM WORLD, "k" ) ; break ; }; P e t s c P r i n t f (PETSC COMM WORLD, "=%d \ n" , s l i c e ) ; } P e t s c I n t M, N, P , d o f ; /  Get t h e g l o b a l and l o c a l d i m e n s i o n s o f s o l u t i o n DA  / DAGetInfo ( pctx ->da , PETSC IGNORE, & M,&N,&P , PETSC IGNORE, PETSC IGNORE, PETSC IGNORE, &dof , PETSC IGNORE, PETSC IGNORE, PETSC IGNORE) ; a s s e r t ( dlo >=0) ; a s s e r t ( dhi <=d o f ) ; PetscInt PetscInt PetscInt PetscInt PetscInt PetscInt i l o =( p l a n e==X i h i =( p l a n e==X j l o =( p l a n e==Y j h i =( p l a n e==Y k l o =( p l a n e==Z k h i =( p l a n e==Z SLICE? s l i c e SLICE? s l i c e SLICE? s l i c e SLICE? s l i c e SLICE ? s l i c e SLICE ? s l i c e :0) ; :M- 1) ; :0) ; : N- 1) ; :0) ; : P- 1) ;

3.5. IO.C

DA da2D ; Vec sol2D ; VecScatter s l i c e s c a t t e r ; C r e a t e S l i c e S c a t t e r ( pctx , s o l u t i o n , i l o , i h i , j l o , j h i , k l o , khi , dlo , dhi ,&da2D,& sol2D ,& slice scatter ) ; PetscViewer viewer ; P e t s c V i e w e r C r e a t e (PETSC COMM WORLD,& v i e w e r ) ; PetscVi ew erSetType ( v i e w e r , PETSC VIEWER ASCII) ; i f ( RequestedFileName ) { P e t s c V i e w e r F i l e S e t N a m e ( v i e w e r , RequestedFileName ) ; } else { char FileName [ ] = " s l i c e i 0 0 0 0 0 0 . vtk " ; switch ( p l a n e ) { case X SLICE : s p r i n t f ( FileName , " s l i c e %c %06d . vtk " , ' i ' , s l i c e ) ; break ;

97

3.5. IO.C
679 680 681 682 683 684 685 686 687 688 689 690 691

APPENDIX 3. SOURCE CODE

case Y SLICE : s p r i n t f ( FileName , " s l i c e %c %06d . vtk " , ' j ' , s l i c e ) ; break ; case Z SLICE : s p r i n t f ( FileName , " s l i c e %c %06d . vtk " , ' k ' , s l i c e ) ; break ; }; P e t s c V i e w e r F i l e S e t N a m e ( v i e w e r , FileName ) ; } PetscViewerSet Format ( v i e w e r , PETSC VIEWER ASCII VTK) ; DAView( da2D , v i e w e r ) ; i e r r=V e c S c a t t e r B e g i n ( s l i c e s c a t t e r , s o l u t i o n , sol2D , INSERT VALUES ,SCATTER FORWARD) ; CHKERRQ( i e r r ) ; i e r r=VecScatterEnd ( s l i c e s c a t t e r , s o l u t i o n , sol2D , INSERT VALUES ,SCATTER FORWARD) ; CHKERRQ( i e r r ) ; i e r r=VecView ( sol2D , v i e w e r ) ; CHKERRQ( i e r r ) ;

692 693 694 i e r r=V e c S c a t t e r D e s t r o y ( s l i c e s c a t t e r ) ; 695 i e r r=P e t s c V i e w e r D e s t r o y ( v i e w e r ) ; CHKERRQ( i e r r ) ; 696 i e r r=VecDestroy ( sol2D ) ; CHKERRQ( i e r r ) ; 697 i e r r=DADestroy ( da2D ) ; CHKERRQ( i e r r ) ; 698 return 0 ; 699 } 700 return 1 ; 701 } 702 703 P e t s c E r r o r C o d e C r e a t e S l i c e S c a t t e r ( a p p c t x  pctx , 704 Vec v e c f r o m , 705 PetscInt ilo , 706 PetscInt ihi , 707 PetscInt jlo , 708 PetscInt jhi , 709 PetscInt klo , 710 P e t s c I n t khi , 711 P e t s c I n t dlo , 712 P e t s c I n t dhi , 713 DA  d a t o , 714 Vec  v e c t o , 715 VecScatter  pscatter ) 716 { 717 PetscErrorCode i e r r ; 718 i n t rank , s i z e ; 719 720 MPI Comm rank (PETSC COMM WORLD,& rank ) ; 721 MPI Comm size (PETSC COMM WORLD,& s i z e ) ; 722 723 P e t s c I n t M, N, P ,m, n , p , d o f ; 724 /  Get t h e g l o b a l and l o c a l d i m e n s i o n s o f s o l u t i o n DA  / 725 DAGetInfo ( pctx ->da , PETSC IGNORE, 726 & M,&N,&P ,

98

APPENDIX 3. SOURCE CODE
727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 &m,&n,&p , &dof , PETSC IGNORE, PETSC IGNORE, PETSC IGNORE) ; P e t s c I n t sx , sy , sz , mx, my, mz ; /  Get l o c a l g r i d b o u n d a r i e s , which a r e i n d e p e n d e n t o f d o f  / DAGetCorners ( pctx ->da ,& sx ,& sy ,& sz ,&mx,&my,&mz) ; P e t s c I n t M2D, N2D ; P e t s c R e a l xgmin , ygmin , xgmax , ygmax ; i f ( i l o==i h i ) /  X SLICE  / { M2D=khi - k l o +1 ,N2D=j h i - j l o +1; xgmin=pctx ->params->mesh . zmin+( k l o - 0)/ pctx ->i n v d z ; xgmax=pctx ->params->mesh . zmax -(P-1- k h i ) / pctx ->i n v d z ; ygmin=pctx ->params->mesh . ymin+( j l o - 0)/ pctx ->invdy ; ygmax=pctx ->params->mesh . ymax-(N-1- j h i ) / pctx ->invdy ; } e l s e i f ( j l o==j h i ) /  Y SLICE  / { M2D=i h i - i l o +1 ,N2D=khi - k l o +1; xgmin=pctx ->params->mesh . xmin+( i l o - 0)/ pctx ->invdx ; xgmax=pctx ->params->mesh . xmax-(M -1- i h i ) / pctx ->invdx ; ygmin=pctx ->params->mesh . zmin+( k l o - 0)/ pctx ->i n v d z ; ygmax=pctx ->params->mesh . zmax -(P-1- k h i ) / pctx ->i n v d z ; } e l s e i f ( k l o==k h i ) /  Z SLICE  / { M2D=i h i - i l o +1 ,N2D=j h i - j l o +1; xgmin=pctx ->params->mesh . xmin+( i l o - 0)/ pctx ->invdx ; xgmax=pctx ->params->mesh . xmax-(M -1- i h i ) / pctx ->invdx ; ygmin=pctx ->params->mesh . ymin+( j l o - 0)/ pctx ->invdy ; ygmax=pctx ->params->mesh . ymax-(N-1- j h i ) / pctx ->invdy ; } else { P e t s c P r i n t f (PETSC COMM WORLD, " E r r o r i n s l i c e s p e c i f i c a t i o n ! \ n" ) ; return 1 ; } P e t s c I n t d o f g =(dhi -d l o +1) ; i e r r=DACreate2d (PETSC COMM WORLD, DA NONPERIODIC, DA STENCIL STAR , M2D, N2D, PETSC DECIDE, PETSC DECIDE, dofg , 0, PETSC NULL, PETSC NULL, da to ) ;

3.5. IO.C

99

3.5. IO.C
777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 CHKERRQ( i e r r ) ; i e r r=DASetUniformCoordinates (  d a t o , xgmin , xgmax , ygmin , ygmax , 0 ,0) ; CHKERRQ( i e r r ) ;

APPENDIX 3. SOURCE CODE

/  A v e c t o r t o s t o r e ground p l a n e RMS o f p r e s s u r e  / i e r r=DACreateGlobalVector (  d a t o , v e c t o ) ; CHKERRQ( i e r r ) ; P e t s c I n t n i d x ,  i d x t o=NULL,  i d x f r o m=NULL; IS i s t o , i s f r o m ; /  C r e a t e i n d e x s e t f o r s c a t t e r from 3D s o l u t i o n t o 2D p v e c t o r  / i f ( sx+mx-1>= i l o && sx<=i h i && sy+my-1>= j l o && sy<=j h i && s z+mz-1>=k l o && sz <=k h i ) { P e t s c I n t i 0 =(sx > i l o ? sx : i l o ) ; P e t s c I n t iN=( sx+mx-1< i h i ? sx+mx- 1: i h i ) ; P e t s c I n t j 0 =(sy > j l o ? sy : j l o ) ; P e t s c I n t jN=( sy+my-1< j h i ? sy+my- 1: j h i ) ; P e t s c I n t k0=( sz > k l o ? s z : k l o ) ; P e t s c I n t kN=( s z+mz-1< k h i ? s z+mz- 1: k h i ) ; n i d x =(kN-k0+1)  ( jN- j 0 +1)  ( iN- i 0 +1)  d o f g ; a s s e r t ( n i d x > 0) ; P e t s c M a l l o c ( s i z e o f ( P e t s c I n t )  n i d x ,& i d x t o ) ; P e t s c M a l l o c ( s i z e o f ( P e t s c I n t )  n i d x ,& i d x f r o m ) ; const P e t s c I n t  l x ,  l y ,  l z ; DAGetOwnershipRanges ( pctx ->da ,& l x ,& l y ,& l z ) ; P e t s c I n t Mg, Ng , Pg , mg, ng , pg ; /  Get t h e g l o b a l and l o c a l d i m e n s i o n s o f s l i c e DA  / DAGetInfo (  d a t o , PETSC IGNORE, &Mg,&Ng , PETSC IGNORE, &mg,&ng , PETSC IGNORE, PETSC IGNORE, PETSC IGNORE, PETSC IGNORE, PETSC IGNORE) ; /  Get t h e o w n e r s h i p d i m e n s i o n s f o r t h e l o c a l 2D s l i c e  / const P e t s c I n t  l x g ,  l y g ; DAGetOwnershipRanges (  d a t o ,& l x g ,& l y g , PETSC NULL) ; /  i , j , k a r e t h e g l o b a l node i n d i c e s i n 3D mesh . d i s t h e i n d e x w i t h i n d o f  / PetscInt i , j , k , d ; /  i g , j g a r e t h e g l o b a l node i n d i c e s i n t h e 2D mesh  /

100

APPENDIX 3. SOURCE CODE
827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 PetscInt ig , jg ; /  b i , b j , bk i n d e x b l o c k s o f 3D mesh owned by p r o c e s s o r  / P e t s c I n t bi , bj , bk , sumi =0 , sumj =0 ,sumk=0; P e t s c I n t big , bjg , sumig =0 , sumjg =0; /  L o c a t e t h e o f f s e t s o f a l l p r o c e s s b l o c k s f o r mesh s l i c e  / P e t s c I n t o f f s e t g [ mg ] [ ng ] ; /  Zero o u t a r r a y  / f o r ( b j =0; bj <ng ; b j++) f o r ( b i =0; bi <mg ; b i++) o f f s e t g [ bi ] [ bj ]=0; P e t s c I n t o f f s e t =0; f o r ( b j g =0; bjg <ng ; b j g++) f o r ( b i g =0; big <mg ; b i g++) { o f f s e t g [ big ] [ bjg ] = o f f s e t ; o f f s e t += l x g [ b i g ]  l y g [ b j g ]  d o f g ; } /  L o c a t e t h e o f f s e t o f t h i s p r o c e s s b l o c k o f t h e mesh  / o f f s e t =0; P e t s c I n t p r o c =0; f o r ( bk =0;bk<p ; bk++) f o r ( b j =0; bj <n ; b j++) f o r ( b i =0; bi < m; b i++) { i f ( p r o c==rank ) break ; o f f s e t += l x [ b i ]  l y [ b j ]  l z [ bk ]  d o f ; p r o c ++; } /  i i c o u n t s w i t h i n i d x f r o m and i d x t o  / P e t s c I n t i i =0; /  Consume up t o i0 , j0 , k0 t o g e t t h e b i , b j , bk p r o c e s s o r b l o c k  / sumk=0; f o r ( bk =0;bk<p ; bk++) { i f ( sumk+l z [ bk] > k0 ) break ; sumk += l z [ bk ] ; } a s s e r t ( bk<p ) ; sumj =0; f o r ( b j =0; bj <n ; b j++) { i f ( sumj+l y [ b j ] > j 0 ) break ; sumj += l y [ b j ] ; }

3.5. IO.C

101

3.5. IO.C
877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 a s s e r t ( bj <n ) ; sumi =0; f o r ( b i =0; bi < m; b i++) { i f ( sumi+l x [ b i ] > i 0 ) break ; sumi += l x [ b i ] ; } a s s e r t ( bi < m) ;

APPENDIX 3. SOURCE CODE

/  b i , b j , bk s h o u l d p o i n t t o t h i s p r o c e s s o r ' s b l o c k o f t h e mesh . sumi , sumj , sumk s h o u l d be t h e number o f nodes up t o t h e l o w e s t c o r n e r of t h i s process block . We s h o u l d n e v e r l e a v e t h i s p r o c e s s o r ' s b l o c k , so b i , b j , bk and sumi , sumj , sumk s h o u l d n o t change p a s t t h i s p o i n t . / /  Need t o k e e p t r a c k o f b i g , b j g which can change due t o t h e f a c t t h a t 2D mesh s l i c e i s p a r t i t i o n e d amongst a l l p r o c e s s o r s . F u r t h e r c o m p l i c a t i o n : c o n c e p t o f i and j d i r e c t i o n s on 2D mesh a r e d i f f e r e n t d e p e n d i n g on v a l u e o f ' p l a n e ' . / f o r ( k=k0 ; k<=kN ; k++) { i f ( i l o==i h i | | j l o==j h i ) /  X SLICE or Y SLICE  / j g=k- k l o ; f o r ( j=j 0 ; j <=jN ; j ++) { i f ( k l o==k h i ) /  Z SLICE  / j g=j - j l o ; e l s e i f ( i l o==i h i ) /  X SLICE  / i g=j - j l o ; f o r ( i=i 0 ; i <=iN ; i ++) { i f ( j l o==j h i | | k l o==k h i ) /  Y SLICE or Z SLICE  / i g=i - i l o ; sumjg =0; f o r ( b j g =0; bjg <ng ; b j g++) { i f ( sumjg+l y g [ b j g ] > j g ) break ; sumjg += l y g [ b j g ] ; } a s s e r t ( bjg <ng ) ; sumig =0; f o r ( b i g =0; big <mg ; b i g++) { i f ( sumig+l x g [ b i g ] > i g ) break ;

102

APPENDIX 3. SOURCE CODE

3.5. IO.C

927 sumig += l x g [ b i g ] ; 928 } 929 a s s e r t ( big <mg) ; 930 931 f o r ( d=d l o ; d<=d h i ; d++) 932 { 933 a s s e r t ( i i <n i d x ) ; 934 i d x f r o m [ i i ]= o f f s e t +((( k-sumk )  l y [ b j ]+( j -sumj ) )  l x [ b i ]+( i -sumi ) )  d o f+d ; 935 a s s e r t ( i d x f r o m [ i i ] <MNP d o f ) ; 936 937 i d x t o [ i i ]= o f f s e t g [ b i g ] [ b j g ] + ( ( j g -sumjg )  l x g [ b i g ]+( i g -sumig ) )  d o f g +(d-d l o ) ; 938 a s s e r t ( i d x t o [ i i ] <Mg Ng  d o f g ) ; 939 i i ++; 940 } 941 } 942 } 943 } 944 } 945 else 946 { 947 n i d x =0; 948 } 949 950 i e r r=I S C r e a t e G e n e r a l (PETSC COMM WORLD, n i d x , i d x f r o m ,& i s f r o m ) ; CHKERRQ( i e r r ) ; 951 i e r r=I S C r e a t e G e n e r a l (PETSC COMM WORLD, n i d x , i d x t o ,& i s t o ) ; CHKERRQ( i e r r ) ; 952 953 i f ( idx to ) PetscFree ( idx to ) ; 954 i f ( idx from ) PetscFree ( idx from ) ; 955 956 VecScatter s l i c e s c a t t e r ; 957 i e r r=V e c S c a t t e r C r e a t e ( v e c f r o m , i s f r o m ,  v e c t o , i s t o , p s c a t t e r ) ; CHKERRQ( i e r r ) ; 958 959 ISDestroy ( i s f r o m ) ; 960 ISDestroy ( i s t o ) ; 961 962 return 0 ; 963 } 964 965 void ComputeFFT ( P e t s c I n t NHistory , 966 PetscReal  tHistory , 967 PetscReal  vHistory , 968 P e t s c I n t N, 969 P e t s c R e a l  f , 970 P e t s c R e a l  vmag , 971 P e t s c R e a l  vphase , 972 P e t s c I n t  Nband , 973 P e t s c R e a l  fband , 974 P e t s c R e a l  vband ) 975 { 976 const P e t s c I n t ANSIBandNumber [ 3 5 ] = { 1 0 , 1 1 , 1 2 , 1 3 , 1 4 , 1 5 , 1 6 , 1 7 , 1 8 , 1 9 , 2 0 , 2 1 ,

103

3.5. IO.C
977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026

APPENDIX 3. SOURCE CODE

const

const

const

const

const

const

22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44}; P e t s c R e a l ANSINominalCenterFreq [ 3 5 ] = { 1 0 . 0 , 1 2 . 5 , 1 6 , 2 0 , 2 5 , 3 1 , 4 0 , 5 0 , 6 3 , 80 , 100 , 125 , 160 , 200 , 250 , 315 , 400 , 500 , 630 , 800 , 1000 , 1250 , 1600 , 2000 , 2500 , 3150 , 4000 , 5000 , 6300 , 8000 , 10000 , 12500 , 16000 , 20000 , 25000}; P e t s c R e a l ANSIActualCenterFreq [ 3 5 ] = { 9 . 8 4 3 , 1 2 . 4 0 1 , 1 5 . 6 2 5 , 1 9 . 6 8 6 , 2 4 . 8 0 3 , 31.250 , 39.373 , 49.606 , 62.500 , 78.745 , 99.213 , 125.000 , 154.490 , 198.425 , 250.000 , 314.980 , 396.850 , 500.000 , 629.961 , 793.701 , 1000.000 , 1259.921 , 1587.401 , 2000.000 , 2519.842 , 3174.802 , 4000.000 , 5039.684 , 6349.604 , 8000.00 , 10079.368 , 12699.208 , 16000.000 , 20158.737 , 25398.417}; P e t s c R e a l ANSIBandLowFreq [ 3 5 ] = { 8 . 7 6 9 , 1 1 . 0 4 9 , 1 3 . 9 2 0 , 1 7 . 5 3 8 , 2 2 . 0 9 8 , 2 7 . 8 4 0 , 35.077 , 44.194 , 55.681 , 70.154 , 88.388 , 111.362 , 140.308 , 176.777 , 222.725 , 280.616 , 353.553 , 445.449 , 561.123 , 707.107 , 890.899 , 1122.462 , 1414.214 , 1781.797 , 2244.924 , 2828.427 , 3563.595 , 4489.848 , 5656.854 , 7127.190 , 8979.696 , 11313.708 , 14253.379 , 17959.393 , 22627.417}; P e t s c R e a l ANSIBandUpperFreq [ 3 5 ] = { 1 1 . 0 4 9 , 1 3 . 9 2 0 , 1 7 . 5 3 8 , 2 2 . 0 9 8 , 2 7 . 8 4 0 , 35.077 , 44.194 , 55.681 , 70.154 , 88.388 , 111.362 , 140.308 , 176.777 , 222.725 , 280.616 , 353.553 , 445.449 , 561.123 , 707.107 , 890.899 , 1122.462 , 1414.214 , 1781.797 , 2244.924 , 2828.427 , 3563.595 , 4489.848 , 5656.854 , 7127.190 , 8979.696 , 11313.708 , 14253.379 , 17959.393 , 22627.417 , 28508.759}; P e t s c I n t ANSIBandNumBins [ 3 5 ] = { 3 , 4 , 5 , 6 , 8 , 1 0 , 1 2 , 1 6 , 2 0 , 2 4 , 3 2 , 4 0 , 4 8 , 64 , 80 , 96 , 128 , 160 , 192 , 256 , 320 , 384 , 512 , 640 , 768 , 1024 , 1280 , 1536 , 2048 , 2560 , 3072 , 4096 , 5120 , 6144 , 8192}; P e t s c I n t ANSIBandBinUpper [ 3 5 ] = { 1 5 , 1 9 , 2 4 , 3 0 , 3 8 , 4 8 , 6 0 , 7 6 , 9 6 , 1 2 0 , 1 5 2 , 192 , 240 , 304 , 384 , 480 , 608 , 768 , 960 , 1216 , 1536 , 1920 , 2432 , 3072 , 3840 , 4862 , 6144 , 7680 , 9728 , 12288 , 15360 , 19456 , 24576 , 30720 , 38912};

i n t rank ; MPI Comm rank (PETSC COMM WORLD,& rank ) ; i f ( rank ) return ; assert ( tHistory ) ; a s s e r t ( vHistory ) ; /  v H i s t o r y may n o t be u n i f o r m l y sampled , d e p e n d i n g upon t h e time march method used .

104

APPENDIX 3. SOURCE CODE
1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 Resample f o r N s a m p l e s  / const const const const unsigned unsigned unsigned unsigned int int int int De siredSampleRa te =48000; DesiredFFTBlocks =65516; bandlo =0; bandhi=43-ANSIBandNumber [ 0 ] ;

3.5. IO.C

P e t s c R e a l T=t H i s t o r y [ NHistory -1]- t H i s t o r y [ 0 ] ; unsigned i n t L=( unsigned i n t ) ( ( ( double ) D esi red S a m p l e R a t e ) T) ; unsigned i n t NFFT=DesiredFFTBlocks ; i f ( L>NFFT) { L=NFFT; } P e t s c R e a l Fs=L/T ; /  Sample f r e q u e n c y  /

P e t s c P r i n t f (PETSC COMM WORLD, " Using sample l e n g t h %d and FFT b l o c k s i z e %d ( Fs=%g ) \ n" , L , NFFT, Fs ) ; double  i n ; f f t w c o m p l e x  out ; fftw plan p; i n = ( double  ) f f t w m a l l o c ( s i z e o f ( double )  NFFT) ; out = ( f f t w c o m p l e x  ) f f t w m a l l o c ( s i z e o f ( f f t w c o m p l e x )  (NFFT/2+1) ) ; memset ( in , 0 , s i z e o f ( double ) NFFT) ; /  Zero o u t i n v e c t o r , so i t end  / P e t s c R e a l dt=T/ ( ( P e t s c R e a l ) ( L- 1) ) ; / I n t e r p o l a t e v a l u e h i s t o r y t o i n v e c t o r / int i , j ; f o r ( i =0 , j =0; i <L ; i ++) { P e t s c R e a l t=i  dt+t H i s t o r y [ 0 ] ; while ( j <NHistory && t H i s t o r y [ j ]<= t ) j ++; a s s e r t ( j > 0) ; i f ( j==NHistory ) j=NHistory - 1; i n [ i ]=( v H i s t o r y [ j ] - v H i s t o r y [ j - 1]) / ( t H i s t o r y [ j ] - t H i s t o r y [ j - 1])  ( t - t H i s t o r y [ j - 1])+ vHistory [ j -1]; // P e t s c P r i n t f (PETSC COMM WORLD,"%d %d %g %g (%g %g %g %g ) \ n " , i , j , t , i n [ i ] , t H i s t o r y [ j ] , t H i s t o r y [ j - 1] , v H i s t o r y [ j ] , v H i s t o r y [ j - 1]) ; } p = f f t w p l a n d f t r 2 c 1 d (NFFT, in , out , FFTW ESTIMATE) ; fftw execute (p) ; (  N)=NFFT/2+1; P e t s c M a l l o c ( s i z e o f ( P e t s c R e a l )  (  N) , f ) ; i s z e r o padded a t t h e

105

3.6. MEAN.H
1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 } P e t s c M a l l o c ( s i z e o f ( P e t s c R e a l )  (  N) , vmag ) ; P e t s c M a l l o c ( s i z e o f ( P e t s c R e a l )  (  N) , vphase ) ;

APPENDIX 3. SOURCE CODE

double d e l t a f =(Fs / 2 ) / ( ( double ) ( (  N) -1) ) ; f o r ( i =0; i < ( N) ; i ++) { (  f ) [ i ]= i  d e l t a f ; (  vmag ) [ i ]= s q r t ( out [ i ] [ 0 ]  out [ i ] [ 0 ] + out [ i ] [ 1 ]  out [ i ] [ 1 ] ) / ( ( double )NFFT) ; (  vphase ) [ i ]= atan2 ( out [ i ] [ 1 ] , out [ i ] [ 0 ] ) ; } (  Nband )=bandhi -bandlo ; P e t s c M a l l o c ( s i z e o f ( P e t s c R e a l )  (  Nband ) , fband ) ; P e t s c M a l l o c ( s i z e o f ( P e t s c R e a l )  (  Nband ) , vband ) ; f o r ( i=ba ndlo ; i <bandhi ; i ++) { (  fband ) [ i -bandlo ]= ANSINominalCenterFreq [ i ] ; (  vband ) [ i -bandlo ] = 0 . 0 ; unsigned i n t j l o=ANSIBandBinUpper [ i ] - ANSIBandNumBins [ i ] ; unsigned i n t j h i=ANSIBandBinUpper [ i ] ; a s s e r t ( j l o <NFFT/2+1) ; a s s e r t ( j h i <NFFT/2+1) ; f o r ( j=j l o +1; j <=j h i ; j ++) { (  vband ) [ i -bandlo ] += (  vmag ) [ j ] ; } } fftw destroy plan (p) ; f f t w f r e e ( in ) ; f f t w f r e e ( out ) ;

3.6
1 2 3 4 5 6 7 8 9 10 11 12 13

mean.h

#i f n d e f MEAN H #define MEAN H #include < p e t s c . h> #include <p e t s c b a g . h> /  ! \ f i l e mean . h \ b r i e f Mean f l o w p a r a m e t e r s D e f i n i t i o n s and d e c l a r e d f u n c t i o n s f o r d e s c r i b i n g t h e mean f l o w b e h a v i o u r . / /  ! \ b r i e f Ambient a i r p r o p e r t i e s

106

APPENDIX 3. SOURCE CODE
14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 Free stream f l u i d p r o p e r t i e s o f a i r . / typedef struct { P e t s c R e a l rho ; /  ! < f l u i d d e n s i t y ( kg /m^3)  / PetscReal T; /  ! < f l u i d t e m p e r a t u r e ( deg C)  / P e t s c R e a l R; /  ! < i d e a l g a s c o n s t a n t ( J/ kg .K)  / P e t s c R e a l gamma ; / !< r a t i o o f s p e c i f i c h e a t s / } fluid properties ; /  ! \ b r i e f Mean uniform f l o w p r o p e r t i e s F l u i d p r o p e r t i e s f o r mean uniform f l o w , i n c l u d i n g q u i e s c e n t f l u i d .  / typedef struct { P e t s c R e a l kappa , b , kappae , be , s e ; P e t s c R e a l vx ; P e t s c R e a l vy ; P e t s c R e a l vz ; P e t s c R e a l M; /  ! < f l o w Mach number  / PetscReal dirx ; / !< f l o w d i r e c t i o n i n x / PetscReal diry ; /  ! < f l o w d i r e c t i o n i n y ( s h o u l d a l w a y s be z e r o )  / PetscReal d i r z ; / !< f l o w d i r e c t i o n i n z / } mean uniform parameters ; /  ! \ b r i e f Power law p r o f i l e p r o p e r t i e s F l u i d p r o p e r t i e s f o r power law p r o f i l e f l o w .  / typedef struct { P e t s c R e a l kappa , b , kappae , be , s e ; PetscReal dirx ; / !< d i r e c t i o n o f f l o w i n x / PetscReal d i r z ; / !< d i r e c t i o n o f f l o w i n z / PetscReal a ; /  ! < Power exponent , u s u a l l y 1/7  / P e t s c R e a l ur ; /  ! < r e f e r e n c e s p e e d (m/ s )  / PetscReal zr ; /  ! < r e f e r e n c e h e i g h t (m)  / } power profile parameters ;

3.6. MEAN.H

/  ! A v a i l a b l e mean f l o w models  / typedef enum { MEAN UNIFORM=0 , /  ! < uniform mean f l o w , i n c l u d i n g q u i e s c e n t  / POWER PROFILE=1 /  ! < power law p r o f i l e mean f l o w , i n c l u d i n g q u i e s c e n t  / } mean flow type ; /  ! R e g i s t e r f l u i d p r o p e r t i e s , and o p t i o n a l l y l o a d v a l u e s from f i l e .  / P e t s c E r r o r C o d e R e g i s t e r P r o p e r t i e s B a g ( PetscBag  bag , f l u i d p r o p e r t i e s  p , P e t s c T r u t h LoadFromFile ) ; /  ! Get t h e ambient s p e e d o f sound (m/ s )  / P e t s c R e a l GetSpeedOfSound ( f l u i d p r o p e r t i e s  pprop ) ; /  ! Get t h e ambient p r e s s u r e (Pa)  / P e t s c R e a l G e t P r e s s u r e ( f l u i d p r o p e r t i e s  pprop ) ; /  ! Get t h e ambient d e n s i t y ( kg /m^3)  /

107

3.7. MEAN.C
63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 P e t s c R e a l GetDensity ( f l u i d p r o p e r t i e s  prop ) ; /  ! Get t h e r a t i o o f s p e c i f i c h e a t s  / P e t s c R e a l G e t R a t i o O f S p e c i f i c H e a t s ( f l u i d p r o p e r t i e s  prop ) ; /  ! Get t h e ambient t e m p e r a t u r e (K)  / P e t s c R e a l GetTemperature ( f l u i d p r o p e r t i e s  prop ) ; /  ! Get t h e i d e a l g a s c o n s t a n t ( J/ kg .K)  / P e t s c R e a l GetGasConstant ( f l u i d p r o p e r t i e s  prop ) ; /  ! Save mean f l o w parameter v a l u e s t o f i l e .  / void SaveMeanBag ( PetscBag bag ) ; /  ! Save f l u i d p r o p e r t i e s t o f i l e .  / void S a v e F l u i d P r o p e r t i e s B a g ( PetscBag bag ) ;

APPENDIX 3. SOURCE CODE

/  ! R e g i s t e r uniform mean f l o w parameters , and o p t i o n a l l y l o a d v a l u e s from f i l e .  / P e t s c E r r o r C o d e RegisterUniformMeanBag ( PetscBag  bag , void  params , P e t s c T r u t h LoadFromFile ) ; /  ! I n i t i a l i z e uniform mean f l o w parameter v a l u e s  / P e t s c E r r o r C o d e I n i t i a l i z e U n i f o r m M e a n ( void  vpctx ) ; /  ! R e g i s t e r power law p r o f i l e f l o w parameters , and o p t i o n a l l y l o a d v a l u e s from f i l e .  / P e t s c E r r o r C o d e R e g i s t e r P o w e r P r o f i l e M e a n B a g ( PetscBag  bag , void  params , P e t s c T r u t h LoadFromFile ) ;

84 85 /  ! I n i t i a l i z e power law p r o f i l e mean f l o w parameter v a l u e s  / 86 P e t s c E r r o r C o d e I n i t i a l i z e P o w e r P r o f i l e M e a n ( void  vpctx ) ; 87 88 89 #endif

3.7
1 2 3 4 5 6 7 8 9 10 11

mean.c

#include < s t d l i b . h> #include < a s s e r t . h> #include < p e t s c . h> #include "mean . h" #include " ode . h" const char F l u i d P r o p e r t i e s F i l e [ ] = " p r o p e r t i e s . dat " ; const char MeanParametersFile [ ] = " mparameters . dat " ;

P e t s c E r r o r C o d e R e g i s t e r P r o p e r t i e s B a g ( PetscBag  bag , f l u i d p r o p e r t i e s  pparams , P e t s c T r u t h LoadFromFile ) 12 { 13 PetscErrorCode i e r r ; 14 15 a s s e r t ( bag ) ; 16 a s s e r t ( pparams ) ;

108

APPENDIX 3. SOURCE CODE
17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61

3.7. MEAN.C

i e r r=P e t s c B a g C r e a t e (PETSC COMM WORLD, s i z e o f ( f l u i d p r o p e r t i e s ) , bag ) ; CHKERRQ( i e r r ) ; i e r r=PetscBagGetData (  bag , ( void   ) pparams ) ; CHKERRQ( i e r r ) ; PetscBagSetName (  bag , " F l u i d P r o p e r t i e s " , " runt i m e p a r a m e t e r s f o r f l u i d p r o p e r t i e s " ) ; f l u i d p r o p e r t i e s  p r o p e r t i e s = pparams ; assert ( properties ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& p r o p e r t i e s ->rho , 1 . 2 5 , " f l u i d r h o " , " F l u i d d e n s i t y ( kg /m ^ 3 ) " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& p r o p e r t i e s ->T, 2 0 , " f l u i d T " , " F l u i d t e m p e r a t u r e ( deg C) " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& p r o p e r t i e s ->gamma , 1 . 4 , " fluid gamma " , " F l u i d r a t i o o f s p e c i f i c h e a t s " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& p r o p e r t i e s ->R, 2 8 7 , " f l u i d R " , " F l u i d g a s c o n s t a n t ( J/ kg . K) " ) ; CHKERRQ( i e r r ) ; i f ( LoadFromFile ) { PetscViewer bagviewer ; i f ( i e r r=PetscViewerBinaryOpen (PETSC COMM WORLD, F l u i d P r o p e r t i e s F i l e , FILE MODE READ ,& b a g v i e w e r ) ) { P e t s c P r i n t f (PETSC COMM WORLD, " Unable t o l o a d %s . \ n" , F l u i d P r o p e r t i e s F i l e ) ; CHKERRQ( i e r r ) ; } i e r r=PetscBagLoad ( b agv iewe r , bag ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c V i e w e r D e s t r o y ( b a g v i e w e r ) ; CHKERRQ( i e r r ) ; i e r r=PetscBagGetData (  bag , ( void   ) pparams ) ; CHKERRQ( i e r r ) ; P e t s c P r i n t f (PETSC COMM WORLD, " Loaded f l u i d p r o p e r t i e s : \ n" ) ; i e r r=PetscBagView (  bag ,PETSC VIEWER STDOUT WORLD) ; CHKERRQ( i e r r ) ; } return 0 ; } P e t s c R e a l GetSpeedOfSound ( f l u i d p r o p e r t i e s  pprop ) { a s s e r t ( pprop ) ; return s q r t ( pprop ->gamma pprop ->R  ( pprop ->T+ 2 7 3 . 1 5 ) ) ; } P e t s c R e a l G e t P r e s s u r e ( f l u i d p r o p e r t i e s  pprop ) { a s s e r t ( pprop ) ; return pprop ->rho  pprop ->R  ( pprop ->T+ 2 7 3 . 1 5 ) ; } P e t s c R e a l GetDensity ( f l u i d p r o p e r t i e s  prop ) { a s s e r t ( prop ) ;

109

3.7. MEAN.C
62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 return prop ->rho ; } P e t s c R e a l G e t R a t i o O f S p e c i f i c H e a t s ( f l u i d p r o p e r t i e s  prop ) { a s s e r t ( prop ) ; return prop ->gamma ; } P e t s c R e a l GetTemperature ( f l u i d p r o p e r t i e s  prop ) { a s s e r t ( prop ) ; return prop ->T+ 2 7 3 . 1 5 ; } P e t s c R e a l GetGasConstant ( f l u i d p r o p e r t i e s  prop ) { a s s e r t ( prop ) ; return prop ->R; }

APPENDIX 3. SOURCE CODE

void SaveMeanBag ( PetscBag bag ) { PetscViewer bagviewer ; /  Save t h e runtime p a r a m e t e r s t o a b i n a r y f i l e  / PetscViewerBinaryOpen (PETSC COMM WORLD, MeanParametersFile , FILE MODE WRITE,& b a g v i e w e r ) ; PetscBagView ( bag , b a g v i e w e r ) ; PetscViewerDestroy ( bagviewer ) ; }

void S a v e F l u i d P r o p e r t i e s B a g ( PetscBag bag ) { PetscViewer bagviewer ; /  Save t h e runtime p a r a m e t e r s t o a b i n a r y f i l e  / PetscViewerBinaryOpen (PETSC COMM WORLD, F l u i d P r o p e r t i e s F i l e , FILE MODE WRITE,& b a g v i e w e r ) ; 97 PetscBagView ( bag , b a g v i e w e r ) ; 98 PetscViewerDestroy ( bagviewer ) ; 99 } 100 101 P e t s c E r r o r C o d e RegisterUniformMeanBag ( PetscBag  bag , void  pparams , P e t s c T r u t h LoadFromFile ) 102 { 103 PetscErrorCode i e r r ; 104 a s s e r t ( bag ) ; 105 a s s e r t ( pparams ) ; 106 107 i e r r=P e t s c B a g C r e a t e (PETSC COMM WORLD, s i z e o f ( m e a n u n i f o r m p a r a m e t e r s ) , bag ) ; CHKERRQ( ierr ) ; 108 i e r r=PetscBagGetData (  bag , pparams ) ; CHKERRQ( i e r r ) ;

110

APPENDIX 3. SOURCE CODE
109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152

3.7. MEAN.C

i e r r=PetscBagSetName (  bag , " Uniform Mean Flow P a r a m e t e r s " , " r u n t i m e p a r a m e t e r s f o r a u n i f o r m mean f l o w " ) ; CHKERRQ( i e r r ) ; m e a n u n i f o r m p a r a m e t e r s  pmean=( m e a n u n i f o r m p a r a m e t e r s  ) (  pparams ) ; /  Uniform mean f l o w p a r a m e t e r s  / i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmean-> M, 0 , " mean uniform M " , "Mean f l o w mach number" ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmean->d i r x , 1 , " m e a n u n i f o r m d i r e c t i o n x " , "Mean f l o w d i r e c t i o n i n x- d i r e c t i o n " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmean->d i r y , 0 , " m e a n u n i f o r m d i r e c t i o n y " , "Mean f l o w d i r e c t i o n i n y- d i r e c t i o n " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmean-> d i r z , 0 , " m e a n u n i f o r m d i r e c t i o n z " , "Mean f l o w d i r e c t i o n i n z- d i r e c t i o n " ) ; CHKERRQ( i e r r ) ; i f ( LoadFromFile ) { PetscViewer bagviewer ; i f ( i e r r=PetscViewerBinaryOpen (PETSC COMM WORLD, MeanParametersFile , FILE MODE READ ,& b a g v i e w e r ) ) { P e t s c P r i n t f (PETSC COMM WORLD, " Unable t o l o a d %s . \ n" , MeanParametersFile ) ; CHKERRQ( i e r r ) ; } i e r r=PetscBagLoad ( b agv iewe r , bag ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c V i e w e r D e s t r o y ( b a g v i e w e r ) ; CHKERRQ( i e r r ) ; i e r r=PetscBagGetData (  bag , pparams ) ; CHKERRQ( i e r r ) ; P e t s c P r i n t f (PETSC COMM WORLD, " Loaded u n i f o r m mean f l o w p a r a m e t e r s : \ n" ) ; i e r r=PetscBagView (  bag ,PETSC VIEWER STDOUT WORLD) ; CHKERRQ( i e r r ) ; } return 0 ; } P e t s c R e a l Uniform kappa ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , void  p v o i d ) { a p p c t x  p c t x =( a p p c t x  ) p v o i d ; m e a n u n i f o r m p a r a m e t e r s  pmean=( m e a n u n i f o r m p a r a m e t e r s  ) ( pctx ->pmean ) ; a s s e r t ( pvoid ) ; a s s e r t ( pctx ) ; a s s e r t ( pmean ) ; return pmean->kappa ; }

P e t s c R e a l Uniform b ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , void  p v o i d ) { a p p c t x  p c t x =( a p p c t x  ) p v o i d ; m e a n u n i f o r m p a r a m e t e r s  pmean=( m e a n u n i f o r m p a r a m e t e r s  ) ( pctx ->pmean ) ; a s s e r t ( pvoid ) ; a s s e r t ( pctx ) ;

111

3.7. MEAN.C
153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 a s s e r t ( pmean ) ; return pmean->b ; }

APPENDIX 3. SOURCE CODE

P e t s c R e a l Uniform v ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , P e t s c I n t d , void  p v o i d ) { a p p c t x  p c t x =( a p p c t x  ) p v o i d ; m e a n u n i f o r m p a r a m e t e r s  pmean=( m e a n u n i f o r m p a r a m e t e r s  ) ( pctx ->pmean ) ; a s s e r t ( pvoid ) ; a s s e r t ( pctx ) ; a s s e r t ( pmean ) ; a s s e r t ( d>=0 && d < 3) ; switch ( d ) { case 0 : return pmean->vx ; break ; case 1 : return pmean->vy ; break ; case 2 : return pmean->vz ; break ; }; return 0 . 0 ; }

P e t s c R e a l Uniform dv ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , P e t s c I n t d , P e t s c I n t dd , void  p v o i d ) 185 { 186 return 0 . 0 ; 187 } 188 189 P e t s c E r r o r C o d e I n i t i a l i z e U n i f o r m M e a n ( void  vpctx ) 190 { 191 a p p c t x  p c t x =( a p p c t x  ) vpctx ; 192 PetscInt d ; 193 PetscReal c ; 194 P e t s c R e a l rho ; 195 PetscReal invlen ; 196 m e a n u n i f o r m p a r a m e t e r s  pmean=( m e a n u n i f o r m p a r a m e t e r s  ) pctx ->pmean ; 197 198 a s s e r t ( pctx ) ; 199 a s s e r t ( pmean ) ; 200 a s s e r t ( pctx -> p r o p e r t i e s ) ; 201

112

APPENDIX 3. SOURCE CODE
202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 c=GetSpeedOfSound ( pctx -> p r o p e r t i e s ) ; rho=Ge tDensit y ( pctx -> p r o p e r t i e s ) ; pctx -> c a l c k a p p a=Uniform kappa ; pctx -> c a l c b=Uniform b ; pctx -> c a l c v=Uniform v ; pctx -> c a l c d v d x=Uniform dv ; pctx -> c a l c d v d y=Uniform dv ; pctx -> c a l c d v d z=Uniform dv ; pmean->b =1.0/ rho ; pmean->kappa=rho  c  c ; i n v l e n =1.0/ s q r t ( pmean-> d i r x  pmean-> d i r x+ pmean-> d i r y  pmean-> d i r y+ pmean-> d i r z  pmean-> d i r z ) ; pmean->vx=pmean-> M c  pmean-> d i r x  i n v l e n ; pmean->vy=pmean-> M c  pmean-> d i r y  i n v l e n ; pmean->vz=pmean-> M c  pmean-> d i r z  i n v l e n ;

3.7. MEAN.C

P e t s c P r i n t f (PETSC COMM WORLD, " I n i t i a l i z i n g u n i f o r m mean f l o w : \ n" ) ; P e t s c P r i n t f (PETSC COMM WORLD, " c=%g m/ s M =%g i n %g ,%g ,%g d i r e c t i o n . \ n" , c , pmean-> M, pmean->d i r x , pmean->d i r y , pmean-> d i r z ) ; P e t s c P r i n t f (PETSC COMM WORLD, " kappa=%g b=%g . \ n" , pmean->kappa , pmean->b ) ; P e t s c P r i n t f (PETSC COMM WORLD, " v x=%g v y=%g v z=%g . \ n" , pmean->vx , pmean->vy , pmean->vz ) ;

224 225 return 0 ; 226 } 227 228 P e t s c E r r o r C o d e R e g i s t e r P o w e r P r o f i l e M e a n B a g ( PetscBag  bag , void  pparams , P e t s c T r u t h LoadFromFile ) 229 { 230 PetscErrorCode i e r r ; 231 a s s e r t ( bag ) ; 232 a s s e r t ( pparams ) ; 233 234 i e r r=P e t s c B a g C r e a t e (PETSC COMM WORLD, s i z e o f ( p o w e r p r o f i l e p a r a m e t e r s ) , bag ) ; CHKERRQ( ierr ) ; 235 i e r r=PetscBagGetData (  bag , pparams ) ; CHKERRQ( i e r r ) ; 236 i e r r=PetscBagSetName (  bag , "Power P r o f i l e Mean Flow P a r a m e t e r s " , " r u n t i m e p a r a m e t e r s f o r a power law p r o f i l e mean f l o w " ) ; CHKERRQ( i e r r ) ; 237 238 p o w e r p r o f i l e p a r a m e t e r s  pmean=( p o w e r p r o f i l e p a r a m e t e r s  ) (  pparams ) ; 239 /  Power law p r o f i l e mean f l o w p a r a m e t e r s  / 240 i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmean->ur , 7 . 5 , " p o w e r l a w u r e f " , "Mean f l o w r e f e r e n c e s p e e d (m/ s ) " ) ; CHKERRQ( i e r r ) ; 241 i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmean->zr , 5 0 , " p o w e r l a w z r e f " , "Mean f l o w r e f e r e n c e s p e e d h e i g h t (m) " ) ; CHKERRQ( i e r r ) ; 242 i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmean->a , 1 . 0 / 7 . 0 , " p o w e r l a w a " , "Mean f l o w r e f e r e n c e power exponent " ) ; CHKERRQ( i e r r ) ;

113

3.7. MEAN.C
243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289

APPENDIX 3. SOURCE CODE

i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmean->d i r x , 1 , " p o w e r l a w d i r e c t i o n x " , "Mean f l o w d i r e c t i o n i n x- d i r e c t i o n " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmean-> d i r z , 0 , " p o w e r l a w d i r e c t i o n z " , "Mean f l o w d i r e c t i o n i n z- d i r e c t i o n " ) ; CHKERRQ( i e r r ) ; i f ( LoadFromFile ) { PetscViewer bagviewer ; i f ( i e r r=PetscViewerBinaryOpen (PETSC COMM WORLD, MeanParametersFile , FILE MODE READ ,& b a g v i e w e r ) ) { P e t s c P r i n t f (PETSC COMM WORLD, " Unable t o l o a d %s . \ n" , MeanParametersFile ) ; CHKERRQ( i e r r ) ; } i e r r=PetscBagLoad ( b agv iewe r , bag ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c V i e w e r D e s t r o y ( b a g v i e w e r ) ; CHKERRQ( i e r r ) ; i e r r=PetscBagGetData (  bag , pparams ) ; CHKERRQ( i e r r ) ; P e t s c P r i n t f (PETSC COMM WORLD, " Loaded power law p r o f i l e mean f l o w p a r a m e t e r s : \ n" ) ; i e r r=PetscBagView (  bag ,PETSC VIEWER STDOUT WORLD) ; CHKERRQ( i e r r ) ; } return 0 ; } P e t s c R e a l P o w e r P r o f i l e k a p p a ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , void  p v o i d ) { a p p c t x  p c t x =( a p p c t x  ) p v o i d ; p o w e r p r o f i l e p a r a m e t e r s  pmean=( p o w e r p r o f i l e p a r a m e t e r s  ) ( pctx ->pmean ) ; a s s e r t ( pvoid ) ; a s s e r t ( pctx ) ; a s s e r t ( pmean ) ; return pmean->kappa ; }

P e t s c R e a l P o w e r P r o f i l e b ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , void  p v o i d ) { a p p c t x  p c t x =( a p p c t x  ) p v o i d ; p o w e r p r o f i l e p a r a m e t e r s  pmean=( p o w e r p r o f i l e p a r a m e t e r s  ) ( pctx ->pmean ) ; a s s e r t ( pvoid ) ; a s s e r t ( pctx ) ; a s s e r t ( pmean ) ; return pmean->b ; }

P e t s c R e a l P o w e r P r o f i l e v ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , P e t s c I n t d , void  p v o i d ) {

114

APPENDIX 3. SOURCE CODE

3.7. MEAN.C

290 a p p c t x  p c t x =( a p p c t x  ) p v o i d ; 291 p o w e r p r o f i l e p a r a m e t e r s  pmean=( p o w e r p r o f i l e p a r a m e t e r s  ) ( pctx ->pmean ) ; 292 P e t s c R e a l y=0 ,u=0; 293 294 a s s e r t ( pvoid ) ; 295 a s s e r t ( pctx ) ; 296 a s s e r t ( pmean ) ; 297 a s s e r t ( d>=0 && d < 3) ; 298 299 i f ( y>0 && pmean->zr >0 && ( d==0 | | d==2) ) 300 { 301 i f ( j >pctx -> j l o ) 302 { 303 a s s e r t ( pctx ->params ) ; 304 a s s e r t ( pctx ->invdy ) ; 305 y =(( P e t s c R e a l ) j -pctx -> j l o )  pctx ->dy ; 306 i f ( d==1) y += 0 . 5  pctx ->dy ; 307 } 308 u=pmean->ur  pow ( y/pmean->zr , pmean->a ) ; 309 switch ( d ) 310 { 311 case 0 : 312 return u  pmean-> d i r x ; 313 break ; 314 case 2 : 315 return u  pmean-> d i r z ; 316 break ; 317 }; 318 } 319 return 0 . 0 ; 320 } 321 322 323 P e t s c R e a l P o w e r P r o f i l e d v ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , P e t s c I n t d , P e t s c I n t dd , void  pvoid ) 324 { 325 a p p c t x  p c t x =( a p p c t x  ) p v o i d ; 326 p o w e r p r o f i l e p a r a m e t e r s  pmean=( p o w e r p r o f i l e p a r a m e t e r s  ) ( pctx ->pmean ) ; 327 P e t s c R e a l y=0 ,u=0 ,du=0; 328 329 a s s e r t ( pvoid ) ; 330 a s s e r t ( pctx ) ; 331 a s s e r t ( pmean ) ; 332 a s s e r t ( d>=0 && d < 3) ; 333 a s s e r t ( dd>=0 && dd < 3) ; 334 335 i f ( y>0 && pmean->zr >0 && ( d==0 | | d==2) && dd==1) 336 { 337 i f ( j >pctx -> j l o ) 338 {

115

3.7. MEAN.C

APPENDIX 3. SOURCE CODE

339 a s s e r t ( pctx ->params ) ; 340 a s s e r t ( pctx ->invdy ) ; 341 y =(( P e t s c R e a l ) j -pctx -> j l o )  pctx ->dy ; 342 i f ( d==1) y += 0 . 5  pctx ->dy ; 343 } 344 du=pmean->ur  pmean->a  pow ( y/pmean->zr , pmean->a - 1)/pmean-> z r ; 345 switch ( d ) 346 { 347 case 0 : 348 return du  pmean-> d i r x ; 349 break ; 350 case 2 : 351 return du  pmean-> d i r z ; 352 break ; 353 }; 354 } 355 return 0 . 0 ; 356 357 } 358 359 P e t s c E r r o r C o d e I n i t i a l i z e P o w e r P r o f i l e M e a n ( void  vpctx ) 360 { 361 a p p c t x  p c t x =( a p p c t x  ) vpctx ; 362 PetscInt d ; 363 P e t s c R e a l rho , c ; 364 PetscReal invlen ; 365 p o w e r p r o f i l e p a r a m e t e r s  pmean=( p o w e r p r o f i l e p a r a m e t e r s  ) pctx ->pmean ; 366 367 a s s e r t ( pctx ) ; 368 a s s e r t ( pmean ) ; 369 370 c=GetSpeedOfSound ( pctx -> p r o p e r t i e s ) ; 371 rho=GetDensity ( pctx -> p r o p e r t i e s ) ; 372 373 pctx -> c a l c k a p p a=P o w e r P r o f i l e k a p p a ; 374 pctx -> c a l c b=P o w e r P r o f i l e b ; 375 pctx -> c a l c v=P o w e r P r o f i l e v ; 376 pctx -> c a l c d v d x=P o w e r P r o f i l e d v ; 377 pctx -> c a l c d v d y=P o w e r P r o f i l e d v ; 378 pctx -> c a l c d v d z=P o w e r P r o f i l e d v ; 379 pmean->b =1.0/ rho ; 380 pmean->kappa=rho  c  c ; 381 i n v l e n =1.0/ s q r t ( pmean-> d i r x  pmean-> d i r x+ 382 pmean-> d i r z  pmean-> d i r z ) ; 383 384 P e t s c P r i n t f (PETSC COMM WORLD, " I n i t i a l i z i n g power law p r o f i l e mean f l o w : \ n" ) ; 385 P e t s c P r i n t f (PETSC COMM WORLD, " u=%g m/ s a t h e i g h t %g m i n %g ,%g d i r e c t i o n . \ n" , pmean-> ur , pmean->zr , pmean->d i r x , pmean-> d i r z ) ; 386 P e t s c P r i n t f (PETSC COMM WORLD, " kappa=%g b=%g . \ n" , pmean->kappa , pmean->b ) ; 387

116

APPENDIX 3. SOURCE CODE
388 return 0 ; 389 }

3.8. ODE.H

3.8
1 2 3 4 5 6 7 8 9

ode.h

#i f n d e f ODE H #define ODE H #include " p e t s c . h" #include " p e t s c d a . h" /  ! \ f i l e ode . h \ b r i e f ODE d e f i n i t i o n and a p p l i c a t i o n c o n t e x t .

This h e a d e r f i l e d e f i n e s t h e a p p l i c a t i o n c o n t e x t ( f o r p a s s i n g p a r a m e t e r s t o v a r i o u s PETSc r o u t i n e s ) and d e c l a r e s t h e f u n c t i o n s f o r f o r m i n g t h e RHS o f t h e i n i t i a l v a l u e problem . 10  / 11 12 #include "param . h" 13 14 /  ! \ b r i e f The a p p l i c a t i o n c o n t e x t . 15 16 This s t r u c t u r e i s used t o p a s s p a r a m e t e r s and f u n c t i o n s t o PETSc TS f u n c t i o n s . Note t h a t f u n c t i o n s a r e p a s s e d as p o i n t e r t o f u n c t i o n s . 17  / 18 typedef struct { 19 / P e t s c l o g e v e n t s / 20 i n t SetupEvent , FormODEEvent , C a l c S o u r c e E v e n t ; 21 // i n t FormJacobianEvent ; 22 /  Runtime parameter s u p p o r t . S t o r e d h e r e f o r c h e c k p o i n t i n g / s i g n a l h a n d l i n g  / 23 PetscBag bag ; /  ! < Parameter s t o r a g e  / 24 25 /  Source term c a l c u l a t o r  / 26 P e t s c E r r o r C o d e (  I n i t S o u r c e ) ( void  ) ; /  ! < Source term i n i t i a l i z a t i o n f x n .  / 27 void (  C a l c u l a t e S o u r c e ) ( P e t s c R e a l t , Vec v , void  ) ; /  ! < C a l c u l a t e s o u r c e s a t time t , s t o r e i n v . / 28 P e t s c R e a l (  GetSourceLowestFrequency ) ( void  ) ; /  ! < Get l o w e s t f r e q u e n c y o f s o u r c e .  / 29 P e t s c R e a l (  G e t S o u r c e H i g h e s t F r e q u e n c y ) ( void  ) ; /  ! < Get l o w e s t f r e q u e n c y o f s o u r c e .  / 30 P e t s c R e a l (  G e t O r i g i n ) ( void  , P e t s c I n t i ) ; /  ! < Get s o u r c e o r i g i n i n domain .  / 31 P e t s c E r r o r C o d e (  D e s t r o y S o u r c e ) ( void  ) ; /  ! < Source term d e a l l o c a t i o n f x n .  / 32 PetscBag s o u r c e b a g ; /  ! < Source term parameter s t o r a g e .  / 33 void  p s o u r c e ; /  ! < Ptr t o s o u r c e s t r u c t .  / 34 35 /  Common f l u i d p r o p e r t i e s  / 36 PetscBag pbag ; / !< F l u i d p r o p e r t i e s s t o r a g e / 37 fluid properties  properties ; /  ! < Ptr t o f l u i d p r o p e r t i e s s t r u c t  / 38 39 /  Mean f l o w c a l c u l a t o r s ( on-demand )  / 40 P e t s c E r r o r C o d e (  InitMeanFlow ) ( void  ) ; /  ! < I n i t i a l i z e mean f l o w  /

117

3.8. ODE.H
41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64

APPENDIX 3. SOURCE CODE

PetscBag meanbag ; /  ! < Mean f l o w parameter s t o r a g e  / void  pmean ; /  ! < Ptr t o mean f l o w s t r u c t  / /  ! Get \ f $ \ kappa \ f $ f o r mesh l o c a t i o n \ f $ ( i , j , k ) \ f $ , c o r r e s p o n d i n g t o l o c a t i o n \ f $ ( x , y , z ) \ f $ . / P e t s c R e a l (  c a l c k a p p a ) ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , void  p c t x ) ; /  ! Get \ f $ b \ f $ f o r mesh l o c a t i o n \ f $ ( i , j , k ) \ f $ , c o r r e s p o n d i n g t o l o c a t i o n \ f $ ( x , y , z ) \ f $ . / P e t s c R e a l (  c a l c b ) ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , void  p c t x ) ; /  ! Get mean f l o w v e l o c i t y component \ f $ v d \ f $ f o r mesh l o c a t i o n \ f $ ( i , j , k ) \ f $ , o f f e s t a c c o r d i n g l y . For example , \ f $ v x \ f $ i s l o c a t e d a t \ f $ ( x+dx /2 , y , z ) \ f $ .  / P e t s c R e a l (  c a l c v ) ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , P e t s c I n t d , void  p c t x ) ; /  ! Get \ f $ \ f r a c {\ p a r t i a l v d }{\ p a r t i a l x }\ f $ f o r mesh l o c a t i o n \ f $ ( i , j , k ) \ f $ , o f f s e t a c c o r d i n g l y . For example , \ f $ v x \ f $ i s l o c a t e d a t \ f $ ( x+dx /2 , y , z ) \ f $ .  / P e t s c R e a l (  c a l c d v d x ) ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , P e t s c I n t d , P e t s c I n t dd , void  pctx ) ; /  ! Get \ f $ \ f r a c {\ p a r t i a l v d }{\ p a r t i a l y }\ f $ f o r mesh l o c a t i o n \ f $ ( i , j , k ) \ f $ , o f f s e t a c c o r d i n g l y . For example , \ f $ v x \ f $ i s l o c a t e d a t \ f $ ( x+dx /2 , y , z ) \ f $ .  / P e t s c R e a l (  c a l c d v d y ) ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , P e t s c I n t d , P e t s c I n t dd , void  pctx ) ; /  ! Get \ f $ \ f r a c {\ p a r t i a l v d }{\ p a r t i a l z }\ f $ f o r mesh l o c a t i o n \ f $ ( i , j , k ) \ f $ , o f f s e t a c c o r d i n g l y . For example , \ f $ v x \ f $ i s l o c a t e d a t \ f $ ( x+dx /2 , y , z ) \ f $ .  / P e t s c R e a l (  c a l c d v d z ) ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , P e t s c I n t d , P e t s c I n t dd , void  pctx ) ; /  A b s o r b i n g boundary c o n d i t i o n r e g i o n ( on-demand )  / P e t s c E r r o r C o d e (  InitBC ) ( void  ) ; /  ! < I n i t i a l i z e boundary c o n d i t i o n s  / PetscBag bcbag ; /  ! < BC parameter s t o r a g e  / void  pbc ; /  ! < Ptr t o BC s t r u c t  / /  ! Get \ f $ \ k a p p a e \ f $ i n ABC r e g i o n f o r mesh l o c a t i o n \ f $ ( i , j , k ) \ f $ , c o r r e s p o n d i n g t o l o c a t i o n \ f $ ( x , y , z ) \ f $ . / P e t s c R e a l (  c a l c k a p p a e ) ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , void  p c t x ) ; /  ! Get \ f $ b e \ f $ i n ABC r e g i o n f o r mesh l o c a t i o n \ f $ ( i , j , k ) \ f $ , c o r r e s p o n d i n g t o l o c a t i o n \ f $ ( x , y , z ) \ f $ . / P e t s c R e a l (  c a l c b e ) ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , void  p c t x ) ; /  ! Get \ f $ s e \ f $ i n ABC r e g i o n f o r mesh l o c a t i o n \ f $ ( i , j , k ) \ f $ , c o r r e s p o n d i n g t o l o c a t i o n \ f $ ( x , y , z ) \ f $ . / P e t s c R e a l (  c a l c s e ) ( P e t s c I n t i , P e t s c I n t j , P e t s c I n t k , void  p c t x ) ;

65 66 67 /  ! G l o b a l runtime p a r a m e t e r s  / 68 p a r a m e t e r s  params ; 69 70 /  Dimensions o f t h e domain  / 71 /  ! Mesh s p a c i n g i n \ f $ x \ f $  / 72 P e t s c R e a l dx ; 73 /  ! Mesh s p a c i n g i n \ f $ y \ f $  / 74 P e t s c R e a l dy ; 75 /  ! Mesh s p a c i n g i n \ f $ z \ f $  / 76 P e t s c R e a l dz ; 77 /  ! I n v e r s e o f mesh s p a c 78 i n g  /

118

APPENDIX 3. SOURCE CODE
79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 P e t s c R e a l invdx , invdy , i n v d z ; /  ! L o c a l l o w e r and upper l i m i t s o f t h e mesh  / PetscInt i l o , i hi , j lo , j hi , k lo , k hi ; /  ! PETSc d i s t r i b u t e d a r r a y  / DA da ; /  Ground-p l a n e sound p r e s s u r e l e v e l s , sound power l e v e l s  / PetscTru th I n t e g r a t i o n S t a r t e d , S a v e T r a n s i e n t P r e s s u r e , S a v e T r a n s i e n t , DoProbe , I n t e n s i t y S t a r t e d , MaxAbsPressure ; DA dagp , dagw ; V e c S c a t t e r groundp , groundw ; Vec prms , I , c u r r p , currw , pmaxabs ; PetscScalar tstart , tlast , dtlast ; PetscInt rms slice ; P e t s c R e a l RMSProbeDistance ; PetscInt probe li , probe lj ; P e t s c R e a l probe w [ 2 ] [ 2 ] ; /  I n t e g r a t i o n o f power a l o n g e x t e r i o r o f i n t e r i o r domain , t r a c k i n g o f power h i s t o r y , t r a c k i n g of probe pressure h i s t o r y / P e t s c I n t NHistory , H i s t o r y A l l o c L e n ; P e t s c R e a l SWL,  t H i s t o r y ,  PowerHistory ,  p H i s t o r y ;

3.8. ODE.H

/  C h e c k p o i n t / Terminate s u p p o r t  / PetscTru th c h e c k p o i n t , t e r m i n a t e ; /  Monitor s u p p o r t  / PetscLogDouble A v g S e c o n d s P e r I t e r ; } app ctx ;

/  ! I n i t i a l i z e t h e s o l u t i o n v e c t o r f o r \ f $ t =0\ f $ .  / void I n i t i a l i z e S o l u t i o n ( Vec s o l u t i o n , app ctx  pctx ) ; /  ! S e t u p t h e ODE problem , i f n e c e s s a r y  / void SetupODE ( a p p c t x  p c t x ) ; /  ! \ b r i e f Form t h e RHS o f t h e ODE. Form t h e RHS o f t h e ODE a t time \ f $ t \ f $ , u s i n g t h e c u r r e n t s o l u t i o n v e c t o r \ f $ u \ f $ , s t o r i n g t h e r e s u l t s i n t h e r e s i d u a l v e c t o r \ f$R \ f $ . Note t h a t t h e s o l u t i o n and r e s i d u a l v e c t o r a r e b l o c k v e c t o r s , where each b l o c k r e p r e s e n t s mesh l o c a t i o n \ f $ ( i , j , k ) \ f $ . Each b l o c k o f t h e s o l u t i o n v e c t o r r e p r e s e n t s a c o u s t i c p r e s s u r e and v e l o c i t y components \ f $ [ p , w x , w y , w z ] \ f $ . Note

119

3.8. ODE.H

APPENDIX 3. SOURCE CODE

t h a t t h e mesh i s s t a g g a r d i n s p a c e . The p r e s s u r e v a l u e a t mesh l o c a t i o n \ f $ ( i , j , k ) \ f $ r e p r e s e n t s l o c a t i o n \ f $ ( x , y , z ) \ f$ , w h i l e \ f$w x \ f $ r e p r e s e n t s the a c o u s t i c s p e e d i n t h e \ f $ x \ f $ d i r e c t i o n a t l o c a t i o n \ f $ ( x+dx /2 , y , z ) \ f $ . S i m i l a r i l y , \ f $ w y \ f $ r e p r e s e n t s t h e a c o u s t i c s p e e d i n t h e \ f $ y \ f $ d i r e c t i o n a t l o c a t i o n \ f $ ( x , y+dy /2 , z ) \ f $ , w h i l e \ f $ w z \ f $ r e p r e s e n t s t h e a c o u s t i c s p e e d i n t h e \ f $ z \ f $ d i r e c t i o n a t \ f $ ( x , y , z+dz /2) \ f $ . 125 126 127 128 The r e s i d u a l v e c t o r (RHS) i s a s s e m b l e d as f o l l o w s f o r i n t e r i o r p o i n t s i n t h e mesh . \ f { e q n a r r a y  }{ R { i , j , k } [ 0 ] &=&\ f r a c {\ p a r t i a l p }{\ p a r t i a l t }= - \ l e f t ( v x \ f r a c {\ p a r t i a l }{\ p a r t i a l x }+ v y \ f r a c {\ p a r t i a l }{\ p a r t i a l y }+ v z \ f r a c {\ p a r t i a l }{\ p a r t i a l z }\ r i g h t ) p - \ kappa \ l e f t ( \ f r a c {\ p a r t i a l w x }{\ p a r t i a l x }+ \ f r a c {\ p a r t i a l w y }{\ p a r t i a l y }+\ f r a c {\ p a r t i a l w z }{\ p a r t i a l z }\ r i g h t ) + \ kappa Q\\ R { i , j , k } [ 1 ] &=&\ f r a c {\ p a r t i a l w x }{\ p a r t i a l t }= - \ l e f t ( w x \ f r a c {\ p a r t i a l }{\ p a r t i a l x }+w y \ f r a c {\ p a r t i a l }{\ p a r t i a l y }+w z \ f r a c {\ p a r t i a l }{\ p a r t i a l z }\ r i g h t ) v x -\ l e f t ( v x \ f r a c {\ p a r t i a l }{\ p a r t i a l x }+v y \ f r a c {\ p a r t i a l }{\ p a r t i a l y }+ v z \ f r a c {\ p a r t i a l }{\ p a r t i a l z }\ r i g h t ) w x -b \ f r a c {\ p a r t i a l p }{\ p a r t i a l x } + b F x \\ R { i , j , k } [ 2 ] &=&\ f r a c {\ p a r t i a l w y }{\ p a r t i a l t }= - \ l e f t ( w x \ f r a c {\ p a r t i a l }{\ p a r t i a l x }+w y \ f r a c {\ p a r t i a l }{\ p a r t i a l y }+w z \ f r a c {\ p a r t i a l }{\ p a r t i a l z }\ r i g h t ) v y -\ l e f t ( v x \ f r a c {\ p a r t i a l }{\ p a r t i a l x }+v y \ f r a c {\ p a r t i a l }{\ p a r t i a l y }+ v z \ f r a c {\ p a r t i a l }{\ p a r t i a l z }\ r i g h t ) w y -b \ f r a c {\ p a r t i a l p }{\ p a r t i a l y } + b F y \\ R { i , j , k } [ 3 ] &=&\ f r a c {\ p a r t i a l w z }{\ p a r t i a l t }= - \ l e f t ( w x \ f r a c {\ p a r t i a l }{\ p a r t i a l x }+w y \ f r a c {\ p a r t i a l }{\ p a r t i a l y }+w z \ f r a c {\ p a r t i a l }{\ p a r t i a l z }\ r i g h t ) v z -\ l e f t ( v x \ f r a c {\ p a r t i a l }{\ p a r t i a l x }+v y \ f r a c {\ p a r t i a l }{\ p a r t i a l y }+ v z \ f r a c {\ p a r t i a l }{\ p a r t i a l z }\ r i g h t ) w z -b \ f r a c {\ p a r t i a l p }{\ p a r t i a l z } + b F z \\ \ kappa &=& \ rho c ^2 \\ b &=& \ f r a c { 1 }{\ rho }\\ \f} For a b s o r b i n g boundary c o n d i t i o n (ABC) r e g i o n s o f t h e mesh , t h e r e s i d u a l v e c t o r i s a s s e m b l e d as f o l l o w s . \ f { e q n a r r a y  }{ R { i , j , k } [ 0 ] &=&\ f r a c {\ p a r t i a l p }{\ p a r t i a l t }= - \ k a p p a e \ l e f t ( \ f r a c {\ p a r t i a l w x }{\ p a r t i a l x }+\ f r a c {\ p a r t i a l w y }{\ p a r t i a l y }+\ f r a c {\ p a r t i a l w z }{\ p a r t i a l z }\ r i g h t ) \\ R { i , j , k } [ 1 ] &=&\ f r a c {\ p a r t i a l w x }{\ p a r t i a l t }= - s e w x - b e \ f r a c {\ p a r t i a l p }{\ p a r t i a l x }\\ R { i , j , k } [ 2 ] &=&\ f r a c {\ p a r t i a l w y }{\ p a r t i a l t }= - s e w y - b e \ f r a c {\ p a r t i a l p }{\ p a r t i a l y }\\ R { i , j , k } [ 3 ] &=&\ f r a c {\ p a r t i a l w z }{\ p a r t i a l t }= - s e w z - b e \ f r a c {\ p a r t i a l p }{\ p a r t i a l z }\\ \ k a p p a e &=& \ f r a c {\ rho c ^2 }{\ gamma \ Omega }\\ b e &=& \ f r a c { 1 }{\ r h o e }\\ s e &=& \ f r a c {\ sigma }{\ r h o e }\\ \f} See bc . h and s o u r c e . h f o r more i n f o r m a t i o n . For r e f l e c t i n g ground , t h e s p a t i a l d e r i v a t i v e s and s o l u t i o n v a l u e s a c r o s s t h e r e f l e c t i n g plane are a d j u s t e d to p r e s e r v e r e f l e c t i o n p r o p e r t i e s . a

129

130

131

132 133 134 135 136 137 138

139 140 141 142 143 144 145 146 147 148 149

120

APPENDIX 3. SOURCE CODE
150

3.8. ODE.H

Note t h a t t h e a b o v e s p a t i a l d e r i v a t i v e s a r e c u r r e n t l y a p p r o x i m a t e d u s i n g second -o r d e r c e n t e r e d d i f f e r e n c e s , e x c e p t a t t h e b o u n d a r i e s o f t h e mesh where \ f $ p=w x=w y=w z =0\ f $ i s assumed o u t s i d e t h e domain boundary . / P e t s c E r r o r C o d e FormODE(TS t s , PetscReal t , / !< Vec s o l u t i o n , / !< Vec r e s i d u a l , / !< void  vpctx / !< ); /  ! < [ i n ] PETSc T i m e s t e p p e r  / [ i n ] time ( s )  / [ i n ] c u r r e n t s o l u t i o n / [ o u t ] r e s i d u a l v e c t o r / [ i n ] a p p l i c a t i o n c o n t e x t /

151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197

/  ! Determine i f mesh l o c a t i o n i s w i t h i n i n t e r i o r r e g i o n .  / Pe tscTru th I n t e r i o r R e g i o n ( a p p c t x  pctx , PetscInt i , PetscInt j , PetscInt k) ; /  ! Determine i f mesh l o c a t i o n i s w i t h i n r e f l e c t i o n r e g i o n .  / Pe tscTru th R e f l e c t i o n R e g i o n ( a p p c t x  pctx , PetscInt i , PetscInt j , PetscInt k) ; /  ! Determine i f mesh l o c a t i o n i s w i t h i n ABC r e g i o n .  / Pe tscTru th AbsorbingBCRegion ( a p p c t x  pctx , PetscInt i , PetscInt j , PetscInt k) ; /  ! Determine i f mesh i s two-d i m e n s i o n a l  / Pe tscTru th TwoDimensional ( a p p c t x  p c t x ) ; /  ! Determine i f a t l o w e s t i i n d e x o f mesh .  / Pe tscTru th ILowFace ( a p p c t x  pctx , PetscInt i , PetscInt j , PetscInt k) ; /  ! Determine i f a t l o w e s t j i n d e x o f mesh .  / Pe tscTru th JLowFace ( a p p c t x  pctx , PetscInt i , PetscInt j , PetscInt k) ; /  ! Determine i f a t l o w e s t k i n d e x o f mesh .  / Pe tscTru th KLowFace ( a p p c t x  pctx , PetscInt i , PetscInt j , PetscInt k) ;

121

3.9. ODE.C
198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 /  ! Determine i f a t h i g h e s t i i n d e x o f mesh .  / Pets cTru th IHighFace ( a p p c t x  pctx , PetscInt i , PetscInt j , PetscInt k) ; /  ! Determine i f a t h i g h e s t j i n d e x o f mesh .  / Pets cTru th JHighFace ( a p p c t x  pctx , PetscInt i , PetscInt j , PetscInt k) ; /  ! Determine i f a t h i g h e s t k i n d e x o f mesh .  / Pets cTru th KHighFace ( a p p c t x  pctx , PetscInt i , PetscInt j , PetscInt k) ; #endif

APPENDIX 3. SOURCE CODE

3.9
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27

ode.c

#include <math . h> #include < a s s e r t . h> #include < s t d l i b . h> #include < p e t s c . h> #include <ode . h> void I n i t i a l i z e S o l u t i o n ( Vec s o l u t i o n , app ctx  pctx ) { PetscInt i , j ; / I n i t i a l c o n d i t i o n s a r e z e r o e v e r y w h e r e / VecSet ( s o l u t i o n , 0 . 0 ) ; } void SetupODE ( a p p c t x  p c t x ) { } P e t s c E r r o r C o d e FormODE(TS t s , PetscReal t , Vec s o l u t i o n , Vec r e s i d u a l , void  vpctx ) { a p p c t x  p c t x =( a p p c t x  ) ( vpctx ) ; P e t s c I n t i , j , k , d , dof , Nx , Ny , Nz , sx , sy , sz , mx, my, mz ;

122

APPENDIX 3. SOURCE CODE
28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 Vec l o c a l ; P e t s c S c a l a r  s ; P e t s c S c a l a r  r ; a s s e r t ( pctx ) ; PetscLogEventBegin ( pctx ->FormODEEvent , 0 , 0 , 0 , 0 ) ; /  Assemble t h e r e s i d u a l v e c t o r , which i s a l r e a d y a l o c a l v e c t o r  / /  Zero r e s i d u a l v e c t o r  / VecSet ( r e s i d u a l , 0 . 0 ) ; /  Borrow l o c a l v e c t o r r e p r e s e n t a t i o n from DA  / DAGetLocalVector ( pctx ->da ,& l o c a l ) ; /  Determine g l o b a l mesh n o d a l e x t e n t s  / DAGetInfo ( pctx ->da , PETSC IGNORE,&Nx,&Ny,&Nz , PETSC IGNORE, PETSC IGNORE, PETSC IGNORE, &dof , PETSC IGNORE, PETSC IGNORE, PETSC IGNORE) ; /  Gather from g l o b a l s o l u t i o n t o l o c a l , e n s u r e g h o s t s a r e up-to -d a t e  / DAGlobalToLocalBegin ( pctx ->da , s o l u t i o n , INSERT VALUES , l o c a l ) ; DAGlobalToLocalEnd ( pctx ->da , s o l u t i o n , INSERT VALUES , l o c a l ) ; /  Grab t h e a r r a y r e p r e s e n t a t i o n o f t h e l o c a l s o l u t i o n and r e s i d u a l v e c t o r s / DAVecGetArrayDOF ( pctx ->da , l o c a l ,& s ) ; DAVecGetArrayDOF ( pctx ->da , r e s i d u a l ,& r ) ; /  Get l o c a l g r i d b o u n d a r i e s , which a r e i n d e p e n d e n t o f d o f  / DAGetCorners ( pctx ->da ,& sx ,& sy ,& sz ,&mx,&my,&mz) ; /  F i l l i n r e s i d u a l v e c t o r w i t h s o u r c e terms Q, F t o s a v e memory .  / i f ( pctx -> C a l c u l a t e S o u r c e ) (  pctx -> C a l c u l a t e S o u r c e ) ( t , r e s i d u a l , vpctx ) ;

3.9. ODE.C

/  To a v o i d a n u m e r i c a l problem r e f e r r e d t o as odd-even d e c o u p l i n g , t h e s p a t i a l d i s c r e t i z a t i o n o f t h e s o l u t i o n i s s t o r e d u s i n g a s t a g g e r e d mesh . The s o l u t i o n i s s t o r e d w i t h i n one b l o c k a r r a y b u t r e p r e s e n t s a s t a g g e r e d mesh . p , b , kappa , Q a r e s t o r e d a t w h o l e mesh nodes , which r e p r e s e n t l o c a t i o n s ( x=i  dx , y= j  dy , z=k  dz ) . vx , vy , vz , wx , wy , wz , Fx , Fy , Fz a r e s t o r e d a t h a l f nodes which r e p r e s e n t t h e s o l u t o n a t l o c a t i o n s ( x=( i +1/2)  dx , y=( j +1/2)  dy , z =(k +1/2)  dz ) . Thus s o l u t i o n i s a b l o c k v e c t o r which can be i n d e x e d u s i n g DAVecGetArray , which can be i n d e x e d as s [ k ] [ j ] [ i ] [ d ] f o r t h e s o l u t i o n a t node ( i , j , k ) , e q u a t i o n d . As wx , vx , Fx , e t c a r e s t o r e d i n t h e same array , t h e ( i , j , k ) t h b l o c k e n t r y o f t h e v e c t o r r e p r e s e n t s t h e s o l u t i o n p ( i  dx , j  dy , k  dz ) , wx ( ( i +1/2)  dx , j  dy , k  dz ) , wy (

69 70

123

3.9. ODE.C
i  dx , ( j +1/2)  dy , k  dz ) , wz ( i  dx , j  dy , ( k +1/2)  dz ) . 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 /

APPENDIX 3. SOURCE CODE

This means t h e r e i s a band o f nodes a l o n g i =0, j =0 and k=0 where no wx , wy , and wz a r e known .

/  Macros t o make code more r e a d a b l e  / /  b a t h a l f node l o c a t i o n s  / #define b i 2 ( i , j , k ) ( 0 . 5  ( pctx -> c a l c b ( i +1 , j , k , vpctx )+pctx -> c a l c b ( i , j , k , vpctx ) ) ) #define b j 2 ( i , j , k ) ( 0 . 5  ( pctx -> c a l c b ( i , j +1 ,k , vpctx )+pctx -> c a l c b ( i , j , k , vpctx ) ) ) #define bk2 ( i , j , k ) ( 0 . 5  ( pctx -> c a l c b ( i , j , k+1 , vpctx )+pctx -> c a l c b ( i , j , k , vpctx ) ) ) #define BI2FLOPS 2 #define BJ2FLOPS 2 #define BK2FLOPS 2 /  be #define #define #define / s e #define #define #define #define #define #define a t h a l f node l o c a t i o n s , s t o r e d i n b  / b e i 2 ( i , j , k ) ( 0 . 5  ( pctx -> c a l c b e ( i +1 , j , k , vpctx )+pctx -> c a l c b e ( i , j , k , vpctx ) ) ) b e j 2 ( i , j , k ) ( 0 . 5  ( pctx -> c a l c b e ( i , j +1 ,k , vpctx )+pctx -> c a l c b e ( i , j , k , vpctx ) ) ) bek2 ( i , j , k ) ( 0 . 5  ( pctx -> c a l c b e ( i , j , k+1 , vpctx )+pctx -> c a l c b e ( i , j , k , vpctx ) ) ) a t h a l f node l o c a t i o n s , s t o r e d i n s e  / s e i 2 ( i , j , k ) ( 0 . 5  ( pctx -> c a l c s e ( i +1 , j , k , vpctx )+pctx -> c a l c s e ( i , j , k , vpctx ) ) ) s e j 2 ( i , j , k ) ( 0 . 5  ( pctx -> c a l c s e ( i , j +1 ,k , vpctx )+pctx -> c a l c s e ( i , j , k , vpctx ) ) ) s e k 2 ( i , j , k ) ( 0 . 5  ( pctx -> c a l c s e ( i , j , k+1 , vpctx )+pctx -> c a l c s e ( i , j , k , vpctx ) ) ) SEI2FLOPS 2 SEJ2FLOPS 2 SEK2FLOPS 2

/  kappa , kappa e , Q a t w h o l e node l o c a t i o n  / #define kappa ( i , j , k ) ( pctx -> c a l c k a p p a ( i , j , k , vpctx ) ) #define kappae ( i , j , k ) ( pctx -> c a l c k a p p a e ( i , j , k , vpctx ) ) /  vx , vy , v z a t w h o l e node l o c a t i o n s  / #define vx ( i , j , k ) ( 0 . 5  ( pctx -> c a l c v ( i , j , k , 0 , vpctx )+pctx -> c a l c v ( i - 1 , j , k , 0 , vpctx ) ) ) #define vy ( i , j , k ) ( 0 . 5  ( pctx -> c a l c v ( i , j , k , 1 , vpctx )+pctx -> c a l c v ( i , j - 1 ,k , 1 , vpctx ) ) ) #define v y r e f l e c t ( i , j , k ) ( 0 . 0 ) #define vz ( i , j , k ) ( 0 . 5  ( pctx -> c a l c v ( i , j , k , 2 , vpctx )+pctx -> c a l c v ( i , j , k - 1 ,2 , vpctx ) ) ) #define VXFLOPS 2 #define VYFLOPS 2 #define VZFLOPS 2 /  px , py , pz a t w h o l e node l o c a t i o n s  / #define px ( i , j , k ) ( 0 . 5  ( s [ k ] [ j ] [ i +1][0] - s [ k ] [ j ] [ i - 1 ] [ 0 ] )  pctx ->invdx ) //#d e f i n e p x i l o ( i , j , k ) ( ( s [ k ] [ j ] [ i +1][0] - s [ k ] [ j ] [ i ] [ 0 ] )  p c t x ->i n v d x ) //#d e f i n e p x i h i ( i , j , k ) ( ( s [ k ] [ j ] [ i ] [ 0 ] - s [ k ] [ j ] [ i - 1 ] [ 0 ] )  p c t x ->i n v d x ) #define p x i l o ( i , j , k ) ( 0 . 5  ( s [ k ] [ j ] [ i + 1 ] [ 0 ] - 0 )  pctx ->invdx ) #define p x i h i ( i , j , k ) ( 0 . 5  ( 0 - s [ k ] [ j ] [ i - 1 ] [ 0 ] )  pctx ->invdx ) #define py ( i , j , k ) ( 0 . 5  ( s [ k ] [ j + 1 ] [ i ] [ 0 ] - s [ k ] [ j - 1 ] [ i ] [ 0 ] )  pctx ->invdy ) #define p y r e f l e c t ( i , j , k ) ( 0 . 5  ( s [ k ] [ j + 1 ] [ i ] [ 0 ] - s [ k ] [ j ] [ i ] [ 0 ] )  pctx ->invdy ) #define pz ( i , j , k ) ( 0 . 5  ( s [ k + 1 ] [ j ] [ i ] [ 0 ] - s [ k - 1 ] [ j ] [ i ] [ 0 ] )  pctx ->i n v d z )

124

APPENDIX 3. SOURCE CODE
119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 //#d e f i n e p z k l o ( i , j //#d e f i n e p z k h i ( i , j #define p z k l o ( i , j , k ) #define p z k h i ( i , j , k ) #define PXFLOPS 3 #define PYFLOPS 3 #define PZFLOPS 3 , k ) ( ( s [ k + 1 ] [ j ] [ i ] [ 0 ] - s [ k ] [ j ] [ i ] [ 0 ] )  p c t x -> i n v d z ) , k ) ( ( s [ k ] [ j ] [ i ] [ 0 ] - s [ k - 1 ] [ j ] [ i ] [ 0 ] )  p c t x -> i n v d z ) ( 0 . 5  ( s [ k + 1 ] [ j ] [ i ] [ 0 ] - 0 )  pctx ->i n v d z ) ( 0 . 5  ( 0 - s [ k - 1 ] [ j ] [ i ] [ 0 ] )  pctx ->i n v d z )

3.9. ODE.C

/  wxx , wyy , wzz a t w h o l e node l o c a t i o n s  / #define wxx ( i , j , k ) ( ( s [ k ] [ j ] [ i ] [ 1 ] - s [ k ] [ j ] [ i - 1 ] [ 1 ] )  pctx ->invdx ) //#d e f i n e w x x i l o ( i , j , k ) ( ( s [ k ] [ j ] [ i +1][1] - s [ k ] [ j ] [ i ] [ 1 ] )  p c t x ->i n v d x ) #define w x x i l o ( i , j , k ) ( ( s [ k ] [ j ] [ i ] [ 1 ] - 0 )  pctx ->invdx ) #define wyy ( i , j , k ) ( ( s [ k ] [ j ] [ i ] [ 2 ] - s [ k ] [ j - 1 ] [ i ] [ 2 ] )  pctx ->invdy ) //#d e f i n e w y y j l o ( i , j , k ) ( ( s [ k ] [ j + 1 ] [ i ] [ 2 ] - s [ k ] [ j ] [ i ] [ 2 ] )  p c t x ->i n v d y ) #define w y y j l o ( i , j , k ) ( ( s [ k ] [ j ] [ i ] [ 2 ] - 0 )  pctx ->invdy ) #define w y y r e f l e c t ( i , j , k ) ( ( 2  s [ k ] [ j ] [ i ] [ 2 ] )  pctx ->invdy ) #define wzz ( i , j , k ) ( ( s [ k ] [ j ] [ i ] [ 3 ] - s [ k - 1 ] [ j ] [ i ] [ 3 ] )  pctx ->i n v d z ) //#d e f i n e w z z k l o ( i , j , k ) ( ( s [ k + 1 ] [ j ] [ i ] [ 3 ] - s [ k ] [ j ] [ i ] [ 3 ] )  p c t x -> i n v d z ) #define w z z k l o ( i , j , k ) ( ( s [ k ] [ j ] [ i ] [ 3 ] - 0 )  pctx ->i n v d z ) #define WXXFLOPS 2 #define WYYFLOPS 2 #define WZZFLOPS 2 /  px , py , pz a t h a l f node l o c a t i o n s  / #define p x i 2 ( i , j , k ) ( ( s [ k ] [ j ] [ i +1][0] - s [ k ] [ j ] [ i ] [ 0 ] )  pctx ->invdx ) //#d e f i n e p x i 2 i h i ( i , j , k ) ( ( s [ k ] [ j ] [ i ] [ 0 ] - s [ k ] [ j ] [ i - 1 ] [ 0 ] )  p c t x ->i n v d x ) #define p x i 2 i h i ( i , j , k ) ((0 - s [ k ] [ j ] [ i ] [ 0 ] )  pctx ->invdx ) #define p y j 2 ( i , j , k ) ( ( s [ k ] [ j + 1 ] [ i ] [ 0 ] - s [ k ] [ j ] [ i ] [ 0 ] )  pctx ->invdy ) //#d e f i n e p y j 2 j h i ( i , j , k ) ( ( s [ k ] [ j ] [ i ] [ 0 ] - s [ k ] [ j - 1 ] [ i ] [ 0 ] )  p c t x ->i n v d y ) #define p y j 2 j h i ( i , j , k ) ((0 - s [ k ] [ j ] [ i ] [ 0 ] )  pctx ->invdy ) #define pzk2 ( i , j , k ) ( ( s [ k + 1 ] [ j ] [ i ] [ 0 ] - s [ k ] [ j ] [ i ] [ 0 ] )  pctx ->i n v d z ) //#d e f i n e p z k 2 k h i ( i , j , k ) ( ( s [ k ] [ j ] [ i ] [ 0 ] - s [ k - 1 ] [ j ] [ i ] [ 0 ] )  p c t x -> i n v d z ) #define p z k 2 k h i ( i , j , k ) ( ( 0 . 0 - s [ k ] [ j ] [ i ] [ 0 ] )  pctx ->i n v d z ) #define PXI2FLOPS 2 #define PYJ2FLOPS 2 #define PZK2FLOPS 2 /  vx , vy , v z a t ( i +1/2 , j , k ) h a l f node l o c a t i o n s  / #define v x i 2 ( i , j , k ) ( pctx -> c a l c v ( i , j , k , 0 , vpctx ) ) #define v y i 2 ( i , j , k ) ( 0 . 2 5  ( pctx -> c a l c v ( i , j , k , 1 , vpctx )+pctx -> c a l c v ( i +1 , j , k , 1 , vpctx )+ pctx -> c a l c v ( i , j - 1 ,k , 1 , vpctx )+pctx -> c a l c v ( i +1 , j - 1 ,k , 1 , vpctx ) ) ) #define v y i 2 r e f l e c t ( i , j , k ) ( 0 . 0 ) #define v z i 2 ( i , j , k ) ( 0 . 2 5  ( pctx -> c a l c v ( i , j , k , 2 , vpctx )+pctx -> c a l c v ( i +1 , j , k , 2 , vpctx )+ pctx -> c a l c v ( i , j , k - 1 ,2 , vpctx )+pctx -> c a l c v ( i +1 , j , k - 1 ,2 , vpctx ) ) ) #define VXI2FLOPS 0 #define VYI2FLOPS 4 #define VZI2FLOPS 4

161 162 163 164 165 /  wx , wy , wz a t ( i +1/2 , j , k ) h a l f node l o c a t i o n s  / 166 #define wxi2 ( i , j , k ) ( s [ k ] [ j ] [ i ] [ 1 ] )

125

3.9. ODE.C

APPENDIX 3. SOURCE CODE

167 #define wyi2 ( i , j , k ) ( 0 . 2 5  ( s [ k ] [ j ] [ i ] [ 2 ] + s [ k ] [ j ] [ i + 1 ] [ 2 ] + s [ k ] [ j - 1 ] [ i ] [ 2 ] + s [ k ] [ j - 1 ] [ i +1][2]) ) 168 #define w y i 2 r e f l e c t ( i , j , k ) ( 0 . 0 ) 169 #define wzi2 ( i , j , k ) ( 0 . 2 5  ( s [ k ] [ j ] [ i ] [ 3 ] + s [ k ] [ j ] [ i + 1 ] [ 3 ] + s [ k - 1 ] [ j ] [ i ] [ 3 ] + s [ k - 1 ] [ j ] [ i +1][3]) ) 170 //#d e f i n e w z i 2 i h i ( i , j , k ) ( 0 . 5  ( s [ k ] [ j ] [ i ] [ 3 ] + s [ k - 1 ] [ j ] [ i ] [ 3 ] ) ) 171 //#d e f i n e w z i 2 k l o ( i , j , k ) ( 0 . 5  ( s [ k ] [ j ] [ i ] [ 3 ] + s [ k ] [ j ] [ i + 1 ] [ 3 ] ) ) 172 //#d e f i n e w z i 2 i h i k l o ( i , j , k ) ( ( s [ k ] [ j ] [ i ] [ 3 ] ) ) 173 #define w z i 2 i h i ( i , j , k ) ( 0 . 2 5  ( s [ k ] [ j ] [ i ] [ 3 ] + 0 + s [ k - 1 ] [ j ] [ i ] [ 3 ] + 0 ) ) 174 #define w z i 2 k l o ( i , j , k ) ( 0 . 2 5  ( s [ k ] [ j ] [ i ] [ 3 ] + s [ k ] [ j ] [ i +1][3]+0+0) ) 175 #define w z i 2 i h i k l o ( i , j , k ) ( 0 . 2 5  ( s [ k ] [ j ] [ i ][3]+0+0+0) ) 176 #define WXI2FLOPS 0 177 #define WYI2FLOPS 4 178 #define WZI2FLOPS 4 179 180 /  vx , vy , v z a t ( i , j +1/2 , k ) h a l f node l o c a t i o n s  / 181 #define v x j 2 ( i , j , k ) ( 0 . 2 5  ( pctx -> c a l c v ( i , j , k , 0 , vpctx )+pctx -> c a l c v ( i , j +1 ,k , 0 , vpctx )+ pctx -> c a l c v ( i - 1 , j +1 ,k , 0 , vpctx )+pctx -> c a l c v ( i - 1 , j , k , 0 , vpctx ) ) ) 182 #define v y j 2 ( i , j , k ) ( pctx -> c a l c v ( i , j , k , 1 , vpctx ) ) 183 #define v z j 2 ( i , j , k ) ( 0 . 2 5  ( pctx -> c a l c v ( i , j , k , 2 , vpctx )+pctx -> c a l c v ( i , j +1 ,k , 2 , vpctx )+ pctx -> c a l c v ( i , j +1 ,k - 1 ,2 , vpctx )+pctx -> c a l c v ( i , j , k - 1 ,2 , vpctx ) ) ) 184 #define VXJ2FLOPS 4 185 #define VYJ2FLOPS 0 186 #define VZJ2FLOPS 4 187 188 /  wx , wy , wz a t ( i , j +1/2 , k ) h a l f node l o c a t i o n s  / 189 #define wxj2 ( i , j , k ) ( 0 . 2 5  ( s [ k ] [ j ] [ i ] [ 1 ] + s [ k ] [ j + 1 ] [ i ] [ 1 ] + s [ k ] [ j + 1 ] [ i - 1 ] [ 1 ] + s [ k ] [ j ] [ i -1][1]) ) 190 //#d e f i n e w x j 2 i l o ( i , j , k ) ( 0 . 5  ( s [ k ] [ j ] [ i ] [ 1 ] + s [ k ] [ j + 1 ] [ i ] [ 1 ] ) ) 191 #define w x j 2 i l o ( i , j , k ) ( 0 . 2 5  ( s [ k ] [ j ] [ i ] [ 1 ] + s [ k ] [ j + 1 ] [ i ] [ 1 ] + 0 + 0 ) ) 192 #define wyj2 ( i , j , k ) ( s [ k ] [ j ] [ i ] [ 2 ] ) 193 #define wzj2 ( i , j , k ) ( 0 . 2 5  ( s [ k ] [ j ] [ i ] [ 3 ] + s [ k ] [ j + 1 ] [ i ] [ 3 ] + s [ k - 1 ] [ j + 1 ] [ i ] [ 3 ] + s [ k - 1 ] [ j ] [ i ][3]) ) 194 //#d e f i n e w z j 2 k l o ( i , j , k ) ( 0 . 5  ( s [ k ] [ j ] [ i ] [ 3 ] + s [ k ] [ j + 1 ] [ i ] [ 3 ] ) ) 195 #define w z j 2 k l o ( i , j , k ) ( 0 . 2 5  ( s [ k ] [ j ] [ i ] [ 3 ] + s [ k ] [ j + 1 ] [ i ] [ 3 ] + 0 + 0 ) ) 196 #define WXJ2FLOPS 4 197 #define WYJ2FLOPS 0 198 #define WZJ2FLOPS 4 199 200 /  vx , vy , v z a t ( i , j , k +1/2) h a l f node l o c a t i o n s  / 201 #define vxk2 ( i , j , k ) ( 0 . 2 5  ( pctx -> c a l c v ( i , j , k , 0 , vpctx )+pctx -> c a l c v ( i - 1 , j , k , 0 , vpctx )+ pctx -> c a l c v ( i , j , k +1 ,0 , vpctx )+pctx -> c a l c v ( i - 1 , j , k +1 ,0 , vpctx ) ) ) 202 #define vyk2 ( i , j , k ) ( 0 . 2 5  ( pctx -> c a l c v ( i , j , k , 1 , vpctx )+pctx -> c a l c v ( i , j - 1 ,k , 1 , vpctx )+ pctx -> c a l c v ( i , j , k +1 ,1 , vpctx )+pctx -> c a l c v ( i , j - 1 ,k +1 ,1 , vpctx ) ) ) 203 #define v y k 2 r e f l e c t ( i , j , k ) ( 0 . 0 ) 204 #define vzk2 ( i , j , k ) ( pctx -> c a l c v ( i , j , k , 2 , vpctx ) ) 205 #define VXK2FLOPS 4 206 #define VYK2FLOPS 4 207 #define VZK2FLOPS 0 208

126

APPENDIX 3. SOURCE CODE

3.9. ODE.C

209 /  wx , wy , wz a t ( i , j , k +1/2) h a l f node l o c a t i o n s  / 210 #define wxk2 ( i , j , k ) ( 0 . 2 5  ( s [ k ] [ j ] [ i ] [ 1 ] + s [ k ] [ j ] [ i - 1 ] [ 1 ] + s [ k + 1 ] [ j ] [ i ] [ 1 ] + s [ k + 1 ] [ j ] [ i -1][1]) ) 211 //#d e f i n e w x k 2 k h i ( i , j , k ) ( 0 . 5  ( s [ k ] [ j ] [ i ] [ 1 ] + s [ k ] [ j ] [ i - 1 ] [ 1 ] ) ) 212 //#d e f i n e w x k 2 i l o ( i , j , k ) ( 0 . 5  ( s [ k ] [ j ] [ i ] [ 1 ] + s [ k + 1 ] [ j ] [ i ] [ 1 ] ) ) 213 //#d e f i n e w x k 2 i l o k h i ( i , j , k ) ( ( s [ k ] [ j ] [ i ] [ 1 ] ) ) 214 #define wxk2 khi ( i , j , k ) ( 0 . 2 5  ( s [ k ] [ j ] [ i ] [ 1 ] + s [ k ] [ j ] [ i - 1][1]+0+0) ) 215 #define w x k 2 i l o ( i , j , k ) ( 0 . 2 5  ( s [ k ] [ j ] [ i ] [ 1 ] + 0 + s [ k + 1 ] [ j ] [ i ] [ 1 ] + 0 ) ) 216 #define w x k 2 i l o k h i ( i , j , k ) ( 0 . 2 5  ( s [ k ] [ j ] [ i ][1]+0+0+0) ) 217 #define wyk2 ( i , j , k ) ( 0 . 2 5  ( s [ k ] [ j ] [ i ] [ 2 ] + s [ k ] [ j - 1 ] [ i ] [ 2 ] + s [ k + 1 ] [ j ] [ i ] [ 2 ] + s [ k + 1 ] [ j - 1 ] [ i ][2]) ) 218 #define w y k 2 r e f l e c t ( i , j , k ) ( 0 . 0 ) 219 #define wzk2 ( i , j , k ) ( s [ k ] [ j ] [ i ] [ 3 ] ) 220 #define WXK2FLOPS 4 221 #define WYK2FLOPS 4 222 #define WZK2FLOPS 0 223 224 /  wxx , wxy , wxz a t h a l f node l o c a t i o n s ( i +1/2 , j , k )  / 225 #define wxxi2 ( i , j , k ) ( 0 . 5  ( s [ k ] [ j ] [ i +1][1] - s [ k ] [ j ] [ i - 1 ] [ 1 ] )  pctx ->invdx ) 226 //#d e f i n e w x x i 2 i h i ( i , j , k ) ( ( s [ k ] [ j ] [ i ] [ 1 ] - s [ k ] [ j ] [ i - 1 ] [ 1 ] )  p c t x ->i n v d x ) 227 //#d e f i n e w x x i 2 i l o ( i , j , k ) ( ( s [ k ] [ j ] [ i +1][1] - s [ k ] [ j ] [ i ] [ 1 ] )  p c t x ->i n v d x ) 228 #define w x x i 2 i h i ( i , j , k ) ( 0 . 5  ( 0 - s [ k ] [ j ] [ i - 1 ] [ 1 ] )  pctx ->invdx ) 229 #define w x x i 2 i l o ( i , j , k ) ( 0 . 5  ( s [ k ] [ j ] [ i + 1 ] [ 1 ] - 0 )  pctx ->invdx ) 230 #define wxyi2 ( i , j , k ) ( 0 . 5  ( s [ k ] [ j + 1 ] [ i ] [ 1 ] - s [ k ] [ j - 1 ] [ i ] [ 1 ] )  pctx ->invdy ) 231 #define w x y i 2 r e f l e c t ( i , j , k ) ( 0 . 5  ( s [ k ] [ j + 1 ] [ i ] [ 1 ] - s [ k ] [ j ] [ i ] [ 1 ] )  pctx ->invdy ) 232 #define wxzi2 ( i , j , k ) ( 0 . 5  ( s [ k + 1 ] [ j ] [ i ] [ 1 ] - s [ k - 1 ] [ j ] [ i ] [ 1 ] )  pctx ->i n v d z ) 233 //#d e f i n e w x z i 2 k l o ( i , j , k ) ( ( s [ k + 1 ] [ j ] [ i ] [ 1 ] - s [ k ] [ j ] [ i ] [ 1 ] )  p c t x -> i n v d z ) 234 //#d e f i n e w x z i 2 k h i ( i , j , k ) ( ( s [ k ] [ j ] [ i ] [ 1 ] - s [ k - 1 ] [ j ] [ i ] [ 1 ] )  p c t x -> i n v d z ) 235 #define w x z i 2 k l o ( i , j , k ) ( 0 . 5  ( s [ k + 1 ] [ j ] [ i ] [ 1 ] - 0 )  pctx ->i n v d z ) 236 #define w x z i 2 k h i ( i , j , k ) ( 0 . 5  ( 0 - s [ k - 1 ] [ j ] [ i ] [ 1 ] )  pctx ->i n v d z ) 237 #define WXXI2FLOPS 3 238 #define WXYI2FLOPS 3 239 #define WXZI2FLOPS 3 240 241 /  wyx , wyy , wyz a t h a l f node l o c a t i o n s ( i , j +1/2 , k )  / 242 #define wyxj2 ( i , j , k ) ( 0 . 5  ( s [ k ] [ j ] [ i +1][2] - s [ k ] [ j ] [ i - 1 ] [ 2 ] )  pctx ->invdx ) 243 //#d e f i n e w y x j 2 i l o ( i , j , k ) ( ( s [ k ] [ j ] [ i +1][2] - s [ k ] [ j ] [ i ] [ 2 ] )  p c t x ->i n v d x ) 244 //#d e f i n e w y x j 2 i h i ( i , j , k ) ( ( s [ k ] [ j ] [ i ] [ 2 ] - s [ k ] [ j ] [ i - 1 ] [ 2 ] )  p c t x ->i n v d x ) 245 #define w y x j 2 i l o ( i , j , k ) ( 0 . 5  ( s [ k ] [ j ] [ i + 1 ] [ 2 ] - 0 )  pctx ->invdx ) 246 #define w y x j 2 i h i ( i , j , k ) ( 0 . 5  ( 0 - s [ k ] [ j ] [ i - 1 ] [ 2 ] )  pctx ->invdx ) 247 #define wyyj2 ( i , j , k ) ( 0 . 5  ( s [ k ] [ j + 1 ] [ i ] [ 2 ] - s [ k ] [ j - 1 ] [ i ] [ 2 ] )  pctx ->invdy ) 248 #define w y y j 2 r e f l e c t ( i , j , k ) ( 0 . 5  ( s [ k ] [ j + 1 ] [ i ] [ 2 ] + s [ k ] [ j ] [ i ] [ 2 ] )  pctx ->invdy ) 249 #define wyzj2 ( i , j , k ) ( 0 . 5  ( s [ k + 1 ] [ j ] [ i ] [ 2 ] - s [ k - 1 ] [ j ] [ i ] [ 2 ] )  pctx ->i n v d z ) 250 //#d e f i n e w y z j 2 k l o ( i , j , k ) ( 0 . 5  ( s [ k + 1 ] [ j ] [ i ] [ 2 ] - s [ k ] [ j ] [ i ] [ 2 ] )  p c t x -> i n v d z ) 251 //#d e f i n e w y z j 2 k h i ( i , j , k ) ( 0 . 5  ( s [ k ] [ j ] [ i ] [ 2 ] - s [ k - 1 ] [ j ] [ i ] [ 2 ] )  p c t x -> i n v d z ) 252 #define w y z j 2 k l o ( i , j , k ) ( 0 . 5  ( s [ k + 1 ] [ j ] [ i ] [ 2 ] - 0 )  pctx ->i n v d z ) 253 #define w y z j 2 k h i ( i , j , k ) ( 0 . 5  ( 0 - s [ k - 1 ] [ j ] [ i ] [ 2 ] )  pctx ->i n v d z ) 254 #define WYXJ2FLOPS 3 255 #define WYYJ2FLOPS 3 256 #define WYZJ2FLOPS 3

127

3.9. ODE.C
257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306

APPENDIX 3. SOURCE CODE

/  wzx , wzy , wzz a t h a l f node l o c a t i o n s ( i , j , k +1/2)  / #define wzxk2 ( i , j , k ) ( 0 . 5  ( s [ k ] [ j ] [ i +1][3] - s [ k ] [ j ] [ i - 1 ] [ 3 ] )  pctx ->invdx ) //#d e f i n e w z x k 2 i l o ( i , j , k ) ( ( s [ k ] [ j ] [ i +1][3] - s [ k ] [ j ] [ i ] [ 3 ] )  p c t x ->i n v d x ) //#d e f i n e w z x k 2 i h i ( i , j , k ) ( ( s [ k ] [ j ] [ i ] [ 3 ] - s [ k ] [ j ] [ i - 1 ] [ 3 ] )  p c t x ->i n v d x ) #define w z x k 2 i l o ( i , j , k ) ( 0 . 5  ( s [ k ] [ j ] [ i + 1 ] [ 3 ] - 0 )  pctx ->invdx ) #define w z x k 2 i h i ( i , j , k ) ( 0 . 5  ( 0 - s [ k ] [ j ] [ i - 1 ] [ 3 ] )  pctx ->invdx ) #define wzyk2 ( i , j , k ) ( 0 . 5  ( s [ k ] [ j + 1 ] [ i ] [ 3 ] - s [ k ] [ j - 1 ] [ i ] [ 3 ] )  pctx ->invdy ) #define w z y k 2 r e f l e c t ( i , j , k ) ( 0 . 5  ( s [ k ] [ j + 1 ] [ i ] [ 3 ] - s [ k ] [ j ] [ i ] [ 3 ] )  pctx ->invdy ) #define wzzk2 ( i , j , k ) ( 0 . 5  ( s [ k + 1 ] [ j ] [ i ] [ 3 ] - s [ k - 1 ] [ j ] [ i ] [ 3 ] )  pctx ->i n v d z ) //#d e f i n e w z z k 2 k l o ( i , j , k ) ( ( s [ k + 1 ] [ j ] [ i ] [ 3 ] - s [ k ] [ j ] [ i ] [ 3 ] )  p c t x -> i n v d z ) //#d e f i n e w z z k 2 k h i ( i , j , k ) ( ( s [ k ] [ j ] [ i ] [ 3 ] - s [ k - 1 ] [ j ] [ i ] [ 3 ] )  p c t x -> i n v d z ) #define w z z k 2 k l o ( i , j , k ) ( 0 . 5  ( s [ k + 1 ] [ j ] [ i ] [ 3 ] - 0 )  pctx ->i n v d z ) #define w z z k 2 k h i ( i , j , k ) ( 0 . 5  ( 0 - s [ k - 1 ] [ j ] [ i ] [ 3 ] )  pctx ->i n v d z ) #define WZXK2FLOPS 3 #define WZYK2FLOPS 3 #define WZZK2FLOPS 3 /  vxx , vxy , v x z a t h a l f node #define v x x i 2 ( i , j , k ) ( pctx -> c a l c #define v x y i 2 ( i , j , k ) ( pctx -> c a l c #define v x z i 2 ( i , j , k ) ( pctx -> c a l c #define VXXI2FLOPS 0 #define VXYI2FLOPS 0 #define VXZI2FLOPS 0 /  vyx , vyy , v y z a t h a l f node #define v y x j 2 ( i , j , k ) ( pctx -> c a l c #define v y y j 2 ( i , j , k ) ( pctx -> c a l c #define v y z j 2 ( i , j , k ) ( pctx -> c a l c #define VYXJ2FLOPS 0 #define VYYJ2FLOPS 0 #define VYZJ2FLOPS 0 /  vzx , vzy , v z z a t h a l f node #define vzxk2 ( i , j , k ) ( pctx -> c a l c #define vzyk2 ( i , j , k ) ( pctx -> c a l c #define vzzk2 ( i , j , k ) ( pctx -> c a l c #define VZXK2FLOPS 0 #define VZYK2FLOPS 0 #define VZZK2FLOPS 0 locations dvdx ( i , j dvdy ( i , j dvdz ( i , j ( i +1/2 , j , k )  / , k , 0 , 0 , vpctx ) ) , k , 0 , 1 , vpctx ) ) , k , 0 , 2 , vpctx ) )

locations dvdx ( i , j dvdy ( i , j dvdz ( i , j

( i , j +1/2 , k )  / , k , 1 , 0 , vpctx ) ) , k , 1 , 1 , vpctx ) ) , k , 1 , 2 , vpctx ) )

locations dvdx ( i , j dvdy ( i , j dvdz ( i , j

( i , j , k +1/2)  / , k , 2 , 0 , vpctx ) ) , k , 2 , 1 , vpctx ) ) , k , 2 , 2 , vpctx ) )

/  C a l c u l a t e t h e r e s i d u a l on t h e l o c a l g r i d  / f o r ( i=sx ; i <sx+mx ; i ++) f o r ( j=sy ; j <sy+my ; j ++) f o r ( k=s z ; k< s z+mz ; k++) { i f ( I n t e r i o r R e g i o n ( pctx , i , j , k ) ) { i f ( TwoDimensional ( p c t x ) )

128

APPENDIX 3. SOURCE CODE
307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 { /  dp / d t a t ( i  dx , j  dy , k  dz )  / r [ k ] [ j ] [ i ][0]= ( - ( vx ( i , j , k )  px ( i , j , k )+ vy ( i , j , k )  py ( i , j , k ) ) +kappa ( i , j , k )  ( r [ k ] [ j ] [ i ][0] - ( wxx ( i , j , k )+ wyy ( i , j , k ) ) ) ) ; P e t s c L o g F l o p s (3+2+ (VXFLOPS+VYFLOPS+ PXFLOPS+PYFLOPS) -2 +1+1+1+2+ (WXXFLOPS + WYYFLOPS) -1) ; /  dwx/ d t a t ( ( i +1/2)  dx , j  dy , k  dz )  / r [ k ] [ j ] [ i ][1]= ( - ( wxi2 ( i , j , k )  v x x i 2 ( i , j , k )+ wyi2 ( i , j , k )  v x y i 2 ( i , j , k ) ) -( v x i 2 ( i , j , k )  wxxi2 ( i , j , k )+ v y i 2 ( i , j , k )  wxyi2 ( i , j , k ) ) +b i 2 ( i , j , k )  ( r [ k ] [ j ] [ i ][1] - pxi2 ( i , j , k ) ) ) ; P e t s c L o g F l o p s (3+2+ (WXI2FLOPS+WYI2FLOPS+ VXXI2FLOPS+VXYI2FLOPS) -2 +1+3+2+ (VXI2FLOPS+VYI2FLOPS+ WXXI2FLOPS+WXYI2FLOPS) -2 +1+1+1+ PXI2FLOPS) ; /  dwy/ d t a t ( i  dx , ( j +1/2)  dy , k  dz )  / r [ k ] [ j ] [ i ][2]= ( - ( wxj2 ( i , j , k )  v y x j 2 ( i , j , k )+ wyj2 ( i , j , k )  v y y j 2 ( i , j , k ) ) -( v x j 2 ( i , j , k )  wyxj2 ( i , j , k )+ v y j 2 ( i , j , k )  wyyj2 ( i , j , k ) ) +b j 2 ( i , j , k )  ( r [ k ] [ j ] [ i ][2] - pyj2 ( i , j , k ) ) ) ; P e t s c L o g F l o p s (3+2+ (WXJ2FLOPS+WYJ2FLOPS+ VYXJ2FLOPS+VYYJ2FLOPS) -2 +1+3+2+ (VXJ2FLOPS+VYJ2FLOPS+ WYXJ2FLOPS+WYYJ2FLOPS) -2 +1+1+1+ PYJ2FLOPS) ;

3.9. ODE.C

129

3.9. ODE.C
357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 /  dwy/ d t a t ( i  dx , j  dy , ( k +1/2)  dz )  / r [k ][ j ][ i ][3]=0.0; } else { /  dp / d t a t ( i  dx , j  dy , k  dz )  / r [ k ] [ j ] [ i ][0]= ( - ( vx ( i , j , k )  px ( i , j , k )+ vy ( i , j , k )  py ( i , j , k )+ vz ( i , j , k )  pz ( i , j , k ) ) +kappa ( i , j , k )  ( r [ k ] [ j ] [ i ][0] - ( wxx ( i , j , k )+ wyy ( i , j , k )+ wzz ( i , j , k ) ) ) ) ; P e t s c L o g F l o p s (3+2+ (VXFLOPS+VYFLOPS+VZFLOPS+ PXFLOPS+PYFLOPS+PZFLOPS) +1+1+1+2+ (WXXFLOPS + WYYFLOPS +WZZFLOPS) ) ; /  dwx/ d t a t ( ( i +1/2)  dx , j  dy , k  dz )  / r [ k ] [ j ] [ i ][1]= ( - ( wxi2 ( i , j , k )  v x x i 2 ( i , j , k )+ wyi2 ( i , j , k )  v x y i 2 ( i , j , k )+ wzi2 ( i , j , k )  v x z i 2 ( i , j , k ) ) -( v x i 2 ( i , j , k )  wxxi2 ( i , j , k )+ v y i 2 ( i , j , k )  wxyi2 ( i , j , k )+ v z i 2 ( i , j , k )  wxzi2 ( i , j , k ) ) +b i 2 ( i , j , k )  ( r [ k ] [ j ] [ i ][1] - pxi2 ( i , j , k ) ) ) ; P e t s c L o g F l o p s (3+2+ (WXI2FLOPS+WYI2FLOPS+WZI2FLOPS+ VXXI2FLOPS+VXYI2FLOPS+VXZI2FLOPS) +1+3+2+ (VXI2FLOPS+VYI2FLOPS+VZI2FLOPS+ WXXI2FLOPS+WXYI2FLOPS+WXZI2FLOPS) +1+1+1+ PXI2FLOPS) ; /  dwy/ d t a t ( i  dx , ( j +1/2)  dy , k  dz )  / r [ k ] [ j ] [ i ][2]= ( - ( wxj2 ( i , j , k )  v y x j 2 ( i , j , k )+ wyj2 ( i , j , k )  v y y j 2 ( i , j , k )+ wzj2 ( i , j , k )  v y z j 2 ( i , j , k ) ) -( v x j 2 ( i , j , k )  wyxj2 ( i , j , k )+ v y j 2 ( i , j , k )  wyyj2 ( i , j , k )+ v z j 2 ( i , j , k )  wyzj2 ( i , j , k ) ) +b j 2 ( i , j , k ) 

APPENDIX 3. SOURCE CODE

130

APPENDIX 3. SOURCE CODE
407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 ( r [ k ] [ j ] [ i ][2] - pyj2 ( i , j , k ) ) ) ; P e t s c L o g F l o p s (3+2+ (WXJ2FLOPS+WYJ2FLOPS+WZJ2FLOPS+ VYXJ2FLOPS+VYYJ2FLOPS+VYZJ2FLOPS) +1+3+2+ (VXJ2FLOPS+VYJ2FLOPS+VZJ2FLOPS+ WYXJ2FLOPS+WYYJ2FLOPS+WYZJ2FLOPS) +1+1+1+ PYJ2FLOPS) ; /  dwy/ d t a t ( i  dx , j  dy , ( k +1/2)  dz )  / r [ k ] [ j ] [ i ][3]= ( - (wxk2 ( i , j , k )  vzxk2 ( i , j , k )+ wyk2 ( i , j , k )  vzyk2 ( i , j , k )+ wzk2 ( i , j , k )  vzzk2 ( i , j , k ) ) -(vxk2 ( i , j , k )  wzxk2 ( i , j , k )+ vyk2 ( i , j , k )  wzyk2 ( i , j , k )+ vzk2 ( i , j , k )  wzzk2 ( i , j , k ) ) +bk2 ( i , j , k )  ( r [ k ] [ j ] [ i ] [ 3 ] - pzk2 ( i , j , k ) ) ) ; P e t s c L o g F l o p s (3+2+ (WXK2FLOPS+WYK2FLOPS+WZK2FLOPS+ VZXK2FLOPS+VZYK2FLOPS+VZZK2FLOPS) +1+3+2+ (VXK2FLOPS+VYK2FLOPS+VZK2FLOPS+ WZXK2FLOPS+WZYK2FLOPS+WZZK2FLOPS) +1+1+1+ PZK2FLOPS) ; } } e l s e i f ( R e f l e c t i o n R e g i o n ( pctx , i , j , k ) ) { i f ( TwoDimensional ( p c t x ) ) { /  A r e f l e c t i n g ground c o n d i t i o n  / /  dp / d t a t ( i  dx , j  dy , k  dz )  / /  r [ k ] [ j ] [ i ] [ 0 ] c o u l d c o n t a i n a s o u r c e term , u n l i k e l y b u t p o s s i b l e  / r [ k ] [ j ] [ i ] [ 0 ] = kappa ( i , j , k ) ; i f ( ILowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 0 ] -= vx ( i , j , k )  p x i l o ( i , j , k ) ; e l s e i f ( IHighFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 0 ] -= vx ( i , j , k )  p x i h i ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 0 ] -= vx ( i , j , k )  px ( i , j , k ) ; /  vy ( i , j , k ) z e r o on w h o l e node f o r r e f l e c t i o n  / i f ( ILowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 0 ] -= kappa ( i , j , k )  w x x i l o ( i , j , k ) ; else

3.9. ODE.C

131

3.9. ODE.C
457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 r [ k ] [ j ] [ i ] [ 0 ] -= kappa ( i , j , k )  wxx ( i , j , k ) ; r [ k ] [ j ] [ i ] [ 0 ] -= kappa ( i , j , k )  w y y r e f l e c t ( i , j , k ) ; P e t s c L o g F l o p s (3+2+ (VXFLOPS+ PXFLOPS) +1+1+1+2+ (WXXFLOPS + WYYFLOPS) ) ;

APPENDIX 3. SOURCE CODE

/  dwx/ d t a t ( ( i +1/2)  dx , j  dy , k  dz )  / /  r [ k ] [ j ] [ i ] [ 1 ] c o u l d c o n t a i n a s o u r c e term , u n l i k e l y b u t p o s s i b l e  / r [ k ] [ j ] [ i ] [ 1 ] = b i 2 ( i , j , k ) ; r [ k ] [ j ] [ i ] [ 1 ] -= wxi2 ( i , j , k )  v x x i 2 ( i , j , k ) ; /  v x y i 2 ( i , j , k ) z e r o on ( ( i +1/2)  dx , j  dy , k  dz ) f o r r e f l e c t i o n  / i f ( ILowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 1 ] -= v x i 2 ( i , j , k )  w x x i 2 i l o ( i , j , k ) ; e l s e i f ( IHighFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 1 ] -= v x i 2 ( i , j , k )  w x x i 2 i h i ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 1 ] -= v x i 2 ( i , j , k )  wxxi2 ( i , j , k ) ; /  v y i 2 ( i , j , k ) z e r o on ( ( i +1/2)  dx , j  dy , k  dz ) f o r r e f l e c t i o n  / i f ( IHighFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 1 ] -= b i 2 ( i , j , k )  p x i 2 i h i ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 1 ] -= b i 2 ( i , j , k )  p x i 2 ( i , j , k ) ; P e t s c L o g F l o p s (3+2+ (WXI2FLOPS+ VXXI2FLOPS) +1+3+2+ (VXI2FLOPS+ WXXI2FLOPS) +1+1+1+ PXI2FLOPS) ; /  dwy/ d t a t ( i  dx , ( j +1/2)  dy , k  dz )  / /  r [ k ] [ j ] [ i ] [ 2 ] c o u l d c o n t a i n a s o u r c e term , u n l i k e l y b u t p o s s i b l e  / r [ k ] [ j ] [ i ] [ 2 ] = b j 2 ( i , j , k ) ; i f ( ILowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 2 ] -= w x j 2 i l o ( i , j , k )  v y x j 2 ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 2 ] -= wxj2 ( i , j , k )  v y x j 2 ( i , j , k ) ; r [ k ] [ j ] [ i ] [ 2 ] -= wyj2 ( i , j , k )  v y y j 2 ( i , j , k ) ;

132

APPENDIX 3. SOURCE CODE
507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 i f ( ILowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 2 ] -= v x j 2 ( i , j e l s e i f ( IHighFace ( pctx , i , j r [ k ] [ j ] [ i ] [ 2 ] -= v x j 2 ( i , j else r [ k ] [ j ] [ i ] [ 2 ] -= v x j 2 ( i , j

3.9. ODE.C

, k) wyxj2 ilo ( i , j , k) ; , k) ) , k) wyxj2 ihi ( i , j , k) ; , k )  wyxj2 ( i , j , k ) ;

r [ k ] [ j ] [ i ] [ 2 ] -= v y j 2 ( i , j , k )  w y y j 2 r e f l e c t ( i , j , k ) ; r [ k ] [ j ] [ i ] [ 2 ] -= b j 2 ( i , j , k )  p y j 2 ( i , j , k ) ; P e t s c L o g F l o p s (3+2+ (WXJ2FLOPS+WYJ2FLOPS+ VYXJ2FLOPS+VYYJ2FLOPS) +1+3+2+ (VXJ2FLOPS+VYJ2FLOPS+ WYXJ2FLOPS+WYYJ2FLOPS) +1+1+1+ PYJ2FLOPS) ; /  dwy/ d t a t ( i  dx , j  dy , ( k +1/2)  dz )  / r [k ][ j ][ i ][3] = 0.0; } else { /  A r e f l e c t i n g ground c o n d i t i o n  / /  dp / d t a t ( i  dx , j  dy , k  dz )  / /  r [ k ] [ j ] [ i ] [ 0 ] c o u l d c o n t a i n a s o u r c e term , u n l i k e l y b u t p o s s i b l e  / r [ k ] [ j ] [ i ] [ 0 ] = kappa ( i , j , k ) ; i f ( ILowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 0 ] -= vx ( i , j , k )  p x i l o ( i , j , k ) ; e l s e i f ( IHighFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 0 ] -= vx ( i , j , k )  p x i h i ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 0 ] -= vx ( i , j , k )  px ( i , j , k ) ; /  vy ( i , j , k ) z e r o on w h o l e node f o r r e f l e c t i o n  / i f ( KLowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 0 ] -= vz ( i , j , k )  p z k l o ( i , j , k ) ; e l s e i f ( KHighFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 0 ] -= vz ( i , j , k )  p z k h i ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 0 ] -= vz ( i , j , k )  pz ( i , j , k ) ; i f ( ILowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 0 ] -= kappa ( i , j , k )  w x x i l o ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 0 ] -= kappa ( i , j , k )  wxx ( i , j , k ) ; r [ k ] [ j ] [ i ] [ 0 ] -= kappa ( i , j , k )  w y y r e f l e c t ( i , j , k ) ;

133

3.9. ODE.C
557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606

APPENDIX 3. SOURCE CODE

i f ( KLowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 0 ] -= kappa ( i , j , k )  w z z k l o ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 0 ] -= kappa ( i , j , k )  wzz ( i , j , k ) ; P e t s c L o g F l o p s (3+2+ (VXFLOPS+VZFLOPS+ PXFLOPS+PZFLOPS) +1+1+1+2+ (WXXFLOPS + WYYFLOPS +WZZFLOPS) ) ; /  dwx/ d t a t ( ( i +1/2)  dx , j  dy , k  dz )  / /  r [ k ] [ j ] [ i ] [ 1 ] c o u l d c o n t a i n a s o u r c e term , u n l i k e l y b u t p o s s i b l e  / r [ k ] [ j ] [ i ] [ 1 ] = b i 2 ( i , j , k ) ; r [ k ] [ j ] [ i ] [ 1 ] -= wxi2 ( i , j , k )  v x x i 2 ( i , j , k ) ; /  v x y i 2 ( i , j , k ) z e r o on ( ( i +1/2)  dx , j  dy , k  dz ) f o r r e f l e c t i o n  / i f ( IHighFace ( pctx , i , j , k ) && KLowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 1 ] -= w z i 2 i h i k l o ( i , j , k )  v x z i 2 ( i , j , k ) ; e l s e i f ( IHighFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 1 ] -= w z i 2 i h i ( i , j , k )  v x z i 2 ( i , j , k ) ; e l s e i f ( KLowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 1 ] -= w z i 2 k l o ( i , j , k )  v x z i 2 ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 1 ] -= wzi2 ( i , j , k )  v x z i 2 ( i , j , k ) ; i f ( ILowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 1 ] -= v x i 2 ( i , j , k )  w x x i 2 i l o ( i , j , k ) ; e l s e i f ( IHighFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 1 ] -= v x i 2 ( i , j , k )  w x x i 2 i h i ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 1 ] -= v x i 2 ( i , j , k )  wxxi2 ( i , j , k ) ; /  v y i 2 ( i , j , k ) z e r o on ( ( i +1/2)  dx , j  dy , k  dz ) f o r r e f l e c t i o n  / i f ( KLowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 1 ] -= v z i 2 ( i , j , k )  w x z i 2 k l o ( i , j , k ) ; e l s e i f ( KHighFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 1 ] -= v z i 2 ( i , j , k )  w x z i 2 k h i ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 1 ] -= v z i 2 ( i , j , k )  wxzi2 ( i , j , k ) ; i f ( IHighFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 1 ] -= b i 2 ( i , j , k )  p x i 2 i h i ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 1 ] -= b i 2 ( i , j , k )  p x i 2 ( i , j , k ) ; P e t s c L o g F l o p s (3+2+ (WXI2FLOPS+WZI2FLOPS+ VXXI2FLOPS+VXZI2FLOPS) +1+3+2+

134

APPENDIX 3. SOURCE CODE
607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 (VXI2FLOPS+VZI2FLOPS+ WXXI2FLOPS+WXZI2FLOPS) +1+1+1+ PXI2FLOPS) ; /  dwy/ d t a t ( i  dx , ( j +1/2)  dy , k  dz )  / /  r [ k ] [ j ] [ i ] [ 2 ] c o u l d c o n t a i n a s o u r c e term , u n l i k e l y b u t p o s s i b l e  / r [ k ] [ j ] [ i ] [ 2 ] = b j 2 ( i , j , k ) ; i f ( ILowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 2 ] -= w x j 2 i l o ( i , j , k )  v y x j 2 ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 2 ] -= wxj2 ( i , j , k )  v y x j 2 ( i , j , k ) ; r [ k ] [ j ] [ i ] [ 2 ] -= wyj2 ( i , j , k )  v y y j 2 ( i , j , k ) ; i f ( KLowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 2 ] -= w z j 2 k l o ( i , j , k )  v y z j 2 ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 2 ] -= wzj2 ( i , j , k )  v y z j 2 ( i , j , k ) ; i f ( ILowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 2 ] -= v x j 2 ( i , j , k )  w y x j 2 i l o ( i , j e l s e i f ( IHighFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 2 ] -= v x j 2 ( i , j , k )  w y x j 2 i h i ( i , j else r [ k ] [ j ] [ i ] [ 2 ] -= v x j 2 ( i , j , k )  wyxj2 ( i , j , k ) ; r [ k ] [ j ] [ i ] [ 2 ] -= v y j 2 ( i , j , k )  w y y j 2 r e f l e c t ( i i f ( KLowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 2 ] -= v z j 2 ( i , j , k )  w y z j 2 k l o ( i , j e l s e i f ( KHighFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 2 ] -= v z j 2 ( i , j , k )  w y z j 2 k h i ( i , j else r [ k ] [ j ] [ i ] [ 2 ] -= v z j 2 ( i , j , k )  wyzj2 ( i , j , k ) ; r [ k ] [ j ] [ i ] [ 2 ] -= b j 2 ( i , j , k )  p y j 2 ( i , j , k ) ; P e t s c L o g F l o p s (3+2+ (WXJ2FLOPS+WYJ2FLOPS+WZJ2FLOPS+ VYXJ2FLOPS+VYYJ2FLOPS+VYZJ2FLOPS) +1+3+2+ (VXJ2FLOPS+VYJ2FLOPS+VZJ2FLOPS+ WYXJ2FLOPS+WYYJ2FLOPS+WYZJ2FLOPS) +1+1+1+ PYJ2FLOPS) ; /  dwy/ d t a t ( i  dx , j  dy , ( k +1/2)  dz )  / /  r [ k ] [ j ] [ i ] [ 3 ] c o u l d c o n t a i n a s o u r c e term , u n l i k e l y b u t p o s s i b l e  / r [ k ] [ j ] [ i ] [ 3 ] = bk2 ( i , j , k ) ; i f ( ILowFace ( pctx , i , j , k ) && KHighFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 3 ] -= w x k 2 i l o k h i ( i , j , k )  vzxk2 ( i , j , k ) ;

3.9. ODE.C

, k) ; , k) ;

, j , k) ; , k) ; , k) ;

135

3.9. ODE.C
657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 e l s e i f ( ILowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 3 ] -= w x k 2 i l o ( i , j , k )  vzxk2 ( i , j , k ) ; e l s e i f ( KHighFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 3 ] -= wxk2 khi ( i , j , k )  vzxk2 ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 3 ] -= wxk2 ( i , j , k )  vzxk2 ( i , j , k ) ; /  wyk2 ( i , j , k ) z e r o on i +1/2 nodes f o r r e f l e c t i o n  / r [ k ] [ j ] [ i ] [ 3 ] -= wzk2 ( i , j , k )  vzzk2 ( i , j , k ) ; i f ( ILowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 3 ] -= vxk2 ( i , j , k )  w z x k 2 i l o ( i , j , k ) ; e l s e i f ( IHighFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 3 ] -= vxk2 ( i , j , k )  w z x k 2 i h i ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 3 ] -= vxk2 ( i , j , k )  wzxk2 ( i , j , k ) ; /  vyk2 ( i , j , k ) z e r o on k+1/2 nodes f o r r e f l e c t i o n  / i f ( KLowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 3 ] -= vzk2 ( i , j , k )  w z z k 2 k l o ( i , j , k ) ; e l s e i f ( KHighFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 3 ] -= vzk2 ( i , j , k )  w z z k 2 k h i ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 3 ] -= vzk2 ( i , j , k )  wzzk2 ( i , j , k ) ; i f ( KHighFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 3 ] -= bk2 ( i , j , k )  p z k 2 k h i ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 3 ] -= bk2 ( i , j , k )  pzk2 ( i , j , k ) ; P e t s c L o g F l o p s (3+2+ (WXK2FLOPS+WZK2FLOPS+ VZXK2FLOPS+VZZK2FLOPS) +1+3+2+ (VXK2FLOPS+VZK2FLOPS+ WZXK2FLOPS+WZZK2FLOPS) +1+1+1+ PZK2FLOPS) ; }

APPENDIX 3. SOURCE CODE

} e l s e i f ( AbsorbingBCRegion ( pctx , i , j , k ) ) { i f ( TwoDimensional ( p c t x ) ) { /  A b s o r b i n g Boundary C o n d i t i o n l a y e r s , i n c l u d i n g e x t r e m e s o f mesh  / /  dp / d t a t ( i  dx , j  dy , k  dz )  / r [k ][ j ][ i ][0]=0.0; i f ( ILowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 0 ] += -kappae ( i , j , k )  w x x i l o ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 0 ] += -kappae ( i , j , k )  wxx ( i , j , k ) ; i f ( JLowFace ( pctx , i , j , k ) )

136

APPENDIX 3. SOURCE CODE
707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 r [ k ] [ j ] [ i ] [ 0 ] += -kappae ( i , j , k )  w y y j l o ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 0 ] += -kappae ( i , j , k )  wyy ( i , j , k ) ; P e t s c L o g F l o p s (1+1+2+WXXFLOPS + WYYFLOPS) ; /  dwx/ d t a t ( ( i +1/2)  dx , j  dy , k  dz )  / i f ( IHighFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ][1]= (- s e i 2 ( i , j , k )  wxi2 ( i , j , k ) -b e i 2 ( i , j , k )  p x i 2 i h i ( i , j , k ) ) ; else r [ k ] [ j ] [ i ][1]= (- s e i 2 ( i , j , k )  wxi2 ( i , j , k ) -b e i 2 ( i , j , k )  p x i 2 ( i , j , k ) ) ; P e t s c L o g F l o p s (1+2+SEI2FLOPS+WXI2FLOPS+BI2FLOPS+PXI2FLOPS) ; /  dwy/ d t a t ( i  dx , ( j +1/2)  dy , k  dz )  / i f ( JHighFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ][2]= (- s e j 2 ( i , j , k )  wyj2 ( i , j , k ) -b e j 2 ( i , j , k )  p y j 2 j h i ( i , j , k ) ) ; else r [ k ] [ j ] [ i ][2]= (- s e j 2 ( i , j , k )  wyj2 ( i , j , k ) -b e j 2 ( i , j , k )  p y j 2 ( i , j , k ) ) ; P e t s c L o g F l o p s (1+2+SEJ2FLOPS+WYJ2FLOPS+BJ2FLOPS+PYJ2FLOPS) ; r [k ][ j ][ i ][3] = 0.0; } else { /  A b s o r b i n g Boundary C o n d i t i o n l a y e r s , i n c l u d i n g e x t r e m e s o f mesh  / /  dp / d t a t ( i  dx , j  dy , k  dz )  / r [k ][ j ][ i ][0]=0.0; i f ( ILowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 0 ] += -kappae ( i , j , k )  w x x i l o ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 0 ] += -kappae ( i , j , k )  wxx ( i , j , k ) ; i f ( JLowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 0 ] += -kappae ( i , j , k )  w y y j l o ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 0 ] += -kappae ( i , j , k )  wyy ( i , j , k ) ; i f ( KLowFace ( pctx , i , j , k ) ) r [ k ] [ j ] [ i ] [ 0 ] += -kappae ( i , j , k )  w z z k l o ( i , j , k ) ; else r [ k ] [ j ] [ i ] [ 0 ] += -kappae ( i , j , k )  wzz ( i , j , k ) ; P e t s c L o g F l o p s (1+1+2+WXXFLOPS + WYYFLOPS +WZZFLOPS) ; /  dwx/ d t a t ( ( i +1/2)  dx , j  dy , k  dz )  / i f ( IHighFace ( pctx , i , j , k ) )

3.9. ODE.C

137

3.9. ODE.C

APPENDIX 3. SOURCE CODE

757 r [ k ] [ j ] [ i ][1]= 758 (- s e i 2 ( i , j , k )  wxi2 ( i , j , k ) 759 -b e i 2 ( i , j , k )  p x i 2 i h i ( i , j , k ) ) ; 760 else 761 r [ k ] [ j ] [ i ][1]= 762 (- s e i 2 ( i , j , k )  wxi2 ( i , j , k ) 763 -b e i 2 ( i , j , k )  p x i 2 ( i , j , k ) ) ; 764 P e t s c L o g F l o p s (1+2+SEI2FLOPS+WXI2FLOPS+BI2FLOPS+PXI2FLOPS) ; 765 766 /  dwy/ d t a t ( i  dx , ( j +1/2)  dy , k  dz )  / 767 i f ( JHighFace ( pctx , i , j , k ) ) 768 r [ k ] [ j ] [ i ][2]= 769 (- s e j 2 ( i , j , k )  wyj2 ( i , j , k ) 770 -b e j 2 ( i , j , k )  p y j 2 j h i ( i , j , k ) ) ; 771 else 772 r [ k ] [ j ] [ i ][2]= 773 (- s e j 2 ( i , j , k )  wyj2 ( i , j , k ) 774 -b e j 2 ( i , j , k )  p y j 2 ( i , j , k ) ) ; 775 P e t s c L o g F l o p s (1+2+SEJ2FLOPS+WYJ2FLOPS+BJ2FLOPS+PYJ2FLOPS) ; 776 777 /  dwy/ d t a t ( i  dx , ( j +1/2)  dy , k  dz )  / 778 i f ( KHighFace ( pctx , i , j , k ) ) 779 r [ k ] [ j ] [ i ][3]= 780 (- s e k 2 ( i , j , k )  wzk2 ( i , j , k ) 781 -bek2 ( i , j , k )  p z k 2 k h i ( i , j , k ) ) ; 782 else 783 r [ k ] [ j ] [ i ][3]= 784 (- s e k 2 ( i , j , k )  wzk2 ( i , j , k ) 785 -bek2 ( i , j , k )  pzk2 ( i , j , k ) ) ; 786 P e t s c L o g F l o p s (1+2+SEK2FLOPS+WZK2FLOPS+BK2FLOPS+PZK2FLOPS) ; 787 } 788 } 789 else 790 { 791 r [k ][ j ][ i ][0]=0.0; 792 r [k ][ j ][ i ][1]=0.0; 793 r [k ][ j ][ i ][2]=0.0; 794 r [k ][ j ][ i ][3]=0.0; 795 } 796 } 797 / R e l e a s e a c c e s s t o a r r a y / 798 DAVecRestoreArrayDOF ( pctx ->da , r e s i d u a l ,& r ) ; 799 DAVecRestoreArrayDOF ( pctx ->da , l o c a l ,& s ) ; 800 801 /  Return l o c a l v e c t o r r e p r e s e n t a t i o n t o DA  / 802 DARestoreLocalVector ( pctx ->da ,& l o c a l ) ; 803 804 PetscLogEventEnd ( pctx ->FormODEEvent , 0 , 0 , 0 , 0 ) ; 805 806 // P e t s c R e a l Min , Max ;

138

APPENDIX 3. SOURCE CODE
807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 // // // // // // // //

3.9. ODE.C

VecMin ( r e s i d u a l , PETSC IGNORE,&Min ) ; VecMax ( r e s i d u a l , PETSC IGNORE,&Max) ; i f ( Min!=Min | | Max!=Max) { /  The s o l v e r has d i v e r g e d !  / P e t s c P r i n t f (PETSC COMM WORLD, " The s o l v e r a p p e a r s t o have d i v e r g e d (NaN i n r e s i d u a l ) ! \ n ") ; return 1; } return 0 ;

} // PetscErrorCode FormJacobian (TS t s , // PetscReal t , // Vec s o l u t i o n , // Mat  pJ , // Mat pPC, // MatStructure  f l a g , // void  vpctx ) // { // a p p c t x  p c t x =( a p p c t x  ) ( v p c t x ) ; // P e t s c I n t i , j , k , d , dof , Nx , Ny , Nz , sx , sy , sz , mx , my, mz ; // Vec l o c a l ; // PetscScalar val [ 1 3  4 ] [ 4 ] ; // M a t S t e n c i l row , c o l ; // P e t s c S c a l a r  s ; // P e t s c S c a l a r Q; // P e t s c S c a l a r  F ; // PetscTruth Valid ; // // a s s e r t ( 0 ) ; /  This f u n c t i o n i s n o t c o m p l e t e ( R e f l e c t i o n R e g i o n i s c u r r e n t l y wrong a t i =0, k =0, i=Nx - 1, k=Nz - 1.) Some J a c o b i a n terms a r e // n o t c a l c u l a t e d c o r r e c t l y and u s e o f t h i s f u n c t i o n // p r o d u c e s e x p o n e n t i a l memory u s a g e  / // assert ( pctx ) ; // // P etscLo gEventB eg in ( p c t x ->FormJacobianEvent , 0 , 0 , 0 , 0 ) ; // // /  Assemble t h e r e s i d u a l v e c t o r , // which i s a l r e a d y a l o c a l v e c t o r  / // // /  Borrow l o c a l v e c t o r r e p r e s e n t a t i o n from DA  / // DAGetLocalVector ( p c t x ->da ,& l o c a l ) ; // // /  Determine g l o b a l mesh n o d a l e x t e n t s  / // DAGetInfo ( p c t x ->da , PETSC IGNORE,&Nx,&Ny,&Nz , // PETSC IGNORE, PETSC IGNORE, PETSC IGNORE, // &dof , PETSC IGNORE, // PETSC IGNORE,PETSC IGNORE) ;

139

3.9. ODE.C
855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

APPENDIX 3. SOURCE CODE

/  Gather from g l o b a l s o l u t i o n t o l o c a l  / DAGlobalToLocalBegin ( p c t x ->da , s o l u t i o n , INSERT VALUES, l o c a l ) ; DAGlobalToLocalEnd ( p c t x ->da , s o l u t i o n , INSERT VALUES, l o c a l ) ; /  Grab t h e a r r a y r e p r e s e n t a t i o n o f t h e l o c a l s o l u t i o n and r e s i d u a l v e c t o r s / DAVecGetArrayDOF ( p c t x ->da , l o c a l ,& s ) ; /  Get l o c a l g r i d b o u n d a r i e s , which a r e i n d e p e n d e n t o f d o f  / DAGetCorners ( p c t x ->da ,& sx ,& sy ,& s z ,&mx,&my,&mz) ; /  C a l c u l a t e t h e r e s i d u a l on t h e l o c a l g r i d  / f o r ( i=s x ; i <s x+mx ; i ++) f o r ( j=s y ; j <s y+my ; j ++) f o r ( k=s z ; k< s z+mz ; k++) { row . i=i ; row . j=j ; row . k=k ; row . c =0; i f ( InteriorRegion ( pctx , i , j , k ) ) { c o l . i=i ; c o l . j=j ; c o l . k=k ; c o l . c =0; /  dR ( i , j , k ) / dS ( i , j , k ) a t b l o c k ( i , j , k ) , ( i , j , k )  / val [0][0]=0.0; v a l [ 0 ] [ 1 ] = - kappa ( i , j , k )  p c t x ->i n v d x ; v a l [ 0 ] [ 2 ] = - kappa ( i , j , k )  p c t x ->i n v d y ; v a l [ 0 ] [ 3 ] = - kappa ( i , j , k )  p c t x -> i n v d z ; v a l [ 1 ] [ 0 ] = b i 2 ( i , j , k )  p c t x ->i n v d x ; v a l [1][1]= - v x x i 2 ( i , j , k ) ; v a l [1][2]= -0.25 vxyi2 ( i , j , k ) ; v a l [1][3]= -0.25 v x z i 2 ( i , j , k ) ; v a l [ 2 ] [ 0 ] = b j 2 ( i , j , k )  p c t x ->i n v d y ; v a l [2][1]= -0.25 vyxj2 ( i , j , k ) ; v a l [2][2]= - vyyj2 ( i , j , k ) ; v a l [2][3]= -0.25 vyzj2 ( i , j , k ) ; v a l [ 3 ] [ 0 ] = bk2 ( i , j , k )  p c t x -> i n v d z ; v a l [3][1]= -0.25 vzxk2 ( i , j , k ) ; v a l [3][2]= -0.25 vzyk2 ( i , j , k ) ; v a l [3][3]= - vzzk2 ( i , j , k ) ; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; / E l i m i n a t e z e r o s i n d i a g o n a l o f p r e c o n d i t i o n e r / // f o r ( d=0;d<d o f ; d++) // i f ( v a l [ d ] [ d]==0) v a l [ d ] [ d]=1 e - 3; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (3+ 3+(BI2FLOPS+VXXI2FLOPS+VXYI2FLOPS+VXZI2FLOPS)+ 3+(BJ2FLOPS+VYXJ2FLOPS+VYYJ2FLOPS+VYZJ2FLOPS)+ 3+(BK2FLOPS+VZXK2FLOPS+VZYK2FLOPS+VZZK2FLOPS) ) ; c o l . i=i +1; c o l . j=j ; c o l . k=k ; c o l . c =0; /  dR ( i , j , k ) / dS ( i +1, j , k ) a t b l o c k ( i , j , k ) , ( i +1, j , k )  /

140

APPENDIX 3. SOURCE CODE
905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

3.9. ODE.C

v a l [ 0 ] [ 0 ] = - 0 . 5  p c t x ->i n v d x  vx ( i , j , k ) ; val [0][1]=0.0; val [0][2]=0.0; val [0][3]=0.0; v a l [ 1 ] [ 0 ] = - b i 2 ( i , j , k )  p c t x ->i n v d x ; v a l [ 1 ] [ 1 ] = - 0 . 5  v x i 2 ( i , j , k )  p c t x ->i n v d x ; v a l [1][2]= -0.25 vxyi2 ( i , j , k ) ; v a l [1][3]= -0.25 v x z i 2 ( i , j , k ) ; val [2][0]=0.0; val [2][1]=0.0; v a l [ 2 ] [ 2 ] = - 0 . 5  v x j 2 ( i , j , k )  p c t x ->i n v d x ; val [2][3]=0.0; val [3][0]=0.0; val [3][1]=0.0; val [3][2]=0.0; v a l [ 3 ] [ 3 ] = - 0 . 5  p c t x ->i n v d x  v x k 2 ( i , j , k ) ; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (2+(VXFLOPS)+ 5+(BI2FLOPS+VXI2FLOPS+VXYI2FLOPS+VXZI2FLOPS)+ 2+(VXJ2FLOPS)+ 2+(VXK2FLOPS) ) ; c o l . i=i - 1; c o l . j=j ; c o l . k=k ; c o l . c =0; /  dR ( i , j , k ) / dS ( i - 1, j , k ) a t b l o c k ( i , j , k ) , ( i - 1, j , k )  / v a l [ 0 ] [ 0 ] = + 0 . 5  p c t x ->i n v d x  vx ( i , j , k ) ; v a l [ 0 ] [ 1 ] = kappa ( i , j , k )  p c t x ->i n v d x ; val [0][2]=0.0; val [0][3]=0.0; val [1][0]=0.0; v a l [ 1 ] [ 1 ] = + 0 . 5  v x i 2 ( i , j , k )  p c t x ->i n v d x ; val [1][2]=0.0; val [1][3]=0.0; val [2][0]=0.0; v a l [2][1]= -0.25 vyxj2 ( i , j , k ) ; v a l [ 2 ] [ 2 ] = + 0 . 5  v x j 2 ( i , j , k )  p c t x ->i n v d x ; val [2][3]=0.0; val [3][0]=0.0; v a l [3][1]= -0.25 vzxk2 ( i , j , k ) ; val [3][2]=0.0; v a l [ 3 ] [ 3 ] = 0 . 5  p c t x ->i n v d x  v x k 2 ( i , j , k ) ; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (3+(VXFLOPS)+ 2+(VXI2FLOPS)+ 3+(VYXJ2FLOPS+VXJ2FLOPS)+ 3+(VZXK2FLOPS+VXK2FLOPS) ) ; c o l . i=i ; c o l . j=j +1; c o l . k=k ; c o l . c =0;

141

3.9. ODE.C
955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

APPENDIX 3. SOURCE CODE

/  dR ( i , j , k ) / dS ( i , j +1, k ) a t b l o c k ( i , j , k ) , ( i , j +1, k )  / v a l [ 0 ] [ 0 ] = - 0 . 5  p c t x ->i n v d y  vy ( i , j , k ) ; val [0][1]=0.0; val [0][2]=0.0; val [0][3]=0.0; val [1][0]=0.0; v a l [ 1 ] [ 1 ] = - 0 . 5  p c t x ->i n v d y  v y i 2 ( i , j , k ) ; val [1][2]=0.0; val [1][3]=0.0; v a l [ 2 ] [ 0 ] = - p c t x ->i n v d y  b j 2 ( i , j , k ) ; v a l [2][1]= -0.25 vyxj2 ( i , j , k ) ; v a l [ 2 ] [ 2 ] = - 0 . 5  p c t x ->i n v d y  v y j 2 ( i , j , k ) ; v a l [2][3]= -0.25 vyzj2 ( i , j , k ) ; val [3][0]=0.0; val [3][1]=0.0; val [3][2]=0.0; v a l [ 3 ] [ 3 ] = - 0 . 5  p c t x ->i n v d y  vyk2 ( i , j , k ) ; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (2+(VYFLOPS)+ 5+(BJ2FLOPS+VYJ2FLOPS+VYXJ2FLOPS+VYZJ2FLOPS)+ 2+(VYI2FLOPS)+ 2+(VYK2FLOPS) ) ; c o l . i=i ; c o l . j=j - 1; c o l . k=k ; c o l . c =0; /  dR ( i , j , k ) / dS ( i , j - 1, k ) a t b l o c k ( i , j , k ) , ( i , j - 1, k )  / v a l [ 0 ] [ 0 ] = 0 . 5  p c t x ->i n v d y  vy ( i , j , k ) ; val [0][1]=0.0; v a l [ 0 ] [ 2 ] = p c t x ->i n v d y  kappa ( i , j , k ) ; val [0][3]=0.0; val [1][0]=0.0; v a l [ 1 ] [ 1 ] = 0 . 5  p c t x ->i n v d y  v y i 2 ( i , j , k ) ; v a l [1][2]= -0.25 vxyi2 ( i , j , k ) ; val [1][3]=0.0; val [2][0]=0.0; val [2][1]=0.0; v a l [ 2 ] [ 2 ] = 0 . 5  p c t x ->i n v d y  v y j 2 ( i , j , k ) ; val [2][3]=0.0; val [3][0]=0.0; val [3][1]=0.0; v a l [3][2]= -0.25 vzyk2 ( i , j , k ) ; v a l [ 3 ] [ 3 ] = 0 . 5  p c t x ->i n v d y  vyk2 ( i , j , k ) ; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (3+(VYFLOPS)+ 2+(VYJ2FLOPS)+ 3+(VXYI2FLOPS+VYI2FLOPS)+ 3+(VZXK2FLOPS+VYK2FLOPS) ) ; c o l . i=i ; c o l . j=j ; c o l . k=k +1; c o l . c =0;

142

APPENDIX 3. SOURCE CODE
1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

3.9. ODE.C

/  dR ( i , j , k ) / dS ( i , j , k+1) a t b l o c k ( i , j , k ) , ( i , j , k+1)  / v a l [ 0 ] [ 0 ] = - 0 . 5  p c t x -> i n v d z  v z ( i , j , k ) ; val [0][1]=0.0; val [0][2]=0.0; val [0][3]=0.0; val [1][0]=0.0; v a l [ 1 ] [ 1 ] = - 0 . 5  p c t x -> i n v d z  v z i 2 ( i , j , k ) ; val [1][2]=0.0; val [1][3]=0.0; val [2][0]=0.0; val [2][1]=0.0; v a l [ 2 ] [ 2 ] = - 0 . 5  p c t x -> i n v d z  v z j 2 ( i , j , k ) ; val [2][3]=0.0; v a l [ 3 ] [ 0 ] = - p c t x -> i n v d z  bk2 ( i , j , k ) ; v a l [3][1]= -0.25 vzxk2 ( i , j , k ) ; v a l [3][2]= -0.25 vzyk2 ( i , j , k ) ; v a l [ 3 ] [ 3 ] = - 0 . 5  p c t x -> i n v d z  v z k 2 ( i , j , k ) ; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (2+(VZFLOPS)+ 5+(BK2FLOPS+VZK2FLOPS+VZXK2FLOPS+VZYK2FLOPS)+ 2+(VZI2FLOPS)+ 2+(VZJ2FLOPS) ) ; c o l . i=i ; c o l . j=j ; c o l . k=k - 1; c o l . c =0; /  dR ( i , j , k ) / dS ( i , j , k -1) a t b l o c k ( i , j , k ) , ( i , j , k -1)  / v a l [ 0 ] [ 0 ] = 0 . 5  p c t x -> i n v d z  v z ( i , j , k ) ; val [0][1]=0.0; val [0][2]=0.0; v a l [ 0 ] [ 3 ] = p c t x -> i n v d z  kappa ( i , j , k ) ; val [1][0]=0.0; v a l [ 1 ] [ 1 ] = 0 . 5  p c t x -> i n v d z  v z i 2 ( i , j , k ) ; val [1][2]=0.0; v a l [1][3]= -0.25 v x z i 2 ( i , j , k ) ; val [2][0]=0.0; val [2][1]=0.0; v a l [ 2 ] [ 2 ] = 0 . 5  p c t x -> i n v d z  v z j 2 ( i , j , k ) ; v a l [2][3]= -0.25 vyzj2 ( i , j , k ) ; val [3][0]=0.0; val [3][1]=0.0; val [3][2]=0.0; v a l [ 3 ] [ 3 ] = 0 . 5  p c t x -> i n v d z  v z k 2 ( i , j , k ) ; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (3+(VZFLOPS)+ 2+(VZK2FLOPS)+ 3+(VXZI2FLOPS+VZI2FLOPS)+ 3+(VYZJ2FLOPS+VZJ2FLOPS) ) ; c o l . i=i +1; c o l . j=j ; c o l . k=k - 1; c o l . c =0;

143

3.9. ODE.C
1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

APPENDIX 3. SOURCE CODE

/  dR ( i , j , k ) / dS ( i +1, j , k -1) a t b l o c k ( i , j , k ) , ( i +1, j , k -1)  / val [0][0]=0.0; val [0][1]=0.0; val [0][2]=0.0; val [0][3]=0.0; val [1][0]=0.0; val [1][1]=0.0; val [1][2]=0.0; v a l [1][3]= -0.25 v x z i 2 ( i , j , k ) ; val [2][0]=0.0; val [2][1]=0.0; val [2][2]=0.0; val [2][3]=0.0; val [3][0]=0.0; val [3][1]=0.0; val [3][2]=0.0; val [3][3]=0.0; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (1+VXZI2FLOPS) ; c o l . i=i - 1; c o l . j=j ; c o l . k=k +1; c o l . c =0; /  dR ( i , j , k ) / dS ( i - 1, j , k+1) a t b l o c k ( i , j , k ) , ( i - 1, j , k+1)  / val [0][0]=0.0; val [0][1]=0.0; val [0][2]=0.0; val [0][3]=0.0; val [1][0]=0.0; val [1][1]=0.0; val [1][2]=0.0; val [1][3]=0.0; val [2][0]=0.0; val [2][1]=0.0; val [2][2]=0.0; val [2][3]=0.0; val [3][0]=0.0; v a l [3][1]= -0.25 vzxk2 ( i , j , k ) ; val [3][2]=0.0; val [3][3]=0.0; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (1+VZXK2FLOPS) ; c o l . i=i ; c o l . j=j +1; c o l . k=k - 1; c o l . c =0; /  dR ( i , j , k ) / dS ( i , j +1,k -1) a t b l o c k ( i , j , k ) , ( i , j +1,k -1)  / val [0][0]=0.0; val [0][1]=0.0; val [0][2]=0.0; val [0][3]=0.0; val [1][0]=0.0;

144

APPENDIX 3. SOURCE CODE
1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

3.9. ODE.C

val [1][1]=0.0; val [1][2]=0.0; val [1][3]=0.0; val [2][0]=0.0; val [2][1]=0.0; val [2][2]=0.0; v a l [2][3]= -0.25 vyzj2 ( i , j , k ) ; val [3][0]=0.0; val [3][1]=0.0; val [3][2]=0.0; val [3][3]=0.0; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (1+VYZJ2FLOPS) ; c o l . i=i ; c o l . j=j - 1; c o l . k=k +1; c o l . c =0; /  dR ( i , j , k ) / dS ( i , j - 1, k+1) a t b l o c k ( i , j , k ) , ( i , j - 1, k+1)  / val [0][0]=0.0; val [0][1]=0.0; val [0][2]=0.0; val [0][3]=0.0; val [1][0]=0.0; val [1][1]=0.0; val [1][2]=0.0; val [1][3]=0.0; val [2][0]=0.0; val [2][1]=0.0; val [2][2]=0.0; val [2][3]=0.0; val [3][0]=0.0; val [3][1]=0.0; v a l [3][2]= -0.25 vzyk2 ( i , j , k ) ; val [3][3]=0.0; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (1+VZYK2FLOPS) ; c o l . i=i +1; c o l . j=j - 1; c o l . k=k ; c o l . c =0; /  dR ( i , j , k ) / dS ( i +1, j - 1, k ) a t b l o c k ( i , j , k ) , ( i +1, j - 1, k )  / val [0][0]=0.0; val [0][1]=0.0; val [0][2]=0.0; val [0][3]=0.0; val [1][0]=0.0; val [1][1]=0.0; v a l [1][2]= -0.25 vxyi2 ( i , j , k ) ; val [1][3]=0.0; val [2][0]=0.0; val [2][1]=0.0; val [2][2]=0.0;

145

3.9. ODE.C
1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

APPENDIX 3. SOURCE CODE

val [2][3]=0.0; val [3][0]=0.0; val [3][1]=0.0; val [3][2]=0.0; val [3][3]=0.0; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (1+VXYI2FLOPS) ; c o l . i=i - 1; c o l . j=j +1; c o l . k=k ; c o l . c =0; /  dR ( i , j , k ) / dS ( i - 1, j +1, k ) a t b l o c k ( i , j , k ) , ( i - 1, j +1, k )  / val [0][0]=0.0; val [0][1]=0.0; val [0][2]=0.0; val [0][3]=0.0; val [1][0]=0.0; val [1][1]=0.0; val [1][2]=0.0; val [1][3]=0.0; val [2][0]=0.0; v a l [2][1]= -0.25 vyxj2 ( i , j , k ) ; val [2][2]=0.0; val [2][3]=0.0; val [3][0]=0.0; val [3][1]=0.0; val [3][2]=0.0; val [3][3]=0.0; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (1+VYXJ2FLOPS) ; } else { i f ( ReflectionRegion ( pctx , i , j , k ) ) /  A r e f l e c t i n g ground c o n d i t i o n  / c o l . i=i ; c o l . j=j ; c o l . k=k ; c o l . c =0; /  dR ( i , j , k ) / dS ( i , j , k ) a t b l o c k ( i , j , k ) , ( i , j , k )  / val [0][0]=0.0; v a l [ 0 ] [ 1 ] = - kappa ( i , j , k )  p c t x ->i n v d x ; v a l [ 0 ] [ 2 ] = - 2  kappa ( i , j , k )  p c t x ->i n v d y ; v a l [ 0 ] [ 3 ] = - kappa ( i , j , k )  p c t x -> i n v d z ; v a l [ 1 ] [ 0 ] = b i 2 ( i , j , k )  p c t x ->i n v d x ; v a l [1][1]= - v x x i 2 ( i , j , k ) ; val [1][2]=0.0; v a l [1][3]= -0.25 v x z i 2 ( i , j , k ) ; v a l [ 2 ] [ 0 ] = b j 2 ( i , j , k )  p c t x ->i n v d y ; v a l [2][1]= -0.25 vyxj2 ( i , j , k ) ; v a l [ 2 ] [ 2 ] = - v y y j 2 ( i , j , k ) +0.5  p c t x ->i n v d y  v y j 2 ( i , j , k ) ; v a l [2][3]= -0.25 vyzj2 ( i , j , k ) ; v a l [ 3 ] [ 0 ] = bk2 ( i , j , k )  p c t x -> i n v d z ; v a l [3][1]= -0.25 vzxk2 ( i , j , k ) ;

146

APPENDIX 3. SOURCE CODE
1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

3.9. ODE.C

val [3][2]=0.0; v a l [3][3]= - vzzk2 ( i , j , k ) ; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; / E l i m i n a t e z e r o s i n d i a g o n a l o f p r e c o n d i t i o n e r / // f o r ( d=0;d<d o f ; d++) // i f ( v a l [ d ] [ d]==0) v a l [ d ] [ d]=1 e - 3; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (4+ 3+(VYJ2FLOPS)+ 3+(BI2FLOPS+VXXI2FLOPS+VXZI2FLOPS)+ 3+(BJ2FLOPS+VYXJ2FLOPS+VYYJ2FLOPS+VYZJ2FLOPS)+ 3+(BK2FLOPS+VZXK2FLOPS+VZZK2FLOPS) ) ; c o l . i=i +1; c o l . j=j ; c o l . k=k ; c o l . c =0; /  dR ( i , j , k ) / dS ( i +1, j , k ) a t b l o c k ( i , j , k ) , ( i +1, j , k )  / v a l [ 0 ] [ 0 ] = - 0 . 5  p c t x ->i n v d x  vx ( i , j , k ) ; val [0][1]=0.0; val [0][2]=0.0; val [0][3]=0.0; v a l [ 1 ] [ 0 ] = - b i 2 ( i , j , k )  p c t x ->i n v d x ; v a l [ 1 ] [ 1 ] = - 0 . 5  v x i 2 ( i , j , k )  p c t x ->i n v d x ; val [1][2]=0.0; v a l [1][3]= -0.25 v x z i 2 ( i , j , k ) ; val [2][0]=0.0; val [2][1]=0.0; v a l [ 2 ] [ 2 ] = - 0 . 5  v x j 2 ( i , j , k )  p c t x ->i n v d x ; val [2][3]=0.0; val [3][0]=0.0; val [3][1]=0.0; val [3][2]=0.0; v a l [ 3 ] [ 3 ] = - 0 . 5  p c t x ->i n v d x  v x k 2 ( i , j , k ) ; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (2+(VXFLOPS)+ 5+(BI2FLOPS+VXI2FLOPS+VXZI2FLOPS)+ 2+(VXJ2FLOPS)+ 2+(VXK2FLOPS) ) ; c o l . i=i - 1; c o l . j=j ; c o l . k=k ; c o l . c =0; /  dR ( i , j , k ) / dS ( i - 1, j , k ) a t b l o c k ( i , j , k ) , ( i - 1, j , k )  / v a l [ 0 ] [ 0 ] = + 0 . 5  p c t x ->i n v d x  vx ( i , j , k ) ; v a l [ 0 ] [ 1 ] = kappa ( i , j , k )  p c t x ->i n v d x ; val [0][2]=0.0; val [0][3]=0.0; val [1][0]=0.0; v a l [ 1 ] [ 1 ] = + 0 . 5  v x i 2 ( i , j , k )  p c t x ->i n v d x ; val [1][2]=0.0; val [1][3]=0.0; val [2][0]=0.0;

147

3.9. ODE.C
1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

APPENDIX 3. SOURCE CODE

v a l [2][1]= -0.25 vyxj2 ( i , j , k ) ; v a l [ 2 ] [ 2 ] = + 0 . 5  v x j 2 ( i , j , k )  p c t x ->i n v d x ; val [2][3]=0.0; val [3][0]=0.0; v a l [3][1]= -0.25 vzxk2 ( i , j , k ) ; val [3][2]=0.0; v a l [ 3 ] [ 3 ] = 0 . 5  p c t x ->i n v d x  v x k 2 ( i , j , k ) ; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (3+(VXFLOPS)+ 2+(VXI2FLOPS)+ 3+(VYXJ2FLOPS+VXJ2FLOPS)+ 3+(VZXK2FLOPS+VXK2FLOPS) ) ; c o l . i=i ; c o l . j=j +1; c o l . k=k ; c o l . c =0; /  dR ( i , j , k ) / dS ( i , j +1, k ) a t b l o c k ( i , j , k ) , ( i , j +1, k )  / val [0][0]=0.0; val [0][1]=0.0; val [0][2]=0.0; val [0][3]=0.0; val [1][0]=0.0; val [1][1]=0.0; val [1][2]=0.0; val [1][3]=0.0; v a l [ 2 ] [ 0 ] = - p c t x ->i n v d y  b j 2 ( i , j , k ) ; v a l [2][1]= -0.25 vyxj2 ( i , j , k ) ; v a l [ 2 ] [ 2 ] = - 0 . 5  p c t x ->i n v d y  v y j 2 ( i , j , k ) ; v a l [2][3]= -0.25 vyzj2 ( i , j , k ) ; val [3][0]=0.0; val [3][1]=0.0; val [3][2]=0.0; val [3][3]=0.0; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (5+(BJ2FLOPS+VYJ2FLOPS+VYXJ2FLOPS+VYZJ2FLOPS) ) ; c o l . i=i ; c o l . j=j ; c o l . k=k +1; c o l . c =0; /  dR ( i , j , k ) / dS ( i , j , k+1) a t b l o c k ( i , j , k ) , ( i , j , k+1)  / v a l [ 0 ] [ 0 ] = - 0 . 5  p c t x -> i n v d z  v z ( i , j , k ) ; val [0][1]=0.0; val [0][2]=0.0; val [0][3]=0.0; val [1][0]=0.0; v a l [ 1 ] [ 1 ] = - 0 . 5  p c t x -> i n v d z  v z i 2 ( i , j , k ) ; val [1][2]=0.0; val [1][3]=0.0; val [2][0]=0.0; val [2][1]=0.0; v a l [ 2 ] [ 2 ] = - 0 . 5  p c t x -> i n v d z  v z j 2 ( i , j , k ) ; val [2][3]=0.0;

148

APPENDIX 3. SOURCE CODE
1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

3.9. ODE.C

v a l [ 3 ] [ 0 ] = - p c t x -> i n v d z  bk2 ( i , j , k ) ; v a l [3][1]= -0.25 vzxk2 ( i , j , k ) ; val [3][2]=0.0; v a l [ 3 ] [ 3 ] = - 0 . 5  p c t x -> i n v d z  v z k 2 ( i , j , k ) ; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (2+(VZFLOPS)+ 5+(BK2FLOPS+VZK2FLOPS+VZXK2FLOPS)+ 2+(VZI2FLOPS)+ 2+(VZJ2FLOPS) ) ; c o l . i=i ; c o l . j=j ; c o l . k=k - 1; c o l . c =0; /  dR ( i , j , k ) / dS ( i , j , k -1) a t b l o c k ( i , j , k ) , ( i , j , k -1)  / v a l [ 0 ] [ 0 ] = 0 . 5  p c t x -> i n v d z  v z ( i , j , k ) ; val [0][1]=0.0; val [0][2]=0.0; v a l [ 0 ] [ 3 ] = p c t x -> i n v d z  kappa ( i , j , k ) ; val [1][0]=0.0; v a l [ 1 ] [ 1 ] = 0 . 5  p c t x -> i n v d z  v z i 2 ( i , j , k ) ; val [1][2]=0.0; v a l [1][3]= -0.25 v x z i 2 ( i , j , k ) ; val [2][0]=0.0; val [2][1]=0.0; v a l [ 2 ] [ 2 ] = 0 . 5  p c t x -> i n v d z  v z j 2 ( i , j , k ) ; v a l [2][3]= -0.25 vyzj2 ( i , j , k ) ; val [3][0]=0.0; val [3][1]=0.0; val [3][2]=0.0; v a l [ 3 ] [ 3 ] = 0 . 5  p c t x -> i n v d z  v z k 2 ( i , j , k ) ; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (3+(VZFLOPS)+ 2+(VZK2FLOPS)+ 3+(VXZI2FLOPS+VZI2FLOPS)+ 3+(VYZJ2FLOPS+VZJ2FLOPS) ) ; c o l . i=i +1; c o l . j=j ; c o l . k=k - 1; c o l . c =0; /  dR ( i , j , k ) / dS ( i +1, j , k -1) a t b l o c k ( i , j , k ) , ( i +1, j , k -1)  / val [0][0]=0.0; val [0][1]=0.0; val [0][2]=0.0; val [0][3]=0.0; val [1][0]=0.0; val [1][1]=0.0; val [1][2]=0.0; v a l [1][3]= -0.25 v x z i 2 ( i , j , k ) ; val [2][0]=0.0; val [2][1]=0.0; val [2][2]=0.0; val [2][3]=0.0;

149

3.9. ODE.C
1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

APPENDIX 3. SOURCE CODE

val [3][0]=0.0; val [3][1]=0.0; val [3][2]=0.0; val [3][3]=0.0; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (1+VXZI2FLOPS) ; c o l . i=i - 1; c o l . j=j ; c o l . k=k +1; c o l . c =0; /  dR ( i , j , k ) / dS ( i - 1, j , k+1) a t b l o c k ( i , j , k ) , ( i - 1, j , k+1)  / val [0][0]=0.0; val [0][1]=0.0; val [0][2]=0.0; val [0][3]=0.0; val [1][0]=0.0; val [1][1]=0.0; val [1][2]=0.0; val [1][3]=0.0; val [2][0]=0.0; val [2][1]=0.0; val [2][2]=0.0; val [2][3]=0.0; val [3][0]=0.0; v a l [3][1]= -0.25 vzxk2 ( i , j , k ) ; val [3][2]=0.0; val [3][3]=0.0; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (1+VZXK2FLOPS) ; c o l . i=i ; c o l . j=j +1; c o l . k=k - 1; c o l . c =0; /  dR ( i , j , k ) / dS ( i , j +1,k -1) a t b l o c k ( i , j , k ) , ( i , j +1,k -1)  / val [0][0]=0.0; val [0][1]=0.0; val [0][2]=0.0; val [0][3]=0.0; val [1][0]=0.0; val [1][1]=0.0; val [1][2]=0.0; val [1][3]=0.0; val [2][0]=0.0; val [2][1]=0.0; val [2][2]=0.0; v a l [2][3]= -0.25 vyzj2 ( i , j , k ) ; val [3][0]=0.0; val [3][1]=0.0; val [3][2]=0.0; val [3][3]=0.0; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ;

150

APPENDIX 3. SOURCE CODE
1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // P e t s c L o g F l o p s (1+VYZJ2FLOPS) ;

3.9. ODE.C

c o l . i=i - 1; c o l . j=j +1; c o l . k=k ; c o l . c =0; /  dR ( i , j , k ) / dS ( i - 1, j +1, k ) a t b l o c k ( i , j , k ) , ( i - 1, j +1, k )  / val [0][0]=0.0; val [0][1]=0.0; val [0][2]=0.0; val [0][3]=0.0; val [1][0]=0.0; val [1][1]=0.0; val [1][2]=0.0; val [1][3]=0.0; val [2][0]=0.0; v a l [2][1]= -0.25 vyxj2 ( i , j , k ) ; val [2][2]=0.0; val [2][3]=0.0; val [3][0]=0.0; val [3][1]=0.0; val [3][2]=0.0; val [3][3]=0.0; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (1+VYXJ2FLOPS) ; } else { i f ( AbsorbingBCRegion ( p c t x , i , j , k ) )

/  ABC r e g i o n , extreme l i m i t s o f mesh  / c o l . i=i ; c o l . j=j ; c o l . k=k ; c o l . c =0; /  dR ( i , j , k ) / dS ( i , j , k ) a t b l o c k ( i , j , k ) , ( i , j , k )  / val [0][0]=0.0; i f ( ILowFace ( p c t x , i , j , k ) ) v a l [ 0 ] [ 1 ] = + p c t x ->i n v d x  kappae ( i , j , k ) ; else v a l [ 0 ] [ 1 ] = - p c t x ->i n v d x  kappae ( i , j , k ) ; i f ( JLowFace ( p c t x , i , j , k ) ) v a l [ 0 ] [ 2 ] = + p c t x ->i n v d y  kappae ( i , j , k ) ; else v a l [ 0 ] [ 2 ] = - p c t x ->i n v d y  kappae ( i , j , k ) ; i f ( KLowFace ( p c t x , i , j , k ) ) v a l [ 0 ] [ 3 ] = + p c t x -> i n v d z  kappae ( i , j , k ) ; else v a l [ 0 ] [ 3 ] = - p c t x -> i n v d z  kappae ( i , j , k ) ; i f ( IHighFace ( p c t x , i , j , k ) ) v a l [ 1 ] [ 0 ] = - p c t x ->i n v d x  b e i 2 ( i , j , k ) ; else v a l [ 1 ] [ 0 ] = + p c t x ->i n v d x  b e i 2 ( i , j , k ) ; v a l [1][1]= - s e i 2 ( i , j , k ) ; val [1][2]=0.0; val [1][3]=0.0; i f ( JHighFace ( p c t x , i , j , k ) )

151

3.9. ODE.C
1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

APPENDIX 3. SOURCE CODE

v a l [ 2 ] [ 0 ] = - p c t x ->i n v d y  b e j 2 ( i , j , k ) ; else v a l [ 2 ] [ 0 ] = + p c t x ->i n v d y  b e j 2 ( i , j , k ) ; val [2][1]=0.0; v a l [2][2]= - s e j 2 ( i , j , k ) ; val [2][3]=0.0; i f ( KHighFace ( p c t x , i , j , k ) ) v a l [ 3 ] [ 0 ] = - p c t x -> i n v d z  b e k 2 ( i , j , k ) ; else v a l [ 3 ] [ 0 ] = + p c t x -> i n v d z  b e k 2 ( i , j , k ) ; val [3][1]=0.0; val [3][2]=0.0; v a l [3][3]= - sek2 ( i , j , k ) ; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; / E l i m i n a t e z e r o s i n d i a g o n a l o f p r e c o n d i t i o n e r / // f o r ( d=0;d<d o f ; d++) // i f ( v a l [ d ] [ d]==0) v a l [ d ] [ d]=1 e - 3; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (3+ 1+(BI2FLOPS+SEI2FLOPS)+ 1+(BJ2FLOPS+SEJ2FLOPS)+ 1+(BK2FLOPS+SEK2FLOPS) ) ; if { c o l . i=i +1; c o l . j=j ; c o l . k=k ; c o l . c =0; /  dR ( i , j , k ) / dS ( i +1, j , k ) a t b l o c k ( i , j , k ) , ( i +1, j , k )  / val [0][0]=0.0; i f ( ILowFace ( p c t x , i , j , k ) ) v a l [ 0 ] [ 1 ] = - p c t x ->i n v d x  kappae ( i , j , k ) ; else val [0][1]=0.0; val [0][2]=0.0; val [0][3]=0.0; v a l [ 1 ] [ 0 ] = - p c t x ->i n v d x  b e i 2 ( i , j , k ) ; val [1][1]=0.0; val [1][2]=0.0; val [1][3]=0.0; val [2][0]=0.0; val [2][1]=0.0; val [2][2]=0.0; val [2][3]=0.0; val [3][0]=0.0; val [3][1]=0.0; val [3][2]=0.0; val [3][3]=0.0; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (1+BI2FLOPS) ; } ( ! IHighFace ( p c t x , i , j , k ) )

152

APPENDIX 3. SOURCE CODE
1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

3.9. ODE.C

if {

( ! ILowFace ( p c t x , i , j , k ) )

c o l . i=i - 1; c o l . j=j ; c o l . k=k ; c o l . c =0; /  dR ( i , j , k ) / dS ( i - 1, j , k ) a t b l o c k ( i , j , k ) , ( i - 1, j , k )  / val [0][0]=0.0; v a l [ 0 ] [ 1 ] = + p c t x ->i n v d x  kappae ( i , j , k ) ; val [0][2]=0.0; val [0][3]=0.0; i f ( IHighFace ( p c t x , i , j , k ) ) v a l [ 1 ] [ 0 ] = - p c t x ->i n v d x  b e i 2 ( i , j , k ) ; else val [1][0]=0.0; val [1][1]=0.0; val [1][2]=0.0; val [1][3]=0.0; val [2][0]=0.0; val [2][1]=0.0; val [2][2]=0.0; val [2][3]=0.0; val [3][0]=0.0; val [3][1]=0.0; val [3][2]=0.0; val [3][3]=0.0; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; PetscLogFlops (1) ; } if { c o l . i=i ; c o l . j=j +1; c o l . k=k ; c o l . c =0; /  dR ( i , j , k ) / dS ( i , j +1, k ) a t b l o c k ( i , j , k ) , ( i , j +1, k )  / val [0][0]=0.0; val [0][1]=0.0; i f ( JLowFace ( p c t x , i , j , k ) ) v a l [ 0 ] [ 2 ] = - p c t x ->i n v d y  kappae ( i , j , k ) ; else val [0][2]=0.0; val [0][3]=0.0; val [1][0]=0.0; val [1][1]=0.0; val [1][2]=0.0; val [1][3]=0.0; v a l [ 2 ] [ 0 ] = - p c t x ->i n v d y  b e j 2 ( i , j , k ) ; val [2][1]=0.0; val [2][2]=0.0; val [2][3]=0.0; val [3][0]=0.0; val [3][1]=0.0; ( ! JHighFace ( p c t x , i , j , k ) )

153

3.9. ODE.C
1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

APPENDIX 3. SOURCE CODE

val [3][2]=0.0; val [3][3]=0.0; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (1+BJ2FLOPS) ; } if { c o l . i=i ; c o l . j=j - 1; c o l . k=k ; c o l . c =0; /  dR ( i , j , k ) / dS ( i , j - 1, k ) a t b l o c k ( i , j , k ) , ( i , j - 1, k )  / val [0][0]=0.0; val [0][1]=0.0; v a l [ 0 ] [ 2 ] = + p c t x ->i n v d y  kappae ( i , j , k ) ; val [0][3]=0.0; val [1][0]=0.0; val [1][1]=0.0; val [1][2]=0.0; val [1][3]=0.0; i f ( JHighFace ( p c t x , i , j , k ) ) v a l [ 2 ] [ 0 ] = - p c t x ->i n v d y  b e j 2 ( i , j , k ) ; else val [2][0]=0.0; val [2][1]=0.0; val [2][2]=0.0; val [2][3]=0.0; val [3][0]=0.0; val [3][1]=0.0; val [3][2]=0.0; val [3][3]=0.0; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; PetscLogFlops (1) ; } if { c o l . i=i ; c o l . j=j ; c o l . k=k +1; c o l . c =0; /  dR ( i , j , k ) / dS ( i , j , k+1) a t b l o c k ( i , j , k ) , ( i , j , k+1)  / val [0][0]=0.0; val [0][1]=0.0; val [0][2]=0.0; i f ( KLowFace ( p c t x , i , j , k ) ) v a l [ 0 ] [ 3 ] = - p c t x -> i n v d z  kappae ( i , j , k ) ; else val [0][3]=0.0; val [1][0]=0.0; val [1][1]=0.0; val [1][2]=0.0; val [1][3]=0.0; ( ! KHighFace ( p c t x , i , j , k ) ) ( ! JLowFace ( p c t x , i , j , k ) )

154

APPENDIX 3. SOURCE CODE
1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // //

3.9. ODE.C

val [2][0]=0.0; val [2][1]=0.0; val [2][2]=0.0; val [2][3]=0.0; v a l [ 3 ] [ 0 ] = - p c t x -> i n v d z  b e k 2 ( i , j , k ) ; val [3][1]=0.0; val [3][2]=0.0; val [3][3]=0.0; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; P e t s c L o g F l o p s (1+BK2FLOPS) ; } if { c o l . i=i ; c o l . j=j ; c o l . k=k - 1; c o l . c =0; /  dR ( i , j , k ) / dS ( i , j , k -1) a t b l o c k ( i , j , k ) , ( i , j , k -1)  / val [0][0]=0.0; val [0][1]=0.0; val [0][2]=0.0; v a l [ 0 ] [ 3 ] = + p c t x -> i n v d z  kappae ( i , j , k ) ; val [1][0]=0.0; val [1][1]=0.0; val [1][2]=0.0; val [1][3]=0.0; val [2][0]=0.0; val [2][1]=0.0; val [2][2]=0.0; val [2][3]=0.0; i f ( KHighFace ( p c t x , i , j , k ) ) v a l [ 3 ] [ 0 ] = - p c t x -> i n v d z  b e k 2 ( i , j , k ) ; else val [3][0]=0.0; val [3][1]=0.0; val [3][2]=0.0; val [3][3]=0.0; M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pPC,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; PetscLogFlops (1) ; } } else { c o l . i=i ; c o l . j=j ; c o l . k=k ; c o l . c =0; /  dR ( i , j , k ) / dS ( i , j , k ) a t b l o c k ( i , j , k ) , ( i , j , k )  / val [0][0]=1.0; val [0][1]=0.0; val [0][2]=0.0; val [0][3]=0.0; val [1][0]=0.0; ( ! KLowFace ( p c t x , i , j , k ) )

155

3.9. ODE.C
1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704

APPENDIX 3. SOURCE CODE

// val [1][1]=1.0; // val [1][2]=0.0; // val [1][3]=0.0; // val [2][0]=0.0; // val [2][1]=0.0; // val [2][2]=1.0; // val [2][3]=0.0; // val [3][0]=0.0; // val [3][1]=0.0; // val [3][2]=0.0; // val [3][3]=1.0; // M a t S e t V a l u e s B l o c k e d S t e n c i l (  pJ ,1 ,& row ,1 ,& c o l ,& v a l [ 0 ] [ 0 ] , INSERT VALUES) ; // } // } // MatAssemblyBegin (  pJ ,MAT FINAL ASSEMBLY) ; // MatAssemblyEnd (  pJ ,MAT FINAL ASSEMBLY) ; // // MatAssemblyBegin (  pPC,MAT FINAL ASSEMBLY) ; // // MatAssemblyEnd (  pPC ,MAT FINAL ASSEMBLY) ;m, m, // // DAVecRestoreArrayDOF ( p c t x ->da , l o c a l ,& s ) ; // /  Return l o c a l v e c t o r r e p r e s e n t a t i o n t o DA  / // DARestoreLocalVector ( p c t x ->da ,& l o c a l ) ; // // /  The non-z e r o p a t t e r n o f t h e s e m a t r i c e s i s unchanged from t i m e s t e p t o t i m e s t e p  / // (  f l a g )=SAME NONZERO PATTERN; // // /  S e t a f l a g t o t h r o u g h an e r r o r i f t h e nonzero p a t t e r n d o e s change  / // MatSetOption (  pJ ,MAT NEW NONZERO LOCATION ERR,PETSC TRUE) ; // // MatSetOption (  pPC ,MAT NEW NONZERO LOCATION ERR,PETSC TRUE) ; // // PetscLogEventEnd ( p c t x ->FormJacobianEvent , 0 , 0 , 0 , 0 ) ; // // return 0; // } // Pets cTruth I n t e r i o r R e g i o n ( a p p c t x  pctx , PetscInt i , PetscInt j , PetscInt k) { i f ( i >pctx -> i l o && i <pctx -> i h i && j >pctx -> j l o && j <pctx -> j h i && ( TwoDimensional ( p c t x ) | | ( k>pctx -> k l o && k<pctx -> k h i ) ) ) return PETSC TRUE ; return PETSC FALSE ; } Pets cTruth R e f l e c t i o n R e g i o n ( a p p c t x  pctx , PetscInt i ,

156

APPENDIX 3. SOURCE CODE

3.9. ODE.C

1705 PetscInt j , 1706 PetscInt k) 1707 { 1708 / I f s t a t e m e n t s s h o u l d a l w a y s c h e c k f o r I n t e r i o r R e g i o n f i r s t b e f o r e R e f l e c t i o n R e g i o n / 1709 b c p a r a m e t e r s  bc=( b c p a r a m e t e r s  ) pctx ->pbc ; 1710 a s s e r t ( bc ) ; 1711 i f ( bc->R e f l e c t i v e G r o u n d && 1712 j==pctx -> j l o && 1713 ( i >=0 && i <=pctx ->params->mesh . Nx- 1) && 1714 ( TwoDimensional ( p c t x ) | | ( k>=0 && k<=pctx ->params->mesh . Nz - 1) ) ) 1715 return PETSC TRUE ; 1716 return PETSC FALSE ; 1717 } 1718 1719 PetscTruth AbsorbingBCRegion ( a p p c t x  pctx , 1720 PetscInt i , 1721 PetscInt j , 1722 PetscInt k) 1723 { 1724 / I f s t a t e m e n t s s h o u l d a l w a y s c h e c k f o r R e f l e c t i o n R e g i o n f i r s t b e f o r e AbsorbingBCRegion  / 1725 i f ( ( i >=0 && i <=pctx -> i l o ) | | 1726 ( i >=pctx -> i h i && i <=pctx ->params->mesh . Nx- 1) | | 1727 ( j >=0 && j <=pctx -> j l o ) | | 1728 ( j >=pctx -> j h i && j <=pctx ->params->mesh . Ny- 1) | | 1729 ( ! TwoDimensional ( p c t x ) && k>=0 && k<=pctx -> k l o ) | | 1730 ( ! TwoDimensional ( p c t x ) && k>=pctx -> k h i && k<=pctx ->params->mesh . Nz - 1) ) 1731 return PETSC TRUE ; 1732 return PETSC FALSE ; 1733 } 1734 1735 PetscTruth TwoDimensional ( a p p c t x  p c t x ) 1736 { 1737 i f ( pctx ->params->mesh . Nz==1) return PETSC TRUE ; 1738 return PETSC FALSE ; 1739 } 1740 1741 PetscTruth ILowFace ( a p p c t x  pctx , 1742 PetscInt i , 1743 PetscInt j , 1744 PetscInt k) 1745 { 1746 i f ( i ==0) return PETSC TRUE ; 1747 return PETSC FALSE ; 1748 } 1749 1750 PetscTruth JLowFace ( a p p c t x  pctx , 1751 PetscInt i , 1752 PetscInt j ,

157

3.10. PARAM.H
1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 PetscInt k) { i f ( j ==0) return PETSC TRUE ; return PETSC FALSE ; } Pets cTruth KLowFace ( a p p c t x  pctx , PetscInt i , PetscInt j , PetscInt k) { i f ( k==0) return PETSC TRUE ; return PETSC FALSE ; } Pets cTruth IHighFace ( a p p c t x  pctx , PetscInt i , PetscInt j , PetscInt k) { i f ( i==pctx ->params->mesh . Nx- 1) return PETSC TRUE ; return PETSC FALSE ; } Pets cTruth JHighFace ( a p p c t x  pctx , PetscInt i , PetscInt j , PetscInt k) { i f ( j==pctx ->params->mesh . Ny- 1) return PETSC TRUE ; return PETSC FALSE ; } Pets cTruth KHighFace ( a p p c t x  pctx , PetscInt i , PetscInt j , PetscInt k) { i f ( k==pctx ->params->mesh . Nz - 1) return PETSC TRUE ; return PETSC FALSE ; }

APPENDIX 3. SOURCE CODE

3.10
1 2 3 4 5

param.h

#i f n d e f PARAM H #define PARAM H #include < p e t s c . h> #include <p e t s c b a g . h>

158

APPENDIX 3. SOURCE CODE

3.10. PARAM.H

6 7 /  ! \ f i l e param . h 8 \ b r i e f Run-time p a r a m e t e r s h e a d e r f i l e . 9 10 This h e a d e r f i l e d e f i n e s a number o f p a r a m e t e r s which c o n t r o l t h e b e h a v i o u r o f t h e solver . 11  / 12 13 #include " s o u r c e . h" 14 #include "mean . h" 15 #include " bc . h" 16 17 /  ! \ b r i e f Time march p a r a m e t e r s 18 19 Parameters r e l a t e d t o time marching methods .  / 20 typedef struct { 21 PetscReal t0 ; /  ! < I n i t i a l time  / 22 P e t s c R e a l dt ; /  ! < Time s t e p i n t e r v a l  / 23 P e t s c R e a l tmax ; /  ! < F i n a l time  / 24 PetscReal T; /  ! < RMS a v e r a g e i n t e r v a l  / 25 PetscReal courant ; /  ! < Courant number  / 26 P e t s c I n t maxsteps ; /  ! < Maximum number o f time s t e p s  / 27 PetscInt savefreq ; / !< C h e c k p o i n t s a v e i n t e r v a l / 28 } t i m e m a r c h p a r a m e t e r s ; 29 30 /  ! \ b r i e f Mesh p a r a m e t e r s 31 32 Parameters r e l a t e d t o mesh d i m e n s i o n s .  / 33 typedef struct { 34 P e t s c I n t Nx ; /  ! < Mesh dimension i n x d i r e c t i o n  / 35 P e t s c I n t Ny ; /  ! < Mesh dimension i n y d i r e c t i o n  / 36 P e t s c I n t Nz ; /  ! < Mesh dimension i n z d i r e c t i o n  / 37 P e t s c R e a l xmax ; /  ! < Maximum s p a c e dimension i n x d i r e c t i o n  / 38 P e t s c R e a l xmin ; /  ! < Minimum s p a c e dimension i n x d i r e c t i o n  / 39 PetscReal xlayer ; /  ! < T h i c k n e s s o f ABC r e g i o n p e r p e n d i c u l a r t o x  / 40 P e t s c R e a l ymax ; /  ! < Maximum s p a c e dimension i n y d i r e c t i o n  / 41 P e t s c R e a l ymin ; /  ! < Minimum s p a c e dimension i n y d i r e c t i o n  / 42 PetscReal ylayer ; /  ! < T h i c k n e s s o f ABC r e g i o n p e r p e n d i c u l a r t o y  / 43 P e t s c R e a l zmax ; /  ! < Maximum s p a c e dimension i n z d i r e c t i o n  / 44 P e t s c R e a l zmin ; /  ! < Minimum s p a c e dimension i n z d i r e c t i o n  / 45 PetscReal z l a y e r ; /  ! < T h i c k n e s s o f ABC r e g i o n p e r p e n d i c u l a r t o z  / 46 P e t s c I n t NodesPerWave ; /  ! < D e s i r e d number o f mesh nodes p e r w a v e l e n g t h  / 47 P e t s c I n t NumWavesInLayer ; /  ! < D e s i r e d number o f w a v e l e n g t h s w i t h i n ABC r e g i o n  / 48 } m e s h p a r a m e t e r s ; 49 50 /  ! \ b r i e f G l o b a l p a r a m e t e r s 51 52 C o l l e c t i o n o f g l o b a l run-time p a r a m e t e r s p a r a m e t e r s .  / 53 typedef struct { 54 m e s h p a r a m e t e r s mesh ; /  ! < C o l l e c t i o n o f mesh p a r a m e t e r s  /

159

3.11. PARAM.C

APPENDIX 3. SOURCE CODE

55 t i m e m a r c h p a r a m e t e r s tm ; /  ! < C o l l e c t i o n o f timemarching p a r a m e t e r s  / 56 m e a n f l o w t y p e mean ; /  ! < Mean f l o w t y p e s p e c i f i e r  / 57 source type source ; /  ! < Source t y p e s p e c i f i e r  / 58 } p a r a m e t e r s ; 59 60 /  ! R e g i s t e r p a r a m e t e r s u s i n g PetscBag , o p t i o n a l l y l o a d i n g v a l u e s from e x i s t i n g f i l e  / 61 P e t s c E r r o r C o d e R e g i s t e r P a r a m e t e r B a g ( PetscBag  bag , p a r a m e t e r s  params , P e t s c T r u t h LoadFromFile ) ; 62 63 /  ! Save parameter v a l u e s t o f i l e .  / 64 void SaveParameterBag ( PetscBag bag ) ; 65 66 /  ! Check v a l i d i t y o f c u r r e n t p a r a m e t e r s  / 67 PetscTr uth P a r a m e t e r s A r e I n c o r r e c t ( p a r a m e t e r s  params ) ; 68 69 #endif

3.11
1 2 3 4 5 6 7

param.c

#include < a s s e r t . h> #include < s t d l i b . h> #include < p e t s c . h> #include "param . h"

const char  MeanChoices [ ] = { " mean uniform " , " power law " , "Mean Flow C h o i c e s " , " " , 0 } ; const char  S o u r c e C h o i c e s [ ] = { " none " , " mono ping " , " monopole " , " d i p o l e " , " m o n o p o l e s e r i e s " , " d i p o l e s e r i e s " , " Source Choices " , "" , 0 } ; 8 const char P a r a m e t e r s F i l e [ ] = " p a r a m e t e r s . dat " ; 9 10 P e t s c E r r o r C o d e R e g i s t e r P a r a m e t e r B a g ( PetscBag  bag , p a r a m e t e r s  params , P e t s c T r u t h LoadFromFile ) 11 { 12 PetscErrorCode i e r r ; 13 a s s e r t ( bag ) ; 14 a s s e r t ( params ) ; 15 16 i e r r=P e t s c B a g C r e a t e (PETSC COMM WORLD, s i z e o f ( p a r a m e t e r s ) , bag ) ; CHKERRQ( i e r r ) ; 17 i e r r=PetscBagGetData (  bag , ( void   ) params ) ; CHKERRQ( i e r r ) ; 18 19 i e r r=PetscBagSetName (  bag , " Parameter s " , " runt ime p a r a m e t e r s f o r t h e a c o u s t i c s o l v e r " ) ; 20 /  Mesh p a r a m e t e r s  / 21 i e r r=P e t s c B a g R e g i s t e r I n t (  bag ,&(  params )->mesh . Nx , 1 1 , "N x" , "Number o f mesh nodes i n x- d i r e c t i o n " ) ; CHKERRQ( i e r r ) ; 22 i e r r=P e t s c B a g R e g i s t e r I n t (  bag ,&(  params )->mesh . Nx , 1 1 , "N x" , "Number o f mesh nodes i n x- d i r e c t i o n " ) ; CHKERRQ( i e r r ) ; 23 i e r r=P e t s c B a g R e g i s t e r I n t (  bag ,&(  params )->mesh . Ny , 1 1 , "N y" , "Number o f mesh nodes i n y- d i r e c t i o n " ) ; CHKERRQ( i e r r ) ; 24 i e r r=P e t s c B a g R e g i s t e r I n t (  bag ,&(  params )->mesh . Nz , 1 1 , " N z " , "Number o f mesh nodes i n z- d i r e c t i o n " ) ; CHKERRQ( i e r r ) ;

160

APPENDIX 3. SOURCE CODE
25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55

3.11. PARAM.C

i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&(  params )->mesh . xmin , - 100 , " x min " , " Lower x- d i r e c t i o n l i m i t on f l o w r e g i o n " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&(  params )->mesh . ymin , - 100 , " y min " , " Lower y- d i r e c t i o n l i m i t on f l o w r e g i o n " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&(  params )->mesh . zmin , - 100 , " z min " , " Lower z- d i r e c t i o n l i m i t on f l o w r e g i o n " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&(  params )->mesh . xmax , + 1 0 0 , "x max" , " Upper x- d i r e c t i o n l i m i t on f l o w r e g i o n " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&(  params )->mesh . ymax , + 1 0 0 , "y max" , " Upper y- d i r e c t i o n l i m i t on f l o w r e g i o n " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&(  params )->mesh . zmax , + 1 0 0 , " z max " , " Upper z- d i r e c t i o n l i m i t on f l o w r e g i o n " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&(  params )->mesh . x l a y e r , 0 , " x l a y e r " , "ABC l a y e r t h i c k n e s s i n x- d i r e c t i o n " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&(  params )->mesh . y l a y e r , 0 , " y l a y e r " , "ABC l a y e r t h i c k n e s s i n y- d i r e c t i o n " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&(  params )->mesh . z l a y e r , 0 , " z l a y e r " , "ABC l a y e r t h i c k n e s s i n z- d i r e c t i o n " ) ; CHKERRQ( i e r r ) ; /  Time march p a r a m e t e r s  / i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&(  params )->tm . dt , 1 , " dt " , "Time s t e p i n t e r v a l ( s ) , i f u s i n g f i x e d time s t e p " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&(  params )->tm . t0 , 0 , " t 0 " , " I n i t i a l time ( s ) " ) ; CHKERRQ( ierr ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&(  params )->tm . tmax , 1 , " t max " , " F i n a l time ( s ) " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&(  params )->tm . T, 0 . 1 , "T" , "RMS a v e r a g e p e r i o d o f sound p r e s s u r e ( s ) " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&(  params )->tm . c o u r a n t , 0 . 5 , " c o u r a n t " , " Courant number" ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r I n t (  bag ,&(  params )->tm . maxsteps , 1 0 0 0 0 0 , " m a x s t e p s " , "Maximum number o f time s t e p s " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r I n t (  bag ,&(  params )->tm . s a v e f r e q , 0 , " s a v e f r e q " , " Timestep f r e q u e n c y o f c h e c k p o i n t s a v e " ) ; CHKERRQ( i e r r ) ; /  Mean f l o w t y p e  / i e r r=PetscBagRegisterEnum (  bag ,&(  params )->mean , MeanChoices , ( PetscEnum )MEAN UNIFORM, " mean" , " Choose mean f l o w method " ) ; CHKERRQ( i e r r ) ; /  Source t y p e  / i e r r=PetscBagRegisterEnum (  bag ,&(  params )-> s o u r c e , S o u r c e C h o i c e s , ( PetscEnum ) SOURCE MONO PING, " s o u r c e " , " Choose s o u r c e method " ) ; CHKERRQ( i e r r ) ; (  params )->mesh . NodesPerWave =1; (  params )->mesh . NumWavesInLayer =0; i f ( LoadFromFile ) { PetscViewer bagviewer ; i f ( i e r r=PetscViewerBinaryOpen (PETSC COMM WORLD, P a r a m e t e r s F i l e , FILE MODE READ,& bagviewer ) )

161

3.11. PARAM.C
56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 {

APPENDIX 3. SOURCE CODE

P e t s c P r i n t f (PETSC COMM WORLD, " Unable t o l o a d %s . \ n" , P a r a m e t e r s F i l e ) ; CHKERRQ( i e r r ) ; } i e r r=PetscBagLoad ( b agv iewe r , bag ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c V i e w e r D e s t r o y ( b a g v i e w e r ) ; CHKERRQ( i e r r ) ; i e r r=PetscBagGetData (  bag , ( void   ) params ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c P r i n t f (PETSC COMM WORLD, " Loaded p a r a m e t e r s : \ n" ) ; CHKERRQ( i e r r ) ; i e r r=PetscBagView (  bag ,PETSC VIEWER STDOUT WORLD) ; CHKERRQ( i e r r ) ; } return 0 ; } void SaveParameterBag ( PetscBag bag ) { PetscViewer bagviewer ; /  Save t h e runtime p a r a m e t e r s t o a b i n a r y f i l e  / PetscViewerBinaryOpen (PETSC COMM WORLD, P a r a m e t e r s F i l e , FILE MODE WRITE,& b a g v i e w e r ) ; PetscBagView ( bag , b a g v i e w e r ) ; PetscViewerDestroy ( bagviewer ) ; } PetscTr uth P a r a m e t e r s A r e I n c o r r e c t ( p a r a m e t e r s  params ) { unsigned long MaxIndex=1<<( s i z e o f ( P e t s c I n t )  8 - 1) ; unsigned long NumUnknowns=4 params->mesh . Nx params->mesh . Ny params->mesh . Nz ; a s s e r t ( params ) ; i f ( params->mesh . Nx<3 | | params->mesh . Ny<3 | | params->mesh . Nz < 1) { P e t s c P r i n t f (PETSC COMM WORLD, "Mesh d i m e n s i o n s must be g r e a t e r than 3 i n a t l e a s t t h e x and y d i m e n s i o n . \ n" ) ; return PETSC TRUE ; } i f ( params->tm . c o u r a n t <=0) { P e t s c P r i n t f (PETSC COMM WORLD, " Courant number s h o u l d be > 0, e . g . 0 . 8 5 \ n" ) ; return PETSC TRUE ; } i f ( NumUnknowns>MaxIndex ) { P e t s c P r i n t f (PETSC COMM WORLD, " Problem s i z e w i l l e x c e e d maximum number o f unknowns a v a i l a b l e on t h i s system ( s i z e o f P e t s c I n t i s %d ) \ n" , s i z e o f ( P e t s c I n t ) ) ; return PETSC TRUE ; } i f ( params->mesh . xmax<params->mesh . xmin | | params->mesh . ymax<params->mesh . ymin | |

162

APPENDIX 3. SOURCE CODE
104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 ( params->mesh . Nz>1 && params->mesh . zmax<params->mesh . zmin ) ) { P e t s c P r i n t f (PETSC COMM WORLD, " Flow domain d i m e n s i o n . \ n" ) ; P e t s c P r i n t f (PETSC COMM WORLD, " xmin : %g m params->mesh . xmax ) ; P e t s c P r i n t f (PETSC COMM WORLD, " ymin : %g m params->mesh . ymax ) ; P e t s c P r i n t f (PETSC COMM WORLD, " zmin : %g m params->mesh . zmax ) ; return PETSC TRUE ; }

3.12. SETUP.H

must span a non- z e r o i n t e r v a l i n each t o xmax : %g m\ n" , params->mesh . xmin , t o ymax : %g m\ n" , params->mesh . ymin , t o zmax : %g m\ n" , params->mesh . zmin ,

124 125 126 127 128 129 130 return PETSC FALSE ; 131 }

i f ( params->mesh . x l a y e r  2 > (params->mesh . xmax-params->mesh . xmin ) | | params->mesh . y l a y e r  2 > (params->mesh . ymax-params->mesh . ymin ) | | params->mesh . z l a y e r  2 > (params->mesh . zmax-params->mesh . zmin ) | | params->mesh . xmin+params->mesh . x l a y e r >params->mesh . xmax-params->mesh . x l a y e r | | params->mesh . ymin+params->mesh . y l a y e r >params->mesh . ymax-params->mesh . y l a y e r | | params->mesh . zmin+params->mesh . z l a y e r >params->mesh . zmax-params->mesh . z l a y e r ) { P e t s c P r i n t f (PETSC COMM WORLD, " Flow domain must span a t l e a s t 2x t h e r e q u e s t e d boundary c o n d i t i o n l a y e r s . \ n" ) ; P e t s c P r i n t f (PETSC COMM WORLD, " xmin : %g m t o xmax : %g m\ n" , params->mesh . xmin , params->mesh . xmax ) ; P e t s c P r i n t f (PETSC COMM WORLD, " ymin : %g m t o ymax : %g m\ n" , params->mesh . ymin , params->mesh . ymax ) ; P e t s c P r i n t f (PETSC COMM WORLD, " zmin : %g m t o zmax : %g m\ n" , params->mesh . zmin , params->mesh . zmax ) ; P e t s c P r i n t f (PETSC COMM WORLD, " x l a y e r : %g m\ n" , params->mesh . x l a y e r ) ; P e t s c P r i n t f (PETSC COMM WORLD, " y l a y e r : %g m\ n" , params->mesh . y l a y e r ) ; P e t s c P r i n t f (PETSC COMM WORLD, " z l a y e r : %g m\ n" , params->mesh . z l a y e r ) ; return PETSC TRUE ; }

3.12
1 2 3 4 5 6 7 8 9 #i f n d e f #define

setup.h
SETUP H SETUP H

#include " ode . h" / ! \ f i l e s e t u p . h \ b r i e f Setup f o r data s t r u c t u r e s D e c l a r e s f u n c t i o n s f o r a l l o c a t i n g and d e a l l o c a t i n g d a t a s t r u c t u r e s b a s e d upon run-time parameters .

163

3.13. SETUP.C
10 11 12 13 14 15 16 17 18 19 20 /

APPENDIX 3. SOURCE CODE

/  ! C r e a t e t h e n e c e s s a r y d a t a s t r u c t u r e s t o time march t h e s o l u t i o n  / P e t s c E r r o r C o d e C r e a t e S t o r a g e ( Vec  p s o l , app ctx  pctx ) ; /  ! D e s t r o y t h e n e c e s s a r y d a t a s t r u c t u r e s t o time march t h e s o l u t i o n  / P e t s c E r r o r C o d e D e s t r o y S t o r a g e ( Vec p s o l , app ctx  context ) ; #endif

3.13
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35

setup.c

#include < a s s e r t . h> #include < p e t s c . h> #include " ode . h" #include " s e t u p . h" #include "math . h" #include " i o . h" P e t s c E r r o r C o d e C r e a t e S t o r a g e ( Vec  p s o l u t i o n , app ctx  pctx ) { const i n t d o f =4; const i n t s t e n c i l w i d t h =1; DAStencilType s t e n c i l t y p e=DA STENCIL BOX ; P e t s c I n t sx , sy , sz , mx, my, mz ; P e t s c I n t low , high , g l o b a l l e n , l o c a l l e n ; P e t s c I n t mlow , mhigh ,mM,mN; i n t rank , s i z e ; ISColoring i s c o l o r i n g ; p a r a m e t e r s  params=pctx ->params ; PetscErrorCode i e r r ; MPI Comm rank (PETSC COMM WORLD,& rank ) ; MPI Comm size (PETSC COMM WORLD,& s i z e ) ; a s s e r t ( pctx ) ; a s s e r t ( params ) ; assert ( psolution ) ; PetscLogEventBegin ( pctx ->SetupEvent , 0 , 0 , 0 , 0 ) ; /  V e c t o r s f o r i n t e r m e d i a t e c a l c u l a t i o n s a r e s t o r e d under t h e a p p c t x t y p e . These v e c t o r s a r e c r e a t e d once a t t h e s t a r t o f t h e code and d e s t r o y e d a t t h e end o f t h e program . /

164

APPENDIX 3. SOURCE CODE
36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 } i f ( pctx ->p s o u r c e && pctx ->GetSourceLowestFrequency ) { a s s e r t ( pctx ->GetSourceLowestFrequency ) ; P e t s c R e a l f l o=pctx ->GetSourceLowestFrequency ( pctx ->p s o u r c e ) ; P e t s c R e a l f h i=pctx ->G e t S o u r c e H i g h e s t F r e q u e n c y ( pctx ->p s o u r c e ) ; a s s e r t ( pctx -> p r o p e r t i e s ) ; P e t s c R e a l c=GetSpeedOfSound ( pctx -> p r o p e r t i e s ) ;

3.13. SETUP.C

P e t s c R e a l lambda max=c / f l o ; P e t s c P r i n t f (PETSC COMM WORLD, " L o n g e s t w a v e l e n g t h : %g m\ n" , lambda max ) ; P e t s c R e a l lambda min=c / f h i ; P e t s c P r i n t f (PETSC COMM WORLD, " S h o r t e s t w a v e l e n g t h : %g m\ n" , lambda min ) ; i f ( pctx ->params->mesh . NumWavesInLayer > 0) { P e t s c R e a l l e n =(( P e t s c R e a l ) pctx ->params->mesh . NumWavesInLayer )  lambda max ; P e t s c P r i n t f (PETSC COMM WORLD, " Automatic BC l a y e r d i m e n s i o n u s i n g wave l e n g t h o f %g m . \ n" , lambda max ) ; params->mesh . x l a y e r=l e n ; params->mesh . y l a y e r=l e n ; params->mesh . z l a y e r=l e n ; } i f ( pctx ->params->mesh . NodesPerWave > 1) { P e t s c R e a l d e l t a=lambda min / ( ( P e t s c R e a l ) ( pctx ->params->mesh . NodesPerWave - 1) ) ; P e t s c P r i n t f (PETSC COMM WORLD, " Automatic domain s p a n n i n g u s i n g wave l e n g t h o f %g m. \ n " , lambda min ) ; params->mesh . xmin= - 0.5  d e l t a  params->mesh . Nx ; params->mesh . xmax=+0.5  d e l t a  params-> mesh . Nx ; b c p a r a m e t e r s  pbc=( b c p a r a m e t e r s  ) ( pctx ->pbc ) ; PetscReal r0 =0.5; i f ( params->mesh . y l a y e r >0 && ! pbc->NoGround ) r 0=params->mesh . y l a y e r / ( d e l t a  params->mesh . Ny) ; params->mesh . ymin=-r 0  d e l t a  params->mesh . Ny ; params->mesh . ymax=+(1- r 0 )  d e l t a  params ->mesh . Ny ; i f ( ! TwoDimensional ( p c t x ) ) params->mesh . zmin= - 0.5  d e l t a  params->mesh . Nz ; params->mesh . zmax=+0.5  d e l t a  params ->mesh . Nz ;

i f ( params->mesh . x l a y e r  2 > (params->mesh . xmax-params->mesh . xmin ) | | params->mesh . y l a y e r  2 > (params->mesh . ymax-params->mesh . ymin ) | | params->mesh . z l a y e r  2 > (params->mesh . zmax-params->mesh . zmin ) | | params->mesh . xmin+params->mesh . x l a y e r >params->mesh . xmax-params->mesh . x l a y e r | | params->mesh . ymin+params->mesh . y l a y e r >params->mesh . ymax-params->mesh . y l a y e r | | params->mesh . zmin+params->mesh . z l a y e r >params->mesh . zmax-params->mesh . z l a y e r )

165

3.13. SETUP.C
81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 { P e t s c P r i n t f (PETSC COMM WORLD, " Flow domain boundary c o n d i t i o n l a y e r s . \ n" ) ; P e t s c P r i n t f (PETSC COMM WORLD, " xmin : %g m ->mesh . xmax ) ; P e t s c P r i n t f (PETSC COMM WORLD, " ymin : %g m ->mesh . ymax ) ; P e t s c P r i n t f (PETSC COMM WORLD, " zmin : %g m ->mesh . zmax ) ; P e t s c P r i n t f (PETSC COMM WORLD, " x l a y e r : %g P e t s c P r i n t f (PETSC COMM WORLD, " y l a y e r : %g P e t s c P r i n t f (PETSC COMM WORLD, " z l a y e r : %g return 1 ; } }

APPENDIX 3. SOURCE CODE

must span a t l e a s t 2x t h e r e q u e s t e d t o xmax : %g m\ n" , params->mesh . xmin , params t o ymax : %g m\ n" , params->mesh . ymin , params t o zmax : %g m\ n" , params->mesh . zmin , params m\ n" , params->mesh . x l a y e r ) ; m\ n" , params->mesh . y l a y e r ) ; m\ n" , params->mesh . z l a y e r ) ;

i f ( TwoDimensional ( p c t x ) ) { P e t s c P r i n t f (PETSC COMM WORLD, " R e s e t t i n g z min/max f o r 2D c a l c u l a t i o n . \ n" ) ; params->mesh . zmin = 0 . 0 ; params->mesh . zmax = 1 . 0 ; params->mesh . z l a y e r = 0 . 0 ; } /  Note t h a t a d i s t r i b u t e d a r r a y r e p r e s e n t s t h e mesh d i s t r i b u t e d a c r o s s m u l t i p l e processors . / pctx ->invdx =(params->mesh . Nx- 1) / ( params->mesh . xmax-params->mesh . xmin ) ; pctx ->invdy =(params->mesh . Ny- 1) / ( params->mesh . ymax-params->mesh . ymin ) ; i f ( ! TwoDimensional ( p c t x ) ) pctx ->i n v d z =(params->mesh . Nz - 1) / ( params->mesh . zmax-params->mesh . zmin ) ; else pctx ->i n v d z = 1 . 0 ; pctx ->dx=(params->mesh . xmax-params->mesh . xmin ) / ( params->mesh . Nx- 1) ; pctx ->dy=(params->mesh . ymax-params->mesh . ymin ) / ( params->mesh . Ny- 1) ; i f ( ! TwoDimensional ( p c t x ) ) pctx ->dz=(params->mesh . zmax-params->mesh . zmin ) / ( params->mesh . Nz - 1) ; else pctx ->dz = 1 . 0 ; pctx -> i pctx -> j pctx -> k pctx -> i pctx -> j pctx -> k l o =0; l o =0; l o =0; h i =params->mesh . Nx- 1; h i=params->mesh . Ny- 1; h i=params->mesh . Nz - 1;

i f ( params->mesh . x l a y e r > 0)

166

APPENDIX 3. SOURCE CODE
126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 { pctx -> i l o =( i n t ) ( params->mesh . x l a y e r / ( params->mesh . xmax-params->mesh . xmin )  ( ( double ) params->mesh . Nx) ) ; pctx -> i h i =params->mesh . Nx-1- pctx -> i l o ; } i f ( params->mesh . y l a y e r > 0) { pctx -> j l o =( i n t ) ( params->mesh . y l a y e r / ( params->mesh . ymax-params->mesh . ymin )  ( ( double ) params->mesh . Ny) ) ; pctx -> j h i=params->mesh . Ny-1- pctx -> j l o ; b c p a r a m e t e r s  bc=( b c p a r a m e t e r s  ) pctx ->pbc ; a s s e r t ( bc ) ; i f ( bc->R e f l e c t i v e G r o u n d ) pctx -> j l o =0; } if { pctx -> k l o =( i n t ) ( params->mesh . z l a y e r / ( params->mesh . zmax-params->mesh . zmin )  ( ( double ) params->mesh . Nz ) ) ; pctx -> k h i=params->mesh . Nz-1- pctx -> k l o ; } a s s e r t ( pctx ->params->tm . dt ) ; i f ( pctx ->params->tm . dt < 0) pctx ->params->tm . dt =0; ( ! TwoDimensional ( p c t x ) && params->mesh . z l a y e r > 0)

3.13. SETUP.C

156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173

P e t s c R e a l dr =(TwoDimensional ( p c t x ) ? 1 . 0 / s q r t ( 1 . 0 / ( pctx ->dx  pctx ->dx ) +1 .0 /( pctx ->dy  pctx ->dy ) ) : 1 . 0 / s q r t ( 1 . 0 / ( pctx ->dx  pctx ->dx ) +1 .0 /( pctx ->dy  pctx ->dy ) + 1. 0/ ( pctx ->dz  pctx ->dz ) ) ) ; a s s e r t ( pctx -> p r o p e r t i e s ) ; P e t s c R e a l c=GetSpeedOfSound ( pctx -> p r o p e r t i e s ) ; P e t s c R e a l dt=pctx ->params->tm . c o u r a n t  dr / c ; a s s e r t ( pctx ->params ) ; i f ( pctx ->params->tm . dt >dt ) { pctx ->params->tm . dt=dt ; P e t s c P r i n t f (PETSC COMM WORLD, " Reducing time s t e p t o %g s . \ n" , dt ) ; } /  Mesh d i s t r i b u t e d a r r a y f o r d o f=4  / i e r r=DACreate3d (PETSC COMM WORLD, DA NONPERIODIC, s t e n c i l t y p e , params->mesh . Nx , params->mesh . Ny , params->mesh . Nz , PETSC DECIDE, PETSC DECIDE, PETSC DECIDE, dof , stencilwidth , PETSC NULL, PETSC NULL, PETSC NULL, &(pctx ->da ) ) ;

167

3.13. SETUP.C
174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 CHKERRQ( i e r r ) ; i e r r=DASetUniformCoordinates ( pctx ->da , params->mesh . xmin , params->mesh . xmax , params->mesh . ymin , params->mesh . ymax , params->mesh . zmin , params->mesh . zmax ) ; CHKERRQ( i e r r ) ; / A v e c t o r t o s t o r e t h e s o l u t i o n / i e r r=DACreateGlobalVector ( pctx ->da , p s o l u t i o n ) ; CHKERRQ( i e r r ) ;

APPENDIX 3. SOURCE CODE

P e t s c P r i n t f (PETSC COMM WORLD, " F l u i d mesh d i m e n s i o n s : \ n" ) ; P e t s c P r i n t f (PETSC COMM WORLD, " mesh r e g i o n 0 , 0 , 0 t o %d,%d,%d \ n" , params->mesh . Nx- 1 , params->mesh . Ny- 1 , params->mesh . Nz - 1) ; P e t s c P r i n t f (PETSC COMM WORLD, " i n t e r i o r mesh boundary %d,%d,%d t o %d,%d,%d \ n" , pctx -> i l o , pctx -> j l o , pctx -> k l o , pctx -> i h i , pctx -> j h i , pctx -> k h i ) ; P e t s c P r i n t f (PETSC COMM WORLD, " domain %g ,%g ,%g t o %g ,%g ,%g \ n" , params->mesh . xmin , params->mesh . ymin , params->mesh . zmin , params->mesh . xmax , params->mesh . ymax , params->mesh . zmax ) ; P e t s c P r i n t f (PETSC COMM WORLD, " i n t e r i o r domain %g ,%g ,%g t o %g ,%g ,%g \ n" , params->mesh . xmin+params->mesh . x l a y e r , params->mesh . ymin+params->mesh . y l a y e r , params->mesh . zmin+params->mesh . z l a y e r , params->mesh . xmax-params->mesh . x l a y e r , params->mesh . ymax-params->mesh . y l a y e r , params->mesh . zmax-params->mesh . z l a y e r ) ; // DAView( p c t x ->da ,PETSC VIEWER STDOUT WORLD) ; P e t s c I n t M, N, P ,m, n , p ; /  Get t h e g l o b a l and l o c a l d i m e n s i o n s o f s o l u t i o n DA  / DAGetInfo ( pctx ->da , PETSC IGNORE, & M,&N,&P , &m,&n,&p , PETSC IGNORE, PETSC IGNORE, PETSC IGNORE, PETSC IGNORE) ; b c p a r a m e t e r s  bc=( b c p a r a m e t e r s  ) pctx ->pbc ; a s s e r t ( bc ) ; i f ( pctx -> j l o >0 | | bc->R e f l e c t i v e G r o u n d | | pctx ->MaxAbsPressure ) { b c p a r a m e t e r s  pbc=( b c p a r a m e t e r s  ) ( pctx ->pbc ) ; a s s e r t ( pbc ) ; i f ( pctx ->DoProbe && pctx -> r m s s l i c e ==0) i f ( pbc->NoGround ) pctx -> r m s s l i c e = N/ 2 ; else pctx -> r m s s l i c e = pctx -> j l o ;

168

APPENDIX 3. SOURCE CODE
222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 } PetscInt / PetscInt / PetscInt PetscInt PetscInt / PetscInt / i l o =pctx -> i l o +1; i h i=pctx -> i h i - 1;

3.13. SETUP.C
/  u s e p c t x -> i l o t o t r i m t o non-ABC r e g i o n o f ground /  u s e p c t x -> i h i t o t r i m t o non-ABC r e g i o n o f ground

j l o =(pctx -> r m s s l i c e >0?pctx -> r m s s l i c e : pctx -> j l o ) ; j h i =(pctx -> r m s s l i c e >0?pctx -> r m s s l i c e : pctx -> j l o ) ; k l o=pctx -> k l o +1; /  u s e p c t x -> k l o t o t r i m t o non-ABC r e g i o n o f ground k h i=pctx ->k h i - 1; /  u s e p c t x -> k h i t o t r i m t o non-ABC r e g i o n o f ground

i f ( TwoDimensional ( p c t x ) ) { i l o =0; i h i= M- 1; j l o =0; j h i=N- 1; k l o =0; k h i =0; i f ( pctx ->DoProbe && pctx -> r m s s l i c e ==0) pctx -> r m s s l i c e = 0 ; i f ( pctx ->MaxAbsPressure ) P e t s c P r i n t f (PETSC COMM WORLD, " T r a n s m i s s i o n l o s s c a l c u l a t e d f o r f l o w domain . \ n" , j l o ); } else { i f ( pctx ->MaxAbsPressure ) P e t s c P r i n t f (PETSC COMM WORLD, " T r a n s m i s s i o n l o s s c a l c u l a t e d a l o n g p l a n e a l o n g j=%d \ n" , j l o ) ; else P e t s c P r i n t f (PETSC COMM WORLD, "RMS p r e s s u r e c a l c u l a t e d a l o n g p l a n e a l o n g j=%d \ n" , jlo ) ;

C r e a t e S l i c e S c a t t e r ( pctx ,  p s o l u t i o n , i l o , i h i , j l o , j h i , k l o , khi , 0 , 0 , & pctx ->dagp ,& pctx -> c u r r p ,& pctx ->groundp ) ; C r e a t e S l i c e S c a t t e r ( pctx ,  p s o l u t i o n , i l o , i h i , j l o , j h i , k l o , khi , 1 , 3 , & pctx ->dagw,& pctx -> currw ,& pctx ->groundw ) ; i e r r=DACreateGlobalVector ( pctx ->dagp ,& pctx ->prms ) ; CHKERRQ( i e r r ) ; i e r r=DACreateGlobalVector ( pctx ->dagw,& pctx -> I ) ; CHKERRQ( i e r r ) ; i f ( pctx ->MaxAbsPressure ) i e r r=DACreateGlobalVector ( pctx ->dagp ,& pctx ->pmaxabs ) ; CHKERRQ( i e r r ) ; VecSet ( pctx ->prms , 0 . 0 ) ; VecSet ( pctx ->I , 0 . 0 ) ; i f ( pctx ->MaxAbsPressure ) VecSet ( pctx ->pmaxabs , 0 . 0 ) ; i f ( ( pctx -> r m s s l i c e >0 && ! TwoDimensional ( p c t x ) ) | |

169

3.13. SETUP.C
262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 ( pctx ->DoProbe && TwoDimensional ( p c t x ) ) ) { p a r a m e t e r s  param=pctx ->params ; a s s e r t ( params ) ; a s s e r t ( pctx ->p s o u r c e ) ;

APPENDIX 3. SOURCE CODE

/  x , y from l o w e r l e f t c o r n e r o f SPL s l i c e  / P e t s c R e a l x0=param->mesh . xmin+ i l o  pctx ->dx ; P e t s c R e a l y0=(TwoDimensional ( p c t x ) ? param->mesh . ymin+j l o  pctx ->dy : param->mesh . zmin+ k l o  pctx ->dz ) ; P e t s c R e a l x=pctx ->G e t O r i g i n ( pctx ->p s o u r c e , 0 )+pctx ->RMSProbeDistance ; P e t s c R e a l y=(TwoDimensional ( p c t x ) ? pctx ->G e t O r i g i n ( pctx ->p s o u r c e , 1 ) : pctx ->G e t O r i g i n ( pctx ->p s o u r c e , 2 ) ) ; P e t s c R e a l dx=pctx ->dx ; P e t s c R e a l dy=(TwoDimensional ( p c t x ) ? pctx ->dy : pctx ->dz ) ; P e t s c R e a l xmax=param->mesh . xmax-param->mesh . x l a y e r ; P e t s c R e a l ymax=(TwoDimensional ( p c t x ) ? param->mesh . ymax-param->mesh . y l a y e r : param->mesh . zmax-param->mesh . z l a y e r ) ; a s s e r t ( x>=x0 ) ; a s s e r t ( y>=y0 ) ; a s s e r t ( x<=xmax ) ; a s s e r t ( y<=ymax ) ; pctx -> p r o b e l i =( P e t s c I n t ) ( ( i h i - i l o )  ( x-x0 ) / ( pctx ->dx  ( i h i - i l o ) ) ) ; i f ( ! TwoDimensional ( p c t x ) ) pctx -> p r o b e l j =( P e t s c I n t ) ( ( khi - k l o )  ( y-y0 ) / ( pctx ->dz  ( khi - k l o ) ) ) ; else pctx -> p r o b e l j =( P e t s c I n t ) ( ( j h i - j l o )  ( y-y0 ) / ( pctx ->dy  ( j h i - j l o ) ) ) ; a s s e r t ( pctx -> p r o b e l i >=0) ; a s s e r t ( pctx -> p r o b e l j >=0) ; a s s e r t ( pctx -> p r o b e l i <=i h i - i l o ) ; a s s e r t ( ( ! TwoDimensional ( p c t x ) && pctx -> p r o b e l j <=khi - k l o ) | | ( TwoDimensional ( p c t x ) && pctx -> p r o b e l j <=j h i - j l o ) ) ; P e t s c R e a l px , py ; px=fmax ( 0 . 0 , fmin ( 1 . 0 , ( x -(x0+pctx -> p r o b e l i  dx ) ) /dx ) ) ; py=fmax ( 0 . 0 , fmin ( 1 . 0 , ( y -(y0+pctx -> p r o b e l j  dy ) ) /dy ) ) ; a s s e r t ( px >=0.0 && px < =1.0) ; a s s e r t ( py >=0.0 && py < =1.0) ; pctx ->probe pctx ->probe pctx ->probe pctx ->probe w w w w [0][0] [1][0] [0][1] [1][1] = = = = (1 - px )  (1 - py ) ; px  (1 - py ) ; (1 - px )  py ; px  py ;

170

APPENDIX 3. SOURCE CODE
308

3.13. SETUP.C

P e t s c P r i n t f (PETSC COMM WORLD, " Probe i n p l a n e j=%d a t (%g ,%g ) . L o c a l nodes %d,%d %g % g \ n" , pctx -> r m s s l i c e , x , y , pctx -> p r o b e l i , pctx -> p r o b e l j , px , py ) ;

309 } 310 } 311 312 pctx -> I n t e g r a t i o n S t a r t e d=PETSC FALSE ; 313 pctx -> I n t e n s i t y S t a r t e d=PETSC FALSE ; 314 pctx -> t s t a r t = 0 . 0 ; 315 pctx -> t l a s t = 0 . 0 ; 316 317 pctx -> SWL=0; 318 pctx -> t H i s t o r y=NULL; 319 pctx ->P o w e r H i s t o r y=NULL; 320 pctx ->p H i s t o r y=NULL; 321 pctx -> H i s t o r y A l l o c L e n =0; 322 323 PetscLogEventEnd ( pctx ->SetupEvent , 0 , 0 , 0 , 0 ) ; 324 return 0 ; 325 } 326 327 P e t s c E r r o r C o d e D e s t r o y S t o r a g e ( Vec s o l u t i o n , 328 app ctx  pctx ) 329 { 330 int i ; 331 PetscTru th V a l i d ; 332 PetscErrorCode i e r r ; 333 334 a s s e r t ( pctx ) ; 335 336 PetscLogEventBegin ( pctx ->SetupEvent , 0 , 0 , 0 , 0 ) ; 337 338 i e r r=VecDestroy ( s o l u t i o n ) ; CHKERRQ( i e r r ) ; 339 340 i e r r=DADestroy ( pctx ->da ) ; CHKERRQ( i e r r ) ; 341 342 b c p a r a m e t e r s  bc=( b c p a r a m e t e r s  ) pctx ->pbc ; 343 a s s e r t ( bc ) ; 344 345 i f ( pctx -> j l o >0 | | bc->R e f l e c t i v e G r o u n d ) 346 { 347 i e r r=V e c S c a t t e r D e s t r o y ( pctx ->groundw ) ; CHKERRQ( i e r r ) ; 348 i e r r=V e c S c a t t e r D e s t r o y ( pctx ->groundp ) ; CHKERRQ( i e r r ) ; 349 350 i e r r=VecDestroy ( pctx -> I ) ; CHKERRQ( i e r r ) ; 351 i e r r=VecDestroy ( pctx ->prms ) ; CHKERRQ( i e r r ) ; 352 353 i e r r=VecDestroy ( pctx ->currw ) ; CHKERRQ( i e r r ) ; 354 i e r r=VecDestroy ( pctx ->c u r r p ) ; CHKERRQ( i e r r ) ; 355 356 i e r r=DADestroy ( pctx ->dagw ) ; CHKERRQ( i e r r ) ;

171

3.14. SOURCE.H
357 358 359 360 361 362 363 364 365 366 367 } i e r r=DADestroy ( pctx ->dagp ) ; CHKERRQ( i e r r ) ; }

APPENDIX 3. SOURCE CODE

i f ( pctx ->p H i s t o r y ) P e t s c F r e e ( pctx ->p H i s t o r y ) ; pctx ->p H i s t o r y=NULL; i f ( pctx ->Po w e r H i s t o r y ) P e t s c F r e e ( pctx ->P o w e r H i s t o r y ) ; pctx ->P o w e r H i s t o r y=NULL; i f ( pctx -> t H i s t o r y ) P e t s c F r e e ( pctx -> t H i s t o r y ) ; pctx -> t H i s t o r y=NULL; pctx -> H i s t o r y A l l o c L e n =0; PetscLogEventEnd ( pctx ->SetupEvent , 0 , 0 , 0 , 0 ) ; return 0 ;

3.14
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #i f n d e f #define

source.h
SOURCE H SOURCE H

#include < p e t s c . h> #include <p e t s c b a g . h> / ! \ f i l e s o u r c e . h \ b r i e f Source term p a r a m e t e r s . This h e a d e r f i l e / d e f i n e s t h e p a r a m e t e r s and f u n c t i o n s f o r a p p l y i n g s o u r c e terms .

/  ! \ b r i e f Mesh l o c a t i o n and i n t e r p o l a t i o n A structure for storing interpolation c o e f f i c i e n t s for d i s t r i b u t i o n of a value across a cube o f mesh p o i n t s  / typedef struct { P e t s c R e a l X; / !< P e t s c R e a l Y; / !< PetscReal Z ; / !< PetscInt l i ; / !< PetscInt l j ; / !< PetscInt lk ; / !< PetscReal w [ 2 ] [ 2 ] [ 2 ] ; / !< } interpolation parameters ; /  ! \ b r i e f Montone s o u r c e A monopole s o u r c e term a t a p o i n t i n s p a c e .  / typedef struct { P e t s c R e a l A; /  ! < s o u r c e a m p l i t u d e (1/ s )  / PetscReal f ; /  ! < s o u r c e f r e q u e n c y ( Hz )  / PetscReal phi ; / !< s o u r c e p h a s e a n g l e ( r a d i a n s ) / interpolation parameters Location ;

s o u r c e o r i g i n i n x / s o u r c e o r i g i n i n y / s o u r c e o r i g i n i n z / l o w e s t mesh i n d e x a l o n g x b o u n d i n g s o u r c e o r i g i n  / l o w e s t mesh i n d e x a l o n g y b o u n d i n g s o u r c e o r i g i n  / l o w e s t mesh i n d e x a l o n g z b o u n d i n g s o u r c e o r i g i n  / i n t e r p o l a t i o n w e i g h t i n g s f o r mesh p o i n t s a b o u t o r i g i n  /

172

APPENDIX 3. SOURCE CODE
35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 } harmonic parameters ; /  ! \ b r i e f C a l i b r a t e d monopole s o u r c e A c a l i b r a t e d monopole s o u r c e term a t a p o i n t i n s p a c e .  / typedef struct { P e t s c R e a l MeasuredSWL ; /  ! < SWL (dB) o f s o u r c e as measured  / P e t s c R e a l MeasuredSPL ; /  ! < SPL (dB) o f s o u r c e as measured  / PetscReal Distance ; /  ! < d i s t a n c e from measured s o u r c e  / h a r m o n i c p a r a m e t e r s Harmonic ; /  ! < montone s o u r c e p a r a m e t e r s  / } monopole parameters ; / ! \ b r i e f D i p o l e s o u r c e A d i p o l e s o u r c e term a t a p o i n t i n s p a c e .  / typedef struct { P e t s c R e a l MeasuredSWL ; /  ! < SWL (dB) o f s o u r c e as measured  / P e t s c R e a l MeasuredSPL ; /  ! < SWL (dB) o f s o u r c e as measured  / PetscReal Distance ; /  ! < SWL (dB) o f s o u r c e as measured  / P e t s c R e a l ObserverX ; / !< d i r e c t i o n o f o b s e r v e r i n x / P e t s c R e a l ObserverY ; / !< d i r e c t i o n o f o b s e r v e r i n y / P e t s c R e a l ObserverZ ; / !< d i r e c t i o n o f o b s e r v e r i n z / PetscReal DirectionX ; / !< d i r e c t i o n o f d i p o l e a x i s i n x / PetscReal DirectionY ; / !< d i r e c t i o n o f d i p o l e a x i s i n y / PetscReal DirectionZ ; / !< d i r e c t i o n o f d i p o l e a x i s i n z / h a r m o n i c p a r a m e t e r s Harmonic1 , Harmonic2 ; / !< s o u r c e p a r a m e t e r s / } dipole parameters ; /  ! \ b r i e f A n o i s e spectrum p r o f i l e

3.14. SOURCE.H

A spectrum o f n o i s e f o r a range o f f r e q u e n c i e s .  / typedef struct { P e t s c I n t N; /  ! < Length o f s e r i e s  / h a r m o n i c p a r a m e t e r s  Harmonic ; /  ! < An a r r a y o f harmonic s o u r c e s  / PetscReal  d e l t a f ; interpolation parameters Location ; char I n p u t F i l e [ 1 0 2 4 ] ; /  ! < F i l e which c o n t a i n s s e r i e s d a t a i n CSV f o r m a t  / PetscTru th CSVFile ; PetscTru th InputAWeighted ; } monopole series parameters ; /  ! A v a i l a b l e s o u r c e term t y p e s  / typedef enum { SOURCE NONE=0 , /  ! < No s o u r c e  / SOURCE MONO PING=1 , /  ! < S h o r t d u r a t i o n monopole , ramped s t a r t and end  / SOURCE MONOPOLE=2 , /  ! < C a l i b r a t e d monopole s o u r c e w i t h i n i t i a l ramp  / SOURCE DIPOLE=3 , /  ! < D i p o l e s o u r c e w i t h i n i t i a l ramp  / SOURCE MONOPOLE SERIES=4 , /  ! < F o u r i e r s e r i e s o f monopole s o u r c e s  / SOURCE DIPOLE SERIES=5 / !< F o u r i e r s e r i e s o f d i p o l e s o u r c e s / } source type ;

173

3.14. SOURCE.H

APPENDIX 3. SOURCE CODE

85 86 /  ! Save s o u r c e term parameter v a l u e s t o f i l e .  / 87 void SaveSourceBag ( PetscBag bag ) ; 88 89 /  ! R e g i s t e r s h o r t - d u r a t i o n monopole s o u r c e parameters , and o p t i o n a l l y l o a d v a l u e s from f i l e . / 90 P e t s c E r r o r C o d e Re gisterM onopolePingBag ( PetscBag  bag , void  params , P e t s c T r u t h LoadFromFile ) ; 91 92 P e t s c E r r o r C o d e I n i t i a l i z e M o n o p o l e P i n g S o u r c e ( void  vpctx ) ; 93 94 /  ! C a l c u l a t e s o u r c e term c o n t r i b u t i o n s t o RHS f o r a s h o r t - d u r a t i o n p u l s e a t time t .  / 95 void MonopolePing ( P e t s c R e a l t , Vec R, void  c t x ) ; 96 97 /  ! Get f r e q u e n c y o f monopole s o u r c e  / 98 P e t s c R e a l GetMonopolePingFrequency ( void  vpctx ) ; 99 100 /  ! Get l o c a t i o n o f monopole s o u r c e  / 101 P e t s c R e a l GetMonopolePingOrigin ( void  vpctx , P e t s c I n t i ) ; 102 103 /  ! R e g i s t e r c o n t i n u o u s , c a l i b r a t e d monopole s o u r c e parameters , and o p t i o n a l l y l o a d v a l u e s from f i l e .  / 104 P e t s c E r r o r C o d e R egisterMonopoleBag ( PetscBag  bag , void  params , P e t s c T r u t h LoadFromFile ) ; 105 106 /  ! \ b r i e f I n i t i a l i z e c a l i b r a t e d monopole s o u r c e p a r a m e t e r s 107 108 Assumes a s p h e r i c a l monopole s o u r c e i n q u i e s c e n t f l u i d . The a m p l i t u d e o f t h e p r e s s u r e d i s t r i b u t i o n at distance \ f$r \ f$ i s 109 \ f $ \ r h o 0 c \ f r a c {Q k }{ 4 \ p i r }\ f $ , where \ f $ k =\ f r a c {\ omega }{ c }\ f $ and \ f $ Q \ f $ i s t h e volumetric flow rate of the source . 110 As an RMS a v e r a g e o f a s i n u s o i d p r e s s u r e i s \ f $ p { rms }=\ f r a c { 1 }{\ s q r t { 2 }} p \ f $ , t h e v o l u m e t r i c f l o w r a t e can be 111 d e t e r m i n e d as \ f $ \ f r a c { 2 \ s q r t { 2 } r p { rms }}{\ r h o 0 f }\ f $ . 112  / 113 P e t s c E r r o r C o d e I n i t i a l i z e M o n o p o l e S o u r c e ( void  vpctx ) ; 114 115 /  ! C a l c u l a t e s o u r c e term c o n t r i b u t i o n s t o RHS f o r a c o n t i n u o u s , c a l i b r a t e d monopole s o u r c e a t time t .  / 116 void Monopole ( P e t s c R e a l t , Vec R, void  c t x ) ; 117 118 /  ! Get f r e q u e n c y o f c a l i b r a t e d monopole s o u r c e  / 119 P e t s c R e a l GetMonopoleFrequency ( void  vpctx ) ; 120 121 /  ! Get l o c a t i o n o f c a l i b r a t e d monopole s o u r c e  / 122 P e t s c R e a l GetMonopoleOrigin ( void  vpctx , P e t s c I n t i ) ; 123 124 P e t s c E r r o r C o d e I n i t i a l i z e M o n o p o l e F a m i l y ( h a r m o n i c p a r a m e t e r s  p s o u r c e , void  vpctx ) ; 125 126 /  ! R e g i s t e r c o n t i n u o u s d i p o l e s o u r c e parameters , and o p t i o n a l l y l o a d v a l u e s from f i l e . /

174

APPENDIX 3. SOURCE CODE

3.15. SOURCE.C

127 P e t s c E r r o r C o d e R e g i s t e r D i p o l e B a g ( PetscBag  bag , void  params , P e t s c T r u t h LoadFromFile ) ; 128 129 /  ! C a l c u l a t e s o u r c e term c o n t r i b u t i o n s t o RHS f o r a c o n t i n u o u s d i p o l e s o u r c e a t time t . / 130 void D i p o l e ( P e t s c R e a l t , Vec R, void  c t x ) ; 131 132 /  ! I n i t i a l i z e d i p o l e s o u r c e p a r a m e t e r s  / 133 P e t s c E r r o r C o d e I n i t i a l i z e D i p o l e S o u r c e ( void  vpctx ) ; 134 135 /  ! Get f r e q u e n c y o f d i p o l e s o u r c e  / 136 P e t s c R e a l G e t D i p o l e F r e q u e n c y ( void  vpctx ) ; 137 138 /  ! Get l o c a t i o n o f d i p o l e s o u r c e  / 139 P e t s c R e a l G e t D i p o l e O r i g i n ( void  vpctx , P e t s c I n t i ) ; 140 141 142 /  ! Compute t h e AWeighting g a i n (dB)  / 143 P e t s c R e a l GetAWeighting ( P e t s c R e a l f ) ; 144 145 /  ! R e g i s t e r c o n t i n u o u s , c a l i b r a t e d monopole s o u r c e parameters , and o p t i o n a l l y l o a d v a l u e s from f i l e .  / 146 P e t s c E r r o r C o d e R e g i s t e r M o n o p o l e S e r i e s B a g ( PetscBag  bag , void  params , P e t s c T r u t h LoadFromFile ) ; 147 148 /  ! \ b r i e f I n i t i a l i z e c a l i b r a t e d monopole s o u r c e p a r a m e t e r s 149  / 150 P e t s c E r r o r C o d e I n i t i a l i z e M o n o p o l e S e r i e s S o u r c e ( void  vpctx ) ; 151 152 /  ! C a l c u l a t e s o u r c e term c o n t r i b u t i o n s t o RHS f o r a c o n t i n u o u s , c a l i b r a t e d monopole s o u r c e a t time t .  / 153 void M o n o p o l e S e r i e s ( P e t s c R e a l t , Vec R, void  c t x ) ; 154 155 /  ! Get f r e q u e n c y o f c a l i b r a t e d monopole s o u r c e  / 156 P e t s c R e a l G e t M o n o p o l e S e r i e s L o w e s t F r e q u e n c y ( void  vpctx ) ; 157 P e t s c R e a l G e t M o n o p o l e S e r i e s H i g h e s t F r e q u e n c y ( void  vpctx ) ; 158 159 /  ! Get l o c a t i o n o f c a l i b r a t e d monopole s o u r c e  / 160 P e t s c R e a l G e t M o n o p o l e S e r i e s O r i g i n ( void  vpctx , P e t s c I n t i ) ; 161 162 /  ! \ b r i e f D e a l l o c a t e c a l i b r a t e d monopole s o u r c e p a r a m e t e r s 163  / 164 P e t s c E r r o r C o d e D e s t r o y M o n o p o l e S e r i e s S o u r c e ( void  vpctx ) ; 165 166 #endif

3.15

source.c

1 #include < s t d l i b . h> 2 #include < a s s e r t . h>

175

3.15. SOURCE.C
3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include < p e t s c . h> #include " ode . h" #include " s o u r c e . h" const char S o u r c e P a r a m e t e r s F i l e [ ] = " s p a r a m e t e r s . dat " ;

APPENDIX 3. SOURCE CODE

PetscErrorCode CalculateMeshLocation ( i n t e r p o l a t i o n p a r a m e t e r s  interp , app ctx  pctx ) { p a r a m e t e r s  param=pctx ->params ; assert ( interp ) ; a s s e r t ( pctx ) ; a s s e r t ( param ) ; P e t s c R e a l dx=(param->mesh . xmax-param->mesh . xmin ) / ( param->mesh . Nx- 1) ; P e t s c R e a l dy=(param->mesh . ymax-param->mesh . ymin ) / ( param->mesh . Ny- 1) ; P e t s c R e a l dz = 1 . 0 ; i f ( ! TwoDimensional ( p c t x ) ) dz=(param->mesh . zmax-param->mesh . zmin ) / ( param->mesh . Nz - 1) ; i f ( i n t e r p ->X<param->mesh . xmin | | i n t e r p ->X >param->mesh . xmax | | i n t e r p ->Y<param->mesh . ymin | | i n t e r p ->Y >param->mesh . ymax | | i n t e r p ->Z<param->mesh . zmin | | i n t e r p ->Z>param->mesh . zmax ) { P e t s c P r i n t f (PETSC COMM WORLD, " Harmonic o r i g i n o u t s i d e f l o w domain ! \ n" ) ; return 1 ; } /  Note t h a t wz v a l u e s a r e r e c o r d e d f o r i+dx /2 , j , k  / i n t e r p -> l i =( P e t s c I n t ) ( ( param->mesh . Nx- 1)  ( i n t e r p ->X-param->mesh . xmin ) / ( param->mesh . xmax-param->mesh . xmin ) ) ; i n t e r p -> l j =( P e t s c I n t ) ( ( param->mesh . Ny- 1)  ( i n t e r p ->Y-param->mesh . ymin ) / ( param->mesh . ymax-param->mesh . ymin ) ) ; i f ( ! TwoDimensional ( p c t x ) ) i n t e r p -> l k =( P e t s c I n t ) ( ( param->mesh . Nz - 1)  ( i n t e r p ->Z-param->mesh . zmin ) / ( param->mesh . zmax-param->mesh . zmin ) ) ; else i n t e r p -> l k =0; a s s e r t ( i n t e r p -> l i <param->mesh . Nx- 1) ; a s s e r t ( i n t e r p -> l j <param->mesh . Ny- 1) ; a s s e r t ( ( TwoDimensional ( p c t x ) && i n t e r p -> l k ==0) | | <param->mesh . Nz - 1) ) ;

( ! TwoDimensional ( p c t x ) && i n t e r p ->l k

P e t s c R e a l px , py , pz ; px=fmax ( 0 . 0 , fmin ( 1 . 0 , ( i n t e r p ->X-(param->mesh . xmin+i n t e r p -> l i  dx ) ) /dx ) ) ; py=fmax ( 0 . 0 , fmin ( 1 . 0 , ( i n t e r p ->Y-(param->mesh . ymin+i n t e r p -> l j  dy ) ) /dy ) ) ; i f ( ! TwoDimensional ( p c t x ) )

176

APPENDIX 3. SOURCE CODE
49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78

3.15. SOURCE.C

pz=fmax ( 0 . 0 , fmin ( 1 . 0 , ( i n t e r p ->Z-(param->mesh . zmin+i n t e r p -> l k  dz ) ) / dz ) ) ; else pz = 0 . 0 ; a s s e r t ( px >=0.0 && px < =1.0) ; a s s e r t ( py >=0.0 && py < =1.0) ; a s s e r t ( pz >=0.0 && pz < =1.0) ; / l i , l j , l k / i n t e r p ->w [ 0 ] [ 0 ] [ 0 ] /  l i +1, l j , l k  / i n t e r p ->w [ 1 ] [ 0 ] [ 0 ] /  l i , l j +1, l k  / i n t e r p ->w [ 0 ] [ 1 ] [ 0 ] /  l i +1, l j +1, l k  / i n t e r p ->w [ 1 ] [ 1 ] [ 0 ] if { /  l i , l j , l k+  / i n t e r p ->w [ 0 ] [ 0 ] [ 1 ] = /  l i +1, l j , l k +1  / i n t e r p ->w [ 1 ] [ 0 ] [ 1 ] = /  l i , l j +1, l k +1  / i n t e r p ->w [ 0 ] [ 1 ] [ 1 ] = /  l i +1, l j +1, l k +1  / i n t e r p ->w [ 1 ] [ 1 ] [ 1 ] = } P e t s c P r i n t f (PETSC COMM WORLD, " S o u r c e o r i g i n %g ,%g ,%g between %d,%d,%d and %d,%d,%d (%g ,%g ,%g ) \ n" , i n t e r p ->X, i n t e r p ->Y, i n t e r p ->Z , i n t e r p -> l i , i n t e r p -> l j , i n t e r p ->l k , i n t e r p -> l i +1 , i n t e r p -> l j +1 , i n t e r p -> l k +1 ,px , py , pz ) ; return 0 ; (1 - px )  (1 - py )  pz ; px  (1 - py )  pz ; (1 - px )  py  pz ; px  py  pz ;

= (1 - px )  (1 - py )  (1 - pz ) ; = px  (1 - py )  (1 - pz ) ; = (1 - px )  py  (1 - pz ) ; = px  py  (1 - pz ) ;

( ! TwoDimensional ( p c t x ) )

79 80 } 81 82 void SaveSourceBag ( PetscBag bag ) 83 { 84 PetscViewer bagviewer ; 85 /  Save t h e runtime p a r a m e t e r s t o a b i n a r y f i l e  / 86 PetscViewerBinaryOpen (PETSC COMM WORLD, S o u r c e P a r a m e t e r s F i l e , FILE MODE WRITE,& b a g v i e w e r ); 87 PetscBagView ( bag , b a g v i e w e r ) ; 88 PetscViewerDestroy ( bagviewer ) ; 89 } 90 91 P e t s c R e a l MonopoleSignalWithRamp ( P e t s c R e a l t , 92 h a r m o n i c p a r a m e t e r s  params , 93 P e t s c I n t RampIn , 94 P e t s c I n t Duration , 95 P e t s c I n t RampOut)

177

3.15. SOURCE.C

APPENDIX 3. SOURCE CODE

96 { 97 P e t s c R e a l Q=0; 98 P e t s c R e a l T1 , T2 , T ; 99 PetscReal s c a l e =1.0; 100 101 a s s e r t ( params ) ; 102 103 T1=(( double ) ( RampIn ) ) / params-> f ; 104 T2=(( double ) (RampOut) ) / params-> f ; 105 T=(( double ) ( D u r a t i o n ) ) / params-> f ; 106 107 i f ( t >=0 && t <T1 ) 108 { 109 Q=0.5  params->A (1 - c o s ( M PI  t /T1 ) )  c o s ( 2  M PI  params-> f  t+params->p h i ) ; 110 PetscLogFlops (9) ; 111 } 112 e l s e i f ( t>=T1 && ( ( ( T==0) | | ( T2==0) ) | | (T>0 && T2>0 && t <=(T-T2 ) ) ) ) 113 { 114 Q=params->A c o s ( 2  M PI  params-> f  t+params->p h i ) ; 115 PetscLogFlops (4) ; 116 } 117 e l s e i f (T>0 && T2>0 && ( t >(T-T2 ) && t<=T) ) 118 { 119 Q=0.5  params->A (1+ c o s ( M PI  ( t -(T-T2 ) ) /T2 ) )  c o s ( 2  M PI  params-> f  t+params->p h i ) ; 120 PetscLogFlops (9) ; 121 } 122 return Q; 123 } 124 125 P e t s c E r r o r C o d e R egi ste rMonopolePingBa g ( PetscBag  bag , void  pparams , P e t s c T r u t h LoadFromFile ) 126 { 127 return RegisterMonopoleBag ( bag , pparams , LoadFromFile ) ; 128 } 129 130 P e t s c E r r o r C o d e I n i t i a l i z e M o n o p o l e P i n g S o u r c e ( void  vpctx ) 131 { 132 a p p c t x  p c t x =( a p p c t x  ) vpctx ; 133 p a r a m e t e r s  param=pctx ->params ; 134 h a r m o n i c p a r a m e t e r s  p s o u r c e =( h a r m o n i c p a r a m e t e r s  ) pctx ->p s o u r c e ; 135 136 a s s e r t ( psource ) ; 137 138 P e t s c P r i n t f (PETSC COMM WORLD, " Monopole s o u r c e a m p l i t u d e %g . \ n" , p s o u r c e ->A) ; 139 140 return I n i t i a l i z e M o n o p o l e F a m i l y ( p s o u r c e , vpctx ) ; 141 } 142 143 144 void MonopolePing ( P e t s c R e a l t ,

178

APPENDIX 3. SOURCE CODE

3.15. SOURCE.C

145 Vec R, 146 void  vpctx ) 147 { 148 a p p c t x  p c t x =( a p p c t x  ) vpctx ; 149 P e t s c I n t i , j , k , d , dof , Nx , Ny , Nz , sx , sy , sz , mx, my, mz ; 150 P e t s c S c a l a r  r ; 151 Vec l o c a l ; 152 m o n o p o l e p a r a m e t e r s  p s o u r c e =( m o n o p o l e p a r a m e t e r s  ) ( pctx ->p s o u r c e ) ; 153 a s s e r t ( psource ) ; 154 i n t e r p o l a t i o n p a r a m e t e r s  params=&(p s o u r c e ->Harmonic . L o c a t i o n ) ; 155 156 a s s e r t ( pctx ) ; 157 a s s e r t ( params ) ; 158 159 PetscLogEventBegin ( pctx ->CalcSourceEvent , 0 , 0 , 0 , 0 ) ; 160 161 /  Determine g l o b a l mesh n o d a l e x t e n t s  / 162 DAGetInfo ( pctx ->da , PETSC IGNORE,&Nx,&Ny,&Nz , 163 PETSC IGNORE, PETSC IGNORE, PETSC IGNORE, 164 PETSC IGNORE, PETSC IGNORE, 165 PETSC IGNORE, PETSC IGNORE) ; 166 167 /  Get l o c a l g r i d b o u n d a r i e s , which a r e i n d e p e n d e n t o f d o f  / 168 DAGetCorners ( pctx ->da ,& sx ,& sy ,& sz ,&mx,&my,&mz) ; 169 170 DAVecGetArrayDOF ( pctx ->da , R,& r ) ; 171 172 / R i s p r e v i o u s l y z e r o e d / 173 P e t s c R e a l Mag=MonopoleSignalWithRamp ( t ,&( p s o u r c e ->Harmonic ) , 3 , 1 0 , 3 )  pctx ->invdx  pctx -> invdy  pctx ->i n v d z ; 174 P e t s c I n t kN=(TwoDimensional ( p c t x ) ? 1 : 2 ) ; 175 f o r ( k =0;k<kN ; k++) 176 f o r ( j =0; j < 2; j ++) 177 f o r ( i =0; i < 2; i ++) 178 { 179 i f ( ( params-> l i +i >=sx && params-> l i +i <sx+mx) && 180 ( params-> l j +j >=sy && params-> l j +j <sy+my) && 181 ( params-> l k+k>=s z && params-> l k+k< s z+mz) ) 182 { 183 r [ params-> l k+k ] [ params-> l j +j ] [ params-> l i +i ] [ 0 ] = params->w [ i ] [ j ] [ k ]  Mag ; 184 } 185 } 186 187 / R e l e a s e a c c e s s t o a r r a y / 188 DAVecRestoreArrayDOF ( pctx ->da , R,& r ) ; 189 190 PetscLogEventEnd ( pctx ->CalcSourceEvent , 0 , 0 , 0 , 0 ) ; 191 } 192 193 P e t s c R e a l GetMonopolePingFrequency ( void  p s o u r c e )

179

3.15. SOURCE.C
194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 { h a r m o n i c p a r a m e t e r s  pmono=( h a r m o n i c p a r a m e t e r s  ) p s o u r c e ; return pmono-> f ; } P e t s c R e a l GetMonopolePingOrigin ( void  p s o u r c e , P e t s c I n t d ) { h a r m o n i c p a r a m e t e r s  pmono=( h a r m o n i c p a r a m e t e r s  ) p s o u r c e ; a s s e r t ( d>=0 && d<=2) ; switch ( d ) { case 0 : return pmono->L o c a t i o n .X; break ; case 1 : return pmono->L o c a t i o n .Y; break ; case 2 : return pmono->L o c a t i o n . Z ; break ; }; return 0 ; }

APPENDIX 3. SOURCE CODE

P e t s c E r r o r C o d e R e g i s t e r D i p o l e B a g ( PetscBag  bag , void  pparams , P e t s c T r u t h LoadFromFile ) { P e t s c E r r o r C o d e i e r r =0; a s s e r t ( bag ) ; a s s e r t ( pparams ) ; i e r r=P e t s c B a g C r e a t e (PETSC COMM WORLD, s i z e o f ( d i p o l e p a r a m e t e r s ) , bag ) ; CHKERRQ( i e r r ) ; i e r r=PetscBagGetData (  bag , pparams ) ; CHKERRQ( i e r r ) ; i e r r=PetscBagSetName (  bag , " D i p o l e S o u r c e Pa ram ete r s " , " r u n t i m e p a r a m e t e r s f o r a s i m p l e d i p o l e s o u r c e " ) ; CHKERRQ( i e r r ) ; d i p o l e p a r a m e t e r s  p s o u r c e =( d i p o l e p a r a m e t e r s  ) (  pparams ) ; /  Monopole s o u r c e p a r a m e t e r s  / i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& p s o u r c e ->MeasuredSPL , 0 , " m e a s u r e d s p l " , " D i p o l e s o u r c e sound p r e s s u r e l e v e l i n d i p o l e d i r e c t i o n (dB) " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& p s o u r c e ->D i s t a n c e , 0 , " m e a s u r e d d i s t a n c e " , " D i p o l e s o u r c e d i s t a n c e (m) " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& p s o u r c e ->MeasuredSWL , 0 , " m e a s u r e d s w l " , " D i p o l e s o u r c e sound power l e v e l (dB) " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& p s o u r c e ->ObserverX , 0 , " d i p o l e o b s e r v e r x " , " D i p o l e s o u r c e o b s e r v e r d i r e c t i o n a l o n g x- a x i s " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& p s o u r c e ->ObserverY , 0 , " d i p o l e o b s e r v e r y " , " D i p o l e s o u r c e o b s e r v e r d i r e c t i o n a l o n g y- a x i s " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& p s o u r c e ->ObserverZ , 0 , " d i p o l e o b s e r v e r z " , " D i p o l e s o u r c e o b s e r v e r d i r e c t i o n a l o n g z- a x i s " ) ; CHKERRQ( i e r r ) ;

180

APPENDIX 3. SOURCE CODE
236 237 238 239 240 241 242 243 244 245 246 247 248 249

3.15. SOURCE.C

i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& p s o u r c e ->D i r e c t i o n X , 1 , " d i p o l e d i r e c t i o n x " , " D i p o l e s o u r c e a x i s d i r e c t i o n a l o n g x- a x i s " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& p s o u r c e ->D i r e c t i o n Y , 0 , " d i p o l e d i r e c t i o n y " , " D i p o l e s o u r c e a x i s d i r e c t i o n a l o n g y- a x i s " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& p s o u r c e ->D i r e c t i o n Z , 0 , " d i p o l e d i r e c t i o n z " , " D i p o l e s o u r c e a x i s d i r e c t i o n a l o n g z- a x i s " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& p s o u r c e ->Harmonic1 . A, 0 , " d i p o l e A " , " D i p o l e s o u r c e a m p l i t u d e " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& p s o u r c e ->Harmonic1 . f , 1 0 0 , " d i p o l e f " , " D i p o l e s o u r c e f r e q u e n c y ( Hz ) " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& p s o u r c e ->Harmonic1 . L o c a t i o n . X, 0 , " d i p o l e o r i g i n x " , " D i p o l e s o u r c e o r i g i n a l o n g x- a x i s (m) " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& p s o u r c e ->Harmonic1 . L o c a t i o n . Y, 0 , " d i p o l e o r i g i n y " , " D i p o l e s o u r c e o r i g i n a l o n g y- a x i s (m) " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,& p s o u r c e ->Harmonic1 . L o c a t i o n . Z , 0 , " d i p o l e o r i g i n z " , " D i p o l e s o u r c e o r i g i n a l o n g z- a x i s (m) " ) ; CHKERRQ( i e r r ) ;

250 251 252 253 254 255 256 257 258 259 260 261 p s o u r c e ->Harmonic2 .A=p s o u r c e ->Harmonic1 .A; 262 p s o u r c e ->Harmonic2 . f=p s o u r c e ->Harmonic1 . f ; 263 p s o u r c e ->Harmonic2 . p h i=M PI ; 264 p s o u r c e ->Harmonic1 . p h i =0; 265 p s o u r c e ->Harmonic2 . L o c a t i o n .X=p s o u r c e ->Harmonic1 . L o c a t i o n .X; 266 p s o u r c e ->Harmonic2 . L o c a t i o n .Y=p s o u r c e ->Harmonic1 . L o c a t i o n .Y; 267 p s o u r c e ->Harmonic2 . L o c a t i o n . Z=p s o u r c e ->Harmonic1 . L o c a t i o n . Z ; 268 269 return 0 ; 270 } 271 272 void D i p o l e ( P e t s c R e a l t , 273 Vec R, 274 void  vpctx ) 275 { 276 a p p c t x  p c t x =( a p p c t x  ) vpctx ;

i f ( LoadFromFile ) { PetscViewer bagviewer ; i f ( i e r r=PetscViewerBinaryOpen (PETSC COMM WORLD, S o u r c e P a r a m e t e r s F i l e , FILE MODE READ,& b a g v i e w e r ) ) { P e t s c P r i n t f (PETSC COMM WORLD, " Unable t o l o a d %s . \ n" , S o u r c e P a r a m e t e r s F i l e ) ; CHKERRQ( i e r r ) ; } i e r r=PetscBagLoad ( b agv iewe r , bag ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c V i e w e r D e s t r o y ( b a g v i e w e r ) ; CHKERRQ( i e r r ) ; i e r r=PetscBagGetData (  bag , pparams ) ; CHKERRQ( i e r r ) ; P e t s c P r i n t f (PETSC COMM WORLD, " Loaded d i p o l e s o u r c e p a r a m e t e r s : \ n" ) ; i e r r=PetscBagView (  bag ,PETSC VIEWER STDOUT WORLD) ; CHKERRQ( i e r r ) ; }

181

3.15. SOURCE.C
277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318

APPENDIX 3. SOURCE CODE

d i p o l e p a r a m e t e r s  params=( d i p o l e p a r a m e t e r s  ) ( pctx ->p s o u r c e ) ; P e t s c I n t i , j , k , d , dof , Nx , Ny , Nz , sx , sy , sz , mx, my, mz , s ; P e t s c S c a l a r  r ; Vec l o c a l ; a s s e r t ( pctx ) ; a s s e r t ( params ) ; PetscLogEventBegin ( pctx ->CalcSourceEvent , 0 , 0 , 0 , 0 ) ; /  Determine g l o b a l mesh n o d a l e x t e n t s  / DAGetInfo ( pctx ->da , PETSC IGNORE,&Nx,&Ny,&Nz , PETSC IGNORE, PETSC IGNORE, PETSC IGNORE, PETSC IGNORE, PETSC IGNORE, PETSC IGNORE, PETSC IGNORE) ; /  Get l o c a l g r i d b o u n d a r i e s , which a r e i n d e p e n d e n t o f d o f  / DAGetCorners ( pctx ->da ,& sx ,& sy ,& sz ,&mx,&my,&mz) ; DAVecGetArrayDOF ( pctx ->da , R,& r ) ; / R i s p r e v i o u s l y z e r o e d / P e t s c R e a l Mag1=MonopoleSignalWithRamp ( t ,&( params->Harmonic1 ) , 3 , 0 , 0 )  pctx ->invdx  pctx -> invdy  pctx ->i n v d z ; P e t s c R e a l Mag2=MonopoleSignalWithRamp ( t ,&( params->Harmonic2 ) , 3 , 0 , 0 )  pctx ->invdx  pctx -> invdy  pctx ->i n v d z ; a s s e r t ( pctx -> p r o p e r t i e s ) ; f o r ( i =0; i < 2; i ++) f o r ( j =0; j < 2; j ++) f o r ( k =0;k < 2; k++) { i f ( ( params->Harmonic1 . L o c a t i o n . l i +i >=sx && params->Harmonic1 . L o c a t i o n . l i +i <sx+mx) && ( params->Harmonic1 . L o c a t i o n . l j +j >=sy && params->Harmonic1 . L o c a t i o n . l j +j <sy+my) && ( params->Harmonic1 . L o c a t i o n . l k+k>=s z && params->Harmonic1 . L o c a t i o n . l k+k< s z+mz) ) { r [ params->Harmonic1 . L o c a t i o n . l k+k ] [ params->Harmonic1 . L o c a t i o n . l j +j ] [ params-> Harmonic1 . L o c a t i o n . l i +i ] [ 0 ] += Mag1  params->Harmonic1 . L o c a t i o n . w [ i ] [ j ] [ k ] ; } i f ( ( params->Harmonic2 . L o c a t i o n . l i +i >=sx && params->Harmonic2 . L o c a t i o n . l i +i <sx+mx) && ( params->Harmonic2 . L o c a t i o n . l j +j >=sy && params->Harmonic2 . L o c a t i o n . l j +j <sy+my) && ( params->Harmonic2 . L o c a t i o n . l k+k>=s z && params->Harmonic2 . L o c a t i o n . l k+k< s z+mz) ) { r [ params->Harmonic2 . L o c a t i o n . l k+k ] [ params->Harmonic2 . L o c a t i o n . l j +j ] [ params-> Harmonic2 . L o c a t i o n . l i +i ] [ 0 ] += Mag2  params->Harmonic2 . L o c a t i o n . w [ i ] [ j ] [ k ] ; } }

182

APPENDIX 3. SOURCE CODE

3.15. SOURCE.C

319 / R e l e a s e a c c e s s t o a r r a y / 320 DAVecRestoreArrayDOF ( pctx ->da , R,& r ) ; 321 322 PetscLogEventEnd ( pctx ->CalcSourceEvent , 0 , 0 , 0 , 0 ) ; 323 324 } 325 326 P e t s c E r r o r C o d e I n i t i a l i z e D i p o l e S o u r c e ( void  vpctx ) 327 { 328 P e t s c E r r o r C o d e i e r r =0; 329 const P e t s c R e a l p r e f =20E- 6; 330 const P e t s c R e a l Wref=1E- 12; 331 a p p c t x  p c t x =( a p p c t x  ) vpctx ; 332 p a r a m e t e r s  param=pctx ->params ; 333 d i p o l e p a r a m e t e r s  p s o u r c e =( d i p o l e p a r a m e t e r s  ) pctx ->p s o u r c e ; 334 p a r a m e t e r s  params=pctx ->params ; 335 a s s e r t ( params ) ; 336 337 P e t s c R e a l dx=(params->mesh . xmax-params->mesh . xmin ) / ( params->mesh . Nx- 1) ; 338 P e t s c R e a l dy=(params->mesh . ymax-params->mesh . ymin ) / ( params->mesh . Ny- 1) ; 339 P e t s c R e a l dz = 1 . 0 ; 340 i f ( ! TwoDimensional ( p c t x ) ) 341 dz=(params->mesh . zmax-params->mesh . zmin ) / ( params->mesh . Nz - 1) ; 342 343 P e t s c R e a l d=s q r t ( dx  dx+dy  dy+dz  dz ) ; 344 345 /  Using two monopoles , s e p a r a t e d by d i s t a n c e d and 180 deg o u t o f phase , t o p r o d u c e d i p o l e / 346 347 /  Normalize d i p o l e a x i s  / 348 P e t s c R e a l i n v l e n 1 =1.0/ s q r t ( p s o u r c e ->D i r e c t i o n X  p s o u r c e ->D i r e c t i o n X+ 349 p s o u r c e ->D i r e c t i o n Y  p s o u r c e ->D i r e c t i o n Y+ 350 p s o u r c e -> D i r e c t i o n Z  p s o u r c e -> D i r e c t i o n Z ) ; 351 p s o u r c e ->D i r e c t i o n X = i n v l e n 1 ; 352 p s o u r c e ->D i r e c t i o n Y = i n v l e n 1 ; 353 p s o u r c e -> D i r e c t i o n Z = i n v l e n 1 ; 354 355 /  Normalize o b s e r v e r a x i s  / 356 P e t s c R e a l l e n 2=s q r t ( p s o u r c e ->ObserverX  p s o u r c e ->ObserverX+ 357 p s o u r c e ->ObserverY  p s o u r c e ->ObserverY+ 358 p s o u r c e ->ObserverZ  p s o u r c e ->ObserverZ ) ; 359 i f ( l e n 2 ==0) 360 { 361 p s o u r c e ->ObserverX=p s o u r c e ->D i r e c t i o n X ; 362 p s o u r c e ->ObserverY=p s o u r c e ->D i r e c t i o n Y ; 363 p s o u r c e ->ObserverZ=p s o u r c e -> D i r e c t i o n Z ; 364 } 365 else 366 { 367 P e t s c R e a l i n v l e n 2 =1.0/ l e n 2 ;

183

3.15. SOURCE.C
368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 p s o u r c e ->ObserverX = i n v l e n 2 ; p s o u r c e ->ObserverY = i n v l e n 2 ; p s o u r c e ->ObserverZ = i n v l e n 2 ; } P e t s c R e a l c = GetSpeedOfSound ( pctx -> p r o p e r t i e s ) ; P e t s c R e a l f = p s o u r c e ->Harmonic1 . f ;

APPENDIX 3. SOURCE CODE

392 393 394 395 396 397 398 399

400 401 402 403 404 405 406 407

i f ( p s o u r c e ->Harmonic1 .A==0) { i f ( p s o u r c e ->MeasuredSWL==0) { /  I f p rms i s known a t d i s t a n c e r from s o u r c e i n o b s e r v e r d i r e c t i o n o , f o r d i p o l e a x i s d , then the amplitude of the s o u r c e i s (8  p i  r ^2  p rms ) /( o . d  s q r t (2  (1+ k ^2  r ^2) ) )  / P e t s c R e a l prms = p r e f  pow ( 1 0 . 0 , 0 . 0 5  p s o u r c e ->MeasuredSPL ) ; P e t s c R e a l k=2M PI  f / c ; P e t s c R e a l r=p s o u r c e ->D i s t a n c e ; P e t s c R e a l r 2=r  r ; P e t s c R e a l k2=k  k ; P e t s c R e a l v e c d o t=f a b s ( p s o u r c e ->ObserverX  p s o u r c e ->D i r e c t i o n X+ p s o u r c e ->ObserverY  p s o u r c e ->D i r e c t i o n Y+ p s o u r c e ->ObserverZ  p s o u r c e -> D i r e c t i o n Z ) ; p s o u r c e ->Harmonic1 .A = ( 8  M PI  r 2  prms ) / ( s q r t (2  (1+ k2  r 2 ) )  v e c d o t ) ; P e t s c P r i n t f (PETSC COMM WORLD, " D i p o l e ( a s measured SPL %g dB a t %g m i n d i r e c t i o n %g %g %g ) s o u r c e a m p l i t u d e %g with d i p o l e a x i s %g %g %g . \ n" , p s o u r c e ->MeasuredSPL , p s o u r c e ->D i s t a n c e , p s o u r c e ->ObserverX , p s o u r c e ->ObserverY , p s o u r c e ->ObserverZ , p s o u r c e ->Harmonic1 . A, p s o u r c e ->D i r e c t i o n X , p s o u r c e ->D i r e c t i o n Y , p s o u r c e -> D i r e c t i o n Z ); } else { /  I f power W i s known , t h e a m p l i t u d e o f d u a l v o l u m e t r i c s o u r c e s i s s q r t ( ( 6 p i W) /( rho c ) )  ( 1 / ( k ^2 d ) )  / P e t s c R e a l W = Wref  pow ( 1 0 . 0 , 0 . 1  p s o u r c e ->MeasuredSWL ) ; P e t s c R e a l k = 2  M PI  f / c ; p s o u r c e ->Harmonic1 .A = s q r t ( ( 6  M PI W) / ( GetSpeedOfSound ( pctx -> p r o p e r t i e s )  Ge tD en si ty ( pctx -> p r o p e r t i e s ) ) ) / ( k  k  d ) ; P e t s c P r i n t f (PETSC COMM WORLD, " D i p o l e ( a s measured SWL %g dB) a s d u a l monopole s o u r c e s with a m p l i t u d e %g and s e p a r a t i o n %g m a l o n g x- a x i s . \ n" , p s o u r c e -> MeasuredSWL , p s o u r c e ->Harmonic1 . A, d ) ; p s o u r c e ->MeasuredSPL=p s o u r c e ->MeasuredSWL+10 l o g 1 0 ( 1 / ( 4  M PI  p s o u r c e ->D i s t a n c e  p s o u r c e ->D i s t a n c e ) ) ; } } else { P e t s c P r i n t f (PETSC COMM WORLD, " D i p o l e a m p l i t u d e %g . \ n" , p s o u r c e ->Harmonic1 .A) ; }

184

APPENDIX 3. SOURCE CODE
408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 p s o u r c e ->Harmonic2 .A=p s o u r c e ->Harmonic1 .A; p s o u r c e ->Harmonic2 . f=p s o u r c e ->Harmonic1 . f ; p s o u r c e ->Harmonic2 . p h i=M PI ; p s o u r c e ->Harmonic1 . p h i =0; p s o u r c e ->Harmonic1 . L o c a t i o n .X -= 0 . 5  d  p s o u r c e ->D i r e c t i o n X ; p s o u r c e ->Harmonic1 . L o c a t i o n .Y -= 0 . 5  d  p s o u r c e ->D i r e c t i o n Y ; p s o u r c e ->Harmonic1 . L o c a t i o n . Z -= 0 . 5  d  p s o u r c e -> D i r e c t i o n Z ; p s o u r c e ->Harmonic2 . L o c a t i o n .X += 0 . 5  d  p s o u r c e ->D i r e c t i o n X ; p s o u r c e ->Harmonic2 . L o c a t i o n .Y += 0 . 5  d  p s o u r c e ->D i r e c t i o n Y ; p s o u r c e ->Harmonic2 . L o c a t i o n . Z += 0 . 5  d  p s o u r c e -> D i r e c t i o n Z ;

3.15. SOURCE.C

i e r r=C a l c u l a t e M e s h L o c a t i o n (&( p s o u r c e ->Harmonic1 . L o c a t i o n ) , p c t x ) ; CHKERRQ( i e r r ) ; i e r r=C a l c u l a t e M e s h L o c a t i o n (&( p s o u r c e ->Harmonic2 . L o c a t i o n ) , p c t x ) ; CHKERRQ( i e r r ) ; return 0 ; } P e t s c R e a l G e t D i p o l e F r e q u e n c y ( void  p s o u r c e ) { d i p o l e p a r a m e t e r s  p d i p o l e =( d i p o l e p a r a m e t e r s  ) p s o u r c e ; assert ( pdipole ) ; a s s e r t ( p d i p o l e ->Harmonic1 . f==p d i p o l e ->Harmonic2 . f ) ; return p d i p o l e ->Harmonic1 . f ; } P e t s c R e a l G e t D i p o l e O r i g i n ( void  p s o u r c e , P e t s c I n t d ) { d i p o l e p a r a m e t e r s  p d i p o l e =( d i p o l e p a r a m e t e r s  ) p s o u r c e ; a s s e r t ( d>=0 && d<=2) ; switch ( d ) { case 0 : return 0 . 5  ( p d i p o l e ->Harmonic1 . L o c a t i o n .X+p d i p o l e ->Harmonic2 . L o c a t i o n .X) ; break ; case 1 : return 0 . 5  ( p d i p o l e ->Harmonic1 . L o c a t i o n .Y+p d i p o l e ->Harmonic2 . L o c a t i o n .Y) ; break ; case 2 : return 0 . 5  ( p d i p o l e ->Harmonic1 . L o c a t i o n . Z+p d i p o l e ->Harmonic2 . L o c a t i o n . Z ) ; break ; }; return 0 ; }

P e t s c E r r o r C o d e RegisterMonopoleBa g ( PetscBag  bag , void  pparams , P e t s c T r u t h LoadFromFile ) { P e t s c E r r o r C o d e i e r r =0; a s s e r t ( bag ) ;

185

3.15. SOURCE.C
458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 a s s e r t ( pparams ) ;

APPENDIX 3. SOURCE CODE

i e r r=P e t s c B a g C r e a t e (PETSC COMM WORLD, s i z e o f ( m o n o p o l e p a r a m e t e r s ) , bag ) ; CHKERRQ( i e r r ) ; i e r r=PetscBagGetData (  bag , pparams ) ; CHKERRQ( i e r r ) ; i e r r=PetscBagSetName (  bag , " Measured Monopole S o u r c e P a r a m e t e r s " , " r u n t i m e p a r a m e t e r s f o r a monopole s o u r c e " ) ; CHKERRQ( i e r r ) ; m o n o p o l e p a r a m e t e r s  pmono=( m o n o p o l e p a r a m e t e r s  ) (  pparams ) ; /  Monopole s o u r c e p a r a m e t e r s  / i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmono->Harmonic . A, 0 , "mono A" , " Monopole s o u r c e a m p l i t u d e " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmono->Harmonic . f , 1 0 0 , " mono f " , " Measured monopole s o u r c e f r e q u e n c y ( Hz ) " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmono->MeasuredSPL , 0 , " m e a s u r e d s p l " , " Monopole s o u r c e measured sound p r e s s u r e l e v e l (dB) a t p o i n t o f measurement " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmono->D i s t a n c e , 1 , " m e a s u r e d d i s t a n c e " , " D i s t a n c e from s o u r c e (m) a t p o i n t o f measurement " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmono->MeasuredSWL , 1 , " m e a s u r e d s w l " , " Monopole s o u r c e sound power l e v e l (dB) " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmono->Harmonic . phi , 0 , " mono phi " , " Monopole s o u r c e phase ( r a d i a n s ) " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmono->Harmonic . L o c a t i o n . X, 0 , " m o n o o r i g i n x " , " Monopole s o u r c e o r i g i n a l o n g x- a x i s (m) " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmono->Harmonic . L o c a t i o n . Y, 0 , " m o n o o r i g i n y " , " Monopole s o u r c e o r i g i n a l o n g y- a x i s (m) " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmono->Harmonic . L o c a t i o n . Z , 0 , " m o n o o r i g i n z " , " Monopole s o u r c e o r i g i n a l o n g z- a x i s (m) " ) ; CHKERRQ( i e r r ) ; i f ( LoadFromFile ) { PetscViewer bagviewer ; i f ( i e r r=PetscViewerBinaryOpen (PETSC COMM WORLD, S o u r c e P a r a m e t e r s F i l e , FILE MODE READ,& b a g v i e w e r ) ) { P e t s c P r i n t f (PETSC COMM WORLD, " Unable t o l o a d %s . \ n" , S o u r c e P a r a m e t e r s F i l e ) ; CHKERRQ( i e r r ) ; } i e r r=PetscBagLoad ( b agv iewe r , bag ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c V i e w e r D e s t r o y ( b a g v i e w e r ) ; CHKERRQ( i e r r ) ; i e r r=PetscBagGetData (  bag , pparams ) ; CHKERRQ( i e r r ) ; P e t s c P r i n t f (PETSC COMM WORLD, " Loaded monopole s o u r c e p a r a m e t e r s : \ n" ) ; i e r r=PetscBagView (  bag ,PETSC VIEWER STDOUT WORLD) ; CHKERRQ( i e r r ) ; } return 0 ;

480 481 482 483 484 485 486 487 488 489 490 491 } 492 493 P e t s c E r r o r C o d e I n i t i a l i z e M o n o p o l e F a m i l y ( h a r m o n i c p a r a m e t e r s  p s o u r c e , void  vpctx ) 494 { 495 P e t s c E r r o r C o d e i e r r =0; 496 a p p c t x  p c t x =( a p p c t x  ) vpctx ;

186

APPENDIX 3. SOURCE CODE
497 498 499 500 501 p a r a m e t e r s  param=pctx ->params ; i e r r=C a l c u l a t e M e s h L o c a t i o n (&( p s o u r c e ->L o c a t i o n ) , p c t x ) ; CHKERRQ( i e r r ) ;

3.15. SOURCE.C

P e t s c P r i n t f (PETSC COMM WORLD, " Monopole o r i g i n between mesh nodes %d,%d,%d and %d,%d,%d \ n" , p s o u r c e ->L o c a t i o n . l i , p s o u r c e ->L o c a t i o n . l j , p s o u r c e ->L o c a t i o n . l k , p s o u r c e -> L o c a t i o n . l i +1 , p s o u r c e ->L o c a t i o n . l j +1 , p s o u r c e ->L o c a t i o n . l k +1) ;

502 503 return 0 ; 504 } 505 506 P e t s c E r r o r C o d e I n i t i a l i z e M o n o p o l e S o u r c e ( void  vpctx ) 507 { 508 const P e t s c R e a l p r e f =20E- 6; 509 const P e t s c R e a l Wref=1E- 12; 510 a p p c t x  p c t x =( a p p c t x  ) vpctx ; 511 p a r a m e t e r s  param=pctx ->params ; 512 m o n o p o l e p a r a m e t e r s  p s o u r c e =( m o n o p o l e p a r a m e t e r s  ) pctx ->p s o u r c e ; 513 514 i f ( p s o u r c e ->D i s t a n c e <=0) 515 { 516 P e t s c P r i n t f (PETSC COMM WORLD, " D i s t a n c e from measured s o u r c e must be > 0. \ n" ) ; 517 return 1 ; 518 } 519 520 i f ( p s o u r c e ->Harmonic .A==0) 521 { 522 i f ( p s o u r c e ->MeasuredSWL==0) 523 { 524 /  I f p rms a t d i s t a n c e r i s known , t h e a m p l i t u d e o f t h e v o l u m e t r i c s o u r c e i s (2 s q r t ( 2 ) r p rms ) /( rho f )  / 525 P e t s c R e a l prms = p r e f  pow ( 1 0 . 0 , 0 . 0 5  p s o u r c e ->MeasuredSPL ) ; 526 p s o u r c e ->Harmonic .A = 2  s q r t ( 2 )  prms  p s o u r c e ->D i s t a n c e / ( Ge tD en si ty ( pctx -> p r o p e r t i e s )  p s o u r c e ->Harmonic . f ) ; 527 P e t s c P r i n t f (PETSC COMM WORLD, " Monopole ( a s measured SPL %g dB a t %g m) s o u r c e a m p l i t u d e %g . \ n" , p s o u r c e ->MeasuredSPL , p s o u r c e ->D i s t a n c e , p s o u r c e ->Harmonic .A) ; 528 } 529 else 530 { 531 /  I f power W i s known , t h e a m p l i t u d e o f t h e v o l u m e t r i c s o u r c e i s s q r t ( ( 2 c W) /( rho p i f ^2) )  / 532 P e t s c R e a l W = Wref  pow ( 1 0 . 0 , 0 . 1  p s o u r c e ->MeasuredSWL ) ; 533 p s o u r c e ->Harmonic .A = s q r t ( 2 W GetSpeedOfSound ( pctx -> p r o p e r t i e s ) / G et De ns it y ( pctx -> p r o p e r t i e s ) /M PI ) / p s o u r c e ->Harmonic . f ; 534 P e t s c P r i n t f (PETSC COMM WORLD, " Monopole ( a s measured SWL %g dB) s o u r c e a m p l i t u d e %g . \ n" , p s o u r c e ->MeasuredSWL , p s o u r c e ->Harmonic .A) ; 535 p s o u r c e ->MeasuredSPL=p s o u r c e ->MeasuredSWL+10 l o g 1 0 ( 1 / ( 4  M PI  p s o u r c e ->D i s t a n c e  p s o u r c e ->D i s t a n c e ) ) ; 536 } 537 }

187

3.15. SOURCE.C
538 539 540 else {

APPENDIX 3. SOURCE CODE

P e t s c P r i n t f (PETSC COMM WORLD, " Monopole s o u r c e a m p l i t u d e %g . \ n" , p s o u r c e ->Harmonic .A );

541 } 542 543 return I n i t i a l i z e M o n o p o l e F a m i l y (&( p s o u r c e ->Harmonic ) , vpctx ) ; 544 } 545 546 void Monopole ( P e t s c R e a l t , 547 Vec R, 548 void  vpctx ) 549 { 550 a p p c t x  p c t x =( a p p c t x  ) vpctx ; 551 P e t s c I n t i , j , k , d , dof , Nx , Ny , Nz , sx , sy , sz , mx, my, mz ; 552 P e t s c S c a l a r  r ; 553 Vec l o c a l ; 554 m o n o p o l e p a r a m e t e r s  params=( m o n o p o l e p a r a m e t e r s  ) pctx ->p s o u r c e ; 555 556 a s s e r t ( pctx ) ; 557 a s s e r t ( params ) ; 558 559 PetscLogEventBegin ( pctx ->CalcSourceEvent , 0 , 0 , 0 , 0 ) ; 560 561 /  Determine g l o b a l mesh n o d a l e x t e n t s  / 562 DAGetInfo ( pctx ->da , PETSC IGNORE,&Nx,&Ny,&Nz , 563 PETSC IGNORE, PETSC IGNORE, PETSC IGNORE, 564 PETSC IGNORE, PETSC IGNORE, 565 PETSC IGNORE, PETSC IGNORE) ; 566 567 /  Get l o c a l g r i d b o u n d a r i e s , which a r e i n d e p e n d e n t o f d o f  / 568 DAGetCorners ( pctx ->da ,& sx ,& sy ,& sz ,&mx,&my,&mz) ; 569 570 DAVecGetArrayDOF ( pctx ->da , R,& r ) ; 571 572 / R i s p r e v i o u s l y z e r o e d / 573 P e t s c R e a l Mag=MonopoleSignalWithRamp ( t ,&( params->Harmonic ) , 3 , 0 , 0 )  pctx ->invdx  pctx -> invdy  pctx ->i n v d z ; 574 P e t s c I n t kN=(TwoDimensional ( p c t x ) ? 1 : 2 ) ; 575 f o r ( k =0;k<kN ; k++) 576 f o r ( j =0; j < 2; j ++) 577 f o r ( i =0; i < 2; i ++) 578 { 579 i f ( ( params->Harmonic . L o c a t i o n . l i +i >=sx && params->Harmonic . L o c a t i o n . l i +i <sx+mx) && 580 ( params->Harmonic . L o c a t i o n . l j +j >=sy && params->Harmonic . L o c a t i o n . l j +j <sy+my) && 581 ( params->Harmonic . L o c a t i o n . l k+k>=s z && params->Harmonic . L o c a t i o n . l k+k< s z+mz) ) 582 { 583 r [ params->Harmonic . L o c a t i o n . l k+k ] [ params->Harmonic . L o c a t i o n . l j +j ] [ params-> Harmonic . L o c a t i o n . l i +i ] [ 0 ] = params->Harmonic . L o c a t i o n . w [ i ] [ j ] [ k ]  Mag ; 584 }

188

APPENDIX 3. SOURCE CODE
585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 } / R e l e a s e a c c e s s t o a r r a y / DAVecRestoreArrayDOF ( pctx ->da , R,& r ) ; PetscLogEventEnd ( pctx ->CalcSourceEvent , 0 , 0 , 0 , 0 ) ; } P e t s c R e a l GetMonopoleFrequency ( void  p s o u r c e ) { m o n o p o l e p a r a m e t e r s  pmono=( m o n o p o l e p a r a m e t e r s  ) p s o u r c e ; a s s e r t ( pmono ) ; return pmono->Harmonic . f ; }

3.15. SOURCE.C

P e t s c R e a l GetMonopoleOrigin ( void  p s o u r c e , P e t s c I n t d ) { m o n o p o l e p a r a m e t e r s  pmono=( m o n o p o l e p a r a m e t e r s  ) p s o u r c e ; a s s e r t ( d>=0 && d<=2) ; switch ( d ) { case 0 : return pmono->Harmonic . L o c a t i o n .X; break ; case 1 : return pmono->Harmonic . L o c a t i o n .Y; break ; case 2 : return pmono->Harmonic . L o c a t i o n . Z ; break ; }; return 0 ; }

P e t s c R e a l GetAWeighting ( P e t s c R e a l f ) { const P e t s c R e a l C1=12200  12200; const P e t s c R e a l C2 = 2 0 . 6  2 0 . 6 ; const P e t s c R e a l C3 = 1 0 7 . 7  1 0 7 . 7 ; const P e t s c R e a l C4 = 7 3 7 . 9  7 3 7 . 9 ; P e t s c R e a l f 2=f  f ; P e t s c R e a l RA=(C1  f 2  f 2 ) / ( ( f 2+C2 )  s q r t ( ( f 2+C3 )  ( f 2+C4 ) )  ( f 2+C1 ) ) ; return 2 . 0 + 2 0 . 0  l o g 1 0 (RA) ; }

P e t s c E r r o r C o d e R e g i s t e r M o n o p o l e S e r i e s B a g ( PetscBag  bag , void  pparams , P e t s c T r u t h LoadFromFile ) 632 { 633 P e t s c E r r o r C o d e i e r r =0;

189

3.15. SOURCE.C
634 635 636 637 638 639 640 641 642 643 644 645 a s s e r t ( bag ) ; a s s e r t ( pparams ) ;

APPENDIX 3. SOURCE CODE

i e r r=P e t s c B a g C r e a t e (PETSC COMM WORLD, s i z e o f ( m o n o p o l e s e r i e s p a r a m e t e r s ) , bag ) ; CHKERRQ( ierr ) ; i e r r=PetscBagGetData (  bag , pparams ) ; CHKERRQ( i e r r ) ; i e r r=PetscBagSetName (  bag , " Measured Monopole S o u r c e P a r a m e t e r s " , " r u n t i m e p a r a m e t e r s f o r a monopole s o u r c e " ) ; CHKERRQ( i e r r ) ; m o n o p o l e s e r i e s p a r a m e t e r s  pmono=( m o n o p o l e s e r i e s p a r a m e t e r s  ) (  pparams ) ; /  Monopole s o u r c e p a r a m e t e r s  / i e r r=P e t s c B a g R e g i s t e r S t r i n g (  bag ,&pmono-> I n p u t F i l e , 1 0 2 4 , "mono . c s v " , " m o n o s e r i e s i n p u t " , " Monopole s e r i e s i n p u t data f i l e " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r T r u t h (  bag ,&pmono->CSVFile , PETSC TRUE, " m o n o s e r i e s c s v i n p u t " , " I n d i c a t e monopole s e r i e s i n p u t data f i l e i s i n CSV f o r m a t . " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r T r u t h (  bag ,&pmono->InputAWeighted , PETSC TRUE, " m o n o s e r i e s A w e i g h t e d i n p u t " , " I n d i c a t e monopole s e r i e s i n p u t data f i l e i s i n CSV f o r m a t . " ) ; CHKERRQ( i e r r ) ; // i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmono-> d e l t a f , 1 0 0 , " m o n o d e l t a f " ," Monopole s e r i e s f r e q u e n c y i n t e r v a l ( Hz ) ") ; CHKERRQ( i e r r ) ; // i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmono->MeasuredSWL , 1 , " m e a s u r e d s w l " ," Monopole s o u r c e sound power l e v e l (dB) ") ; CHKERRQ( i e r r ) ; // i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmono->Harmonic . phi , 0 , " mono phi " ," Monopole s o u r c e p h a s e ( r a d i a n s ) ") ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmono->L o c a t i o n . X, 0 , " m o n o o r i g i n x " , " Monopole s o u r c e o r i g i n a l o n g x- a x i s (m) " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmono->L o c a t i o n . Y, 0 , " m o n o o r i g i n y " , " Monopole s o u r c e o r i g i n a l o n g y- a x i s (m) " ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c B a g R e g i s t e r R e a l (  bag ,&pmono->L o c a t i o n . Z , 0 , " m o n o o r i g i n z " , " Monopole s o u r c e o r i g i n a l o n g z- a x i s (m) " ) ; CHKERRQ( i e r r ) ; i f ( LoadFromFile ) { PetscViewer bagviewer ; i f ( i e r r=PetscViewerBinaryOpen (PETSC COMM WORLD, S o u r c e P a r a m e t e r s F i l e , FILE MODE READ,& b a g v i e w e r ) ) { P e t s c P r i n t f (PETSC COMM WORLD, " Unable t o l o a d %s . \ n" , S o u r c e P a r a m e t e r s F i l e ) ; CHKERRQ( i e r r ) ; } i e r r=PetscBagLoad ( b agv iewe r , bag ) ; CHKERRQ( i e r r ) ; i e r r=P e t s c V i e w e r D e s t r o y ( b a g v i e w e r ) ; CHKERRQ( i e r r ) ; i e r r=PetscBagGetData (  bag , pparams ) ; CHKERRQ( i e r r ) ; P e t s c P r i n t f (PETSC COMM WORLD, " Loaded monopole s e r i e s s o u r c e p a r a m e t e r s : \ n" ) ; i e r r=PetscBagView (  bag ,PETSC VIEWER STDOUT WORLD) ; CHKERRQ( i e r r ) ; } return 0 ;

646 647 648 649 650 651 652 653 654 655 656

657 658 659 660 661 662 663 664 665 666 667 668 } 669 670 P e t s c E r r o r C o d e I n i t i a l i z e M o n o p o l e S e r i e s S o u r c e ( void  vpctx )

190

APPENDIX 3. SOURCE CODE

3.15. SOURCE.C

671 { 672 const P e t s c R e a l Wref=1E- 12; 673 PetscErrorCode i e r r ; 674 a p p c t x  p c t x =( a p p c t x  ) vpctx ; 675 p a r a m e t e r s  param=pctx ->params ; 676 m o n o p o l e s e r i e s p a r a m e t e r s  p s o u r c e =( m o n o p o l e s e r i e s p a r a m e t e r s  ) pctx ->p s o u r c e ; 677 678 /  Read i n p a r a m e t e r s from f i l e  / 679 FILE  f p=f o p e n ( p s o u r c e -> I n p u t F i l e , " r " ) ; 680 i f ( ! fp ) 681 { 682 P e t s c P r i n t f (PETSC COMM WORLD, " Unable t o open %s f o r r e a d i n g monopole s e r i e s data . \ n" , p s o u r c e -> I n p u t F i l e ) ; 683 return 1 ; 684 } 685 686 p s o u r c e ->N=0; 687 P e t s c I n t NAlloc =10; 688 P e t s c R e a l SWL,  f ,  d e l t a f ; 689 P e t s c M a l l o c ( s i z e o f ( P e t s c R e a l )  NAlloc ,&SWL) ; 690 P e t s c M a l l o c ( s i z e o f ( P e t s c R e a l )  NAlloc ,& f ) ; 691 P e t s c M a l l o c ( s i z e o f ( P e t s c R e a l )  NAlloc ,& d e l t a f ) ; 692 693 while ( ! f e o f ( f p ) ) 694 { 695 int rc ; 696 float f1 , f2 , f 3 ; 697 i f ( p s o u r c e ->CSVFile==PETSC TRUE) 698 r c=f s c a n f ( fp , "%f ,% f ,% f \ n" ,& f 1 ,& f 2 ,& f 3 ) ; 699 else 700 r c=f s c a n f ( fp , "%f %f %f \ n" ,& f 1 ,& f 2 ,& f 3 ) ; 701 i f ( r c ==3) 702 { 703 f [ p s o u r c e ->N]= f 1 ; 704 d e l t a f [ p s o u r c e ->N]= f 2 ; 705 SWL[ p s o u r c e ->N]= f 3 ; 706 i f ( p s o u r c e ->InputAWeighted==PETSC TRUE) 707 SWL[ p s o u r c e ->N] -= GetAWeighting ( f [ p s o u r c e ->N ] ) ; 708 P e t s c P r i n t f (PETSC COMM WORLD, " I n p u t %5d : f= %g Hz d e l t a f=%g Hz SWL =%g dBA SWL =%g dB \ n" , p s o u r c e ->N, f [ p s o u r c e ->N] , d e l t a f [ p s o u r c e ->N] ,SWL[ p s o u r c e ->N]+ GetAWeighting ( f [ p s o u r c e ->N ] ) ,SWL[ p s o u r c e ->N ] ) ; 709 p s o u r c e ->N++; 710 i f ( p s o u r c e ->N >=NAlloc ) 711 { 712 P e t s c I n t newNAlloc = 2  NAlloc ; 713 P e t s c R e a l newSWL,  newf ,  n e w d e l t a f ; 714 P e t s c M a l l o c ( s i z e o f ( P e t s c R e a l )  newNAlloc ,&newSWL) ; 715 P e t s c M a l l o c ( s i z e o f ( P e t s c R e a l )  newNAlloc ,& newf ) ; 716 P e t s c M a l l o c ( s i z e o f ( P e t s c R e a l )  newNAlloc ,& n e w d e l t a f ) ; 717 memcpy (newSWL,SWL, s i z e o f ( P e t s c R e a l )  NAlloc ) ;

191

3.15. SOURCE.C
718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 memcpy ( newf , f , s i z e o f ( P e t s c R e a l )  NAlloc ) ; memcpy ( n e w d e l t a f , d e l t a f , s i z e o f ( P e t s c R e a l )  NAlloc ) ; P e t s c F r e e (SWL) ; PetscFree ( f ) ; PetscFree ( d e l t a f ) ; SWL =newSWL ; f=newf ; d e l t a f=n e w d e l t a f ; NAlloc=newNAlloc ; } } else {

APPENDIX 3. SOURCE CODE

P e t s c P r i n t f (PETSC COMM WORLD, " E r r o r r e a d i n g data from f i l e %s \ n" , p s o u r c e -> I n p u t F i l e ) ; f c l o s e ( fp ) ; return 1 ; } } f c l o s e ( fp ) ; PetscInt i ; P e t s c R e a l rho=GetDensity ( pctx -> p r o p e r t i e s ) ; P e t s c R e a l c=GetSpeedOfSound ( pctx -> p r o p e r t i e s ) ; i e r r=P e t s c M a l l o c ( s i z e o f ( h a r m o n i c p a r a m e t e r s )  p s o u r c e ->N,&( p s o u r c e ->Harmonic ) ) ; CHKERRQ ( ierr ) ; i e r r=P e t s c M a l l o c ( s i z e o f ( P e t s c R e a l )  p s o u r c e ->N,&( p s o u r c e -> d e l t a f ) ) ; CHKERRQ( i e r r ) ; f o r ( i =0; i <p s o u r c e ->N; i ++) { P e t s c R e a l d f=d e l t a f [ i ] ; // P e t s c R e a l d f 0 =(m==0?0: d e l t a f [m- 1]) ; // P e t s c R e a l d f 1 =(m ==params->N- 1?0: d e l t a f [m] ) ; // P e t s c R e a l d f =0.5  ( d f 0+d f 1 ) ; P e t s c R e a l i n v s c a l e = 1 . 0 / ( 2  M PI  d f ) ; /  I f power W i s known , t h e a m p l i t u d e o f t h e v o l u m e t r i c s o u r c e i s s q r t ( ( 2 c W) /( rho p i f ^2) )  / P e t s c R e a l W = Wref  pow ( 1 0 . 0 , 0 . 1  SWL[ i ] ) ; p s o u r c e ->Harmonic [ i ] . A = s q r t ( 2 W c / rho /M PI ) / f [ i ]  i n v s c a l e ; p s o u r c e ->Harmonic [ i ] . f = f [ i ] ; p s o u r c e ->Harmonic [ i ] . p h i = 0 ; p s o u r c e ->Harmonic [ i ] . L o c a t i o n .X=p s o u r c e ->L o c a t i o n .X; p s o u r c e ->Harmonic [ i ] . L o c a t i o n .Y=p s o u r c e ->L o c a t i o n .Y; p s o u r c e ->Harmonic [ i ] . L o c a t i o n . Z=p s o u r c e ->L o c a t i o n . Z ; p s o u r c e -> d e l t a f [ i ]= d e l t a f [ i ] ; P e t s c P r i n t f (PETSC COMM WORLD, " Monopole s e r i e s ( a s measured SWL[%d]=%g dB) s o u r c e a m p l i t u d e A[%d]=%g . \ n" , i ,SWL[ i ] , i , p s o u r c e ->Harmonic [ i ] . A) ;

192

APPENDIX 3. SOURCE CODE
764 765 766 767 768 769 770 771 } P e t s c F r e e (SWL) ; PetscFree ( f ) ; PetscFree ( d e l t a f ) ;

3.15. SOURCE.C

f o r ( i =0; i <p s o u r c e ->N; i ++) { i e r r=C a l c u l a t e M e s h L o c a t i o n (&( p s o u r c e ->Harmonic [ i ] . L o c a t i o n ) , p c t x ) ; CHKERRQ( i e r r ) ; }

772 773 return 0 ; 774 } 775 776 /  ! C a l c u l a t e s o u r c e term c o n t r i b u t i o n s t o RHS f o r a c o n t i n u o u s , c a l i b r a t e d monopole s o u r c e a t time t .  / 777 void M o n o p o l e S e r i e s ( P e t s c R e a l t , Vec R, void  vpctx ) 778 { 779 a p p c t x  p c t x =( a p p c t x  ) vpctx ; 780 P e t s c I n t i , j , k , d , dof , Nx , Ny , Nz , sx , sy , sz , mx, my, mz ; 781 P e t s c S c a l a r  r ; 782 Vec l o c a l ; 783 m o n o p o l e s e r i e s p a r a m e t e r s  params=( m o n o p o l e s e r i e s p a r a m e t e r s  ) pctx ->p s o u r c e ; 784 785 a s s e r t ( pctx ) ; 786 a s s e r t ( params ) ; 787 788 PetscLogEventBegin ( pctx ->CalcSourceEvent , 0 , 0 , 0 , 0 ) ; 789 790 /  Determine g l o b a l mesh n o d a l e x t e n t s  / 791 DAGetInfo ( pctx ->da , PETSC IGNORE,&Nx,&Ny,&Nz , 792 PETSC IGNORE, PETSC IGNORE, PETSC IGNORE, 793 PETSC IGNORE, PETSC IGNORE, 794 PETSC IGNORE, PETSC IGNORE) ; 795 796 /  Get l o c a l g r i d b o u n d a r i e s , which a r e i n d e p e n d e n t o f d o f  / 797 DAGetCorners ( pctx ->da ,& sx ,& sy ,& sz ,&mx,&my,&mz) ; 798 799 DAVecGetArrayDOF ( pctx ->da , R,& r ) ; 800 801 i n t rank ; MPI Comm rank (PETSC COMM WORLD,& rank ) ; 802 803 a s s e r t ( params->Harmonic ) ; 804 P e t s c I n t m; 805 f o r (m=0;m <params->N;m++) 806 { 807 P e t s c R e a l d f=params-> d e l t a f [m ] ; 808 // P e t s c R e a l d f 0 =(m==0?0:params-> d e l t a f [m- 1]) ; 809 // P e t s c R e a l d f 1 =(m ==params->N- 1?0: params-> d e l t a f [m] ) ; 810 // P e t s c R e a l d f =0.5  ( d f 0+d f 1 ) ;

193

3.15. SOURCE.C
811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853

APPENDIX 3. SOURCE CODE

P e t s c R e a l Mag=2M PI  d f  params->Harmonic [m ] . A c o s ( 2  M PI  params->Harmonic [m ] . f  t )  pctx ->invdx  pctx ->invdy  pctx ->i n v d z ; P e t s c I n t kN=(TwoDimensional ( p c t x ) ? 1 : 2 ) ; f o r ( k =0;k<kN ; k++) f o r ( j =0; j < 2; j ++) f o r ( i =0; i < 2; i ++) { i f ( ( params->Harmonic [m ] . L o c a t i o n . l i +i >=sx && params->Harmonic [m ] . L o c a t i o n . l i +i < sx+mx) && ( params->Harmonic [m ] . L o c a t i o n . l j +j >=sy && params->Harmonic [m ] . L o c a t i o n . l j +j <sy+my) && ( params->Harmonic [m ] . L o c a t i o n . l k+k>=s z && params->Harmonic [m ] . L o c a t i o n . l k+k< s z+mz) ) { r [ params->Harmonic [m ] . L o c a t i o n . l k+k ] [ params->Harmonic [m ] . L o c a t i o n . l j +j ] [ params-> Harmonic [m ] . L o c a t i o n . l i +i ] [ 0 ] += params->Harmonic [m ] . L o c a t i o n . w [ i ] [ j ] [ k ]  Mag ; } } } / R e l e a s e a c c e s s t o a r r a y / DAVecRestoreArrayDOF ( pctx ->da , R,& r ) ; PetscLogEventEnd ( pctx ->CalcSourceEvent , 0 , 0 , 0 , 0 ) ; } /  ! Get f r e q u e n c y o f c a l i b r a t e d monopole s o u r c e  / P e t s c R e a l G e t M o n o p o l e S e r i e s L o w e s t F r e q u e n c y ( void  vpctx ) { P e t s c R e a l MinFrequency=1E6 ; m o n o p o l e s e r i e s p a r a m e t e r s  p s o u r c e =( m o n o p o l e s e r i e s p a r a m e t e r s  ) vpctx ; P e t s c I n t i ,N; f o r ( i =0; i <p s o u r c e ->N; i ++) MinFrequency=(MinFrequency <p s o u r c e ->Harmonic [ i ] . f ? MinFrequency : p s o u r c e ->Harmonic [ i ] . f); return MinFrequency ; } /  ! Get f r e q u e n c y o f c a l i b r a t e d monopole s o u r c e  / P e t s c R e a l G e t M o n o p o l e S e r i e s H i g h e s t F r e q u e n c y ( void  vpctx ) { P e t s c R e a l MaxFrequency =0; m o n o p o l e s e r i e s p a r a m e t e r s  p s o u r c e =( m o n o p o l e s e r i e s p a r a m e t e r s  ) vpctx ; P e t s c I n t i ,N; f o r ( i =0; i <p s o u r c e ->N; i ++) MaxFrequency=(MaxFrequency>p s o u r c e ->Harmonic [ i ] . f ? MaxFrequency : p s o u r c e ->Harmonic [ i ] . f);

194

APPENDIX 3. SOURCE CODE
854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903

3.15. SOURCE.C

return MaxFrequency ; } /  ! Get l o c a t i o n o f c a l i b r a t e d monopole s o u r c e  / P e t s c R e a l G e t M o n o p o l e S e r i e s O r i g i n ( void  vpctx , P e t s c I n t d ) { m o n o p o l e s e r i e s p a r a m e t e r s  p s o u r c e =( m o n o p o l e s e r i e s p a r a m e t e r s  ) vpctx ; PetscInt i ; P e t s c R e a l Sum= 0 . 0 ,Denom= 0 . 0 ; a s s e r t ( d>=0 && d<=2) ; switch ( d ) { case 0 : f o r ( i =0; i <p s o u r c e ->N; i ++) { Sum += p s o u r c e ->Harmonic [ i ] . L o c a t i o n .X; Denom ++; } break ; case 1 : f o r ( i =0; i <p s o u r c e ->N; i ++) { Sum += p s o u r c e ->Harmonic [ i ] . L o c a t i o n .Y; Denom ++; } break ; case 2 : f o r ( i =0; i <p s o u r c e ->N; i ++) { Sum += p s o u r c e ->Harmonic [ i ] . L o c a t i o n . Z ; Denom ++; } break ; }; a s s e r t (Denom) ; return Sum/Denom ; } P e t s c E r r o r C o d e D e s t r o y M o n o p o l e S e r i e s S o u r c e ( void  vpctx ) { PetscErrorCode i e r r ; a p p c t x  p c t x =( a p p c t x  ) vpctx ; p a r a m e t e r s  param=pctx ->params ; m o n o p o l e s e r i e s p a r a m e t e r s  p s o u r c e =( m o n o p o l e s e r i e s p a r a m e t e r s  ) pctx ->p s o u r c e ; i f ( p s o u r c e ->Harmonic ) i e r r=P e t s c F r e e ( p s o u r c e ->Harmonic ) ; CHKERRQ( i e r r ) ; i f ( p s o u r c e -> d e l t a f ) i e r r=P e t s c F r e e ( p s o u r c e -> d e l t a f ) ; CHKERRQ( i e r r ) ; p s o u r c e ->N=0; return 0 ; }

195

3.16. TIMEMARCH.H

APPENDIX 3. SOURCE CODE

3.16
1 2 3 4 5 6 7 8 9 10 #i f n d e f #define

timemarch.h
TIMEMARCH H TIMEMARCH H

#include "param . h" #include " ode . h" /  ! \ f i l e timemarch . h \ b r i e f Time marching methods .

This h e a d e r f i l e d e c l a r e s t h e f u n c t i o n s f o r time marching t h e s o l u t i o n from an i n i t i a l v a l u e o v e r time \ f $ t 0 \ f $ t o \ f $ t { max }\ f $ . 11  / 12 13 /  ! March t h e s o l u t i o n from time \ f $ t 0 \ f $ t o \ f $ t { max }\ f $ .  / 14 P e t s c E r r o r C o d e S o l v e ( t i m e m a r c h p a r a m e t e r s  params , /  ! < [ i n ] time marching p a r a m e t e r s  / 15 a p p c t x  pctx , / !< [ i n ] a p p l i c a t i o n c o n t e x t / 16 Vec s o l u t i o n /  ! < [ in , o u t ] s o l u t i o n v e c t o r  / 17 ); 18 19 /  ! Monitor t h e s o l u t i o n , i n c l u d i n g c h e c k p o i n t i n g as r e q u i r e d .  / 20 P e t s c E r r o r C o d e MonitorFxn (TS t s , 21 PetscInt iter , 22 PetscReal t , 23 Vec s o l u t i o n , 24 void  p c t x ) ; 25 26 /  ! D e a l l o c a t e s t o r a g e c r e a t e d by MonitorFxn .  / 27 P e t s c E r r o r C o d e M o n i t o r F r e e ( void  ) ; 28 29 /  ! Handle a s i g n a l , c h e c k p o i n t i n g as r e q u i r e d .  / 30 P e t s c E r r o r C o d e C h e c k p o i n t H a n d l e r ( i n t signum , void  vpctx ) ; 31 32 /  ! Handle a d d i t i o n a l s i g n a l s o f SIGUSR1 and SIGUSR2 .  / 33 void U s e r S i g n a l s ( i n t ) ; 34 #endif

3.17
1 2 3 4 5 6 7 8 9

timemarch.c

#include < a s s e r t . h> #include < s i g n a l . h> #include < p e t s c . h> #include " c o n f i g . h" #include " timemarch . h" #include " ode . h" #include " t s . h"

196

APPENDIX 3. SOURCE CODE

3.17. TIMEMARCH.C

10 a p p c t x  a c t i v e c t x=NULL; 11 12 P e t s c E r r o r C o d e S o l v e ( t i m e m a r c h p a r a m e t e r s  params , 13 a p p c t x  pctx , 14 Vec s o l u t i o n ) 15 { 16 PetscErrorCode i e r r ; 17 TS t s ; 18 19 a s s e r t ( params ) ; 20 a s s e r t ( pctx ) ; 21 22 a c t i v e c t x=p c t x ; 23 24 TSCreate (PETSC COMM WORLD,& t s ) ; 25 TSSetProblemType ( t s , TS NONLINEAR) ; 26 27 /  R e g i s t e r our own time march methods  / 28 T S R e g i s t e r ( "RK4" , " " , " RK4Create " , Create RK4 ) ; 29 30 TSSetType ( t s ,TSRUNGE KUTTA) ; 31 TSRKSetTolerance ( t s , 1 e - 4) ; 32 33 T S S e t I n i t i a l T i m e S t e p ( t s , params->t0 , params->dt ) ; 34 35 TSSetDuration ( t s , params->maxsteps , params->tmax ) ; 36 37 SetupODE ( p c t x ) ; 38 39 TSSetSolution ( ts , s o l u t i o n ) ; 40 41 TSSetRHSFunction ( t s , FormODE, ( void  ) p c t x ) ; 42 43 TSSetFromOptions ( t s ) ; 44 45 P e t s c P u s h S i g n a l H a n d l e r ( CheckpointHandler , ( void  ) p c t x ) ; 46 /  PETSc c u r r e n t l y i g n o r e s SIGUSR1/USR2  / 47 s i g n a l ( SIGUSR1 , U s e r S i g n a l s ) ; 48 s i g n a l ( SIGUSR2 , U s e r S i g n a l s ) ; 49 50 pctx -> t e r m i n a t e=PETSC FALSE ; 51 pctx -> c h e c k p o i n t=PETSC FALSE ; 52 53 TSMonitorSet ( t s , MonitorFxn , ( void  ) pctx , M o n i t o r F r e e ) ; 54 55 i n t N O p t i o n s L e f t =0; 56 P e t s c O p t i o n s A l l U s e d (& N O p t i o n s L e f t ) ; 57 i f ( NOptionsLeft > 0) 58 { 59 P e t s c P r i n t f (PETSC COMM WORLD, "Some o p t i o n s were s p e c i f i e d but unused ! \ n" ) ;

197

3.17. TIMEMARCH.C
60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 PetscOptionsLeft () ; return 1 ; } i e r r=TSSolve ( t s , s o l u t i o n ) ; CHKERRQ( i e r r ) ; P e t s c I n t TSMaxSteps , TSTimeStepNumber ; P e t s c R e a l TSMaxTime , TSTime ; TSGetDuration ( t s ,&TSMaxSteps ,&TSMaxTime) ; TSGetTimeStepNumber ( t s ,&TSTimeStepNumber ) ; TSGetTime ( t s ,&TSTime ) ;

APPENDIX 3. SOURCE CODE

P e t s c P r i n t f (PETSC COMM WORLD, " F i n a l time %g s , maximum time %g s , \ n" , TSTime , TSMaxTime ) ; P e t s c P r i n t f (PETSC COMM WORLD, " s t e p %d , maximum s t e p s %d . \ n" , TSTimeStepNumber , TSMaxSteps ) ; P e t s c P r i n t f (PETSC COMM WORLD, " Average w a l l c l o c k compute time o f %g s p e r i t e r a t i o n . \ n " , pctx ->A v g S e c o n d s P e r I t e r ) ; P e t s c P r i n t f (PETSC COMM WORLD, " Average w a l l c l o c k compute time o f %g s p e r i t e r a t i o n p e r node . \ n" , pctx ->A v g S e c o n d s P e r I t e r / ( ( P e t s c R e a l ) pctx ->params->mesh . Nx pctx -> params->mesh . Ny pctx ->params->mesh . Nz ) ) ; // TSView ( t s ,PETSC VIEWER STDOUT WORLD) ; PetscPopSignalHandler ( ) ; s i g n a l ( SIGUSR1 , 0 ) ; s i g n a l ( SIGUSR2 , 0 ) ; TSDestroy ( t s ) ; a c t i v e c t x=NULL; return 0 ; } P e t s c E r r o r C o d e MonitorFxn (TS t s , PetscInt iter , PetscReal t , Vec s o l u t i o n , void  vpctx ) { a p p c t x  p c t x =( a p p c t x  ) ( vpctx ) ; s t a t i c Pet scT r uth F i r s t T i m e=PETSC TRUE ; s t a t i c P e t s c R e a l t s t a r t =0; s t a t i c unsigned short LastTimePerCent =0; s t a t i c unsigned short L a s t I t e r P e r C e n t =0; s t a t i c PetscLogDouble PrevTimeOfDay =0; P e t s c I n t I t e r I n t e r v a l =100; PetscLogDouble CurrentTimeOfDay , ElapsedTime ; P e t s c R e a l Norm1 , Norm2 ;

76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104

198

APPENDIX 3. SOURCE CODE
105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150

3.17. TIMEMARCH.C

a s s e r t ( pctx ) ; a s s e r t ( pctx ->params ) ; i f ( F i r s t T i m e==PETSC TRUE) { F i r s t T i m e=PETSC FALSE ; t s t a r t=pctx ->params->tm . t 0 ; LastTimePerCent =0; L a s t I t e r P e r C e n t =0; } unsigned short I t e r P e r C e n t =( unsigned short ) ( 1 0 0 . 0  ( ( f l o a t ) i t e r ) / ( ( f l o a t ) pctx ->params-> tm . maxsteps ) ) ; unsigned short TimePerCent=( unsigned short ) ( 1 0 0 . 0  ( t - t s t a r t ) / ( pctx ->params->tm . tmax- tstart )) ; PetscGetTime(&CurrentTimeOfDay ) ; i f ( CurrentTimeOfDay>=PrevTimeOfDay ) { ElapsedTime=CurrentTimeOfDay-PrevTimeOfDay ; } else { /  M i d n i g h t r o l l -o v e r  / ElapsedTime =(86400 - PrevTimeOfDay )+CurrentTimeOfDay ; } PrevTimeOfDay=CurrentTimeOfDay ; i f ( i t e r > 0) pctx ->A v g S e c o n d s P e r I t e r =(pctx ->A v g S e c o n d s P e r I t e r  ( ( PetscLogDouble ) ( i t e r - 1) )+ ElapsedTime ) / ( ( PetscLogDouble ) i t e r ) ; I t e r I n t e r v a l =( P e t s c I n t ) ( 6 0 0 . 0 / pctx ->A v g S e c o n d s P e r I t e r ) ; i f ( TimePerCent != LastTimePerCent | | I t e r P e r C e n t != L a s t I t e r P e r C e n t | | ( I t e r I n t e r v a l >0 && i t e r%I t e r I n t e r v a l ==0) ) { P e t s c P r i n t f (PETSC COMM WORLD, " i t e r . %6d : time %6.4E s , %3d%% o f f i n a l time " , i t e r , t , TimePerCent ) ; LastTimePerCent=TimePerCent ; L a s t I t e r P e r C e n t=I t e r P e r C e n t ; i n t RemainingSeconds =0; i f ( I t e r P e r C e n t >TimePerCent ) { P e t s c P r i n t f (PETSC COMM WORLD, " , %3d%% o f maximum number o f i t e r a t i o n s " , I t e r P e r C e n t ) ; RemainingSeconds =( i n t ) ( ( ( PetscLogDouble ) ( pctx ->params->tm . maxsteps - i t e r ) )  pctx -> AvgSecondsPerIter ) ; }

199

3.17. TIMEMARCH.C
151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 else {

APPENDIX 3. SOURCE CODE

RemainingSeconds =( i n t ) ( ( ( PetscLogDouble ) i t e r )  ( ( pctx ->params->tm . tmax- t s t a r t ) / ( t - t s t a r t ) -1)  pctx ->A v g S e c o n d s P e r I t e r ) ; } i f ( RemainingSeconds > 0) { P e t s c P r i n t f (PETSC COMM WORLD, " , c o m p l e t i o n i n about " ) ; unsigned i n t Days=RemainingSeconds / 8 6 4 0 0 ; RemainingSeconds -= Days  8 6 4 0 0 ; unsigned i n t Hours=RemainingSeconds / 3 6 0 0 ; RemainingSeconds -= Hours  3 6 0 0 ; unsigned i n t Minutes=RemainingSeconds / 6 0 ; RemainingSeconds -= Minutes  6 0 ; unsigned i n t Seconds=RemainingSeconds ; i f ( Days > 0) P e t s c P r i n t f (PETSC COMM WORLD, "%2d d , " , Days ) ; i f ( Hours > 0) P e t s c P r i n t f (PETSC COMM WORLD, "%2d h , " , Hours ) ; i f ( Minutes > 0) P e t s c P r i n t f (PETSC COMM WORLD, "%2d m, " , Minutes ) ; P e t s c P r i n t f (PETSC COMM WORLD, "%2d s " , Secon ds ) ; } P e t s c P r i n t f (PETSC COMM WORLD, " . \ n" ) ; } /  Update t h e t l a s t i n p a r a m e t e r s so t h a t we can r e s t a r t from l a s t c o m p l e t e d time s t e p / pctx ->params->tm . t 0=t ; i n t rank ; MPI Comm rank (PETSC COMM WORLD,& rank ) ; i f ( t>=pctx ->params->tm . tmax-pctx ->params->tm . T && t<=pctx ->params->tm . tmax ) { /  S c a t t e r p r e s s u r e v a l u e s from t h e s o l u t i o n t o t h e l o c a l ground p l a n e r e p r e s e n t a t i o n / i f ( ! pctx -> I n t e g r a t i o n S t a r t e d ) { b c p a r a m e t e r s  bc=( b c p a r a m e t e r s  ) pctx ->pbc ; a s s e r t ( bc ) ; i f ( pctx -> j l o >0 | | TwoDimensional ( p c t x ) | | bc->R e f l e c t i v e G r o u n d ) { / I n i t i a l i z e v e c t o r s t o z e r o / VecSet ( pctx ->prms , 0 . 0 ) ; VecSet ( pctx ->I , 0 . 0 ) ; VecSet ( pctx ->cu r r p , 0 . 0 ) ; VecSet ( pctx ->currw , 0 . 0 ) ; } /  Record time a t s t a r t o f i n t e g r a t i o n  / pctx -> t s t a r t=t ; pctx -> d t l a s t =0; /  I n i t i a l i z e sound power l e v e l  /

200

APPENDIX 3. SOURCE CODE
199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 pctx -> SWL=0; pctx -> t H i s t o r y=NULL; pctx ->P o w e r H i s t o r y=NULL;

3.17. TIMEMARCH.C

/  E s t i m a t e t h e number o f i n t e g r a t i o n s s t e p s r e m a i n i n g  / i f ( ! rank ) { pctx -> H i s t o r y A l l o c L e n =( P e t s c I n t ) ( fmax ( 1 2 8 , fmin ( 1 0 2 4 , 1 . 2 5  ( pctx ->params->tm . tmax- pctx -> t s t a r t ) / pctx ->params->tm . dt ) ) ) ; P e t s c M a l l o c ( s i z e o f ( P e t s c R e a l )  pctx ->H i s t o r y A l l o c L e n ,& pctx -> t H i s t o r y ) ; P e t s c M a l l o c ( s i z e o f ( P e t s c R e a l )  pctx ->H i s t o r y A l l o c L e n ,& pctx ->P o w e r H i s t o r y ) ; pctx ->NHistory =0; i f ( pctx ->DoProbe ) P e t s c M a l l o c ( s i z e o f ( P e t s c R e a l )  pctx ->H i s t o r y A l l o c L e n ,& pctx ->p H i s t o r y ) ; } } /  I n t e g r a t e by t r a p e z o i d a l r u l e w i t h r e s p e c t t o time  / P e t s c S c a l a r dt =( t==pctx ->params->tm . tmax ? 0 : ( t -pctx -> t l a s t ) ) ; P e t s c S c a l a r t s c a l e =0.5  ( dt+pctx -> d t l a s t ) ; double p r o b e v a l u e = 0 . 0 ; b c p a r a m e t e r s  bc=( b c p a r a m e t e r s  ) pctx ->pbc ; a s s e r t ( bc ) ; i f ( pctx -> j l o >0 | | TwoDimensional ( p c t x ) | | bc->R e f l e c t i v e G r o u n d | | pctx -> MaxAbsPressure ) { /  C a l c u l a t e RMS a v e r a g e o f p r e s s u r e  / / S c a t t e r c u r r e n t s o l u t i o n i n t o c u r r / V e c S c a t t e r B e g i n ( pctx ->groundp , s o l u t i o n , pctx ->c u r r p , INSERT VALUES ,SCATTER FORWARD) ; VecScatterEnd ( pctx ->groundp , s o l u t i o n , pctx ->c u r r p , INSERT VALUES ,SCATTER FORWARD) ; V e c S c a t t e r B e g i n ( pctx ->groundw , s o l u t i o n , pctx ->currw , INSERT VALUES ,SCATTER FORWARD) ; VecScatterEnd ( pctx ->groundw , s o l u t i o n , pctx ->currw , INSERT VALUES ,SCATTER FORWARD) ; /  Update max a b s p r e s s u r e  / i f ( pctx ->MaxAbsPressure ) VecPointwiseMaxAbs ( pctx ->pmaxabs , pctx ->pmaxabs , pctx ->c u r r p ); P e t s c S c a l a r  I ,  prms ,  c u r r p ,  currw ,  l a s t p ,  l a s t w ; P e t s c I n t i , d , np , nw ; V e c G e t L o c a l S i z e ( pctx ->c u r r p ,&np ) ; V e c G e t L o c a l S i z e ( pctx ->currw ,&nw) ; a s s e r t ( 3  np==nw) ;

201

3.17. TIMEMARCH.C
246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 VecGetArray ( pctx ->I ,& I ) ; VecGetArray ( pctx ->prms ,&prms ) ; VecGetArray ( pctx ->c u r r p ,& c u r r p ) ; VecGetArray ( pctx ->currw ,& currw ) ; f o r ( i =0; i <np ; i ++) { prms [ i ] += t s c a l e  ( c u r r p [ i ]  c u r r p [ i ] ) ; } f o r ( i =0; i <nw / 3 ; i ++) f o r ( d=0;d < 3;d++) { I [ i 3+d ] += t s c a l e  ( c u r r p [ i ]  currw [ i 3+d ] ) ; }

APPENDIX 3. SOURCE CODE

VecR estore A rray ( pctx ->currw ,& currw ) ; VecR estore A rray ( pctx ->c u r r p ,& c u r r p ) ; VecR estore A rray ( pctx ->prms ,&prms ) ; VecR estore A rray ( pctx ->I ,& I ) ; i f ( pctx ->DoProbe ) { double p r o b e o u t = 0 . 0 ; P e t s c S c a l a r  p ; DAVecGetArray ( pctx ->dagp , pctx ->cu r r p ,&p ) ; P e t s c I n t sx , sy , sz , mx, my, mz ; /  Get l o c a l g r i d b o u n d a r i e s , which a r e i n d e p e n d e n t o f d o f  / DAGetCorners ( pctx ->dagp ,& sx ,& sy ,& sz ,&mx,&my,&mz) ; PetscInt i , j ; f o r ( j =0; j < 2; j ++) f o r ( i =0; i < 2; i ++) { i f ( ( pctx -> p r o b e l i+i >=sx && pctx -> p r o b e l i+i <sx+mx) && ( pctx -> p r o b e l j+j >=sy && pctx -> p r o b e l j+j <sy+my) ) { p r o b e o u t += pctx ->probe w [ i ] [ j ]  p [ pctx -> p r o b e l j+j ] [ pctx -> p r o b e l i+i ] ; } } DAVecRestoreArray ( pctx ->dagp , pctx ->cu r r p ,&p ) ; MPI Reduce(& p r o b e o u t ,& p r o b e v a l u e , 1 , MPI DOUBLE, MPI SUM, 0 ,PETSC COMM WORLD) ; } } Vec l o c a l ; P e t s c S c a l a r  s ;

202

APPENDIX 3. SOURCE CODE
296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 /  Borrow l o c a l v e c t o r r e p r e s e n t a t i o n from DA  / DAGetLocalVector ( pctx ->da ,& l o c a l ) ;

3.17. TIMEMARCH.C

/  Gather from g l o b a l s o l u t i o n t o l o c a l , e n s u r e g h o s t s a r e up-to -d a t e  / DAGlobalToLocalBegin ( pctx ->da , s o l u t i o n , INSERT VALUES , l o c a l ) ; DAGlobalToLocalEnd ( pctx ->da , s o l u t i o n , INSERT VALUES , l o c a l ) ; /  Grab t h e a r r a y r e p r e s e n t a t i o n o f t h e l o c a l s o l u t i o n  / DAVecGetArrayDOF ( pctx ->da , l o c a l ,& s ) ; P e t s c I n t i , j , k , sx , sy , sz , mx, my, mz ; DAGetCorners ( pctx ->da ,& sx ,& sy ,& sz ,&mx,&my,&mz) ; PetscInt PetscInt PetscInt PetscInt PetscInt PetscInt i l o =(pctx -> i j l o =(pctx -> j k l o =(pctx -> k i h i =(pctx -> i j h i =(pctx -> j k h i =(pctx ->k l o >sx ? pctx -> i l o : sx ) ; l o >sy ? pctx -> j l o : sy ) ; l o > s z ? pctx -> k l o : s z ) ; h i <sx+mx? pctx -> i h i : sx+mx) ; h i <sy+my? pctx -> j h i : sy+my) ; h i < s z+mz? pctx -> k h i : s z+mz) ;

P e t s c R e a l SWL= 0 . 0 ; / i l o f a c e / i f ( pctx -> i l o >=sx && pctx -> i l o <sx+mx) { P e t s c R e a l Area=pctx ->dy  pctx ->dz ; i=pctx -> i l o ; f o r ( j=j l o ; j < j h i ; j ++) f o r ( k=k l o ; k<k h i ; k++) { PetscReal s c a l e =1.0; i f ( j==pctx -> j l o | | j==pctx -> j h i ) s c a l e = 0 . 5 ; i f ( k==pctx -> k l o | | k==pctx -> k h i ) s c a l e = 0 . 5 ; P e t s c R e a l I=-s [ k ] [ j ] [ i ] [ 0 ]  s [ k ] [ j ] [ i ] [ 1 ] ; SWL += s c a l e  Area  I ; } } / i h i f a c e / i f ( pctx -> i h i >=sx && pctx -> i h i <sx+mx) { P e t s c R e a l Area=pctx ->dy  pctx ->dz ; i=pctx -> i h i ; f o r ( j=j l o ; j < j h i ; j ++) f o r ( k=k l o ; k<k h i ; k++) { PetscReal s c a l e =1.0; i f ( j==pctx -> j l o | | j==pctx -> j h i ) s c a l e = 0 . 5 ; i f ( k==pctx -> k l o | | k==pctx -> k h i ) s c a l e = 0 . 5 ; P e t s c R e a l I=+s [ k ] [ j ] [ i ] [ 0 ]  s [ k ] [ j ] [ i ] [ 1 ] ;

203

3.17. TIMEMARCH.C
346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 SWL += s c a l e  Area  I ; } } / j l o f a c e / i f ( pctx -> j l o >=sy && pctx -> j l o <sy+my) { P e t s c R e a l Area=pctx ->dx  pctx ->dz ; j=pctx -> j l o ; f o r ( i= i l o ; i < i h i ; i ++) f o r ( k=k l o ; k<k h i ; k++) { PetscReal s c a l e =1.0; i f ( i==pctx -> i l o | | i==pctx -> i h i ) s c a l e = 0 . 5 ; i f ( k==pctx -> k l o | | k==pctx -> k h i ) s c a l e = 0 . 5 ; P e t s c R e a l I=-s [ k ] [ j ] [ i ] [ 0 ]  s [ k ] [ j ] [ i ] [ 2 ] ; SWL += s c a l e  Area  I ; } } / j h i f a c e / i f ( pctx -> j h i >=sy && pctx -> j h i <sy+my) { P e t s c R e a l Area=pctx ->dx  pctx ->dz ; j=pctx -> j h i ; f o r ( i= i l o ; i < i h i ; i ++) f o r ( k=k l o ; k<k h i ; k++) { PetscReal s c a l e =1.0; i f ( i==pctx -> i l o | | i==pctx -> i h i ) s c a l e = 0 . 5 ; i f ( k==pctx -> k l o | | k==pctx -> k h i ) s c a l e = 0 . 5 ; P e t s c R e a l I=+s [ k ] [ j ] [ i ] [ 0 ]  s [ k ] [ j ] [ i ] [ 2 ] ; SWL += s c a l e  Area  I ; } } / k l o f a c e / i f ( pctx -> k l o >=s z && pctx -> k l o < s z+mz) { P e t s c R e a l Area=pctx ->dx  pctx ->dy ; k=pctx -> k l o ; f o r ( i= i l o ; i < i h i ; i ++) f o r ( j=j l o ; j < j h i ; j ++) { PetscReal s c a l e =1.0; i f ( i==pctx -> i l o | | i==pctx -> i h i ) s c a l e = 0 . 5 ; i f ( j==pctx -> j l o | | j==pctx -> j h i ) s c a l e = 0 . 5 ; P e t s c R e a l I=-s [ k ] [ j ] [ i ] [ 0 ]  s [ k ] [ j ] [ i ] [ 3 ] ; SWL += s c a l e  Area  I ; }

APPENDIX 3. SOURCE CODE

204

APPENDIX 3. SOURCE CODE
396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 } / j h i f a c e / i f ( pctx ->k h i >=s z && pctx ->k h i < s z+mz) { P e t s c R e a l Area=pctx ->dx  pctx ->dy ; k=pctx -> k h i ; f o r ( i= i l o ; i < i h i ; i ++) f o r ( j=j l o ; j < j h i ; j ++) { PetscReal s c a l e =1.0; i f ( i==pctx -> i l o | | i==pctx -> i h i ) s c a l e = 0 . 5 ; i f ( j==pctx -> j l o | | j==pctx -> j h i ) s c a l e = 0 . 5 ; P e t s c R e a l I=+s [ k ] [ j ] [ i ] [ 0 ]  s [ k ] [ j ] [ i ] [ 3 ] ; SWL += s c a l e  Area  I ; } }

3.17. TIMEMARCH.C

double SWLout=SWL, SWLin = 0 . 0 ; MPI Reduce(&SWLout,&SWLin , 1 , MPI DOUBLE, MPI SUM, 0 ,PETSC COMM WORLD) ; if { i f ( pctx ->NHistory >=pctx -> H i s t o r y A l l o c L e n ) { P e t s c I n t n e w H i s t o r y A l l o c L e n=pctx -> H i s t o r y A l l o c L e n +1024; P e t s c R e a l  newPowerHistory ,  n e w t H i s t o r y ,  newpHistory ; P e t s c M a l l o c ( s i z e o f ( P e t s c R e a l )  n e w H i s t o r y A l l o c L e n ,& n e w t H i s t o r y ) ; P e t s c M a l l o c ( s i z e o f ( P e t s c R e a l )  n e w H i s t o r y A l l o c L e n ,& newPowerHistory ) ; i f ( pctx ->DoProbe ) P e t s c M a l l o c ( s i z e o f ( P e t s c R e a l )  n e w H i s t o r y A l l o c L e n ,& newpHistory ); memcpy ( n e w t H i s t o r y , pctx -> t H i s t o r y , s i z e o f ( P e t s c R e a l )  pctx ->NHistory ) ; memcpy ( newPowerHistory , pctx ->PowerHistory , s i z e o f ( P e t s c R e a l )  pctx ->NHistory ) ; i f ( pctx ->DoProbe ) memcpy ( newpHistory , pctx ->p H i s t o r y , s i z e o f ( P e t s c R e a l )  pctx -> NHistory ) ; P e t s c F r e e ( pctx -> t H i s t o r y ) ; P e t s c F r e e ( pctx ->P o w e r H i s t o r y ) ; i f ( pctx ->DoProbe ) P e t s c F r e e ( pctx ->p H i s t o r y ) ; pctx -> t H i s t o r y=n e w t H i s t o r y ; pctx ->P o w e r H i s t o r y=newPowerHistory ; i f ( pctx ->DoProbe ) pctx ->p H i s t o r y=newpHistory ; pctx -> H i s t o r y A l l o c L e n=n e w H i s t o r y A l l o c L e n ; } pctx -> t H i s t o r y [ pctx ->NHistory ] = t ; pctx ->P o w e r H i s t o r y [ pctx ->NHistory ] = SWL; /  P i c k up p r o b e v a l u e  / i f ( pctx ->DoProbe ) { pctx ->p H i s t o r y [ pctx ->NHistory ] = p r o b e v a l u e ; ( ! rank )

205

3.17. TIMEMARCH.C
444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 } pctx ->NHistory++; } pctx -> SWL += t s c a l e  SWLin ; DAVecRestoreArrayDOF ( pctx ->da , l o c a l ,& s ) ; /  Return l o c a l v e c t o r r e p r e s e n t a t i o n t o DA  / DARestoreLocalVector ( pctx ->da ,& l o c a l ) ;

APPENDIX 3. SOURCE CODE

/  Record l a s t time o f i n t e g r a t i o n  / pctx -> t l a s t=t ; pctx -> d t l a s t =(t -pctx -> t l a s t ) ; /  Record t h a t RMS i n t e g r a t i o n has been s t a r t e d  / pctx -> I n t e g r a t i o n S t a r t e d=PETSC TRUE ; } i f ( pctx ->params->tm . s a v e f r e q >0 && i t e r%pctx ->params->tm . s a v e f r e q ==0) { P e t s c P r i n t f (PETSC COMM WORLD, " S a v i n g s o l u t i o n f o r i t e r a t i o n %d . \ n" , i t e r ) ; // SaveVTKByIter ( i t e r , s o l u t i o n , p c t x ) ; SaveCheck point ( s o l u t i o n , p c t x ) ; } i f ( pctx -> c h e c k p o i n t ) { P e t s c P r i n t f (PETSC COMM WORLD, " S a v i n g c h e c k p o i n t s o l u t i o n . \ n" ) ; SaveCheck point ( s o l u t i o n , p c t x ) ; } pctx -> c h e c k p o i n t=PETSC FALSE ; i f ( pctx -> t e r m i n a t e ) { P e t s c P r i n t f (PETSC COMM WORLD, " T e r m i n a t i n g . \ n" ) ; PetscPopSignalHandler ( ) ; s i g n a l ( SIGUSR1 , 0 ) ; s i g n a l ( SIGUSR2 , 0 ) ; TSMonitorCancel ( t s ) ; return 1 ; } i f ( pctx -> S a v e T r a n s i e n t P r e s s u r e ) { SaveVTKByIter ( i t e r , t , s o l u t i o n , p c t x ) ; }

206

APPENDIX 3. SOURCE CODE
494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542

3.17. TIMEMARCH.C

i f ( pctx ->S a v e T r a n s i e n t ) { SaveFullVTKByIter ( i t e r , t , s o l u t i o n , p c t x ) ; } pctx -> t e r m i n a t e=PETSC FALSE ; P e t s c R e a l Min , Max ; VecMin ( s o l u t i o n , PETSC IGNORE,&Min ) ; VecMax ( s o l u t i o n , PETSC IGNORE,&Max) ; i f ( Min!=Min | | Max!=Max) { /  The s o l v e r has d i v e r g e d !  / P e t s c P r i n t f (PETSC COMM WORLD, "The s o l v e r a p p e a r s t o have d i v e r g e d (NaN i n s o l u t i o n ) ! \ n" ) ; return 1 ; } return 0 ; } P e t s c E r r o r C o d e M o n i t o r F r e e ( void  vpctx ) { a p p c t x  p c t x =( a p p c t x  ) ( vpctx ) ; return 0 ; } P e t s c E r r o r C o d e C h e c k p o i n t H a n d l e r ( i n t signum , void  vpctx ) { a p p c t x  p c t x =( a p p c t x  ) ( vpctx ) ; switch ( signum ) { case SIGTERM: case SIGINT : case SIGABRT : case SIGALRM : pctx -> c h e c k p o i n t=PETSC TRUE ; pctx -> t e r m i n a t e=PETSC TRUE ; break ; case SIGUSR1 : case SIGUSR2 : case SIGHUP : pctx -> c h e c k p o i n t=PETSC TRUE ; break ; } return 0 ; }

207

3.18. TS.H
543 544 void U s e r S i g n a l s ( i n t signum ) 545 { 546 if ( active ctx ) 547 { 548 switch ( signum ) { 549 case SIGUSR1 : 550 a c t i v e c t x -> c h e c k p o i n t=PETSC TRUE ; 551 break ; 552 case SIGUSR2 : 553 a c t i v e c t x -> c h e c k p o i n t=PETSC TRUE ; 554 a c t i v e c t x -> t e r m i n a t e=PETSC TRUE ; 555 break ; 556 } 557 } 558 }

APPENDIX 3. SOURCE CODE

3.18
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #i f n d e f #define

ts.h
TS H TS H

#include " p e t s c . h" / ! \ f i l e t s . h \ b r i e f E x t e n s i o n s t o PETSc TS methods D e c l a r e s f u n c t i o n s f o r c r e a t i n g and e x t e n d i n g PETSc TS time marching methods . / /  ! A f i x e d time -s t e p , f o u r t h -o r d e r Runge-Kutta time marching method .  / P e t s c E r r o r C o d e Create RK4 (TS t s ) ; #endif

3.19
1 2 3 4 5 6 7 8 9 10 11 12

ts.c

#define PETSCTS DLL / Code f o r T i m e s t e p p i n g w i t h e x p l i c i t E u l e r . / #include " t s . h" #include " p r i v a t e / t s i m p l . h" / I " p e t s c t s . h" /  ! \ b r i e f Parameters f o r RK4 Parameters f o r computing f o u r t h -o r d e r Runge-Kutta time marching  / typedef struct {

I /

208

APPENDIX 3. SOURCE CODE
13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 Vec f , work , s o l n p 1 ; } TS RKN ; s t a t i c P e t s c E r r o r C o d e SetUp RK4 (TS t s ) { TS RKN RK = (TS RKN  ) t s ->data ; PetscErrorCode i e r r ; PetscFunctionBegin ; i e r r = V e c D u p l i c a t e ( t s -> v e c s o l ,&RK -> f ) ;CHKERRQ( i e r r ) ; i e r r = V e c D u p l i c a t e ( t s -> v e c s o l ,&RK ->work ) ;CHKERRQ( i e r r ) ; i e r r = V e c D u p l i c a t e ( t s -> v e c s o l ,&RK -> s o l n p 1 ) ;CHKERRQ( i e r r ) ; PetscFunctionReturn (0) ; }

3.19. TS.C

s t a t i c P e t s c E r r o r C o d e Step RK4 (TS t s , P e t s c I n t  s t e p s , P e t s c R e a l  ptime ) { const P e t s c R e a l a [ 4 ] = { 0 , 0 . 5 , 0 . 5 , 1 } ; const P e t s c R e a l b [ 4 ] = { 1 . 0 / 6 . 0 , 1 . 0 / 3 . 0 , 1 . 0 / 3 . 0 , 1 . 0 / 6 . 0 } ; const P e t s c R e a l c [ 4 ] = { 0 , 0 . 5 , 0 . 5 , 1 } ; TS RKN RK = (TS RKN  ) t s ->data ; Vec s o l = t s -> v e c s o l , f = RK ->f , work = RK ->work , s o l n p 1 = RK -> s o l n p 1 ; PetscErrorCode i e r r ; PetscInt i , j , m a x s t e p s = t s ->m a x s t e p s ; PetscFunctionBegin ;  s t e p s = - t s -> s t e p s ; i e r r = TSMonitor ( t s , t s -> s t e p s , t s ->ptime , s o l ) ;CHKERRQ( i e r r ) ; f o r ( i =0; i <m a x s t e p s ; i ++) { P e t s c R e a l dt = t s -> t i m e s t e p ; i f ( t s ->ptime+dt >t s ->max time ) dt = t s ->max time -t s ->ptime ; i e r r = TSPreStep ( t s ) ;CHKERRQ( i e r r ) ; // t s ->ptime += d t ; i e r r = VecCopy ( s o l , s o l n p 1 ) ; CHKERRQ( i e r r ) ; i e r r = VecCopy ( s o l , work ) ; CHKERRQ( i e r r ) ; i e r r = TSComputeRHSFunction ( t s , t s ->ptime , work , f ) ;CHKERRQ( i e r r ) ; i e r r = VecAXPY( s o l n p 1 , b [ 0 ]  dt , f ) ;CHKERRQ( i e r r ) ; f o r ( j =1; j < 4; j ++) { i e r r = VecWAXPY( work , a [ j ]  dt , f , s o l ) ; i e r r = TSComputeRHSFunction ( t s , t s ->ptime+c [ j ]  dt , work , f ) ;CHKERRQ( i e r r ) ; i e r r = VecAXPY( s o l n p 1 , b [ j ]  dt , f ) ; } t s ->ptime += dt ; t s -> s t e p s ++; i e r r = VecCopy ( s o l n p 1 , s o l ) ; CHKERRQ( i e r r ) ; i e r r = TSPostStep ( t s ) ;CHKERRQ( i e r r ) ;

209

3.19. TS.C
63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112

APPENDIX 3. SOURCE CODE

i e r r = TSMonitor ( t s , t s ->s t e p s , t s ->ptime , s o l ) ;CHKERRQ( i e r r ) ; i f ( t s ->ptime >= t s ->max time ) break ; }  s t e p s += t s -> s t e p s ;  ptime = t s ->ptime ; PetscFunctionReturn (0) ; } s t a t i c P e t s c E r r o r C o d e Destroy RK4 (TS t s ) { TS RKN RK = (TS RKN  ) t s ->data ; PetscErrorCode i e r r ; PetscFunctionBegin ; i f (RK -> f ) { i e r r = VecDestroy (RK -> f ) ;CHKERRQ( i e r r ) ; } i f (RK ->work ) { i e r r = VecDestroy (RK ->work ) ;CHKERRQ( i e r r ) ; } i f (RK -> s o l n p 1 ) { i e r r = VecDestroy (RK -> s o l n p 1 ) ;CHKERRQ( i e r r ) ; } i e r r = P e t s c F r e e (RK) ;CHKERRQ( i e r r ) ; PetscFunctionReturn (0) ; } s t a t i c P e t s c E r r o r C o d e SetFromOptions RK4 (TS t s ) { PetscFunctionBegin ; PetscFunctionReturn (0) ; } s t a t i c P e t s c E r r o r C o d e View RK4 (TS t s , P e t s c V i e w e r v i e w e r ) { PetscFunctionBegin ; PetscFunctionReturn (0) ; } P e t s c E r r o r C o d e PETSCTS DLLEXPORT Create RK4 (TS t s ) { TS RKN RK; PetscErrorCode i e r r ; PetscFunctionBegin ; t s ->ops ->s e t u p t s ->ops -> s t e p t s ->ops -> d e s t r o y t s ->ops -> s e t f r o m o p t i o n s t s ->ops ->view

= = = = =

SetUp RK4 ; Step RK4 ; Destroy RK4 ; SetFromOptions RK4 ; View RK4 ;

i e r r = PetscNewLog ( t s , TS RKN,&RK) ;CHKERRQ( i e r r ) ; t s ->data = ( void  )RK; PetscFunctionReturn (0) ;

210

APPENDIX 3. SOURCE CODE
113 }

3.19. TS.C

211

References
[1] International organization for standarization - acoustics: Attenuation of sound during propagation outdoors (iso 9613-2). pages 1Â­17, Dec 1996. [2] Government of ontario - ontario's long-term energy plan. pages 12Â­34, Nov 2010. Available from: http://www.mei.gov.on.ca/en/pdf/MEI_LTEP_en.pdf. [3] Ontario chief medical officer of health - the potential health impact of wind turbines. May 2010. Available from: http://www.health.gov.on.ca/en/public/publications/ministry_reports/ wind_turbine/wind_turbine.pdf. [4] Southpoint wind - the southpoint wind 1400mw offshore wind energy project. pages 14Â­ 112, Feb 2010. Available from: http://www.southpointwind.com/files/SPW_Draft_Project_ Description_Report_1400MW.pdf. [5] Southpoint wind - the southpoint wind 30mw offshore wind energy project. pages 15Â­

84, Feb 2010. Available from: http://www.southpointwind.com/files/SPW_Draft_Project_ Description_Report_30MW.pdf. [6] Government of ontario - environmental protection act 359-09. pages 1Â­10, Feb 2011. Available from: http://www.e-laws.gov.on.ca/html/regs/english/elaws_regs_090359_e.htm. [7] Independent electricity system operator - about the ieso. 2011. Available from: http://www.ieso. ca/imoweb/about/about_the_ieso.asp. [8] Independent electricity system operator - map. 2011. Available from: http://www.canaxenergy. com/images/chart_onneighboring.gif. [9] Independent electricity system operator - who we are. 2011. Available from: http://ieso.ca/ imoweb/siteShared/whoweare.asp?sid=md. [10] Independent electricity system operator - wind power in ontario. page 1, Feb 2011. Available from: http://www.ieso.ca/imoweb/marketdata/windpower.asp. [11] Leamington post - turbine issue dead in the water? pages 1Â­2, Feb 2011. Available from: http: //www.leamingtonpostandshopper.com/ArticleDisplay.aspx?e=2536250&archive=true. 213

REFERENCES

REFERENCES

[12] National renewable energy laboratory - integrating wind and solar on the grid-nrel analysis leads the way. Continuum Magazine, 2011. Available from: http://www.nrel.gov/continuum/ integrating_wind_solar.cfm. [13] Norfolk county - erie shores wind farm. Signage, March 2011. [14] Ontario power authority - homepage. Feb 2011. Available from: http://www.powerauthority. on.ca. [15] Toronto western hospital - wave. Feb 2011. Available from: http://www.usra.ca/files/images/ wave%2520frequency.jpg. [16] J.F. Ainslie and J. Scott. Theoretical modelling of noise generated by wind turbines. Wind Engineering, 14(1 , 1990):9Â­14, 1990. Available from: http://www.scopus.com/inward/record.url? eid=2-s2.0-0025018536&partnerID=40&md5=86132855a4fa78b08bc6ccb1790cdc3f. [17] Keith Attenborough. Acoustical characteristics of rigid fibrous absorbents and granular materials. Acoustical Society of America, 73(3):785Â­799, 1983. Available from: http://www.scopus.com/inward/record.url?eid=2-s2.0-0020717329&partnerID=40&md5= c0962b8b7d105a6234098d7974cf2ec8. [18] EF Baerwald, GH D'Amours, BJ Klug, and RMR Barclay. Barotrauma is a sig-

nificant cause of bat fatalities at wind turbines. Current Biology, 18(16):R695Â­R696, 2008. Available from: http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=pubmed&cmd= Retrieve&dopt=AbstractPlus&list_uids=18063636580362992522related:irtJvMPtrvoJ. [19] William K. Blake. Mechanics of Flow-Induced Sound and Vibration - Vol. II Complex Flow-Structure Interactions. Academic Press, 1986. [20] Thomas F. Brooks and Michael A. Marcolini. Airfoil tip vortex formation noise. American Institute of Aeronautics and Astronautics, 24(2):246Â­252, 1986. Available from: http://www.scopus.com/inward/record.url?eid=2-s2.0-0022660745&partnerID=40&md5= a6e1f1f0bb3f42733b18c2879dcdd2e0. [21] Thomas F. Brooks, D. Stuart Pope, and Michael A. Marcolini. Airfoil self-noise and prediction. Technical report, NASA, 1989. [22] Rui Cheng, Philip J. Morris, and Kenneth S. Brentner. A 3d parabolic equation method for wind turbine noise propagation in moving inhomogeneous atmosphere. In 12th AIAA/CEAS Aeroacoustics Conference (27th AIAA Aeroacoustics Conference), Cambridge, Massachusetts, May 2006. [23] M.G. A. Dassen, R. Parchen, J. Bruggeman, and F. Hagg. Wind tunnel measurements of the aerodynamic noise of blade sections. In J.L. Tsipouridis, editor, Proc. of the European Wind Energy Association Conf. & Exhibition, volume I, pages 791Â­798, Thessaloniki, October 1994. 214

REFERENCES

REFERENCES

[24] Robert Doyle. Understanding ontario's electricity system. pages 1Â­12, Sep 2010. Available from: http://thecesh.com/wp-content/uploads/2010/09/IESO_CESH_Sept13_10.pptx. [25] M.R. Fink and D.A. Bailey. Airframe noise reduction studies and clean-airframe noise investigation. Technical report, NASA, 1980. [26] Jens Forssn, Martin Schiff, Eja Pedersen, and Kerstin Persson Waye. Wind turbine noise propagation over flat ground: Measurements and predictions. Acta Acustica United with Acustica, 96:753Â­760, 2010. [27] Stephen D. Gedney. Introduction to the Finite-Difference Time-Domain (FDTD) Method for Electromagnetics. Morgan & Claypool, 2011. [28] Paul Gipe and James Murphy. Ontario landowner's guide to wind energy. Technical report, Ontario Sustainable Energy Association, 2005. Available from: http://www.wind-works.org/articles/ OSEA-Landowners-2005-r1-v3.pdf. [29] Neil Glenister. Frequency weighting equations, 1998. Available from: http://www.

cross-spectrum.com/audio/weighting.html. [30] Lee Greenberg. Ontario wins court round in wind-power fight, March 2011. Available from: http://www.ottawacitizen.com/health/Ontario+wins+court+round+wind+power+ fight/4379558/story.html#ixzz1FZzG6h8W. [31] Ferdinand W. Grosveld. Prediction of broadband noise from horizontal axis wind turbines. Propulsion and Power, 1(4):292Â­299, 1985. Available from: http://www.scopus.com/inward/record. url?eid=2-s2.0-0022098313&partnerID=40&md5=33ecc436ecb46ec12ca938327ea8697f. [32] G. Guidati, R. Barcei, and S. Wagner. An investigation of blade-tower-interaction noise (bti) for horizontal axis wind turbines in upwind and downwind configuration first step towards modeling of aeroelastic effects. In Proc. of the 8th IEA Symposium, Joint Action, Aerodynamics of Wind Turbines, Lyngby, November 1994. [33] JP Harrison. Disconnect between turbine noise guidelines and health authority recommendations. pages 1Â­3, 2008. Available from: http://www.ncbi.nlm.nih.gov/entrez/query.fcgi? db=pubmed&cmd=Retrieve&dopt=AbstractPlus&list_uids=related:PhCsUMrkj1EJ. [34] Erich Hau, Jens Langenbrinck, Wolfgang Palz, and Commission of the European Communities. WEGA: Large Wind Turbines. Springer, 1993. [35] Alan S. Hersh, Paul T. Soderman, and Richard E. Hayden. Investigation of acoustic effects of leading-edge serrations on airfoils. Aircraft, 11(4):197Â­202, 1974. Available from: http://www.scopus.com/inward/record.url?eid=2-s2.0-0016047959&partnerID= 40&md5=c3e283b3be3da131a08291334a4565f2. 215

REFERENCES

REFERENCES

[36] Brian Howe, Bill Gastmeier, and Nick McCabe. Wind turbines and sound: Review and best practice guidelines. Feb 2007. Available from: http://www.canwea.ca/images/uploads/File/ CanWEA_Wind_Turbine_Sound_Study_-_Final.pdf. [37] M.S. Howe. On the generation of side-edge flap noise. Sound and Vibration, 80(4):555Â­573, 1982. Available from: http://www.scopus.com/inward/record.url?eid=2-s2. 0-0020087466&partnerID=40&md5=c8c4bcfaefb706d460f22d5eeb3e45bc. [38] M.S. Howe. Noise produced by a sawtooth trailing edge. Acoustical Society of America,

90(1):482Â­487, 1991. Available from: http://www.scopus.com/inward/record.url?eid=2-s2. 0-0025806981&partnerID=40&md5=8af5a2e1c3b5056ed72b4b82f6ab5f36. [39] Allan Jenkins. Wind generation activities and issues. pages 1Â­15, May 2008. Avail-

able from: http://www.ieso.ca/imoweb/pubs/consult/windpower/wpsc-20080514-Item7_ IESO_Integration.pdf. [40] L.E. Kinsler, A.R. Frey, A.B. Coppens, and J.V. Sanders. Fundamentals of Acoustics. Wiley and Sons, New York, 1987. [41] L.D. Landau and E.M. Lifshitz. Fluid Mechanics. Pergamon, 1987. [42] G. Leloudas, W.J. Zhu, J.N. Srensen, W.Z. Shen, and S. Hjort. Prediction and reduction of noise from a 2.3mw wind turbine. In The Science of Making Torque from Wind, 75, Copenhagen, Denmark, 2007. Technical University of Denmark, IOP Publishing. [43] Chris Loken, Daniel Gruner, Leslie Groer, Richard Peltier, Neil Bunn, Michael Craig, Teresa Henriques, Jillian Dempsey, Ching-Hsing Yu, Joseph Chen, L. Jonathan Dursi, Jason Chong, Scott Northrup, Jaime Pinto, Neil Knecht, and Ramses van Zon. Scinet: Lessons learned from building a power-efficient top-20 system and data centre. In Journal of Physics: Conference Series 256, High Performance Computing Symposium. IOP Publishing, 2010. [44] Lowson. Assessment and prediction of wind turbine noise. pages 1Â­59, December 1992. Flow Solutions Report 92/19, ETSU W/13/00284/REP. [45] Philip M. Morse and K. Uno Ingard. Theoretical Acoustics. Princeton University Press, 1968. [46] Michael Moser. Engineering acoustics: an introduction to noise control. 2009. Available http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=pubmed&cmd=Retrieve&dopt= from: AbstractPlus&list_uids=2608532719430273464related:uAmgDrBeMyQJ. [47] W Musial and S Butterfield. Future for offshore wind energy in the united states. EnergyOcean Proceedings, June 2004, Palm Beach Florida, USA, pages 1Â­5, 2004. Available http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=pubmed&cmd=Retrieve&dopt= from: AbstractPlus&list_uids=11183622522205337476related:hHcbOm41NJsJ. 216

REFERENCES

REFERENCES

[48] P.A. Nelson and C.L. Morfey. Aerodynamic sound production in low speed flow ducts. Sound and Vibration, 79(2):263Â­289, 1981. Available from: http://www.scopus.com/inward/record.url? eid=2-s2.0-0019634767&partnerID=40&md5=1a3be59732849d0726f88cc7084040a2. [49] T. Nomura, K. Takagi, and S. Sato. Finite element simulation of sound propagation concerning meteorological conditions. International Journal for Numerical Methods in Fluids, 64:1296Â­1318, October 2010. [50] VE Ostashev, DK Wilson, L Liu, DF Aldridge, NP Symons, and D Marlin. Equations for finite-difference, time-domain simulation of sound propagation in moving inhomogeneous media and numerical implementation. Acoustical Society of America, 117:503Â­517, 2005. Available from: http://www.ncbi.nlm.nih.gov/entrez/query.fcgi?db=pubmed&cmd= Retrieve&dopt=AbstractPlus&list_uids=18132585892545145772related:rKtpeMzio_sJ. [51] Robert W. Paterson, Roy K. Amiet, and C. Lee Munch. Isolated airfoil Â­ tip vortex interaction noise. In AIAA 12th Aerospace Sciences Meeting. American Institute of Aeronautics and Astronautics, 1974. [52] JN Pinder. Mechanical noise from wind turbines. Wind Engineering, 16(3):158Â­168, 1992. [53] John M. Prospathopoulos and Spyros G. Voutsinas. Noise propagation issues in wind energy applications. American Society of Mechanical Engineers, 127:234Â­241, May 2005. [54] S.W. Rienstra and A. Hirschberg. An Introduction to Acoustics. Eindhoven University of Technology, 2011. [55] Siemens. Siemens wind turbine swt-2.3-101. Available from: http://www.energy.siemens. com/fi/en/power-generation/renewables/wind-power/wind-turbines/swt-2-3-101.htm# content=Technical%20Specification. [56] Peter J. Skirrow. Sound weighting curves. Feb 2011. Available from: http://en.wikipedia.org/ wiki/File:Acoustic_weighting_curves.svg. [57] John W. Slater. Examining spatial (grid) convergence, 2008. Available from: http://www.grc. nasa.gov/WWW/wind/valid/tutorial/spatconv.html. [58] Eunkok Son, Hyunjung Kim, Hogeon Kim, Wooyoung Choi, and Soogab Lee. Integrated numerical method for the prediction of wind turbine noise and the long range propagation. Current Applied Physics, 10:316Â­319, 2010. [59] S. Wagner, R. Barcei, and G. Guidati. Wind Turbine Noise. Springer, 1996. [60] L. Wang and D.J. Mavriplis. Implicit solution of the unsteady euler equations for highorder accurate discontinuous galerkin discretizations. Computational Physics, 225(2):1994Â­ http://www.scopus.com/inward/record.url?eid=2-s2. 2015, 2007. Available from: 0-34547522173&partnerID=40&md5=03966d47f627d070c6b7f88d30f64a63. 217

REFERENCES

REFERENCES

[61] Tim Weis. Wind power realities fact sheet. Pembina Institute, Dec 2009. Available from: http: //www.pembina.org/pub/1943. [62] J E Ffowcs Williams and L H Hall. Aerodynamic sound generation by turbulent flow in the vicinity of a scattering half plane. Fluid Mechanics, 40(04):505, 1970. Available from: http://www.journals. cambridge.org/abstract_S0022112070000368. [63] DK Wilson and L Liu. Finite-difference, time-domain simulation of sound propagation in a dynamic atmosphere. 2004. Available from: http://www.ncbi.nlm.nih.gov/entrez/query.fcgi? db=pubmed&cmd=Retrieve&dopt=AbstractPlus&list_uids=4630605976239540063related: XweP9Jk3Q0AJ. [64] Wei Jun Zhu, Nicolai Heilskov, Wen Zhong Shen, and Jens Nrkr Srensen. Modeling of aerodynamically generated noise from wind turbines. Solar Energy Engineering, 127:517Â­528, 2005. [65] Wei Jun Zhu, Nrr Srensen, and Wen Zhong Shen. An aerodynamic noise propagation model for wind turbines. Wind Engineering, 29:129Â­143, 2005.

218

Acronyms
CN Crank Nicholson. 11, 13, 26 CV Control Volume. 16 DOF Degrees of Freedom. 15 FDTD Finite-Difference, Time-Domain. 1, 12, 13, 15, 16, 19, 37, 57 FEM Finite Element Method. 1 FFP Fast Fourier Program. 12 FVM Finite Volume Method. 1 GCI Grid Convergence Index. 43 GCS Grid Convergence Study. 39, 40, 42Â­44 HO Hydro One. 3 HPC High Performance Computing. 37 Hz hertz. 9 IESO Independant Electricity System Operator. 3 IMO Independant Electricity Market Operator. 3 ISO International Organization for Standardization. 8Â­11 kHz kilohertz. 9 MW megawatts. 2Â­4 OPA Ontario Power Authority. 3 219

Acronyms OPG Ontario Power Generation. 3 PE parabolic Equation. 11Â­13 PETSc Portable Extensible Toolkit for Scientific Computation. 26, 37 PML Perfectly Matched Layer. 57 RMS Root Mean Square. 30, 45 SIL Sound Intensity Level. 38 SPL Sound Pressure Level. 2, 28, 37, 38, 45Â­47, 49, 53, 54 SWL Sound Power Level. 28, 37, 44, 45

Acronyms

220

