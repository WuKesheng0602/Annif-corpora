\).!i J .u IL. . Lc>6
J'D~?c

ROBOT CALIBRATION BASED ON NONLINEAR FORMULATION FOR MODULAR RECONFIGURABLE ROBOTS (MRRS)
by

YuLin Bachelor of Mechanical Engineering Fuzhou University Fuzhou, P. R. China, 2005

A thesis presented to Ryerson University in partial fulfillment of the requirement for the degree of Master of Applied Science in the Program of Mechanical Engineering.

Toronto, Ontario, Canada, 2008

© Yu Lin, 2008

PROPERTY OF RYERSON UNIVERSITY LIBRARY

ABSTRACT
Robot Calibration Based on Nonlinear Formulation for Modular Reconfigurable Robots (MRRs)

YuLin

A thesis for the degree of Master of Applied Science, 2008 Department of Mechanical Engineering, Ryerson University

Developed in this thesis is a full pose kinematic calibration method for modular reconfigurable robots (MRRs). This method is based on a nonlinear formulation as opposed to the conventional linear method that has a number of critical limitations. By avoiding linearization of the nonlinear robot forward kinematic equations, these nonlinear equations are directly used to identify the robot calibration parameters. A hybrid search method is developed to solve the nonlinear error equations by combining genetic algorithms with Monte Carlo simulations to ensure a global search over the robot workspace with good accuracy. A number of comparisons are made between the proposed method and the conventional linear method, indicating the advantages of the former over the latter by eliminating two critical limitations. The first one is the orthogonality sacrifice that leads to ill-conditioning of the Jacobian used in the linear method. The second one is quadrant sensitivity during the determination of the (Tait) Bryan angles from inverting the rotation matrix.

iv

ACKNOWLEDGMENTS

I am deeply indebted to my supervisor Dr. Jeff Xi, to whom I owe a debt of gratitude for the invaluable support, guidance and kindly encouragement throughout the past two-year study. With his strong academic background and innovative ideas, he has been really helpful to me for solving many difficulties whenever I needed help. It has been my pleasure to work under his supervision, and I look forward to working with him for the Ph.D. study in the future.

I would also like to thank NSERC and Engineering Services Inc. (ESI) for providing adequate research funding for me.

I also wish to thank my lab mates Mr. Richard P. Mohamed and Mr. Daniel Finistauri, who were also working on reconfigurable robots, for their advice when I was in need of an opinion. Furthermore, I would like to thank Mr. Haibin Jia, and Mr. Liang Liao, for their moral support over the past two years.

Finally, I would like to sincerely thank my family and close friends for their encouragement, support and understanding over the school years.

v

TABLE OF CONTENTS
AUTHOR'S DECLARATION ........................................................................................ ii INSTRUCTIONS ON BORROWERS ........................................................................... iii ABSTRACT ..................................................................................................................... iv ACKNOWLEDGMENTS ......................................................................··.....·...................v TABLE OF CONTENTS ..............·................................................................................. vi LIST OF TABLES ....·........................................................................................................ x LIST OF FIGURES ......................................................................................................... xi NOMENCLATURE ........................................................................................................ xii CHAPTER 1 INTRODUCTION .................................................................................... 1 1.1 1.2 1.3 1.4 1.5 Background .......................................................................................................... 1 Modular Reconfigurable Robots (MRRs) .........................................................4 Robot Kinematics ................................................................................................ 7 Problem Formulation .......................................................................................... 8 Outline ofThesis ................................................................................................ 11

CHAPTER 2 LITERATURE REVIEW ...................................................................... 13 2.1 2.2 2.3 Kinematic Modeling for Calibration ............................................................... 13 Computation for Calibration ............................................................................ 17 Measurement for Calibration ...........................................................................20
Noncontact Measurement Technology ....................................................... 20

2.3.1

vi

2.3.2

Contact Measurement Technology ............................................................. 23

2.4

Self-calibration ................................................................................................... 26

CHAPTER 3 KINEMATIC MODELING ..................................................................28 3.1 Position and Orientation ...................................................................................28
Position Vector. ........................................................................................... 29 Rotation Matrix ........................................................................................... 30 Angle-set Representation of a Rotation ...................................................... 32

3.1.1 3.1.2 3.1.3

3.2

Translation and Rotation .................................................................................. 36
General Motion of a Single Rigid Module ................................................. 36 General Motion of Multiple Modules ......................................................... 37

3.2.1 3.2.2

3.3

Three-point Target Measurements .................................................................. 40

CHAPTER 4 LINEAR FORMULATION .................................................................. 43 4.1 Error Model ....................................................................................................... 43
Error Model with Full Pose Measurement.. ................................................ 45 Error Model with Position Measurement.. .................................................. 47

4.1.1 4.1.2

4.2

Pose Error Calculations .................................................................................... 47
Differential Transformation ........................................................................ 47 Inverse of a Rotation Matrix ....................................................................... 50

4.2.1 4.2.2

4.3

Computational Methods .................................. ,................................................ 52
Least Squares Method ................................................................................. 52

4.3.1

4.3.1.1 Underdetermined ................................... ,............................................... 52

VII

4.3.1.2 Over-determined .................................................................................... 53 4.3.2 4.3.3 Kinematic Model Error Compensation ....................................................... 53 Calibration Algorithm ................................................................................. 55

CHAPTER 5 NONLINEAR FORMULATION .........................................................59 5.1
5.2

Nonlinear Formulation .....................................................................................59
Genetic Algorithm ............................................................................................. 60

5.2.1 5.2.2 5.2.3
5.3 5.4

Fitness Function .......................................................................................... 61 Initial Population ......................................................................................... 62 Individual Selection and Population Generations ....................................... 63

Calibration Algorithm ....................................................................................... 64 Monte Carlo Simulation .................................................................................... 66

CHAPTER 6 SIMULATIONS AND COMPARISONS .............................................68
6.1 6.2 6.3 Linear Formulation ........................................................................................... 72 Nonlinear Formulation ..................................................................................... 75 Monte Carlo Simulation .................................................................................... 81

CHAPTER 7 CALIBRATION CONSIDERING RECONFIGURATION ..............84
7.1 7.2 7.3 Snap Point ..........................................................................................................84 Path Matrix ........................................................................................................ 85 Simulations ......................................................................................................... 88

7.4

Self-calibration Formulation for MRRs ..........................................................89

CHAPTER 8 CONCLUSIONS AND FUTURE WORK ...........................................92

Vlll

8.1 8.2
8.3

Conclusions ........................................................................................................ 92 Contributions ..................................................................................................... 92
Future Work ...................................................................................................... 93

APPENDIX A (TAIT) BRYAN ANGLE (PITCH, ROLL, YAW, PRY) [18] ............ 95
REFERENCE ................................................................................................................... 96

ix

LIST OF TABLES
Table 3.1: PRY angles inversed from a rotation matrix ................................................... 36 Table 3.3: Rm and bm of different kinematic pairs [18] .................................................... 40 Table 4.1: Four categories of calibration simulations ...................................................... 57 Table 6.1: Nominal link kinematic parameters for MRR-1.. ............................................ 69 Table 6.2: Typical tolerance limits for various manufacturing processes [65] ................. 71 Table 6.3: Assumed geometric parameter errors (m or rad) ............................................. 71 Table 6.4: MRR-1 kinematic parameters before and after calibration ............................. 74 Table 6.5: Identified geometric parameter errors (m or rad) ............................................ 74 Table 6.6: End-effector poses before and after calibration ............................................... 74 Table 6.7: MRR-1 kinematic parameters before and after calibration ............................. 78 Table 6.8: End-effector poses before and after calibration ............................................... 78 Table 6.9: Geometric parameter errors from the final best fit individual.. ....................... 78 Table 6.10: The stable mean value of all best fit individual from GA runs ..................... 82

X

LIST OF FIGURES
Figure 1.1: Modular and reconfigurable robot (MRR-1) ................................................... 5 Figure 1.2: Actual (measured) and nominal (calculated) poses ......................................... 9 Figure 1.3: Nominal pose after calibration ...................................................................... 10 Figure 2.1: Link frames attached and four DH parameters [30]. ..................................... 14 Figure 2.2: (a) Moving camera setup [38]; (b) Stationary camera setup [54] .................. 22 Figure 2.3: Tooling-ball apparatus attached to a robot and CMM [37]. .......................... 24 Figure 2.4: The telescopic ball-bar (LVDT) measuring system [3]. ................................ 25 Figure 2.6: A laser pointer tool carried by Staubli RX-130 robot [36] ............................ 27 Figure 3.1: Multiple modules system for a MRR ............................................................ 29 Figure 3.2: Position vector p [ 18]. ................................................................................... 30 Figure 3.4: General motion of a single module [18]. ....................................................... 37 Figure 3.5: Vector method for a multi-module system [18] ............................................. 38 Figure 3.6: Three-point moving target. ............................................................................ 41 Figure 3.7: Transformation determinations using the three-point position data [55] ...... 42 Figure 4.1: Conventional calibration algorithm (linear formulation) .............................. 56 Figure 5.1: Nonlinear calibration using a genetic algorithm ........................................... 65 Figure 5.2: Three loops of simulation .............................................................................. 67 Figure 6.1: Graphical user interface (GUI) for robot kinematic calibration .................... 68 Figure 6.2: MRR-1 [8] and SolidWorks model... ............................................................. 69 Figure 6.3: Kinematic parameter input panels in the GUI. .............................................. 70 Figure 6.4: Robot configurations before (red lines) and after (blue) movements ............ 70 Figure 6.5: Calibration using Linear Formulation panel.. ................................................ 72 Figure 6.6: Partial pose (position) calibration outputs ..................................................... 73 Figure 6.7: Non-convergent results for the full-pose calibration ..................................... 75 Figure 6.8: Nonlinear Formulation using Genetic Algorithm panel in the GUI. ............. 76 Figure 6.9: (a) Best and Mean fitness; (b) Best fitness .................................................... 77 Figure 6.10: Better performance with large populations and generations ....................... 80 Figure 6.11: Standard deviations of mean values of ~g from GA. .................................. 82 Figure 6.12: 16 calibrated parameters in 8 random configurations ................................. 83 Figure 6.13: Revolute joint 1 and 2 random movements for 8 configurations ................ 83 Figure 6.14: Translational displacements of the prismatic joint 3 for 8 configurations .. 83 Figure 7.1: Snap point between two adjacent modules .................................................... 84 Figure 7.2: (a) Original connection; (b) Reconfigured connection .................................. 86 Figure 7.3: Simulation when reconfiguration .................................................................. 88 Figure 7.4: Robot configuration before and after reconfiguration ................................... 88 Figure 7.5: GA results for MRR-1 after reconfiguration ................................................. 89
XI

NOMENCLATURE

Symbol
X,

Definition
x, y or z coordinate position pitch, roll, and yaw angles position vectors rotation matrix body vectors local body vectors motion parameters (s and 8) linear translational displacement rotation angles identity matrix Jacobian matrix geometry of a robot (bs and Rs) end-effector pose of a robot robot kinematic parameters error end-effector pose errors function of forward kinematics distance

Units
m rad (or degree if specified) m m m m rad (or degree if specified)

p,
p R b b'

Y, Z r, s

q s 0
I J g X L1g L1X

m and rad m and rad

f
d

m

Subscript
i n ICSU

s
m j

tip
min

max

Definition ith module total number of modules Initial configuration setup Static Motion Joint Variables at the tip of module Minimum Maximum

Throughout the thesis, bold lower case indicates vector; bold upper case indicates matrix; and regular indicates scalar.

xii

CHAPTER!
1.1 Background

INTRODUCTION

In general, accuracy is defined by repeatability and bias [I]. Lack of repeatability is due to random error and quantified by the variance of a number of measurements. Bias is a systematic error and determined by the mean value [2]. Sometimes, they are distinguished as repeatability and absolute accuracy. Repeatability of a robot is the precision with which its end-effector achieves a particular pose (position and orientation) under repeated commands by the same set of joint variables, while "absolute accuracy" is the closeness to which the robot's actual pose matches the pose predicted by its controller [3].

A high repeatability is of prime importance for a variety of robot applications such as pick and place, spray painting, and welding. On the other hand, tasks involving off-line planning (OLP) depend on the absolute accuracy of the robot [3], especially for high precision applications, such as robotic surgery. In reality, while the repeatability can reach an order ofO.l mm for the majority oftoday's robots, the absolute positioning accuracy is on the order of I mm or even worse, leading to the accuracy/repeatability ratio in the range from 3 to 20 [4]. Low accuracy of a robot is currently regarded as one of major obstacles for a wider range of applications.
1

While it is difficult to compensate for the random error, compensation for the systematic error can be done effectively by means of calibration [2]. Robot calibration has been explored and investigated since the 1980s. It evolved into a mainstream of robotics research area in the 1990's. At that time, the robot accuracy issue became crucial with many robots and off-line programming (OLP) software packages introduced into the world market. Calibration is even more important for a modular reconfigurable robot (MRR) since after each reconfiguration by re-assembling the modules, the MRR will lose its accuracy. Although variations in the kinematic model mostly arise from imprecision in manufacturing processes, the direct improvement of manufacturing processes is costly [5]. This is another reason to calibrate the robot after it is built.

Basically, a robot calibration technique is the process of improving robot positioning and orientation accuracy by identifying and then modifying the geometric parameters in robotic kinematic models rather than changing or altering the mechanical structures or redesigning the robot [6].

Since the sources of errors vary from one robot design to another, calibration procedures can vary in their scope and complexity. For example, some robot calibration procedures consider only the joint variables while others may involve changes in the robot kinematic model. Roth et al. [6] classified calibration into three levels: joint level, kinematic model

2

level, and dynamic model level. The goal of joint level calibration is to determine the correct relationship between the signals produced by joint displacement transducers and actual joint displacements. This usually involves calibration of the kinematics of the drives and the joint sensors. The kinematic model level calibration is the entire robot kinematic model calibration, and its purpose is to determine the correct geometric parameters of the robot. The dynamic model level calibration is non-geometric calibration, and its concern is about the effects such as joint compliance, friction and clearances, as well as link compliance.

The research reported in this thesis addresses the problem of kinematic model calibration considering both position and orientation. The purpose is the determination of an accurate relationship between the joint movements and the pose of the robot's end-effector. The assumption is that the robot is composed of rigid links and joints, ignoring joint backlash and servo errors.

In general, a calibration procedure can be divided into four steps: modeling, measurement, identification and implementation (or correction) [6]. Modeling refers to the choice of a functional relationship between the robot parameters and the pose of the robot's end-effector. Measurement is to collect the information about the inputs and the outputs. Identification is the determination of the errors that could affect calibration.

3

Implementation is to use the corrected model for robot kinematic control.

Mathematically, robot calibration can be considered as a nonlinear optimization problem, which can be solved in two different ways, linear and nonlinear formulations. The linear method is to linearize the nonlinear kinematic equations, which leads to a Jacobian matrix by ignoring higher order items. The Jacobian matrix, also called the mapping matrix, establishes a linear relationship between the errors of the kinematic parameters and the errors of the end-effector's pose. The main disadvantage of the linear approach is the singularity issue in inverting the Jacobian matrix. The nonlinear method, on the other hand, is to solve the nonlinear equations directly without linearization. Because the Jacobian matrix is not involved, the singularity issue can be avoided. In this thesis, both methods are studied and compared.

1.2

Modular Reconfigurable Robots (MRRs)

Traditional robots are fixed structure robots, meaning that a certain type of robot is built for a certain type of task. Reconfigurable robots are designed such that their structures can be changed to perform a number of different tasks that normally require a number of different types of traditional robots. A modular reconfigurable robot (MRR) is a reconfigurable robot that is built based on a number of modules. These modules can be rearranged through disconnecting and reconnecting in different ways to form a new

4

configuration enabling new functionalities. Figure 1.1 shows an example of a MRR made by a company called Engineering Service Inc. [8].

(a)

(b)

(c)

Figure 1.1: (a) Modular and reconfigurable robot (MRR-1);

(b) 2 DOF module (MRS) and (c) Rotary module (MRJ); Photograph courtesy of Engineering Service Inc. [8].

Modular reconfigurable robots (MRRs) offer three main advantages over the traditional fixed-structure robots: versatility, simplicity, and low cost [9]. Firstly, applications in which MRRs surpass purpose-specialized robots include those in which versatility is critical, such as those requiring a variety of robots to perform multiple tasks of a similar nature. While traditional robots are only capable of performing a particular task for which they have been designed, MRRs offer the advantage of employing a single robot with the structural adaptability to perform multiple tasks based on demands by means of reconfiguration. Employing similar modules in a robotic arrangement leads to simplicity in design when compared with a traditional robot composed of various customized
5

components. Secondly, except for offering multi-purposeful tasks, MRRs enhance simplicity in the method of reconfiguration by employing a common locking mechanism for all joins and modules. Lastly, in addition to offering simplicity in design and versatility, modularity significantly reduces the design and manufacturing costs [ 10].

There are three categories of reconfigurable robots: self-assembly, self-configuring and manual-configuring [11]. Self-assembly robots are the robots with the highest level of reconfigurability because they are able to detach from and attach into a robotic system automatically. For example, the National Mechanical Engineering Laboratory in Japan developed a self-assembly robotic system that uses electro-magnetic disks as the basic units that can attract and repel each other through computer control for automatic reconfiguration [12]. Self-configuring robots cannot perform self-assembly. However, they can fulfill reconfiguration after a robotic system is assembled with some form of manual assistance. For example, robotic cubes were developed in the United Kingdom with an embedded active driving mechanism [13]. Once attached manually, these cubes can slide on each other's faces for reconfiguration. Since the cubes are made in different sizes and can be combined together, the robot is called the fractal shape-changing robot. The manual-configuring types are in fact the modular robots, as shown in Figure 1.1. They can only be reconfigured with some form of manual assistance. The modular units are built with embedded controllers, and the host computer has the capability to quickly 6

recognize new configurations and then achieve the objective of system control. This research work includes the studies at Stanford [14] and Carnegie Mellon University [15].

1.3

Robot Kinematics

To address the problem of robot calibration, the basis is the robot forward kinematics.

A significant number of papers and monographs have been published on different kinematic modeling approaches for calibration [5] [16] [17] [18] [19] [20] [21] [22]. A satisfactory kinematic model should exhibit three qualities: completeness, equivalence, and proportionality [19]. According to [18], the end effector's pose of a robot can be defined by a nonlinear function as follows

X=f(q, g), qi=[Oi

sJ, i=1, ... ,n

(1.1)

where q is the set of joint variables including rotational angles 9i for revolute joints and translational displacements
Si

for prismatic joints, with i ranging from 1 to n, (n is the

total number of joints); and g is the set of geometric parameters of the robot.

The end-effector's pose can be further detailed as the position vector and orientation matrix, described in the global reference frame as [ 18],
n

Pn+I=LRoib:'
i=l
n

(1.2)

Ron =flR(i-I)i'
i=l

(1.3)

7

where b' is the body vector in the local coordinates, which is transformed to the global first and then summed to obtain the position of the end-effector in Equation (1.2);
~i-I)i

represents the rotation matrix between two adjacent bodies, which is sequentially multiplied together to determine the orientation of the end-effector in Equation (1.3).

Since only three of the nine elements of the rotation matrix are independent, the robot orientation is usually specified with three independent parameters. The common approach is to use three angles, such as Euler angles and the (Tait) Bryan angles (often called pitch, roll, and yaw, (PRY)). The angle-axis representation has also been introduced by using a unit vector parallel to the axis of rotation matrix in Equation (1.3) and an angle rotating about the axis. However, this invariant vector may correspond to two possible rotation matrices [21] [23]. To solve this ambiguity, Angeles [23] modified this angle-axis representation and showed that the modified one has a linearity relation with the corresponding rotation matrix, hence leading to simple expressions of the Jacobian matrix.

1.4

Problem Formulation

Due to a number of error sources, including manufacturing, assembly, deflections, measurements, and clearances [24], the robot forward kinematic model (Equation (1.1 )) will not accurately represent the real robot system. In other words, the manipulator will

8

not be able to locate the end-effector at the desired pose Xo calculated from the nominal model given in Equation ( 1.1 ). The actual pose Xm is different, as illustrated in Figure 1.2. The difference between the two is the end-effector pose error. In order to determine the end-effector pose error AX, the actual pose Xm usually needs to be measured after moving the robot by joint variables q 0 · It is given as (1.4)

Error sources

qo
Joint Variables

Xm
Actual (Measured) Pose

qo
Joint Variables

l-..JI'·· ~·.·····

Xo Nominal (Calculated) Pose

Figure 1.2: Actual (measured) and nominal (calculated) poses.

Apparently, the basic consideration is how to eliminate or compensate the pose error in Equation (1.4) in order to reach the desired pose. As one of the solutions, calibration technique aims at identifying the geometric errors Ag of the robot, and then make a correction in the nominal model, i.e., Xo= f (q 0 , g0 +Ag). As a result, the nominal pose of
9

the end effector will be getting closer to the measured ones under the corrected model, i.e., Xo-? Xm, as shown in the Figure 1.3. A well calibrated robot will be able to reach any position within its workspace at the required accuracy.

Qo

Xo-? Xm
Nominal (Calculated) Pose

Joint Variables

Figure 1.3: Nominal pose after calibration.

As an alternative approach, we could adjust joint movements by adding L\q to the original joint variables, i.e.,

(1.5)
This is called compensation, rather than the calibration focused on in this thesis. The details of this approach are outside the scope of this thesis.

As mentioned above, two methodologies are available to determine L\g, namely, linear and nonlinear formulations [25]. The linear least squares method is used for the linearized error model as given below:

L\X = J L\g.

(1.6)

From equation (1.6), L\g can be solved for by a proper linear least-square method depending on the dimensions of the Jacobian matrix. This process is usually carried out

10

iteratively until the tolerance of

~X

becomes less than a given threshold. The second

approach is the nonlinear formulation given as below:

//

(1.7)

Two types of optimization methods can be applied to solve equation (1.7): gradient-based methods and direct-search methods. For gradient-based methods, the identification Jacobian is again required in a manner that differs from that of the linear least-square algorithm [26]. The Levenberg-Marquardt algorithm is one of the popular methods and works surprisingly well even for large residual problems, although in such cases the rate of convergence may be quite slow [17]. This technique is designed to overcome problems related to singularity of the matrix JTJ by adding a time varying nonnegative scalar coefficient, Jl, leading to the matrix JTJ + 11 I. More details can be found in Scales [27]. Alternatively, equation (1.7) can be minimized using direct-search methods, such as Simplex search, Hooke-Jeeves pattern search, Powell's conjugate-direction method [28], genetic algorithm [61] [62] and neural networks [63]. Convergence of all direct search algorithms is generally very slow, but no Jacobians are needed. The linear method was the only possible way to conduct the robot calibration before, and now the nonlinear method becomes possible due to the advent of powerful computers.

1.5

Outline of Thesis

The remaining thesis is organized as follows.
11

Chapter 2 provides a literature review on previous researches on the robot calibration, including modeling, measurement, identification, and correction.

Chapter 3 presents a kinematic modeling method for MRRs. Pose analysis is introduced using six-parameter representations.

Chapter 4 discusses the conventional linear formulation for robot calibration. Error models are derived from linearization of the forward kinematic model in two schemes, depending on how the orientation of an end-effector is measured.

Chapter 5 investigates the nonlinear formulation without linearizing the kinematic model. A genetic algorithm (GA) is applied to solve this problem. Furthermore, Monte Carlo simulations are conducted to take into consideration of the random error by running GA.

Chapter 6 provides the simulations and comparisons between the linear and nonlinear formulation of calibration.

Chapter 7 applies the proposed calibration methods to MRR robots in consideration of reconfiguration.

Chapter 8 provides the summary of conclusions, contributions, and future work.

12

CHAPTER2

LITERATURE REVIEW

This chapter describes a literature review on previous researches that have been done on robot kinematic calibration, including kinematic modeling, measurement, identification, and correction.

2.1

Kinematic Modeling for Calibration

A significant number of methods have been proposed for modeling robot kinematics for the purpose of calibration since the 1980s. For serial robots, joints are either revolute or prismatic. Three important qualities that a satisfactory kinematic model should exhibit are completeness, equivalence, and proportionality [19]. First, the model should contain a sufficient number of parameters to completely satisfy the motion of the robot. Second, there must exist a functional relationship between any two acceptable models, i.e., models should be equivalent in a functional sense. Finally, small changes in the robot geometry should reflect small variations in the model parameters.

The most common method for robot kinematic representation is the use of four Denavit and Hartenberg parameters [29], including link length ai, joint twist ai, link offsets di, and joint offsets 8i, as shown in Figure 2.1.

13

a~··.

., z

\~~Ji
J
'

\\

x·I

Zj.JL
i
... ···························

Figure 2.1: Link frames attached and four DH parameters [30].

Paul [16] demonstrated the use of the Denavit-Hartenberg technique for modeling a serial link manipulator. For each link, a coordinate frame is attached at the joint, and then related consecutively by the four parameters using a homogeneous transformation matrix. All these consecutive link transformation matrices are multiplied to produce a total transformation matrix that relates the last local coordinate system attached to the end effector to the base global coordinate system. The resulting matrix is a nonlinear function of the joint variables (8i) and three link parameters (ai ai di) that describe the geometry of the manipulator. Furthermore, the Denavit-Hartenberg model has been used for the calibration problem by many investigators [5]. For example, Wu [31] [32] used it to examine robots with small variations in their kinematic arrangement.

However, the Denavit-Hartenberg representation was found to exhibit ambiguity when two successive axes are parallel as pointed out by Mooring [33] and Hayati [22]. The link 14

length a;, representing the length of common normal between two consecutive joint axes, varies wildly when two adjacent joint axes deviate slightly from nominally parallel configuration.

For this reason, the Denavit-Hartenberg model was modified. In the nearly-parallel axes case, the parameters are treated to vary in proportion to the degree of misalignment, as proposed by Hsu and Everett [34]. Ibarra and Perreira [35] modified the DenavitHartenberg based transformation matrix by a differential screw matrix for small misalignments. Hayati [22] pointed out the singularity of the Denavit-Hartenberg representation, and introduced an additional rotation fJ in the y-direction in the DH link transformation to describe a misalignment of two consecutive parallel axes. A number of papers subsequently used this modified Denavit-Hartenberg representation as reviewed in Hollerbach [5]. The most recent application can be found in Gatla et al. [36] and Lightca et al. [37]. Gada et al. [36] combined Craig's modified DH [21] and Hayati's (HR) [22] together to build either DH or HR with the four-parameter depending on whether the neighboring joint axes are parallel. This model, however, requires two sets of four link error parameters according to the geometry of link, which makes the modeling task unnecessarily complex. Furthermore, Hayati's model does not cover the transformation from the last link to the tool coordinate frame which in general requires a separate treatment [38].
15

Although the description of the robot kinematics needs at most four parameters per joint, this minimal set of parameters displays proportionality only when the selection of the joint coordinate frames is tailored to a particular manipulator [20]. Thus, a priori knowledge of the nominal manipulator geometry is required for any algorithm that uses such a mode. On the other hand, it is possible to construct a six-parameter model that does not depend on the link geometry and will always display proportionality. As a result, a number of papers have abandoned the Denavit-Hartenberg parameters entirely and treated the general case of two coordinate systems related by six parameters [5]. Three parameters present the coordinate origin displacements, and three parameters for relative coordinate system orientation. Papers differ in terms of the representation of orientation; some use Euler angles, introduced in Chapter 3, and others use variations of the Euler vector, namely, associated rotation about an equivalent vector, detailed in Craig [21].

Mooring [33] also pointed out the problem with the Denavit-Hartenberg representation at the same time as Hayati [22], but proposed a six-parameter representation using Euler vectors. An estimation procedure was outlined but not implemented, in which single joints were moved to two positions. The position and orientation of the gripper were measured at these two positions, and the six parameters for each joint were determined by a direct solution. Mooring and Tang [39] modified the procedure to use three points in a fixture, avoiding the need to determine the gripper position and orientation by external
16

sensing. On the other hand, six-parameters with Euler angles were used [40], and both geometric and non-geometric parameters were modeled. Chen et al. [41] also employed six-parameter transformation with Euler angles. Later, Chen and Chao [42] extended this work to include non-geometric models for gravitational joint deflection and backlash. Stone et al. [43] used a general-purpose "S-model" to model kinematic errors using six parameters per link and then convert them to the Denavit and Harten berg parameters.

2.2

Computation for Calibration

As mentioned before, identification of parameters of the robot kinematic model is generally considered as a nonlinear optimization problem, which can be approached in two ways, namely linear or nonlinear [25]. Many investigators linearized the kinematic equations leading to a linear error model and then applied an iterative least-square estimation procedure, while others applied other nonlinear estimation procedures directly to the nonlinear kinematic equations.

A recursive least squares procedure was employed by Chen et al. [41] to the linearized equations. Chen and Chao [42] suggested linearization as a means for indentifying dependent parameters. At the same time, Chao and Yang [44] applied the nonlinear Levenberg-Marquardt procedure to the same data used by Chao and Chao [42], and achieved identical results.

17

An interesting insight of Mooring and Tang's work [39] was to estimate orientation parameters before position parameters. While the former leads to a nonlinear estimation problem, the latter can then be treated as a linear estimation problem. For the orientation errors, the sum of squares of Euler angle differences is minimized by a finite-difference Levenberg-Marquardt algorithm, which is commonly employed for nonlinear estimation problems. The estimated orientation parameters are then incorporated to apply direct linear estimation to the position parameters. However, this method did not consider the effect of the angular parameter errors on position errors. In other words, it ignored the coupling terms between orientation and position errors in the Jacobian matrix and derived two simpler and separable least squares problems. Simulations indicate better results could be obtained by including the full pose Jacobian of both orientation and position [5].

Lightcap et al. [37] proposed a two-level Levenberg-Marquardt nonlinear least-square optimization algorithm for the calibration of geometric and flexibility parameters in a serial manipulator without the computation of the generalized Jacobian matrix. Link parameters were determined through an outer optimization loop, while robot coordinate system parameters were determined in an inner loop.

Pathre and Driels [25] conducted simulations that have shown that the linear method is four to eight times faster than the nonlinear method. However, nonlinear method, for

18

example the Levenberg-Marquardt algorithm, is much more robust than linear method especially for large parameters.

One of the important problems in calibration is the observation strategy that refers to the selection of robot configurations and the number of observations to be made during the calibration experiment. The selection of measurement configurations during robot calibration plays an important role in determining the accuracy and speed of convergence of the least-square identification algorithms [17]. The number of necessary observations can be reduced if the measurements are performed at robot configurations in which the error model is the most sensitive to changes in model parameters, e.g., where it is the least sensitive to unmodeled error sources [20]. Simulation experiments can significantly help in evaluation of the observation strategy [25]. This strategy may be modified based on the results of simulations if necessary. Two groups of references provide the literature background for the observation strategy. The first approach [45] focuses on the familiar numerical analysis concept of "condition number" of the Jacobian. The second one [46] [47] adopts an observability index as a performance measure. Driels and Pathre [45] have shown that the condition number of the Jacobian is related to the observability index proposed by Menq and Borm [46]. Increase in the observability index implies the reduction ofthe condition number.

19

2.3

Measurement for Calibration

Measurement is an essential part of the calibration procedure. It is conducted by measuring the actual robot end effector's position and orientation at given set of joint displacements. A set of measurement data is obtained by moving the robot to one location within the workspace, recording joint displacements, and then using an external measuring system to determine the robot's position and/or orientation. The robot is then moved to another location to repeat the process and continue till sufficient data is acquired.

There are two aspects of the measurement process that need to be given careful consideration. The first is what measurement system should be used, and the second is how to plan the observation strategy correctly. There are only a few systems that have the necessary precision to make adequate pose or partial pose measurements. Each has its own characteristics such as precision, speed and ease of use, level of measurement noise, cost, and the amount of information that can be obtained from each robot pose. In general, the measurement process is time consuming, laborious, and prone to human error. Textbooks, such as the one by Doebelin [48], provide a much more exhaustive treatment of this field.

2.3.1

Noncontact Measurement Technology

It is desirable that the measuring instrumentation facilitates non-contact sensing, so that 20

the influence of the measurement to the robot performance characteristics is eliminated [20]. The most popular technique of the non-contact measurement is based on utilizing a system of theodolites (Duelen and Schroer [49]; Judd and Knasinski [50]; Caenen and Angue [51]), which facilitates measurements in a wide range and with high accuracy on the order of 0.05 mm [52]. By combining the theodolites with a low-resolution vision system for automatic tracking, focusing and centering, it is possible to build a highquality system for automatic calibration measurements [53].

Researchers have also been investigating camera measurement, which basically has two different setups: a moving camera approach (hand-mounted cameras) and a stationary camera setup. In the moving camera approach, one or more cameras are mounted on the end-effector of a robot and several targets or fixtures are fixed in the workspace. In the stationary setup, cameras are fixed and the fixture or targets are mounted on the robot end-effector.

Generally speaking, high resolution and large field-of-view may be two conflicting requirements [38]. The stationary camera setup suffers from this conflict and has to sacrifice measurement accuracy in order to have a large field-of-view, or the cost of system may increase dramatically by using higher resolution camera. The moving camera approach solves this conflict by using a precise fixture and a stereo camera system. It

21

means that the robot can move to a wide range of configurations and still has a calibration which is as accurate as desired.

Zhuang [38] applied a stereo hand-eye system consisting of a pair of CCD cameras mounted on the robot's end-effector, a camera calibration board, a robot calibration fixture and a PC-based image processing system (Figure 2.2a). Without using expensive or labor-intensive equipment, such as theodolites, laser tracking system, high-resolution opto-camera systems etc., Zhuang [38] stated that the mobile camera system provides low-cost, efficient and fully automated features which are suitable for academic research as well as industrial applications. On the other side, An et al. [54] conducted calibration experiments by using systems of immobile cameras equipped with optoelectronic detectors, and additional LED diodes as targets fixed at the robot's end-effector (Figure 2.2b). This technique may also yield satisfactory results, but in a significantly smaller workspace.

Figure 2.2: (a) Moving camera setup [38]; (b) Stationary camera setup [54].

22

A stationary camera setup provides a non-invasive method, where the camera is often placed outside the robot workspace and needs not be removed after calibration. However, it is necessarily invasive for the moving camera approach, where the camera has to be removed after calibration. Another disadvantage for the moving camera approach is that it only performs local measurements, whereas the global information on the robot endeffector pose is provided through a stationary calibration fixture. For the stationary camera setup, there is no need to identify the transformation relating the camera frame tq the end-effector frame.

2.3.2

Contact Measurement Technology

Contact measurements vary from coordinate measuring machines (CMM), dial indicator, linear-variable differential transformer or LVDT, precisely located targets with force sensors, to a simple ruler etc. A CMM assures extremely high accuracy on the order of 0.01 mm, compared with the other less accurate but less expensive contact measuring techniques.

The three-point method has been utilized commonly in various measuring systems in the past, such as Mooring et al. [17], Lightcap et al. [37], Goswami et al. [3], and Xi et al. [55]. An orientation change can be determined from the initial and final three-point positions, as detailed in Chapter 3.

23

Lightcap et al. [37] used a CMM to measure the locations of three tooling-ball apparatus attached to PA 10-6CE robot (Figure 2.3), to determine the transformation between the CMM coordinate system and a user-defined tooling ball coordinate system. External loads were lowered onto the weight rack and transmitted through the end-effector of the robot directly to avoid the deflection in the rods.

~,

......

Weight Rack

Tooling Balls

Measured
byCMM

Figure 2.3: Tooling-ball apparatus attached to a robot and CMM [37].

Goswami et al. [3] created a telescopic ball-bar measurement (Figure 2.4) for the calibration of PUMA 560 using the Stewart platform analogy. The ball-bar system consists of a single LVDT, which is connected between one steel sphere attached to the robot endpoint and a magnetic chuck mounted on the table. Imagine that the robot endpoint triangle (with three steel spheres) and the base triangle (with three magnetic chucks) are interconnected through six ball-bars, which presents the Stewart platform geometry.
24

Figure 2.4: The telescopic ball-bar (LVDT) measuring system [3].

Mooring et al. [ 17] proposed a three-point moving target and a LVDT measuring fixture which is mounted accurately in the workspace of a robot. A set of three spheres whose relative positions are already known, can be inserted in an array of short-range displacement transducers (Figure 2.5). In this case, these transducers are LVDTs but capacitance probes and dial indicators have also been reported.

Figure 2.5: Three-point moving target and measurement (LVDT) fixture [17].

25

2.4

Self-calibration

Without using external measuring devices introduced in the previous section, selfcalibration methods depend on internal measurements, such as joint angle measurements. Self-calibration is more desirable or practical on a manufacturing floor or in a production line where external measurements are expensive and difficult to implement.

The existing techniques of serial robot calibration can be classified into open-loop and closed-loop approaches [36]. Open-loop methods involve measuring the end-effector pose, which requires measuring equipments, such as theodolites, ball-bar, CMMs, laser tracking system, cameras, etc., which can be found in the last section. On the other hand, closed-loop methods use the internal joint angle measurements already in the robot without external measurement devices, and therefore, can be considered self-calibrating. Usually, these methods impose some constraints on the end-effector, and the joint readings alone are used to calibrate the robot using kinematic closed-loop equations.

Some researchers in the past have applied linear constraints on the end-effector positions allowing the end effector to slide along a line. For example, Neqman et al. [56] used a laser line. Ikis et al. [57] and Zhuang et al. [58] imposed plane constraints on the endeffector positions. However, it may be problematic to use a plane constraint since it is difficult to assure that the end-effector is exactly on the surface.

26

One of recent proposed close-loop methods is the "virtual closed kinematic chain" by Gatla et al. [36], which did not require any physical constraints used in the previous closed-loop methods. A laser pointer tool was applied on the end-effector to aim at a fixed location on a distant object (Figure 2.6), and only joint readings were used to calibrate the robot. The laser tool on the robot acts as a virtual telescopic (prismatic) link giving the robot 7 DOFs, the seventh joint being the length of the laser line from the end effector to the projected laser point on an object. Thus, aiming the laser pointer at a fixed point creates a virtual closed kinematic chain. The main advantage of this method is that the distant laser point is very sensitive to joint values, which facilitates acquiring more accurate joint values for the calibration.

Figure 2.6: A laser pointer tool carried by Staubli RX-130 robot [36].

27

CHAPTER3

KINEMATIC MODELING

This chapter presents the forward kinematic modeling of a modular reconfigurable robot with rigid modules. In an error-model-based kinematic calibration process, the selection of a proper kinematic model is one of the keys to the success of a calibration task. In this chapter, six-parameter representations, rather than the Denavit-Hartenberg parameters, are used for the robot kinematic modeling.

The main topic of the robot forward kinematics is to compute the position and orientation of the end-effector relative to the base coordinate as a function of the joint variables. As shown in Figure 3.1, an MRR system under study can be considered as a multiple module system. The pose of each module is represented using six parameters, three for position and three for orientation. The position vector and rotation matrix are first introduced in this chapter and then the general motion (translation and rotation) of a single module and a multi-module system are discussed along with the three-point measurement methods.

3.1

Position and Orientation

In this section, the position vector and rotation matrix are introduced to represent the pose of each module.

28

Module n Module Module.
l

n-1

Jrt-(_ _·__,·

Module 2 Module Joint
1 1

·····d

n.······ G=.:===, ·.·::::;::;;~·it' Joint n
Joint i

··· f: Joint
n-1

Tip

Base frame

Figure 3.1: Multiple modules system for a MRR. 3.1.1 Position Vector

The position of a point in space is represented with respect to a coordinate frame using a vector. In general, the vector components in the Cartesian coordinate are expressed as (3.1) A position vector, as shown in Figure 3.2, can be expressed in terms of the frame axes in linear combination as

p=p1e1+ p1et+ p~e;·
or where E
=

'k ( .

(3.2a) (3.2b) [x, y, z], and x, y, z are the

p=Ep

[e 1,

ez, e 3]. In the Cartesian coordinate system, E =

29

unit vectors along x, y, and z axes relatively, that is, x = [I, 0,

of, y = [0, I, O]T, z = [0, 0,

Figure 3.2: Position vector p [18]. 3.1.2 Rotation Matrix

A rotation matrix represents a linear transformation between two coordinate frames. In
Figure 3.2, position vectors can be expressed either in frame {e 1, e2, e3 } (Equation 3.2a)

(3.3a) or

p=E'p' .

(3.3b)

Since Equations (3.2) and (3.3) represent the same position vector, so

E'p'=Ep
It leads to

(3.4)

30

p=Rp'
where R is the rotation matrix given as

(3.5)

(3.6)

Since ei is orthogonal to ej, then Ci'Cj = Oij = I when i=j; erej = 0 when i:t:j. Hence, E is orthogonal, and K 1 = E T.

R is in fact defined by the dot product of two unit vectors, i.e., the direction cosine. It is

also called the tensor product, defined as

e1 ·e\ [
e3 ·e I

el ·e'2

R=(E®E')= e 2 ·e:1 e2 ·e'2
e3 ·e'2

e2 ·e 3 e3 ·e'3

·<']

(3.7)

Reversing the order of Equation (3.4), Equation (3.5) becomes

p' = R'p
where R'=E'T·E Obviously

(3.8)

(3.9)

(3.10) Hence, R is orthogonal, and such that all columns are mutually orthogonal and have unit magnitude. In fact, it is proper orthogonal, meaning det(R) = I.

It is clear that the nine elements of a rotation matrix are not all independent.
31

Six

dependencies or constraints between the elements can be easily found from a given rotation matrix, R

= [X Y ZJ : IXI=I IYI=1 jzj=1 X·Y=O X·Z=O Y·Z=O
(3.11a)

(3.11 b)

As a result, three independent parameters representation is developed in the following section in order to express the rotation matrix conveniently, using the angle-set convention.

3.1.3

Angle-set Representation of a Rotation

There are basically two methods to describe the orientation of a frame relative to a reference frame by angle-set conventions. According to Craig [21], one is Euler angles, and one is fixed angles. In the former representation, each rotation is performed about an axis of the moving coordinate system rather than one of the fixed reference frame. For the latter one, each of the three rotations takes place about an axis in the fixed reference frame.

For each method, 12 sets of conventions are employed according to different sequence of rotation about the X-Y-Z axes. One of them is introduced in details in this section, and the
32

rest can be found in [21]. Usually, there is no particular reason to favor one convention over another, but various authors adopt different ones [21]. The following PRY angles (or X-Y-Z Euler angles) are applied in this thesis.
""/" ' I

I

·I

Il

(Tait) Bryan Angles (Pitch Roll Yaw, PRY) [or X.;.Y-Z Euler angles]

In terms of pitch, roll, and yaw angle (PRY) [18], the three individual rotation matrices can be given as:

0
(3.12)

0 siney 1 0
0 cosey

1
(3.13)

-sin ez cosez

0~]
(3.14)

0

Then, the resulting rotation matrix in the global reference frame is given as: (3.15) If the order is reversed, it will become the rotation matrix in the local frame (3.16)

33

Expanding Equation (3.15) leads to

ceycez -ceysez R = s9xs9Yc9z +c9xsez -s9xs9Ysez +c9xcez -cexseycez +s9xsez cexseysez +s9xcez

l

(3.17)

When given three PRY angles, Equation (3.17) can be used to compute the rotation matrix directly. For the reverse problem, some elements in the Equation (3.17) are selected to determine the PRY angles for a given a rotation matrix, for example:
_ ey -

cos ·

1 ([

( r23 ) + ( r33 )

2

2]V2)
(3.18)

where r23 = -sin(8x)cos(8y), r33 = cos(8x)cos(8y), r, 1 = cos(8y)cos(8z).

Different selection of elements from the given rotation matrix leads to different method for a solution. Bai and Teo [59] developed another solution using atan2(y, x), a twoargument arctangent function that uses the signs of both x and y to identify the quadrant in which the resulting angle lies:

(3.19)

However, none of them is capable of solving this inverse problem with a unique solution

34

from a rotation matrix in all four quadrants, which is called the quadrant sensitivity problem. Equation (3 .18) is only valid for 0 :S ey 2': 90o, 0 :S ex 2': 180o, and 0 ::=:; ez 2': 180o; while Equation (3.19) is valid when ey lies in the first and fourth quadrants.

In other words, if ey is located in the second and third quadrants, the values of cos(ey) would become negative. As a result, the two elements r23 = -sin(ex)cos(ey) and r33=cos(ex)cos(ey) in Equation (3 .19) change signs, and the values of ex determined from atan2(r23 , r33 ) are no longer true. It is clearly found from Table (3.1) that there is always 180 degrees offset between the determined values and true ones in this case.

So by modifying Equation (3.19), cosey =

~rz/ + r3/

=

~(-sexceyf + (cexcey) 2

=

~c8/

'

(3.20)

then 8y can also be determined by ey = atan2 (rl3'

~rz/ + r3/).

(3.21)

Even though a second solution exists, by using the positive square root in Equation (3.20) for ey, we always can compute the single solution for which -90" :S 8y 2': 90", making it a one-by-one mapping orientation representation.

Attention should also be paid to the names pitch, roll and yaw angles, since they are often given to other related but different angle-set conventions; for instance, it is referred to the X-Y-Z fixed angles in Craig [21].

35

Table 3.1: PRY angles in versed from a rotation matrix, ex, ey, ez = 45, 135, 225, 315, stands for the full four quadrants, x(-135, 45, -135) is the calculated value.
ez=45 ey=45 135 225 315 135 225 315

-1
x(-135, 45, -135) x(-135, -45,-135)
X X

ex= 45
-1
(-135, 45, -45) (-135, -45, -45)
X X

-1
(-135, 45, 45) (-135, -45, 45)

-1
x(-135, 45, 135) x(-135, -45, 135)

-1 -1
x(-45, 45, -135) x(-45, -45, -135)
X X

-1

-1 -1
X X

-1 -1
x(-45, 45, 135) x( -45, -45, 135)

ex= 135
-1
(-45, 45, -45) ( -45, -45, -45)

ey=45 135 225 315

(-45, 45, 45) (-45, -45, 45)

-1 -1
x( 45, 45, -135) x(45, -45, -135)
X X

-1

-1 -1
X X

-1 -1
x(45, 45, 135) x( 45, -45, 135)

ex= 225
-1
(45, 45, -45) (45, -45, -45)

ey=45 135 225 315

(45, 45, 45) (45, -45, 45)

-1 -1
x(135, 45, -135) x(l35, -45, -135)
X X

-1

-1 -1
X X

-1 -1
x(135, 45, 135) x(135, -45, 135)

ex= 315
-1
(135, 45, -45) (135, -45, -45)

ey=45 135 225 315

(135, 45, 45) (135, -45, 45)

-1

-1

-1

-1

3.2

Translation and Rotation

The motion of a module in the workspace can be described using rotation or translation or both.

3.2.1

General Motion of a Single Rigid Module

As shown in Figure 3.4, the general motion of a single module is the combination of rotation and translation, and the position vector p is
p = Rb' + h = h + Rb'

(3.40)

where h is the vector of translation, b' is the body vector in local coordinate system, and 36

R is the rotation matrix.

Rotation first Translation second Translation first Rotation second

Figure 3.4: General motion of a single module [18].

Clearly, Equation (3.40) is communicative, meaning the order of rotation and translation can be reversed, which can also be found in Figure 3.4. When h is null, it becomes pure rotation.

3.2.2

General Motion of Multiple Modules

Figure 3.5 shows the vector method used to compute the position of a multi-module system.

37

Base frame

Figure 3.5: Vector method for a multi-module system [18]

The position of each joint from 1, 2 to i can be expressed respectively as:

Joint 1 Joint 2 Joint 3

PI =bo P2 = bo + Roib'I =PI+ Roib'I P3 = bo + Roi (b' I+R12b'2) =PI+ Roi R12 b'2

Joint i

Pi= bo + Roi (b'I + ... + Ri-I i b'i) = Pi-I + Ro i-I b'i-I

(3.41)

where Ri-I i defines the rotation between two coordinate systems attached to two adjacent modules i-1 and i; b'i is the local body vector, representing the translation between two coordinate systems, or defining the ith joint to the (i+ 1)th joint in the ith local coordinate frame. 38

Clearly, Equation (3.41) is a recursive method for computing the position of a multimodule system.

Similarly, the recursive method of computing rotation can be given as (3.42)

Hence, in general, the pose (position and orientation) of the end-effector of a n-module system can be expressed as [ 18]
n n

Position

Pn+l

=LRo;b'; =Lh;
i=O i=O

(3.43)

Orientation

Ron

=IT
J=l

n

R(j-l)J

(3.44)

As for a robot system, it usually has the default home configuration or initial configuration setup. Therefore, it should be noted that all the employed parameters here may have static part and motion part. The static part is according to the initial configuration setup, and the motion part represents the movement of each joint. (3.45)

b= bs+ bm

(3.46)

where Rs and bs are initial configuration setup, which are the geometric parameters need to identify; and Rm and bm are related to active joints, i.e., motors. The static part can be further expressed by the PRY angles rotation as 39

(3.47) (3.48) where Rx, Ry, and Rz are the rotation about x, y and z axis of the configuration setup; bx, by, and bz are the translation along the x, y, and z axe of the configuration setup.

In terms of different kinematic pairs, they may be expressed differently according to joint movements, as shown in Table 3.3. As for robotics, usually only revolute and prismatic joints are considered in reality.

In Table 3.3, R(8z), R(8y), and R(8x) are the rotation about z, y, and x axis of the joint respectively; while Sz is the translation along z axis of the joint. Conventionally, the first physical rotation or translation axis of a joint should be defined as axis z, second as y, and last as x. It should be noted this convention is totally different from the sequence of PRY angel set, which is used to represent orientation instead of a rotation matrix. Table 3.3: Rm and bm of different kinematic pairs [ 18]. Joint Revolute Prismatic Cylinder Universal Spherical Rm R(8z) R(O) = 1 R(8z) R(8z)R(8y) R(8z) R(8y) R(8x) bm 0 Sz Sz 0 0

3.3

Three-point Target Measurements

We know that no device can directly measure the complete pose of an object in space, 40

because direct measurement of the orientation is difficult. As a result, the triangular threepoint target, which is made of three equal spheres whose relative positions are known, is introduced and utilized to determine the tip orientation indirectly (Figure 2.3, 2.4, 2.5, and 3.6).

As shown in Figure 3.6, the robot end-effector has a set of three spheres whose relative positions are already known, and they can be either inserted in an array of short-range displacement measuring fixture [17] or measured precisely in a CMM [37]. The kinematic modeling of the three-point measurement is presented in Figure 3.7. In this Figure, Poh p0 2, and Po3 are the initial positions of the three-point target; while Pfl, Po2, and p03 are the final ones measured by certain devices.

Figure 3.6: Three-point moving target.

41

Po

Pol

~3

Po3

Figure 3.7: Transformation determinations using the three-point position data [55]

The initial and final three line vectors formed by the three-point target are [55] (3.50a) and (3.50b)

Then, the rotation matrix from the initial pose to the final pose can be obtained by (3.51) where (3.52a) (3.52b)

Hence, the measured end-effector rotation matrix can be determined by (3.53)

42

CHAPTER4

LINEAR FORMULATION

Chapter 4 discusses the conventional linear formulation for robot calibration. Error models are derived from linearization of robot forward kinematic equations in two schemes, partial-pose (position) and full-pose calibration, depending on whether the orientation of end-effector is available or not. For the full-pose calibration, two methodologies are also investigated when calculating the end-effector pose error and implementing kinematic model error compensation, from which four full-pose calibration categories are generated. Several limitations are found when discussing these two issues. One downside is the orthogonality sacrifice of the rotation matrix leading to illconditioning of the Jacobian in the compensation step, and another is the quadrant sensitivity during the determination of the PRY angles from inversing the rotation matrix. Least-square estimation is applied in the identification of the parameter errors from the error model and tip pose error.

4.1

Error Model

To perform calibration, an error model is developed that takes into consideration all the geometric errors due to imprecision in manufacturing and assembly [18]. Based on this error model, it is shown that the error mapping from the geometric errors to the pose error of the tip of robot depends on the Jacobian matrix. Wu [31] assumed the actual or 43

measured geometric parameters were quite close to the nominal or calculated values and expanded the total transformation as a Taylor series about the nominal values. Keeping only the first order terms resulted in a linear expression for the differential deviations of the Denavit-Hartenberg parameters. Such an idea can be extended here to generate the linear error formulation of the complete kinematic model in Equation ( 1.1 ).

With linearization by Taylor series expanding, the error model can be derived as

~=-~g=J~g

oF og

(4.1)

where

~

represents the pose error of the end-effector of a robot, which is the difference

between the actual (or measured) and the nominal (or calculated) tip poses in Equation
(1.4);
~g

represents the kinematic errors, which includes manufacturing errors, assembly

errors, joint errors, all of which are to be identified together for the robot; J is the Jacobian matrix, or the error mapping matrix, mapping the kinematic parameter errors to the pose error of the end effector.

Two methods are classified here to do the calibration depending on the availability of the orientation measurement of the tip, namely partial (only position) and full (position and orientation) pose measurements.

44

4.1.1

Error Model with Full Pose Measurement

With both position and orientation measurements, the error model in Equation (4.1) can be further detailed as

~6xl = [~:] = [~ p] ~g6nx]
6xl

(4.2a)

fJ 6x6n

(4.2b)

where~

is a 6xl vector representing the robot tip errors including ~p and

~J:l,

which are

the position and orientation error of the tip respectively; J is the Jacobian, as shown in Equation (4.3a), which is a 6x6n matrix, with n joints;
~g

is a 6nxl vector representing

the component errors, which are generalized as six infinitesimal errors for each module, including infinitesimal translation
~ri, ~si), Trans(~xi, ~yi, ~zi)

and infinitesimal rotation

Rot(~pi,

where

~Xi, ~Yi

and

~Zi

represent the linear errors along x, y and z axes of the and
~Si

frame i respectively, and

~pi, ~ri

indicate the angular errors about x, y and z axes

of the frame i respectively. The scripts p, r, and s represent pitch, roll and spin (or yaw) angles, respectively.

Considering the concept of multi-body velocity computation using the Jacobian [I 8] and the fact that the velocity is the derivative of the position, the velocity formula can be transformed and utilized into the error model by replacing the linear and angular velocities with infinitesimal translational and rotational errors respectively, as below: 45

~gl

[dp]
~p

-J~g-

6xl

[J"
JOI

J

P2

JPi JOi

J02

J,"]

~g2

JOn 6x6n

~gi

(4.3a)

~gn

6nxi

where the i th Jacobian matrix

Ji

is
yi zi

J,f"}[X,
JOi

X xPn+I
I I

y xPn+I
I I

0

0

0

xi

yi

ZxP""] z
I I
1

(4.3b)
6x6

with i ranges from 1 to n, n is the number of joints.

xi, Yi,

zi are the three unit vectors

of the global Cartesian coordinate in the ith joint; Pin+ I is the position vector from ith joint to the tip of a robot,
pin+I

= LRo;b~ = Lb;
j=i j=i

n

n

(4.3c)

Hence, the tip error unit contributed by the ith module is
lui

X xPn+I
I I

y xPn+I
I I

ZxP~']
I I

~Yi

&i
6x6

(4.4)

zi

/).pi

~ t1si

6xl

Obviously, it can be found that this general error model covers all the robot kinematic parameter errors. Therefore, it can be regarded as a complete parametric calibration model.

46

4.1.2

Error Model with Position Measurement

Without the orientation measurement of the robot tip, the error model shrinks to
~P3xl

= J p3x6n~g6nxi

(4.5)

and the position error of the robot tip contributed by the ith module is
Llxi

~Y;

X
1

X pn+I
l

y
I

X pn+I
I

Z
I

X pn+l]
I

/),zi
3x6

(4.6)

!!.pi
~lj

/).si 6xl

Compared with the full pose measurements, pure position measurements are easier to perform and the calibration algorithms are easier to implement.

4.2

Pose ~rror Calculations
~X

The pose error of end effector,

in Equation (4.1), is equal to the difference between

the actual (or measured) and the nominal (or calculated) value of end-effector pose, (4.7) where
~p

and

~p

are the infinitesimal position and orientation error respectively. Two

approaches are considered and compared in detail.

4.2.1

Differential Transformation

Firstly, the pose error in Equation (4.7) is regarded as the differential translation and rotation respectively, represented as [16],

47

(4.8a) (4.8b)

Therefore, according to [16], considering the derivative as a differential translation and rotation in terms of the base coordinate frame, the measured pose transformation T m can be obtained below,

Tm =Tn +dT=Trans(dx,dy,dz)Rot(ox,oy,oz)Tn
where T" is the nominal pose transformation; pose transformation matrix is T

(4.9)

~ [ ~ ~] .

So the derivative dT is developed as

dT =(Trans(dx,dy,dz)Rot(ox,oy,oz)- I)T =AT
where A, the differential translation and rotation transformation, is given as 0

(4.10)

-oz
0

A=

oz -oy
0

ox
0

oy dx -ox dy dz 0
0 0

(4.11)

which can be also called pose error transformation.

Since it is easy to calculate the position error Ap, i.e., ~p =

Pactual - Pnominab

simply only

considering the differential rotation 8, the transformation in Equation (4.11) becomes

-oz
0 (4.12)

ox
48

which is the skew symmetric matrix ofthe differential rotation 8 in Equation (4.8b).

As a result, Equation (4.1 0) shrinks to
(4.13)

Therefore, from Equation (4.9), the measured end-effecter rotation matrix Rm is

R m =R n +dR=R n +8Rn =(8+I)R n

(4.14)

where Rm can be measured by the three-point method as described in Chapter 3; Rn is the nominal rotation matrix of the end-effecter, which is calculated through the nominal model.

Hence, according to Equation (4.14), two equivalent methods are found to determine the differential rotation 8, if Rm and Rn are both known:

&=dRR
or

n

T

=(Rm -R n )Rn T

(4.15a)

&=R m R n T -1

(4.15b)

Actually, the first method in Equation (4.15a) can also be derived by the tensor transformation, (4.16) also

49

PROPERTY OF RYERSON UNIVERSITY LIBRARY

co=8fdt where
(jj

(4.17)

is the skew symmetric matrix of angular velocity co.

So, from Equation (4.16) and (4.17),

8/dt = ( dR/dt )Rn T

(4.18)

Thereby, the skew-matrix of 8 is determined as, identical to Equation (4.15a),

8= dRR T
n

= (Rm - R n )Rn T

(4.19)

Consequently, the orientation errors ~p can be solved as

~fJ=vect(6)

(4.20)

where vect( ) is the vector operation, which transforms a skew symmetric matrix into a column vector.

4.2.2

Inverse of a Rotation Matrix

Alternatively, another simple and straight-forward approach of determining the endeffector orientation error is to calculate the Bryan (PRY) rotation angles directly from the rotation matrix Rm and Rn:

o =f- 1 (R)
Many approaches about

I

(4.21)

f"\ ) have been proposed so far, however, none of them is able

to function correctly for all four quadrants from -180° to 180°. This limitation is called

50

quadrant sensitivity stated previously in Section 3.1.3. Hence, the calibration configurations should be considered and chosen carefully to avoid those limitations.

Here is one of them:

(4.22)

where r,, rJJ and r11 are elements from rotation matrix according to the number subscripts, as shown in the Appendix A.

Then, the orientation error can be determined by subtraction between the measured and nominal PRY angles (4.23)

Hence, as the second approach, the orientation error can be determined from m = <llB [18], as (4.24) where 0 sin (}Y ] -sin (}x cos (}Y
COS (}X COS (}y

(4.25)

51

4.3

Computational Methods

Computational methods involve three aspects. The first one is to perform the inverse of the error mapping matrix J which is not a square matrix. The second one is component error compensation, for which two methods are investigated in details. The last aspect is an iterative algorithm for calibration.

4.3.1

Least Squares Method

In order to identify the linear error model in Equation (4.1 ), two categories of the least squares estimation problem are investigated, namely, underdetermined and overdetermined problems, according to the dimension of the error mapping matrix, J, or the number of measurements, m. To ensure the accuracy, measurement points should be sufficient to minimize computational errors, and also the condition number of the Jacobian J should be kept low enough within a reasonable bound.

4.3.1.1 Underdetermined
If only one set of tip poses is measured, as the number of joints n2:1, the number of unknown geometric error parameters is larger than that of independent equations in the Equation (4.1). This is a case of an underdetermined problem. The pseudo-inverse method can be used to obtain a minimum-norm solution as follows,
Ag6nxl =JT 6nx6

(J

6x6nJT 6nx6 )"'

6x6

AX6xl'

n ~I and m= 1

(4.26)

where Jt

= Jr ( JJT )"'

is the pseudo-inverse of J for underdetermined situations.

52

4.3.1.2 Over-determined
A large number of poses must be available to more accurately reflect the robot geometrical characteristics. In order to make Equation (4.1) over-determined, the number of measurement, m, is increased sufficiently to make sure the number of equations, 6m, is larger than the unknown geometric error parameters, 6n. Hence, the pseudo inverse solution is given as when the matrix JTJ is nonsingular,

Ag6nxl
where Jt

= (JT 6nx6mJ 6mx6n )-I6nx6n JT 6nx6mAX6mx] , m ~ n

(4.27)

=(Jr J

t

JT

is also called the pseudo-inverse of J, when m 2:: n.

The condition number of JTJ is used to evaluate the observability and measurement strategy [45]. The better the strategy, the lower the corresponding condition number [19].

4.3.2

Kinematic Model Error Compensation

After identifying the component errors as given below:

the nominal kinematic model should be updated accordingly until the pose error of the end-effector meets certain accuracy requirements.

Iterative updating for static body vectors, bs, yields (4.28) where

53

Ab=[~x I I

~y.J

~z.] I

(4.28a)

However, as for the update of static rotation matrix Rs of each module, two iterative methods are investigated.

The first updating method is more straightforward, which adds the calculated orientation errors into the initial orientation set up and then determines the static rotation matrix accordingly by (4.29) where (4.29a)

(4.29b)

The second updating method is derived from the differential rotation in Equation (4.12) and (4.14). The skew matrix of the identified orientation error for each link is compensated for the local static rotation matrix through the function below, (4.30) where (4.30a)

54

(4.30b)

However, after being updated by Equation (4.30), the orthogonality

df the static rotation
\

matrix is slightly sacrificed, and it may cause the ill-conditioning of th¢ Jacobian, which would result in the poor performance or non-convergence.

4.3.3

Calibration Algorithm

Calibration is a process of determining a set of parameters in the model that best describes the specific robot under study [17]. As shown in the flowchart (Figure 4.1), the whole calibration algorithm is an iterative loop.

In evaluating the pose error, three parameters are used: RMSPE, RMSOE and RMSE, which are the root mean square of the position, orientation and pose errors defined respectively as [59]

RMSPE

= - LI~PI , ~p = ~x, ~y, ~z
2

1

3

(4.31a)

n

I

1 RMSOE = n

L I~PI
I

3

2

, ~p = ~p. M, ~s

(4.31b)

RMSE =

-

1 , 2 :LI~ej , ~e
I

=

~x, ~y, ~z, ~p, M, ~s

(4.31c)

n

55

Robot Geometry

g (bs & Rs)
Input Motions: U

q (8, S)

date~----~r-------'

Kinematic Model Equation (1.1)

X= f(q, g)
Measured Tip Nominal Tip Pose

Xo(R & p)

Tip Pose Error

Two methods of calculating the orientation errors of the endeffector: Equation (4.20) and (4.24)

y

Error Mapping Matrix

Calibrated Kinematic Model

J (or Jacobian)
Error Model
~=J~g

X= f(q,

g+~g)

Identification

~g=J-I ~X

Two methods of updating the identified errors to the nominal kinematic model:

g

~ (g+~g)

Equation (4.29) and (4.30)

Figure 4.1: Conventional calibration algorithm (linear formulation).
56

After carrying out the full pose calibration simulation, different convergent features are found between these three parameters. The termination of the iterative looping occurs when the pose deviation of the robot tip is within the certain specified precision, RMSE ::;
1<>1.

As mentioned in the Sections 4.2 and 4.3.2, there are mainly two methods of determining the end-effector pose error and compensating the component errors in the nominal kinematic model, which are combined together in Table 4.1. There are four categories studied in the calibration simulations.

Table 4.1: Four categories of calibration simulations

Component Errors Compensation

End-Effector Pose Errors Calculation

Afl= vect ( 8)
Equation (4.20) and (4.17) Rs.+ 1 =Rs. +dRs. =Rs.
I I I
1

Afl =«<»(Om -On)
Equation (4.23) and (4.24)
2

(1 +J )
t

Equation (4.30) Rsi+I =Rpry (Oi +AOi) Equation (4.29)

3

4

Simulations have showed that the static rotation matrix is no longer orthogonal after being updated recursively using the first compensation method, i.e., Equation (4.30). After losing the crucial orthogonality, a rotation matrix is no longer eligible to represent the orientation for a robot, which indicates that robot kinematic calibration should avoid

57

this compensation method shown in Equation (4.30). Therefore, the second method in Equation (4.29) would be a better way to update the identified component orientation error into the static rotation matrix for individual links. Furthermore, attention should be paid to quadrant sensitivity in the second method of the end-effector orientation error calculation (Equation (4.23)), which may fail to yield unique Euler angles from a rotation matrix ofthe end-effector in Equation (4.21).

58

CHAPTERS

NONLINEAR FORMULATION

This chapter investigates the nonlinear formulation without linearizing the kinematic model. The norms of tip position error and rotation matrix error are used as the objective function to search for an optimal or global solution. A genetic algorithm (GA) is applied as the search engine. Attention is paid to the population size, generation numbers, crossover or mutation factors, initial population, and other GA options. Furthermore, Monte Carlo simulations are conducted to reduce the stochastic or random error.

5.1

Nonlinear Formulation

Compared with the conventional linear formulation, the nonlinear one determines the pose error of the end-effector between the nominal and measured pose directly,
n n n

Lll~ll2 = LIIXm-Xollz = LIIXm- f(qo,go+L'lg)llz <
i=l i=l i=l

E

(5.la)

(5.lb)
n

where LIIXm - X 0 11 2 represents the summation of 2-norm values of end-effector pose
i= I

errors from n different measurements;

E

is the acceptable accuracy for the pose error of

the end effector, which is the termination condition for the calibration iterations. Equation (5.la) can be solved using genetic algorithm to search the optimal geometric errors L'lg at which the norm value of pose errors is less than 59
E.

Furthermore, the determination of the pose error can be formulated as follows, (5.2) where

IIPm -Po 11 2 and IIRm -Ro 11 2 are the Euclidean norm of position error and the spectral

norm of rotation matrix error of the end-effector respectively. llxll 2 = the Euclidean norm of x in vector space,

IIAII2 =)A-max (A ·A)

represents the spectral

norm, defined by the largest singular value of A or the square root of the largest eigenvalue of the positive-semidefinite matrix A* A.

The use of rotation matrices directly instead of PRY angles to represent the orientation in Equation (5.2) avoids the inverse operation that may cause the quadrant sensitivity problem. Pm and Rm are the measured position and rotation matrix of the robot's endeffector. For Po and (3.46) in Chapter 3.

Ro. it can be given by the robot forward kinematic equations (3.43) ~

5.2

Genetic Algorithm

A genetic algorithm (GA) is a kind of global adaptive probabilistic searching algorithm simulating biological heredity and evolution, first presented by Prof. Holland in Michigan University [60] [61]. GA includes four basic operators, namely, selection, crossover, mutation, and migration. The genetic algorithm repeatedly modifies a population of individual solutions with these operators. Meanwhile, the fitness of each individual in a 60

population is valued by its cost of fitness function, and the best individual has the lowest cost, which has the priority to be selected into the next generation.

5.2.1

Fitness Function

The fitness function is also known as the objective function in other standard optimization algorithms. This is the ultimate cost function that determines the optimization process and direction of GA. The fitness function assigns a higher selection probability to the individuals with the lower cost values. After the global search based on GA is over, we transform the best individual whose cost value is the lowest into the final indentified kinematic parameter errors [7]. A nonlinear identification approach can be regarded as a typical GA optimization problem by setting Equation (5.1) as the fitness, while adding appropriate weighting factors between position and orientation error, as given below

Min(

~~~Xm-Xollz)

(5.3)

IIXm -Xollz = wiiiPm -Po liz + wziiRm -Rollz

(5.4)

where w 1 and w 2 are the weighting factors for position and orientation errors of the end effector, respectively, which are utilized to weigh the importance of two errors. When w1 =1 and w2=0, it shrinks to a pure position calibration only; when w1=0 and w2=l, it shrinks to a pure orientation one.

61

Each individual of a population has 6n parameters in total as the variables in the GA search. Meanwhile, the geometric errors
~gi

(Equation 4.2b) are the variables that are

optimized to minimize the cost of fitness function given in Equation (5.3). Furthermore, the position and orientation errors can be written as follows

IIPm -Poll2 = IIPm -Po (q, g+~gi )112 IIRm -Roll2 = IIRm -Ro (q, g+~gi )112

(5.5)
(5.6)

where g represents the geometric parameters of each link, including the body vectors and initial configuration set up; q represents the joint variables, including rotational angles for revolute joints and translational displacements for prismatic joints.

5.2.2

Initial Population

A genetic algorithm starts generating a new population from the initial population that can be either created by a random generator, say, using a uniform distribution, or set manually. The initial population should provide the diversity of individuals. Assuming there are m population size and n number of variables, the initial population should use an mxn matrix to store. For robot kinematic calibration, the identified kinematic parameter errors from the linear formulation with position measurements can be considered to be an initial population. Both methods are evaluated in the calibration simulations, and better performance can be found when using calibrated
~g

from the

linear formulation. It requires fewer generations and therefore saves calculation times.

62

5.2.3

Individual Selection and Population Generations

The classical algorithm generates a single point at each iteration, and the sequence of points approaches an optimal solution. While GA generates a population of points at each iteration, the best point in the population approaches the optimal solution. Moreover, GA selects the next population by computation which uses a random number generator, as opposed to selecting the next point in the sequence by a deterministic computation in the classical algorithm [62]. With a large population size, the genetic algorithm searches the solution space more thoroughly, thereby reducing the chance that the algorithm will return a local minimum that is not a global minimum. However, a large population size also causes the algorithm to run more slowly.

To create the next generation, GA selects certain individuals in the current population, called parents, and then uses them to create individuals in the next generation, called children. Typically, the algorithm is more likely to select parents that have better fitness values. There are basically four operations for generation, which are selection, crossover, mutation, and migration. An individual with the lowest cost value of the fitness function, called an elite child, will be selected with priority into next generation automatically and survive to the next generation. Besides elite children, other relative lower individuals are selected as parents that contribute to the population at the next generation with crossover and mutation rules. Crossover operation combines two parents to form children for the 63

next generation. Mutation rules apply random changes to a single individual in the current generation to create a child. Mutation broadens the search space for GA and creates genetic diversity. Migration copies the best individuals in one subpopulation to replace the worst individuals in another subpopulation when the population size is more than one.

5.3

Calibration Algorithm

In Figure 5.1, a flowchart is given to show the robot calibration procedure based on the nonlinear formulation using GA. The initial population provides the genes for GA. The individuals with lower cost values are selected with priority to be parents for the next generation. The children are generated through the four basic operators, namely, selection, crossover, mutation, and migration. The final best individual is transformed to be the kinematic parameter errors and implemented into the robot kinematic model when it meets the required accuracy.

64

Robot geometry: g (bs & Rs) Joint variables: q (8, s)

Initial population {Jg}

Measured Tip

Fitness calculation

{//L1Xj/}
Best individual (minjjJXj /i) Jgi

y

Calibrated Kinematic Model

X= f(q, g+Jg)

Children {Jg}

Figure 5.1: Nonlinear calibration using a genetic algorithm.

65

5.4

Monte Carlo Simulation

After each run, GA (loop 1 in Figure 5.2) returns a set of results for component kinematic parameter errors, L\g. In order to reduce stochastic simulation error, Monte Carlo simulation (loop 2 in Figure 5.2) for the genetic algorithm is conducted by running GA for n times, roughly around 50 times, until the mean value of all searched parameter errors of all runs (Equation 5.9) become stable and fluctuates within a certain preset tolerance L1 in Equation (5.7).

(5.7)
k-1

L\g

-k-1

= ..:..i=...:..1_ _
k-1

L:L\gi

(5.8)

-k

L\g

I =

k

L\g;
_

I

k-1

L\g; + L\gk

- k -1

i=1

i=1

= _L\=g_x--'(--'k_-.....:l)_+_L\....::g:..::...k

k

k

k

(5.9)

Simulations show that the more the run times, the more stable is the mean value. In addition to conducting a Monte Carlo simulation for a single configuration (loop 2), more random m configurations in the workspace are generated to repeat loop 2 until the mean value (Equation 5.10) for all the different configurations becomes stable, which can be considered as the global solution in the whole workspace (loop 3 in Figure 5.2).

(5.10)

66

GA; . i-l,n

-7Lig, -2(C.g;)/n
Monte Carlo Ieveil (n GA runs in one configuration) ConfJ, i'-l,m -7 =~ '\' (Ao '-¥.,. J );fm ''"

!o.o ~-~ tiobal

Monte Carlo lever 2 (m configurations in workspace)

Figure 5.2: Three loops of simulation.

67

CHAPTER6

SIMULATIONS AND

COMPARISONS

In this chapter, the calibration algorithms, both linear and nonlinear formulations, are first tested individually and then compared. Figure 6.1 shows the graphical user interface (GUI) for the robot kinematic calibration simulation created in MatLab R14. It consists of a static configuration set-up, motion parameters, assumed link errors, the calibration using linear formulation, the calibration using nonlinear formulation, and outputs. The outputs include graphs of the robot configuration representation and the robot endeffector pose errors, and identified kinematic parameters.
f
I· I

~

' " Ill Ill

I

.I i l l

lfl

Robot Configurations

PIIele ........ , . . . , of ll'ldM: bO: Bille Vedon (m)

"~[ ~:'~ :l l:.J
.5 1 ----····; 0.5 0
X

..........

bs. Sltillc loclf Body Veda's (m)
Rs· Sl*OrilrtllltanwrJ

.()5
0 _:.[

Ratllkln(deg)/ T,......,.,(m)

_ _ .._ -oooe

--j
02

_ ......
-

-,.-X

~~-~(In)

Podian(m)
A

0.~

DJIODI7847 -0.14101 040002 0.0019131 O.CW98828
019901

From
To

l.IXI379439
!ll2ale-007

-2.2856e.OOS 0 0019132

T,..ot_ - J
000.2 OHIOO

v
ICSU_Ciill:nltcl (dig) O.ot212157 .O.Dt322334 Cl.D332! A 0.002892411 -0002765421 00052 -0 0026'95145 180.0199 OD3854 v

.....
To

ZeroReterenceFIWIIII(Ci~Wee)

.!_

-

_.,_. ......
35 Root: Mean Sqare ~osrt1on Error
..oJiOtlMI

_j

..:.!

0.5

o.liieMII.OJiiMcine 01Xm4178 o...

~F-*ws

WI

3 ..

25 15

2 ·..·.·

··········+··········+··········· ······:,,············+.............
------------>---

·········+············+··········

------Vlrill:lltBcvld(m)
~PqiUition

.!

0~
01

::::::::·:_··[::::::::::::::::::::::::::

__
1e-5 10

W2

,.._

.,_,
"""'

_
I """ I

30

_.,.._
"'"*
1000
0005 1e-5

11111n

v-.. DMition

~

Cc:Jnf9nllant ~

1e-4

Figure 6.1: Graphical user interface (GUI) for robot kinematic calibration.

68

The simulations are carried out on the MRR-1 robot. as shown in Figure 6.2. The robot has three joints: two revolute and one prismatic. Table 6.1 lists the robot's kinematic parameters, including local body vectors, initial orientation set-up, and joint motions for simulations.

Figure 6.2: MRR-1 [8] and SolidWorks model.

Table 6.1: Nominal link kinematic parameters for MRR-1
Zero Initial set Pitch n/a 0 0 0 Reference Orientation up (de g) Roll Yaw n/a n/a 0 0 0 0 180 0

Joint i

Local Body Vectors (m)
X 0 0.5 0.4 0

Joint Motions (deg/m) n/a 30 60 0.2

y

z
0.8 -0.15 0 0.2

Base I (R) 2 (R) 3 (P)

0 0 0 0

All the kinematic parameters in Table 6.1 are inputs in the GUI (Figure 6.3). The robot configurations before and after movements Uoint motions are shown in Table 6.1) are illustrated by red and blue solid lines, respectively, in Figure 6.4, and the dashed line represents the base vector from the global frame origin to the first revolute joint centre.

69

.-------------------~MkC~~·------------------~

Please inpli the number o1 modules:

bO: Base Vectors (m)

Number o1 Module

Type o1 Module

bs: stlillic local Body Vectors (m)

00 0.2

Rs: Stlillic Orientation w.r.t. Zero Re1erence Frame (degree)

r Kinematic Modell
Rotation (deg) I Translation (m)

0

-·~1------~~--------~

..------- A8eumed Component Errore------o
l-0.0017649 0.0065496-0.00040919 0.00034179 If .,:·I

I Next ] I Reset I'*"· Con! J

I

I
·

lc

I

·i

>

I Randomly Generate the Preset Errors (m a rad)
Figure 6.3: Kinematic parameter input panels in the GUI.

Robot Configurations

0.8 0.6
N

.--c'~ ........... -!---

0.4 0.2 0 -0.5

y

X

Figure 6.4: Robot configurations before (red lines) and after (blue) movements. 70

In the calibration simulations, the measured end-effector pose is determined using the nominal model with the assumed joint geometric parameter errors according to the manufacturing tolerances in Table 6.2. The nominal pose is determined using the model without the errors [59]. These assumed errors are generated randomly by the Gaussian (normal) distribution with the mean value /-1 = 0 and variance cr 2 = 0.003. The random generator can be found in Figure 6.3. A set of assumed component geometric errors, listed in Table 6.3, is added to both local body vectors and initial orientation set-ups in the nominal kinematic model through Equations (4.28) and (4.29) or (4.30).
Table 6.2: Typical tolerance limits for various manufacturing processes [65]
Typical Tolerance Limit Process
Sand casting: Cast iron Steel Aluminum Die casting Plastic molding: Polyethylene Polystyrene Machining: Drilling, diameter 6 mm (0.250 in) 25 mm (1.000 in) Milling Turning

Typical Tolerance Limits Process
Abrasive processes: Grinding Lapping Honing Nontraditional process: Chemical machining Electric discharge Electrochem. grind Electrochem. machine Electron beam cutting Laser beam cutting Plasma arc cutting

mm
±1.3 ±1.5 ±0.5 ±0.12 ±0.3 ±0.15

inches
±0.050 ±0.060 ±0.020 ±0.005 ±0.010 ±0.006

mm
±0.008 ±0.005 ±0.005 ±0.08 ±0.025 ±0.025 ±0.05 ±0.08 ±0.08 ±1.3

inches
±0.0003 ±0.0002 ±0.0002 ±0.003 ±0.001 ±0.001 ±0.002 ±0.003 ±0.003 ±0.050

+0.08, -0.003 +0.13, -0.05 ±0.08 ±0.05

+0.003, -0.001 +0.006, -0.002 ±0.0003 ±0.002

Table 6.3: Assumed geometric parameter errors (m or rad)

Joint i

Position errors

i=l i=2 i=3

11x; -1.2977e-3 3.5675e-3 -1.7649e-3

~Y;

&i

-4.9968e-3 -1.129e-4 6.5496e-3

3.76e-4 9.8188e-4 -4.0919e-4 71

Orientation errors tlJj /),pi &i -8.6303e-4 3.4394e-3 3.5727e-3 5.2392e-4 -5.6013e-4 2.1774e-3 3.4179e-4 3.2003e-3 1.7784e-4

6.1

Linear Formulation

For the linear formulation (Figure 6.5), two calibration schemes are simulated. The first one is the position calibration and the second one is the full-pose calibration.

Simulations of the calibration using only position measurements are carried out successfully and usually converge to the specified accuracy by no more than 6 iterations, even though it (Equation (4.6)) is simpler and less complete compared with the full pose calibration. For this case, the root mean square position error (RMSPE) values converged from 3.8xi0-3 m to 6.2xi0-7 m by only 4 iterations in Figure 6.6(a). Figure 6.6(b) shows the calibration results.

r Termination Conditiuns --

Tip Pose Error Tolerance

...__I r·-~'"""
!

Calibration Categories

Maximum Iteration Times

, .......
[

Condition Humber ~----'"-- 1
~,

3.180~_]

I Curve

j

I I

......_.........~................................. --~.........................J

[e-ll

I

Figure 6.5: Calibration using Linear Formulation panel.

Table 6.4 shows the identified actual kinematic parameters for MRR-1 compared with the nominal values. The positioning accuracy of MRR-1 can be improved when the actual values are implemented into the kinematic model. The differences between the nominal and actual values are the geometric parameters errors, as shown in Table 6.5.

72

3.5 lr-----.---_;_--.-----4

--Root Mean Sqare Position Error
~*~~~~-~··r~-~-----·--··r·····--·--~·

.-.. .§.
w
·~ 0 0.

... g

3
2.5 2 1.5

~-

----

--------~-------------~------------

.!a

c:

------

------;-------------~------------

(1,)

--------

0::

:::e
0.5
0
1

----~-------------~-----------'
~~~····~~M~~-···r·······--*~·

·····~···~

. . . .

. . . . . . . .

·----~------ ~--------~----~------------

. .

. . . . . . . . . .
'

. .

. . .

2 3 Number of Iterations

4

(a)
Calibrated Kinematic Parameters-- ,........--- RMS Errors--.....,

Bs_Calibrated (m) From 0.40002 0.0019131 0.00098828 2.2856e-005 0.0019132 0.19901

Position (m)

To
Orientation (rad)

ICSU _Calibrated ( deg)

[ Rs _Calibrated J From

1o.oo2692411 -o.oo2'7s5421 o.oo52 ......... ;
1-0.002695145 180.0199 0.03854 v

! 0.01212957

'-0.01~22334. 0.0332f .... l

To
.....J

~~.

.

..

i '

>~-~J
(b)

1

i

Figure 6.6: Partial pose (position) calibration outputs.

With the identified errors in Table 6.5, Table 6.6 indicates that the position of the MRR1's end-effector after calibration is much closer to the actual position than the nominal values before calibration. However, the differences between the calibrated rotation matrix

73

and the actual values are found even after calibration in Table 6.6. Clearly, the orientation accuracy is not taken into account in position calibration.
Table 6.4: MRR-1 kinematic parameters before and after calibration

Joint

Kinematic Earameters Local Body Vectors (m)

Nominal values (m I de~)
X 0.5 0.4 0
y

z

1 2 3

0 0 0 Roll 0 0 180

-0.15 0 0.2 Yaw 0 0 0

Calibrated actual values (m I de~) y X z 0.49835 9.76e-4 -0.1490 0.40002 0.0019131 9.88e-4 -2.3e-5 0.0019132 0.19901 Pitch 0.0121 0.0027 -0.003 Roll -0.013 -0.003 180.02 Yaw 0.0332 0.0052 0.0385

1 2 3

Initial Orientation set up (deg)

Pitch 0 0 0

Table 6.5: Identified geometric parameter errors (m or rad)

Joint i
/),xi

Position errors
~Y;

Orientation errors
&i 9.8828e-4 9.8828e-4 -9.8831e-4

/¥J;
2.1170e-4 4.6991e-5 -4.7039e-5

i=1 i=2 i=3

-1.6453e-3 2.2946e-5 -2.2856e-5

9.7647e-4 1.9131e-3 1.9132e-3

~ -2.3079e-4 -4.8266e-5 3.4700e-4

/),si

5.8048e-4 9.2338e-5 6.7282e-4

Table 6.6: End-effector poses before and after calibration

Tip position Nominal values 4.330127e-l 1.7987616e-4 2.5000e-1 4.2722476e-1 6.5018508e-1 2.531 0769e-1 4.2722582e-1 6.5018489e-1 2.531 0762e-1 0

End-effector rotation matrix

-1
0 -1.8588651e-4 -9.9998926e-1 4.6304586e-3 -6.7281 084e-4 -9. 9999969e-1 4.1729084e-4 74

-1 0 0 -9.9999914e-1 1. 7987616e-4 -1.2983857e-3 -9.9999974e-1 6.7270681e-4 -2.4939540e-4

0 0 -1 1.2975389e-3 -4.6306960e-3 -9.9998844e-1 2.4911461e-4 -4.1745853e-4 -9.9999988e-1

Actual values

Calibrated values

On the other hand, due to the limitations of the linear formulation, simulations have shown that these limitations tend to cause the full-pose calibration results to be nonconvergent, as shown in Figure 6. 7. The root mean square values of position, orientation, and pose errors are represented by blue, red, and black curves, respectively, in Figure 6. 7.

0.16 .--------,.-----,---.,...------,

°' w
2

14

-+- RMS Position Error
····-f+···· RMS Orientation Error
--+---

' ___ /

cr
m

; ·u;
~

:5

0 12 ----

.

RMS Pose Error

0 1 ---------·------------------ -- ·- -- ___ , __

·

:
,

:
,

i:: : :
E 0 o:: O.D2 --------

0.08

---------~----------;---------~----1'--

,

:

I d r·

(j)

T
'

d'

27

-

Number of Iterations

Figure 6.7: Non-convergent results for the full-pose calibration.

6.2

Nonlinear Formulation

For the nonlinear formulation using GA, the options of GA need to be adjusted after several trials in order to obtain a better performance, consisting of the number of populations, generations, crossover factors, initial populations, and weighting factors etc. Figure 6.8 shows the GUI for the nonlinear formulation using GA.

With 50 populations and around 250 generations, the best fitness value has changed from about 4.5><10- 3 to 9.8075x1Q-6 (Figure 6.9), indicating that the norm ofthe pose error of robot end-effector has been decreased below the satisfied accuracy, I xI o- 5 . The best and 75

mean fitness values of each generation are represented by black and blue points. Figure 6.9 also indicates that GA's initial convergence speed is very fast and then gradually becomes slow. Generally, GA needs longer computing time than other optimization methods.

Nonlinnr Formullition using Genetic Algorlthm--Weigi'Dlg Factors Variable Bc:uld (m)

lnlial PopUetion

W1 W2

~
[- 1

Lower
Upper

1-o.oosl

QCelibrated

J

I o.oosl
Flness limit

Population Size

Generations

~

11soo I

~
Configl.rations

I GA l IResuls]

.-------Monte Cerlo Simullltion------:
Mean Value Deviation

IMC 1 l
f·e-·,r.

IMC 2 ]
f·.F!~'

~>,JtC·

~

Figure 6.8: Nonlinear Formulation using Genetic Algorithm panel in the GUI.
Best: 9.BJ75e.OJ6 Mean: 0.0024816 0.018 ---- --;------ ~-- ---- ~------:----- -;----- -~----- -·----- --------.------:

o.o16
0.014

-----+-----1------j------!------r------r------ · MeMflness j ----- +----- ~- ----- i------ i-- ---- ~---- --~-- ----:------ i--- --- i- -----;
I I I I I I I I I

:

:

:

:

:

:

·

Best11tness

:

I I

I I

I I

I I

I I

I I

I I

I

I

I

I

I

I

I

I

I

I

I
I

I
I

I
I

~
~
UJ
U)

0.012 ------:------ ~-- --- -~---- --!- ---- -~----- -~-- ----:----- -~------ t-- ---- ~

0.01 ------:------:------:------:------:------:------:------:------:------:
I I I I I I I I I I I I I I I I I I I I

:

:

:

:

:

:

:

:

:

:

~

s o.C03 ------:-----i- ----: : :
O.OCE 0.004
0.002

.

--- t------ ~---- --r----- -:------ ~--- --- t------ ~ : : : : : : : ------:------ i·- --- -~---- -- f------ ~----- -r-- ----;----- ·i------f------ i
~---

-·-

-t------ ~------ ~--- ---:------; ----- -~----- -:------ ~---- --:------:
I I I I I I

:

:
I

:

:

:

:

:

:
I

:
I

:
I

·

! · · ~- · · ·· · ~ · · ·· · · ~ · · · · --~ · · · · · -~- · · · ·
I I I I I

·1· ···· ·f······~
I I I

I

I

I

I

I

I

I

I

Generatioo

(a) 76

x 1o-3 Best: 9.8075e-006 4.5 ---- -~------ ---- ·:·-- --- :··-- ·:···- -- j- --- ··:···--4
3.
Q)

----- ·:·- ----

5
3

-----j------ ----+-----r·---+-----(·--+----- -----+--------- (---- ------1------ (· ---1------ j·---- ·r----- ----- ·r---------1------ ------j·-----t·-----j··----1------r----- ------r-----

-=
(J)

.s
u:

E2"5
·

---··t··-- -----r----~------i""·---~----·t··-- ---··t··-I

o

I

I

I

I

1

2 -1. 5 :
·

---i-- ---- ---- -~---- --r----- ~------f---- --:------ ------:------- __j_----- ----- _j_----- i---- --!------ ~----- _;_----- ----- -!-----I I I I I I I I I I I I I t

I

I

I

I

I

I

I

1 --~--:------ ------r-----r------r-----r-----~----- ------~-----

I

I

I

I

I

I

I

0.5 ---

..

,------

:

I

I

I

I

I

I

------:------:------:------:------~----- ------~----1 I I
I I I I

0 oL--1~0-0~2-00~~30_0__ 4~00--5~0-0__ 6L00--~70_0__ 8L00--~90-0~1000

I I

I I

I I

I I

0 I I

Generation

(b) Figure 6.9: (a) Best and Mean fitness; (b) Best fitness.

Table 6.7 shows the MRR-1 kinematic parameters before and after calibration using the nonlinear formulation. The satisfactory results of the end-effector pose after calibration are presented in Table 6.8, as compared to the pure position calibration values using the linear formulation in Table 6.6. The calibrated rotation matrix of the end-effector in Table 6.8 is much closer to the actual values compared with the one in Table 6.6, indicating the better performance of the nonlinear formulation using GA.

The final best individual with 18 variables for the MRR-1 is shown in Table 6.9 after 250 generations. They are transformed to be the identified kinematic parameter errors and implemented into the robot kinematic model.

77

Table 6.7: MRR-1 kinematic parameters before and after calibration

Joint

Kinematic Earameters Local Body Vectors (m)

1 2 3

Nominal values (m/deg) y X z 0.5 -0.15 0 0.4 0 0 0 0.2 0 Pitch Roll 0 0 0 0 0 180 Yaw 0 0 0

Calibrated values (m/deg) y z X 4.9647e-1 2.9079e-3 -I.4903e-1 3.9975e-1 1.9099e-3 5.7817e-4 -8.6127e-4 1.0051 e-3 1.9903e-1 Pitch 1.3983e-2 -7.2005e-2 -9.0582e-3 Roll -1.6551 e-1 -8.2925e-2 1.8008e+2 Yaw 8.3171e-2 -1.5142e-1 9.9070e-3

1 2 3

Initial Orientation set U£ (deg)

Table 6.8: End-effector poses before and after calibration

Tip position Nominal values 4.330 127e-1 6.5000e-1 2.5000e-1 4.2722476e-1 6.5018508e-1 2.531 0769e-1 4.2722444e-1 6.50 18405e-1 2.531 0623e-1 0 -1 0

End-effector rotation matrix -1 0 0 -9 .9999914e-1 1.7987616e-4 -1.2983857e-3 -9.9999915e-1 1.7428246e-4 -1.2929769e-3 0 0 -1 1.2975389e-3 -4.6306960e-3 -9.9998844e-1 1.2921556e-3 -4.6325272e-3 -9.9998843e-1

Actual values

-1.8588651e-4 -9 .9998926e-1 4.6304586e-3 -1.80270 19e-4 -9.9998925e-1 4.6322980e-3

Calibrated values

Table 6.9: Geometric parameter errors from the final best fit individual

Joint

1 2 3

Local Body Vectors (m) X y -3.5280e-3 2.9079e-3 -2.4508e-4 1.9099e-3 -8.6127e-4 1.0051e-3

Errors

z 9.7299e-4 5.7817e-4 -9.6915e-4

Zero Reference Orientation set up Errors (de g) Pitch (p) Roll (r) Yaw (s) 2.4404e-4 -2.8887e-3 1.4516e-3 -1.2567e-3 -1.44 73e-3 -2.6428e-3 1.7291e-4 -1.5809e-4 1.4089e-3

78

Basically, the better performance can be expected with a larger population and more generations, although it increases computing time. Figure 6.10 illustrates the different performance for different population and generations. With the same 1000 generations, the final best fitness is improved to 0.0010523, 7.2879xi0- 5, and 5.1947xto- 5 for 100, 150, and 200 populations, respectively. With the same 200 population, the final best fitness is enhanced to 5.1947xl0- 5, and 1.465lx10-5 for 1000 and 1500 generations, respectively.
Best: 0.0010523 Mean: 0.0011444

O.D3
· · Best fitness Mlanfilness

200

4)0

600 Generation

roo

1000

(a) Population 100, Generation 1000;
Best: 7.2379e.005 Me~n: 0.0011399 0.04
· · Best ftness Mean filness

~
u..

~

0.03

.. om
~

~O.Q2

200

400 600 Gererati m

800

1000

(b) Population 150, Generation I 000; 79

Best: 5.1947e-005 Mean: 0.000<¥1433

0.04
Best 1i1ness

.2

.. ..

0.03

·

M!ill flness

... ""

.
c

> ::: 0.02

0.01
oL---~~~._

______________
000 800 1000

0

200

<DO

Generation

(c) Population 200, Generation I 000;
Best: 1. 4651 e-005 M een: 0.00032731 0.03
· · Best ftness
M!an 1ilness

~ 0.02
!§!

i:f

~ G) c

0.01

OOL_--~~~. .-.~. . . . . ..-~~
500 1 oro Generation

150o

(d) Population 200, Generation 1500;
Figure 6.10: Better performance with large populations and generations.

Furthermore, a high crossover probability and a low mutation probability are proved to be more likely to obtain a good performance [61]. Since GA is a stochastic process, each time the program is run, slightly different results are returned. From simulations, it is shown that satisfactory results are generated and enough accuracy of position and orientation is guaranteed after calibration.

80

6.3

Monte Carlo Simulation

In order to reduce the stochastic random error in GA, Monte Carlo simulations (Figure 6.8) in the loop 2 (Figure 5.1) are carried out by repeatedly running GA in loop 1 to calculate the mean values of
~g

until they become stable and fluctuate within certain

bounds. The standard deviations around the mean value are calculated each time when new results are generated from GA, and a convergent pattern is found and illustrated in Figure 6.11.

Since there are 18 parameters for the MRR-1 robot in total, the standard deviations of the mean values for all parameters are plotted together in one chart (Figure 6.11 a) and one of them is clearly shown with 44 iterations (Figure 6.11 b). The final stable mean value of all the best fit individuals from 44 GA runs is calculated and shown in the Table 6.1 0.

Furthermore, in order to obtain a global solution, the Monte Carlo simulation is conducted again repeatedly for 8 random configurations in the robot workspace (Figure 6.8). Random movements for all three joints are generated with a uniform distribution within joint motional bounds (Figure 6.13, 6.14 ). The results in Figure 6.12 show that all the 16 parameters do not fluctuate significantly and remain almost stable in the 8 random configurations over the robot's workspace, which indicates the global property of the solution from Monte Carlo level 1.

81

x 10-

3

Mean Values Deviations
I I I I

x 10"

3

Mean Values Deviations

3~--------------------~
I

2~--~------~----r---~

2.5

.. - - - ~ - - - - - -:- - - - - - i- - - - - - -: .. - - - I I I I

I

I

I

I

1

1.:5 - .. --- t ---- - ~ -- --- -:-- - - -- ~ --- -1 I I I I I I I '"' .... .1. .... "' .... .I ........... .,.I .. . . . . . . . . . . L . . . . . . . . .. I I I I I I I I I I I I I

2

- - - - ; - - .. - - -:- - - .. - I~ - - . . - - ~---I I
I I I I ...... ~ ......................... L .......... I I I I I I I I I I I I
~

........ ..

I I

.... J ............ · ............ L ..........
I I I

J ........ ..
I I I I I I I

0.5 -

...... £ . . . . . . . . . . ~ . . . . . . . . . . . . 1............ L ........ ..

I
I

I
I

I
I

I
I

I

-----·------~-----~----1 I I
I I I

I

1

10

20

30

40

50
Number of Iterations

Number of Iterations

(a)

(b)

Figure 6.11: (a) Standard deviations of mean values of all the parameter errors ~g from

GA; (b) one of the parameters.

Table 6.10: The stable mean value of all best fit individual from GA runs

Joint i

X

2 3

-1.5468941 e-3 -1.1226324 e-3 2.0275948 e-3

y -4.2133711 e-4 9.9691850 e-4 9.1848455 e-4

z
-3.4040037 e-5 3.6835343 e-4 9.1167962 e-4

p

-6.5581664 e-4 -3.7540076 e-005 -2.4716377 e-004

r -2.7366316 e-4 -8.0672008 e-4 1.1293914 e-3

s -3.9937420 e-4 1.3481633 e-3 4.2085826 e-3

82

16 calibrated p~sers in 8 rtndom col'llgunlti(J'lS

1 I I I I ---------~----------£----------~---------~----------~----------~--------' ' '

'

'

'

8
8 con1g..n111:ions

-deltax1 -+-deltay1 -+-deltaz1 -deltap1 -+-deltar1 delta s1 ---e- delta x2 ---e- delta y2 ----e- delta z2 ---e--- delta p2 ---e-- delta r2 ---e- delta s2 delta x3 ----A- delta y3 ----A- delta z3 - A - deltap3 ----8---- delta r3 --6- deltas3

Figure 6.12: 16 calibrated parameters in 8 random configurations.

·~r-----r-----.-----.------r-----.----1?====~
I I I I I

---+-.laniJ

80

................. ~~···---~--------:-·------~-------~------

~~nl::

60

----/

? :o ....Jr_____ i~ 0 ' ............... ,...........
I

i

40 .......i,/......

/

t------- '. . . . . .
I I I

r..... ---- -~- --- . . ·!·'\ ..... ----:- ------- ,. ------- ~---- - I

t- :·~~~ 1- -~=-*------ -~------- t-------:------.
\

\~----~-------t-------~--

0

0

0

-~-------~--

I

6

·::0
·.0
-GO

.................. ~ .....................:............
..,..,..,.., ........ T ..................... , ............

--~----···T···

......... , .................. ...

J
-

'

..,..,~..,..,..,

...... ...

'' - - - - - - -~- - - - - - - -·-------------.
I I

' :------~/:r-=--=--:.:..:.:
- - - - - - . - - - ..._ ....... _- ..... - - - - - ""-. I / I

-eo

-------!------- ~------- . .:. . ------ -~--- :--::."":'! ~...-::.··~---- ~------: : : : "'7 :
a ccntual<nr

··~~.------~--------~------~.~------~;~----~6~------~------~.

Figure 6.13: Revolute joint 1 and 2 random movements for 8 configurations.
Pdnnolc .tcrotl
I I I ··-·---r-------r---····r······-········
0 I

~

~ :;

... ...

~

.

.. o.·
IS

IS 05

' I '

--PIIIIIIIIIc.Jcjnt)

0.3
o~

-------~-----

~

------·--·----~-------~-·-----~----

·~~~~~~·------~----~-------~-------~-------~-0.1 -------~-------~------0
I

---8

I

::

· 8 confguoltcnr

Figure 6.14: Translational displacements of the prismatic joint 3 for 8 configurations.

83

CHAPTER 7

CALIBRATION

CONSIDERING RECONFIGURATION

The chapter is to develop a method to perform calibration when considering reconfiguration for an MRR. A path matrix is introduced to represent the sequence change of modules. A snap point is introduced first before the path matrix. Furthermore, a self-calibration methodology is proposed for future research on MRRs.

7.1

Snap Point

A snap point is the point on the end of each module at which the next module is connected [II]. As shown in Figure 7 .I, the snap point can be regarded as the common point between two adjacent modules. According to Equation (3.41 ), the position of the ith snap point can be expressed as:

(7.1)

Snap Point
si-1

Module i Module i-1

Figure 7.1: Snap point between two adjacent modules.

84

Based on Equation (7 .1 ), snap points can be computed recursively:

(7.2)

where bk and bk' are the body vector representing the kth module in global and local coordinates, respectively, and Si is the vector representing its snap point.

7.2

Path Matrix

The kinematics equations can be generated for a system with the defined sequence of the connecting modules given in Chapter 3. However, for a reconfigurable system, this sequence is subject to change and so is the number of modules. To account for this change, the path matrix [64] is applied. A path matrix is used to define the connectivity of the modules in matrix form as below:

(7.3)

where the rows correspond to the joints as indicated by letter J; the columns correspond to the bodies as indicated by letter B; and the subscript number indicates the body number. The component values of the matrix are either 1 or 0. Tij = 1 if joint i is in the route from Bi to Bj, meaning that the motion of body Bi contributes to that of body Bj. If not in the route, Tij = 0.

85

The matrix given in Equation (7.3) is for the original system shown in Figure 7.2(a). The diagonal values are 1 indicating that the joints are associated with their own bodies. Furthermore, T 12
=

1, as joint 1 is in the route to body 2; T 13

= 1 and T 23 = 1 as joint 1

and 2 are in the route to body 3; the rest are zero. lfthe original system in Figure 7.2(a) is reconfigured to the system shown in Figure 7.2(b), then the path matrix of Equation (7.3) is changed to:

BI B2 BJ

1 0 0 Jl
T= 1 1 1 J2
(7.4)

1 0 1 J3

(a)

(b) (b) Reconfigured connection

Figure 7.2: (a) Original connection

By re-ordering the matrix of Equation (7.4) into an upper triangle form, it becomes:

86

Bz BJ Bl

1 1 1 J2

T= 0 1 1 J'
j

(7.5)

0 0 1 Jl

The sequence of the body indicated by the column headings in the matrix of Equation (7.5) is the true sequence for the reconfigured system.

In general, the relationship between the path matrix and the snap points can be expressed:

(7.6)

where S

=

[sT 1, sT 2, ·.. ST 11 ]T

are the snap points with the number indicating the true
. = [h T 1, h T 2···· h T11 ] T are the vectors of each body With the

sequence of the system; and H

number indicating the body numbers.

In the light of Equation (7.6), the snap points of the original system can be determined as:

(7.7)

For the reconfigured system it becomes:

(7.8)

87

Note that the order of matrix H is changed according to the new path matrix and matched with the column headings. Hence, the utilization of the path matrix provides a means to relate the true sequence of the bodies for calibration of a MRR.

7.3

Simulations

Here is the calibration simulation for the MRR-1 after reconfiguration that corresponds to Figure 7.2(b). Figure 7.3 is the GUI where the sequence of the existing modules in a new configuration can be rearranged. Figure 7.4 illustrates the robot configuration before and after changing the sequence of the modules connection.

Next

Figure 7.3: Simulation when reconfiguration.
Robot Configurations Robot Configurations

y

X

X

Figure 7.4: Robot configuration before and after reconfiguration.

88

Figure 7.5 shows the satisfactory convergent results using GA: the best fitness steadily declines from about 0.005 to 9.4893 x 1o-6 after around 150 generations.

Best: 9.48938-0!li Mean: 0.0030246 0.025 ---------- -;----------- ~-- --------- ~----------- -;----------- ------------- ~
: : : '
I I I

: :
'
I I I
I

: :
'
I I I
I

· ·

Beslflness : Meannness :
I I I I
I

0.02

----------!--- -------- ~----------- ~--- ---------:----------- -~---- ------- ~
I I
I

'
I

I I
I

I I
I I

I I
I

I I
I

I I
I

I I
I

~ 0.015 -----------:-----------:------ -----~----- ------ ~---- ------- -~- ----------:
>
(f:1

I

I

I

I

I

I

ro en

I

I

I

I

I

I

:
I

:
I

:
I

:
I

:
I

:
I

[[

~

0.01

: : : : : : -----------:-----------:-----------:-----------:------------:------------:

I

I

I

I

I

I

0.005 · ----------:-----------:-----------:-----------:---I I I
I

.

:

:
I I I
I

I I I I

:
I I I
I

I I I I

:
I I I
I

I I I I

-------+-----------:
I I I
I

:
I
I

I I I I

:
I I I
I

I I I I

I
I

I
I

I
I

I
I

I

I

I

I

I

0

0

400

500

600

Generatirn

Figure 7.5: GA results for MRR-1 after reconfiguration

7.4

Self-calibration Formulation for MRRs

Assuming there are two fixed and arbitrary points (or targets) in the workspace of an MRR, whose positions p 1 and p 2 are both unknown, but the relative distance between them is precisely provided before the calibration: (7.9)

A pointing tool is rigidly attached on the end-effector of an MRR, such as a laser pointer. Then the MRR is moved and adjusted in order to aim the pointing tool at the two fixed

89

targets one by one; meanwhile, the readings of joint sensors (q 111 ) are recorded for each configuration. Assuming an additional prismatic joint from the pointer tool to the fixed target, the target can be actually treated as the fixed tip of the virtual prismatic joint.

Hence, for the two targets (or virtual tips), their positions can be denoted by
PI=

f (qoJ, go) f (qoz, go)

(7.1 Oa) (7.1 Ob)

P2

=

where q 01 and q 0 z are the nominal joint movements for two targets; and q 0 is adjusted to aim the pointer at the fixed target.

From Equation (7.9) and (7.1 0), the preset distance should be equal to

(7 .11)

However, the recorded readings of all joint sensors (q 111 ) are slightly different from the nominal values (q 0 ), and this leads to the nonlinear fitting formulation of self-calibration, which uses only joint readings without external measuring devices:

(7.12) where
~g

is the set of geometric parameter errors in the robot model, to be identified and

fitted into nonlinear Equation (7.12) to ensure the values of IP1- pzl are close enough to the preset accurate distance d.

90

Moreover, this self-calibration idea might be further extended by setting two full-pose targets, such as three-point targets, which can provide both position and orientation, instead of position only, for fixed point targets. The relative pose (P) of these two pose targets should also be precisely established in advance. The MRR should then be moved to match the end-effector with the preset full-pose targets one by one, and the joint sensor readings should also be recorded in the meantime. Hence, similar nonlinear formulation might be developed: (7.12)

91

CHAPTERS WORK

CONCLUSIONS AND FUTURE

8.1

Conclusions

In this thesis, both linear and nonlinear kinematic calibration methods are investigated and compared for MRRs. Linear position calibration has proved to be a quick convergent method, normally, by less than 6 iterations. However, only the position of the endeffector is considered rather than full-pose accuracy. Linear full-pose calibration appears to be non-robust and susceptible to many aspects during calibration, which may cause divergent and singularity issues. On the other hand, nonlinear calibration using genetic algorithm has been demonstrated to be a robust method, although it usually takes a few minutes to converge to a required accuracy. Both position and orientation accuracies are improved successfully after the nonlinear calibration.

8.2

Contributions

The following contributions are made in this thesis: · Robot kinematic calibration based on the nonlinear formulation is developed and implemented with genetic algorithm (GA). Without using the PRY angles to represent the tip orientation in the nonlinear formulation, it avoids the quadrant sensitivity problem by using the rotation matrix directly. A Euclidean norm, a

92

spectral norm and weighting factors are used to unify the position and orientation errors of the end-effector. · Linear full-pose calibration is discussed in four categories, where some downsides are found. These downsides include quadrant sensitivity problem and

orthogonality sacrifice issues. · Monte Carlo simulation is implemented in the calibration simulations. It includes two levels of Monte Carlo simulation; one in single configuration and another one in 8 random configurations.

8.3

Future Work

First of all, attention should be paid to improve the efficiency of the nonlinear identification with GA, especially for MRR robots with a large number of modules. Some better results identified by the linear formulation may be considered for initial populations. Good initial populations dramatically increase the efficiency of GA. Secondly, although the nonlinear formulation has been proposed by several investigators in similar or slightly different ways, different methods can be found in fitting this nonlinear regression model, such as the Levenberg-Marquardt algorithm, genetic algorithms and neural networks. Hence, another future work would be to compare those different methods through convergence and robustness. Thirdly, a self-calibration approach for MRRs with the formulation in the Chapter 7 should be another important 93

future work to carry out. Last but not least, only simulations were provided to test the calibration methods in this thesis; experiments should be conducted to compare with the simulation results.

94

APPENDIX A

(TAIT) BRYAN ANGLE

(PITCH, ROLL, YAW, PRY) [18]
R( ex)=
0 cos ex

1

0

[

-sin ex cos ex

0

l

0 sin ex

-sinez

cosez
0

o~l

In the body fixed frame

ceycez -ceysez R = sexseycez +cexsez -sexseysez +cexcez -cexseycez +sexsez cexselez +sexcez

r

Relation of PRY with R

95

REFERENCE
[1] American National Standards Institute, "ANSI A15 Standards on Finding Target Features With Optical Equipment." [2] M., Verner, F., Xi, and C., Mechefske, "Optimal Calibration of Parallel Kinematic Machines," ASME Trans. Mechanical Design. Vol. 127, 2005, pp. 62-69. [3] A. Goswami, A. Quaid, and M. Peshkin, "Complete Parameter Identification of a Robot from Partial Pose Information", 1993 IEEE Int. Conf. on Robotics and Automation. [4] [5] J. 0. Berg, Ind. Robot 18, 1991, pp. 29-31. J. M. Hollerbach, "A survey of kinematic calibration," The Robotics Review, 0., Khatib, J. J., Craig, and T., Lozano-Perez (Eds), MIT Press, Cambridge, MA, 1989, pp. 206-242. [6] Z. S. Roth, B. W. Mooring, and B. Ravani, "An overview of robot calibration," IEEE Journal ofRobotics and Automation RA-3, No.5, Oct. 1887, pp. 377-385. [7] B. Liu, C. L. Liang, L. J. Xue, S. H. Hu, andY. S. Jiang, "Calibration of a steward parallel robot using genetic algorithm," Proc. of the 2007 IEEE Int. Conf. on Mechatronics and Automation, Aug. 5-8, 2007, pp. 2495-2500. [8] Engineering Service Inc., http://www.esit.com/frame_ automation.htm 1.

96

[9]

D. Duff, K. Roufas, M. Yim, W. Zhang, and S. Homans, "Modular Reconfigurable Robots in Space Applications," Proc. of the IEEE Int. Conf. on Robots and Automation, Mar. 200I, pp. 235-237.

[IO] N. Bajaj, "Design of a Modular and Reconfigurable Robot for Space and Manufacturing Applications", AER070 Design I Thesis Project - Final Report, Dept. of Aerospace Eng., Ryerson Univ., Apr. 04, 2005, pp. 1, 3-4, I4-I5. [II] S. J. Qiang, "Modeling and Simulation ofReconfigurable Systems with Application to the Polishing Process", MASc. Thesis, Ryerson Univ., 2004. [I2] K. Tomita, S. Murata, E. Yoshida, H. Kurokawa, and S. Kokaji. "Reconfiguration Method for a Distributed Mechanical System", Distributed Autonomous Robotic System, Vol. 2, I996, pp. I7-25. [I3] J. Michael. "Fractal Shape Changing Robot Construction Theory & Application Note", Robodyne Cybernetics Ltd, I995. [I4] M. Yim. "Locomotion with a Unit-modular Reconfigurable Robot", Ph.D. Thesis, Stanford Univ., I994. [I5] C. Unsal, H. Kiliccote, M. Patton, and P. Khosla. "Motion Planning for a Modular Self-reconfiguring Robotic System", Distributed Autonomous Robotic Systems, 4, 2000. [16] R. P. Paul, "Robot manipulators: mathematics, programming, and control," MIT,

97

Cambridge, MA, 1981. [17] B. W. Mooring, A. A. Roth, and M. R. Driels, "Fundamentals of manipulator calibration," Wiley, New York, 1991. [18] F. Xi, "Computational Dynamics lecture notes", Ryerson Univ., Toronto, ON. Canada, c2007. [19] L. J. Everett, M. Driels, and B. W. Mooring, "Kinematic modeling for robot calibration," Proc. of IEEE Int. Conf. of Robotics and Automation, 1987, pp. 183189. [20] B. Karan, and M. Vukobratovic, "Calibration and accuracy of manipulation robot models- an overview," Mechanism and Machine Theory, Vol. 29, No. 3, 1994, pp. 479-500. [21] J. J. Craig, "Introduction to Robotics: Mechanics and Control," Third Edition, Pearson Education, 2005. [22] S. A. Hayati, "Robot Arm Geometric Link Parameters Estimation", Proc. of 22nd IEEE Conf. of Decision and Control, San Antonio, Dec. 14-16, 1983, pp. 14771483. [23] J. Angeles, "On the Numerical Solution of the Inverse Kinematic Problem," The Int. Journal ofRobotics Research, Vol. 4, No.2, MIT, 1985, pp. 21-37. [24] C. Mavroidis, S. Dubowsky, P. Drouet, J. Hinterstreiner, and J. Flanz, "A

98

systematic error analysis of robotic manipulators: application to a high performance medical robot," Proc. of the 1997 IEEE Int. Conf. on Robotics and Automation, Albuquerque, New Mexico, April 1997, pp. 980-985. [25] U. S. Pathre and M. R. Driels, "Simulation experiments in parameter identification for robot calibration," The Int. Journal of Advanced Manufacturing Technology, 1990, pp. 13-33. [26] H. P., Schwefel, "Numerical Optimization of Computer Models", Wiley, New York, 1981. [27] L. E. Scales, "Introduction to Non-Linear Optimization", Springer-Verlag, New York, 1985. [28] F. S., Acton, "Numerical Methods that Work", Harper and Row, New York, 1970. [29] J. Denavit, and R. S. Hartenberg, "A Kinematic Notation for Lower Pair Mechanisms Based on Matrices", ASME Journal of Applied Mechanics, June 1955, pp. 215-221. [30] R. Manseur, "Robot Modeling and Kinematics", First Edition, Da Vinci Engineering Press, 2006. [31] C. Wu, "The kinematic error model for the design of robot manipulators," Proc. of the American control conf., San Francisco, California, 1983, pp. 497-502. [32] C. Wu, "A Kinematic CAD Tool for the Design and Control of a Robot

99

Manipulator", The Int. Jour. of Robotics Research, Vol. 3, No. I, spring 1984, pp. 58-67. [33] B. W. Mooring, "The Effect of Joint Axis Misalignment on Robot Positioning Accuracy", Proc. Computers in Engineering Conf. and Exhibit, 1983, pp. 151-155. [34] T. W. Hsu and L. J. Everett, "Identification ofthe Kinematic Parameters of a Robot Manipulator for Positional Accuracy Improvement", Proc. 1985 Computers in Engineering Conf. and Exhibition, vol. I, 1985, pp. 263-267. [35] R. Ibarra and N. D. Perreira, "Determination of Linkage Parameter and Pair Variable Errors in Open Chain Kinematic Linkages using a Minimal set of Pose Measurement data", ASME Jour. of Mechanisms, Transmissions, Automation in Design, June 1986, pp. 159-166. [36] C. S. Gada, R. Lumia, J. Wood, and G. Starr, "An Automated Method to Calibrate Industrial Robots Using a Virtual Closed Kinematic Chain", IEEE Trans. on Robotics, vol. 23, on. 6, Dec. 2007, pp. 1105-1116. [37] C. Lightcap, S. Hamner, and T. Schmitz, and S. Banks, "Improved Positioning Accuracy of the PAI0-6CE Robot with Geometric and Flexibility Calibration", IEEE Trans. on Robotics, vol. 24, no 2, April, 2008, pp. 452-456. [38] H. Q. Zhuang, L. K. Wang, and Z. S. Roth, "Error-Model-Based Robot Calibration using a Modified CPC Model", Robotics & Computer-Integrated Manufacturing.

100

Vol. IO, no. 4, I993, pp. 287-299. [39] B. W. Mooring and G. R. Tang, "An Improved Method for Identifying the Kinematic Parameters in a Six-axis Robot", Proc. 1984 Int. Computers in Engineering Conf. and Exhibit, vol. I, I984, pp. 79-84. [40] D. E. Whitney, C. A. Lozinski, and J. M. Rourke, "Industrial Robot Forward Calibration Method and Results", ASME Jour. Dynamic Syst., Meas. Contr., vol. I 08, Mar. I986, pp. I-8. [4I] J. Chen, C. B. Wang, and J. C. S. Yang, "Robot Positioning accuracy improvement through kinematic parameter identification", Proc. 3rd Canadian CAD/CAM and Robotics Conf., Toronto, Junei9-22, I984, pp. 4.7-4.I2. [42] J. Chen, and L. M. Chao, "Positioning Error Analysis for Robot Manipulators with All Rotary Joints", Proc. IEEE Int. Conf. Robotics and Automation, San Francisco, April 7-IO, I986, pp. I011-IOI6. [43] H. W. Stone, A. C. Sanderson, and C. P. Neuman, "Arm signature identification", Proc. I986 IEEE Int. Conf. on Robotics and Automation (San Francisco, CA, Ap. I986), vol. I, I986, pp. 4I-48. [44] L. M. Chao, and J. C. S. Yang, "Development and Implementation of a Kinematic Parameter Identification Technique to Improve the Positioning Accuracy of Robots", Robots 10 Conference Proceeding, Chicago, April 20-24, 1986, pp. 11-69

101

- 11-81. [45] M. R. Oriels, and U.S. Pathre, "Significance of Observation Strategy on the Design of Robot Calibration Experiments", Journal of Robotics Systems 7(2), June, 1990, pp. 197-223. [46] C. H. Menq, and J. H. Borm, "Estimation and Observability Measure of Parameter Errors in a Robot Kinematic Model", Proc. Of USA-Japan Symposium on Flexible Automation, pp. 65-70, Minneapolis, Minnesota, July, 1988. [47] J. H. Borm, and C. H. Menq, "Determination of Optimal Measurement Configurations for Robot Calibration Based on Observability Measure", the Int. Journal of Robotics Research, Vol. 10, No. I, Feb. 1991, pp. 5 I -63. [48] E. 0. Doebelin. "Measurement Systems: Application and Design". McGraw-Hill, New York, 1983. [49] G. Duelen and K. Schroer, "Robotics and Computer Integrated Manufacturing", 1991' pp. 223-231. [50] R. P. Judd and A. B. Knasinski, IEEE Trans. Robotics and Automation 6, 1990, pp. 20-30. [51] J. L. Caenen and J. C. Angue, Proc. 1990 IEEE Conf. Robotics and Automation, 1990,pp. 1032-1037. [52] J. F. Jarvis, Proc. 1988 IEEE Int. Conf. Robotics and Automation, 1988, pp. 635-

102

640. [53] M. R. Driels and U.S. Pathre, IEEE Trans. Robotics and Automation, 7, 1991, pp. 351-360. [54] C. H. An, C. G. Atkenson, and J. M. Hollerbach, "Model-Based Control of a Robot Manipulator", MIT Press, Cambridge, MA, 1988, pp. 62. [55] F. Xi, D. Nancoo, and G. Knopf, "Total lease-Squares methods for active view registration of three-dimensional line laser scanning data," ASME Journal of Dynamic Systems, Measurement, and Control, Vol. 127, March 2005, pp. 50-56. [56] D. W., Osborn, and W. S., Newman, "A New Method for Kinematic Parameter Calibration via Laser Line", in Proc. IEEE Int. Conf. Robot Automation, Vol. 2, 1993, pp. 160-165. [57] M. Ikits and J. M. Hollerbach, "Kinematic calibration using a Plane Constraint", in Proc. IEEE Int. Conf. Robot and Automation, 1997, pp. 3191-3196. [58] H., Zhuang, S. H., Motaghedi, and A. S., Roth, "Robot Calibration with Planar Constraints", in Proc. IEEE Int. Conf. Robot and Automation, Detroit, MI, 1999, pp. 805-810. [59] S. Bai, and M. Y. Teo, "Kinematic calibration and pose measurement of a medical parallel manipulator by optical position sensors," Journal of Robotic Systems, Wiley, 2003, pp. 202-209.

103

[60] J. H. Holland, "Adaptation in natural and artificial systems," The University of Michigan Press, Ann Arbor, MI, 1975. [61] D. E. Goldberg, "Genetic algorithms m search, optimization and learning," Addison-Wesley, Reading, MA, 1989. [62] "Help- Genetic Algorithm and Direct Search Box",© 1994-2005 The Math Works, Inc. [63] D. L. Wang, and Y. Bai, "Improving Position Accuracy of Robot Manipulators Using Neural Networks", Instrumental and Measurement Tech. Conf., Ottawa, Canada, 17-19 May 2005, pp. 1524-1526. [64] R. L. Huston, "Multibody Dynamics", Butterworth-Hernemann, 1990. [65] M.P. Groover, "Fundamentals of Modern Manufacturing: Materials, Processes, and Systems", 2002, pp. 87.

104


