Ryerson University

Digital Commons @ Ryerson
Theses and dissertations

1-1-2003

Speed sensorless control of 3-phase induction motor using MRAS speed estimator
Chaozheng Ma
Ryerson University

Follow this and additional works at: http://digitalcommons.ryerson.ca/dissertations Part of the Electrical and Computer Engineering Commons Recommended Citation
Ma, Chaozheng, "Speed sensorless control of 3-phase induction motor using MRAS speed estimator" (2003). Theses and dissertations. Paper 199.

This Thesis Project is brought to you for free and open access by Digital Commons @ Ryerson. It has been accepted for inclusion in Theses and dissertations by an authorized administrator of Digital Commons @ Ryerson. For more information, please contact bcameron@ryerson.ca.

SPEED SENSORLESS CONTROL OF 3-PHASE INDUCTION MOTOR USING MRAS SPEED ESTIMATOR

by

CHAOZHENG MA

A project presented to Ryerson University in partial fulfillment of the requirement for the degree of Master of Engineering in the Program of Electrical and Computer Engineering. Toronto, Ontario, Canada, 2003

©Chaozheng Ma, 2003

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

UMI Number: EC52891

INFORMATION TO USERS

The quality of this reproduction is dependent upon the quality of the copy submitted. Broken or indistinct print, colored or poor quality illustrations and photographs, print bleed-through, substandard margins, and improper alignment can adversely affect reproduction. In the unlikely event that the author did not send a complete manuscript and there are missing pages, these will be noted. Also, if unauthorized copyright material had to be removed, a note will indicate the deletion.

®

UMI
UMI Microform EC52891 Copyright 2008 by ProQuest LLC. All rights reserved. This microform edition is protected against unauthorized copying under Title 17, United States Code. ProQuest LLC 789 E. Eisenhower Parkway PO Box 1346 Ann Arbor, MI 48106-1346

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Instructions on Borrowers
Ryerson University requires the signatures of all persons using or photocopying this project. Please sign below, and give address and date.

I i
i

I

i

I

i

I

'I

S

I I

I

iii

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Abstract
This project investigates the application of model reference adaptive system (MRAS) for the speed sensorless control of an induction motor. The rotor speed can be accurately estimated by employing the closed-loop observer named reactive MRAS. Therefore, this observer eliminates the need of a speed sensor for the control of the motor speed. The method is robust to stator and rotor resistance variations due to change of temperature. The dynamic system equations of the induction machine are formulated, and the motor control system performance is studied. Both scalar voltage-to-frequency 011f) control and vector field oriented control (FOC) schemes, implemented using digital signal processor (DSP), are investigated. The design of the speed sensorless DSP-based controller is completed. Software packages have been developed to implement the design. An experimental system using the proposed controller has been built. Various tests have been conducted to verify the technical feasibility of the control technique. The experimental results confirm the feasibility of the proposed speed sensorless VIf control scheme using MRAS speed estimator. The designed VIf profile has been tested. Even with step change of the load or that of the command speed, the system can achieve the correct steady state after a short transient operation. The experimental results also confirm the feasibility of the proposed speed sensorless FOC control scheme using MRAS speed estimator. The current regulators meet the design requirements. Both the flux-producing current component and the torque-producing current component can be controlled separately. In the implementation, digital signal processor (DSP) TMS320 FL2407 and voltage source inverter (VSI) Skiip 342GD120-316CTV are employed. The modular strategy is adopted to develop the software package.

iv

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

,
Acknowledgments
I would like to express my sincere gratitude and appreciation to Professor Richard

I

Cheung, my supervisor, for his guidance throughout the entire period of this degree program. I also sincerely thank Professor Bin Wu, Dr. S. Wei, Dr. D. Xu and my classmates for their valuable suggestions and help. I thank Ryerson University for the Scholarship.

My special appreciation is extended to Ms Shuping Yang, my wife, for her support.

v

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Contents
1 Inctroduction 1 1.1 Conventional Speed Control Schemes for Induction Motors .............................. 2 1.2 Improved Speed Sensorless Control Schemes for Induction Motors ..................... .3 1.3 Project Objectives ............................................................................... 5 1.4 Project Outlines............................................ ; ...................................... 6 2 MRAS-Model Reference Adaptive System 7 2.1 3-phase to 2-phase Transformation ......................................................... 7 2.1.1 Clarke Transforation of (a,b,c) to (0.,(3) ............................................... 8 2.1.2 Park Transformation of (0.,(3) to (d,q) ................................................ 9 2.2 Dynamic Model ofinduction Machine............................................ '" ...... 10 2.3 MRAS Speed Estimator ..................................................................... 12 2.3.1 Reference ModeL ..................................................................... .12 2.3.2 Adaptive Model. ........................................................................ 13 2.4 Per Unit, Discrete time representation ................................................... 14 2.5 Implementation ofMRAS .................................................................... 16 3 Vlf Control of Induction Machine Using MRAS 17 3.1 Background for V/fControl ofinduction Machine ..................................... 17 3.2 VIf Control ............................................. . .................................... .19 3.3 Implementation ofV/fControl.. ............................................................. 21 3.3.1 The Hardware Organization .......................................................... 21 3.3.2 The Softtware Organization .......................................................... 24 3.3.3 Debugging of the Software ........................................................... 27 3.3.4 Other Considerations ............................................................ ~ ..... 30 3.3.4.1 Numerical Considerrations .....................................................30 3.3.4.2 The VIf Profile Design .......................................................... 31 3.3.4.3 Slip Speed PID Controller Design............................................... 32 3.3.4.4 Load Design ...................................................................... 33 4 Field Oriented Control Using MRAS 35 4.1 Space Vector Pulse Width Modulation................................................... 35 4.2 Backgroud ofFOC Control ofinduction Motor ......................................... 38 4.3 The Basic Scheme for the FOC ............................................................ 39 4.4 Proposed Speed Sensorless FOC Control Scheme Using MRAS ................... .40 4.5 Software Implementation of the Proposed FOC Scheme .............................. .43 5 Experimental Results 4S 5.1 Speed Identification Using the Proposed MRAS Estimator............................ .45 5.2 Open Loop Speed V/fControl ............................................................. .47 5.3 Closed Loop speed V/fControl.. .......................................................... .48

vi

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

1
i
I
~

5.4 Open Loop Speed FOC Control ............................................................ 52 5.5 Summary ........................................................................................ 54

I I

~

Ii:

6 Conclusions 56 6.1 Main Work in This Project. .................................................................. 56 6.2 Suggestions for Furthue Work............................................................... 58 Bibliography 60

Appendix A The Parameters of the Induction Machine
I

62

I

AppendixB Software Package for Vlf Control AppendixC Software Package for FOe Control

63
106

vii

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

List of Symbols
[Motor parameters] Stator resistance.

rr: LIs,LIr :
L1 :

Rotor resistance refered to stator side Stator and rotor leakage inductance Total stator and rotor leakage inductance (= Lis + L1r ) Mutual inductance Stator self inductance (= Lm + Lis) Rotor self inductance (= Lm + L1r ) Leakage coefficient (=l-L m2/ Ls Lr) Rotor time constant (= Lr / rr)

Lm: Ls: Lr :

a:

[Variables in an a-p stationary frame] vsa , vsp: a and p axis components of stator voltage
i sa ' isp : ira ,irp:

a and p axis components of stator current a and p axis components of rotor current a and f3 axis components of stator flux a and f3 axis components of rotor flux

Iff sa ,Iff sp : Iff ra , Iff rp :

[Variables in an d-q rotating frame] i d , iq : d and q axis components of stator current

9, theta:

Rotor flux position.

[Velocities, electric angle and torque] n: Rotor speed (rpm) (i) r : Rotor angular speed Synchronous angular speed Rotor Slip angular speed [Subscripts]

p:
s,r: *, ref: fdb: est:

Derivative operator(=dIdt) Symbol of stator and rotor, respectively. Reference or setting value. Feedback value in a closed loop. Estimated value.

I

viii

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Chapter 1 Introduction

I

Induction motors are relatively economical and reliable machines because they are built without slip rings and commutators compared to dc machines. However, the use of induction motors may have several disadvantages, which include control difficulty due to the motor nonlinear behavior with saturation effects and the electrical parameter variations with temperature. To overcome this difficulty, much attention has been given to the control of induction motors for starting, braking, speed reversal, speed change, etc. Several techniques of controlling an induction motor have been proposed, such as voltagelfrequency (VIf) control and field oriented control (FOC). VIf control is a scalar control, where the ratio of the supply voltage and frequency is maintained constant with the exception that at low speeds the machine flux level is kept constant. FOC control is a vector control, where the flux and the torque are controlled separately [1-5].

Usually a speed sensor is required in the closed loop operation for both VIf control and FOC control. The speed sensor or tachometer is mounted on the motor shaft. However, the shaft encoder may present problems. Delicate critical encodes with internal signal electronics are used, which lower the reliability of the motor system, especially in hostile environments, that requires careful arrangements with special attention to electrical noise. There are situations where the positional feedback is extremely difficult to obtain [3]. In addition, the sensor is cost factor as the provision of special motor-shaft and encode-

I I

mounting surfaces leads to more expensive machine control systems. The elimination of the speed sensor has been one of the important features in the modem motor control systems. This project presents a novel method of controlling the speed of induction . motors without the speed sensor. The information of the rotor speed can be obtained by processing the stator voltages and currents measured at the motor terminals. The rotor

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

speed is estimated by employing a closed-loop observer named model reference adaptive systems (MRAS). In MRAS, a comparison is made between the outputs of two observers. One observer does not involve the rotor speed to be estimated, and one does. A scheme is based on the instantaneous reactive power that maintains the magnetizing current [8]. This approach is also called reactive power MRAS. The method is robust to stator and rotor resistance variations due to temperature changes. This project investigates the MRAS speed estimation technique in the implementation of speed sensorless system for scalar voltage-to-frequency (Vlf) control and vector field orientation control (FOC) of induction motors.

This chapter provides an introduction of the control method developed in this project. Sectionl.l introduces the conventional speed control schemes for induction motors. Sectionl.2 discussed the improved speed sensorless control schemes for induction motors using MRAS technique. Section 1.3 presents the objectives of this project. Section 1.4 provides the structure of this project.

1.1

Conventional Speed Control Schemes for Induction Motors

A typical VIf contro,1 scheme is shown in Figure 1-1.

Slip

controller

Motor

Speed sensor

Figure 1-1: Constant VIf Speed Control with a Speed Sensor

2

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

In Figurel-I, the speed of induction motorliJr is sensored and compared with the reference speed liJ; to calculate the compensated slip. The synchronous speed liJ;yn is computed from the compensated slip and the rotor speed. The relationship between the supply voltage and frequency is maintained linear except at low speeds in order to keep the machine flux level constant and close to its nominarvalues for various motor operating conditions. Constant VIf control techniques are based on static models of the induction motor for the constant flux operation. The VIf control is one of the scalar control techniques [1].

Vector control techniques have made induction motors suitable for high performance applications where traditionally only dc motors are used. The field orientation control is a vector control. In this control, the flux and the torque are controlled separately. A rotor flux oriented vector control scheme is shown in Figure 1-2 [9].

In Figure 1-2, the measured induction motor current signals are converted to two coordinate current signals, id and i q , using the Clark's and Park's transformations. The resulting two dc quantities are compared with the reference d-axis and q-axis components,

idref and iqref · The output of the inverse Park module "I-Park" is used to generate the
pulse width modulation (PWM) signals for turning onloffthe switches in the inverter that drives the motor. A speed sensor is used to measure the motor speed that provides the speed feedback information for the control of the induction motor.

1.2 Improved Speed Sensorless Control Schemes for Induction Motors
This project addresses the real-time control of induction motors combined with MRAS speed estimator. The speed of the induction motor is computed using MRAS estimator. This control scheme has improved the conventional speed control schemes discussed in Section 1.1. This control is implemented in the Power Electronic Laboratory at Ryerson University. The improved speed sensorless V/fand FOC control structures using MRAS technique are shown by Figurel-3 and Figurel-4, respectively.

3

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Voc
iqrej'

+

-

PI PI

V nrDr

Va

i~

I-Park
V Jror · VR

SV

PWM

3-phase Inverter

iQ id

+
Park
T.

t

ia
Clarke

ia
T.

~

ip

ih

e
Cur_M

-

l-l
(iJr

~

Motor
Sp :ed sensor

Figure 1-2: A Conventional FOC Control Scheme with a Speed Sensor The main contribution ofthis project consists of achieving the sensorless control by using MRAS speed estimator in a digital signal processor (DSP) controller. A DSP is especially employed to implement the motor control schemes. The performance of an induction motor strongly depends on the characteristics of its control. DSP can be used to enhance the real time control of induction motors without the need of any electromechanical speed sensor. This reduces the number of components used in the conventional drives and optimizes the design to reduce overall drive system cost. A fixed point DSP TMS320LF2407 from Texas Instrument is used in the implementation. Structured software modules are used to build the control system. The software modules are written in assembly languages.

Slip controller

MRAS speed estimator Motor

Fig.1-3: Sensorless Speed V/fControl Scheme Using MRAS Estimator

4

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

PWMI-6

CFOCM

Inverter

(j)

i

MRAS speed estimator Motor

Figure 1-4: Sensorless Speed FOC Control Scheme Using MRAS Estimator Note that CFOCM in Figure1-4 represents the conventional FOC module illustrated in the dot-lined part of Figure 1-2.

1.3 Project Objectives
The main objective of this project is to use DSP to implement the improved speed sensorless control schemes for induction motor drive. Both scalar VIf control and vector FOC control schemes are investigated. MRAS technique is used to estimate the motor speed such that a speed sensorless three-phase motor control is achieved. More specifically, the following research is conducted:

1- The speed estimation technique MRAS is studied. An induction model is used to determine the performance ofthe induction motor. Differential equations are developed to describe the principle of the MRAS speed estimator. The relevant variables are studied to improve the performance of the MRAS speed estimator. The aim is to eliminate a speed sensor normally required in the control of an induction motor. 2- Both speed sensorless scalar Vlf control and vector FOC control schemes are implemented.

5

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

3- Several different test conditions, including a step change in speed command and an abrupt change in load, are carried out to verify the proposed control method and to demonstrate the system performance. 4- An experimental system including a self-excited induction generator used as the load for the controlled prime motor is built. 5- Software written in assembly languages is developed for the control of induction motor. The software is reliable and flexible for future development.

1.4 Project outlines
The structure of this project is as follows: Chapter 2 describes the modeling of an inductor motor. The MRAS technique is formulated, and the variables are determined. Chapter 3 describes the details for the proposed VIf control using MRAS technique. The design considerations are presented, and the control strategy is discussed. Software package is developed, and software flow chart is illustrated. The experimental system for this' improved VIf control is built. Chapter 4 presents the details for the proposed FOC control using MRAS technique. Chapter 5 shows the experimental results and demonstrates the achieved performance. Chapter 6 provides the conclusions and suggestions for future studies.

6

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Chapter 2 MRAS-Model Reference Adaptive System
MRAS is an approach to estimate induction motor speed from measured terminal voltage and currents for speed-sensorless motor control. It is based on computation of the instantaneous reactive power that maintains the motor magnetizing current [8,11]. The technique is simple, robust to variations of motor parameters due to operating conditions. This approach is not dependent upon the knowledge of the values of stator resistance, nor is it affected by stator resistance thermal variations. In this chapter, the 3-phase to 2phase transformation is introduced ftrst. Then a general description of the model of induction machines in the (a,(3) stationary reference frame is presented. Equations of MRAS estimator of motor speed are derived, and its application to induction motors is discussed.

2.1 3-pbase to 2-pbase Transformation
The three-phase voltages, currents and fluxes of induction motors can be analyzed in terms of complex space vectors. With regard to the currents, the space vector can be defmed as follows. Assume that ia ,ib and icare the instantaneous currents in the stator phases. Then the complex stator current vector i~ is defmed by: (2-1 ) where a

=e

J~K
3

and a 2

=e

JiK
3

represent the spatial operators. Figure 2-1 shows the

complex space vectors of stator currents:

7

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

a

Figure 2-1: Stator Current Space Vector and its Components in (a,b,c) where (a,b,c) are the three phase axes. This current space vector, which represents the three phase sinusoidal system, could be transformed into a two time invariant coordinate system by the following two steps .

·

(a,b,c)=>(a.,~):

Transform the three-phase system into a two-phase system where the

orthogonal coordinate system is time varying. This transformation is crucial to the MRAS technique, which will be discussed in this chapter. ·
(a.,~)=>(d,q):

Transform the time-varying system into time-invariant system. This

transformation is crucial to the field oriented control, which will be discussed in Chapter

4.

2.1.1 Clarke Transformation of (a,b,c) to (0.,13)
The space vector can be expressed in a reference frame with only two orthogonal axes called (a.,~). It is assumed that the axis "a" and the axis "a." are in the same direction as shown in Figure 2-2. This transformation is also called Clarke transformation. Since in a three-phase balanced system, the sum of three phase currents ia + ib + ic = o. The two-phase (a.,~) currents can derived as follows.

ia = ia ip =(ia+2ib)/.J3
(2-2 )

8

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

b

a=a

Figure 2-2: Clarke Transformation If the three phase currents are assumed as:

ia = I sin(lVt) ib = I sine lVt + 21Z" / 3) ic = Isin(lVt-21Z"/3)
then the output (0.,(3) currents are: (2-3 )

ia

= I sin(lVt)

ip = Isin(lVt+1Z"/2)

(2-4 )

2.1.2 Park Transformation of (a,J}) to (d,q)
Park transformation is used to change the two-phase orthogonal system (0.,(3) into (d, q) rotating reference frame. This is the most important transformation in the FOC control which will discussed in the Chapter 4. With the d axis aligned with the rotor flux, Figure 2-3 shows the relationship of the two reference frames:

9

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

q

ia

a =a

Figure 2-3: Park Transformation In Figure2-3 Q is the rotor flux position. The flux and torque components of the current vector are determined by the following equations:

id =ia cosO+ip sinO

iq = -ia sinO + ip cosO

(2-5 )

These components depend on the current vector (0.,13) components and on the rotor flux position.

The (d,q) system has the following characteristics:

· It is a two-coordinate time-invariant system, where both id and iq are DC quantities.
· The current id is a flux-related component and the current iq is a torque-related component.

2.2 Dynamic Model of Induction Machine
To implement the MRAS, an appropriate model of induction motor is required. The model proposed in [10] is taken into consideration. Figure 2.4 shows the fundamental induction motor model in the (0.,13) stationary reference frame. An induction machine model that is used by complex space vectors relies on the sinusoidal distribution. Space harmonics are not considered, and the model is called fundamental model [4].

10

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

rs
+

( a)
rs

+
-OJ r

f// ra

(b)

Figure 2-4: The Equivalent Circuit oflnduction Machine Model in (a,~) Stationary Reference Frame. The related stator and rotor voltage equations in the stator frame are [4]:

Vsa V sp

= rsisa + = rsisp +
+ +

d If/ sa dt d If/ sp dt

(2-6 ) (2-7 )
(J) If/ r rp

o = rrira o = rrirp

d If/ ra dt d If/ rp dt

+

(2-8 ) (2-9 )

- (J) rlf/ ra

where (J)r is the angular velocity of the rotor, the flux linkage equation are:

= LJsa + Lmira If/sp = Lisp + Lmirp If/ra = Ln,isa + Lrira If/rp = Lmisp + Lrirp
If/s a

(2-10 ) (2-11 ) (2-12 ) (2-13 )

Equations (2-6) to (2-13) are used by MRAS to compute the reactive power in the reference model and that in the adaptive model of MRAS.

11

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

2.3 MRAS Speed Estimator
MRAS is based on the comparison between the outputs of two observers. The observers are used to calculate the instantaneous reactive power maintaining the magnetizing current [8, 11]. Figure 2-5 illustrates the structure of MRAS for speed estimation.
V'"

V,o

iw
iro

Reference Model

q

---

6
A

&

Adaptive Model

q

A

Wr

I
I

K + K, p s-

l

I

Figure 2-5: Simplified Block Diagram of Reactive Power MRAS Speed Estimator The input data required for this model is the stator voltages and stator currents in the (a,p) stationary reference frame. Two sets of equations are developed to compare reactive power of the induction machine in the reference model and the adaptive model. The reference model does not involve the rotor speed, while the adaptive model needs the estimated rotor speed to adjust the computed reactive power to that computed from the reference model. The upper portion of Figure 2-5 serves as a reference model while the lower one as an adaptive model. The error between two models is used to drive a suitable proportional integrator (PI) controller, which generates an estimated rotor speedmr.

2.3.1 Reference Model
The active power in the reference model is computed from cross product of the stator currents and the counter electromotive force (emf). The counter emf is derived from Equations (2-6), (2-7), (2-10) and (2-11). They can be expressed as follow.

12

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

r
~

. L d~ ~ e ma =~~ =V -ri -aL ~ L dt sa s sa s dt
/'

(2-14) (2-15) (2-16)

L
where
(j

2

= 1- _m_, leakage coefficient. The stator currents,

LSL,.

( 2-17 )
The reactive power q , which represents the instantaneous reactive power that maintains the magnetizing current, can be computed from the following equation:

(2-18)
The reactive power in (2-18) can be further derived as:

(2-19 )

2.3.2 Adaptive Model
The active power in the adaptive model is computed from cross product of the stator currents and the estimated counter electromotive force (emf). The estimated counter emf is derived from Eq. (2-8) to (2-13). They can be expressed as follow.

A

m lma m ( e ma = --= - -, (JJI· -I· + I. ) L dt L I' mp ma sa
I'
A

L

2

d·

L

2

A

,.'1'
1/1

(2-20 ) ( 2-21 ) (2-22 )

emp

m mp =---=- -

L

2

di

L

2
( -'I'

A

(JJlma -Imp

·

·

LI'

dt

LI"r

+ lsp

.)

13

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

where

Tr

= L,. / r,. is rotor time constant. The currents

ima,i mfJ

can be computed from

following equations:

(2-23 ) (2-24 ) After the estimated counter emf, em, is computed by using (2-20) to (2-21), the estimated reactive power can be computed as follows. (2-25 ) The voltage model of equation (2-19) does not involve rotor speed OJr , while the current model of equation (2-25) does .The speed can be estimated based on the output difference between these two models.
A

OJ r

= (k p +-')&
S

K.

(2-26 )

where

&

=q -

q.
OJr

The above PI controller tunes the estimated rotor speed

such that the reactive powerq,

generated by adaptive model, matches that q generated by reference model. From equations (2-19), (2-25) and (2-26), it is evident that the speed estimation system of Figure2-3 is robust to the stator resistance, and thus is not affected by the stator resistance thermal variations.

2.4 Per Unit, Discrete Time Representation
For implementation on DSP-based system, the differential equations given in Section 2.3 need to be discretized. For generality, per unit (PU) values are used in all equations. The reactive power MRAS can be expressed in the following.

14

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

r
~

Reference Model:
According to equation (2-19), and using backward approximation with the sampling period T, then . (k) (k) . (k) (k (. isp (k)-isp (k-l) q(k)=lsa vsp -lsp vsa )-aLs lsa(k) T

I·

sp

(k)(\·a(k)-i~a(k-l»)2_27) T

Equation (2-27) can be further simplified as follows: (2-28 ) Dividing equation (2-28) by base power of Vb1b and rearranging the resulting equation the per unit representation is as follows:

(2-29 ) where K\ = aLJb ,Vb is base voltage, and Ib is base current. TVb

Adaptive Model:
In same way as in reference model, equation (2-25) is discretized as follows: (2-30 ) and equation (2-21) to (2-24) can re-written in per unit representation as: ema (k) = K2 (-K3 OJ, (k)imp(k) - ima (k) + isa (k» emp (k) = K 2 (-K3 OJr (k)inra (k) - imp (k) + isp (k))
,,2

(2-31) (2-32) (2-33) (2-34)

ima(k) = ima(k -1)( -K4 (OJ (k) + K 5 ) -imp(k -1)OJ(k)K6 + isa (k)K7 imp(k) = imp (k-l)( -K4 (OJ (k) + K 5 ) -ima(k -1)OJ(k)K6 + isp (k)K7
" 2
"-

"

15

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

where:
-~

~-

After i ma (k) and imP (k) in per unit are calculated from (2-33) and (2-34), the counter emf can be computed by using (2-31) and (2-32). Then per unit estimated reactive power in adaptive model can be simply calculated from (2-30).

2.5 Implementation of MRAS
To implement the discussed MRAS technique in motor control drive, some motor parameters are needed. The parameters consist of: · · · · · Number of poles Rotor resistance (rr) Stator leakage inductance (Lsi) Rotor leakage inductance (L rl ) Magnetizing inductance (Lm)

The base quantities are: · Base current (Ib) · Base voltage ( Vb ) · Base electrically angular velocity «(1)b ) · Sampling period (T)

In summary, the 3-phase to 2-phase transformation has been introduced. The general description of the model of induction machines in the (a,~) stationary reference frame has been presented. Equations ofMRAS estimator of motor speed have been derived, and its application to induction motors has also been discussed in this chapter.

16

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

,
I
i
i

I

~-

f

Chapter 3 V/fControl of Induction Motor Using MRAS
Constant VIf control techniques are based on the static models of the induction motor for the constant flux operation. The VIf control is a scalar control. This chapter deals with the scalar VIf control of three-phase induction motors using DSP eZdspTM LF2407. This chapter explains in detail the hardware and software configuration. This chapter presents the techniques to implement the speed sensorless VIf control system for induction motor drive using MRAS speed estimator. An experimental system is built to validate the designed drive performance.

f
i
f

3.1 Background for Vlf Control of Induction Machine
In the VIf control, the speed of induction motor is controlled by adjusting both the magnitude V and the frequency

f

of the stator voltages in such a way that the air gap

flux is always maintained at the desired steady-state level [11]. Figure 3-1 shows the steady-state equivalent circuit of an induction machine. In the figure,
Xis'

xlr andx m

represent the stator leakage impedance, the rotor leakage impedance and the mutual impedance, respectively. r s' !....r..-, vsand Em represent the stator resistance, equivalent s rotor resistance, stator voltage and the counter electromotive force ( emf), respectively.

XIII

!..L
s

Figure 3-1: Equivalent Circuit of Induction Machine

17

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

If the voltage applied to a three-phase induction motor is sinusoidal, we have, at steady state, the enifand the air gap flux can be expressed as:

(3-1 )
where Ns is number of turns,

Is is stator frequency, and 'If

is air gap flux.

( 3-2 )

( 3-3 )

(3-4 ) where Vs is the magnitude of the stator voltage. From (3-4), it follows that if the ratio Vs / Is keeps constant for any change in the supply frequency Is for the speed control of an induction motor, then the motor flux remains constant and the torque becomes independent of the supply frequency.

Since the stator flux is maintained to be constant, the torque developed depends only on the slip speed. This is shown in Figure 3-2. Therefore by regulating the slip speed, the torque and speed of an induction motor can be controlled using the constant V/ I method.

Slip speed Figure 3-2: Torque vs. Slip Speed of an Induction Motor with Constant Flux

18

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

In a practical implementation, the ratio ofthe stator voltage magnitude to frequency is usually based on the motor rated parameters. However, in case of the frequency, and hence the stator voltage, is low, the voltage drop across the stator resistor and leakage inductance cannot be neglected and must be compensated. On the other hand, when the frequency is higher than the rated value, maintaining constant Vs I Is means exceeding rated stator voltage and thereby causing the possibility of voltage insulation problem. In order to avoid this, constant VI I principle is also violated at such frequencies. Basically, there are three speed ranges in the VI I profile: stator voltage drop compensation region, linear region and field weakening region. A typical Vllprofile is illustrated in Figure 3-3.

~ale

1--------,.---,

compen. region

field weakening region

I
linear region

o

hate

Figure3-3: Voltage vs. Frequency Profile

3.2 V/ f Control
To precisely control the speed of the induction motor with a load, a closed-loop V/f control is needed. Since the frequency of the stator voltage represents the synchronous speed but not the real speed of the motor, a slip speed exists. At no load condition, the slip is very small. As the load increases, the slip also increases. The slip controller is needed for speed regulation. A typical V I I control with a speed sensor has been shown in Figure 1-1, and for convenience, it is re-shown in Figure 3-4. In Figure3-4, the speed of induction motormr is measured using a sensor and compared with the reference speedm; to calculate the compensated slip. The synchronous speed m.:yn is computed from the compensated slip and the rotor speed.

19

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

r I
Slip controller

+

Speed sensor

Figure 3-4: Constant VI jSpeed Control Scheme with a Speed Sensor The speed of the induction motor can be estimated by MRAS estimator. The synchronous
speedaJ~n

can be computed from the compensated slip and the reference rotor speed. As

shown in Chapter 2, MRAS estimator consists of two models: the reference model and the adaptive model. The reference model does not involve the rotor speed, while the adaptive model needs the estimated rotor speed to adjust the computed reactive power to that computed from the reference model. The error between two models is fed to a PI controller, which generates an estimated rotor speedaJr · Figure 3-5 shows the proposed speed sensorless VI j control scheme using MRAS technique. The detail will be discussed in this Chapter.

51 i P control I er

MRAS speed estimator
Mltor

Figure 3-5: Sensorless Speed VlfControl Scheme Using MRAS Estimator

20

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

3.3 Implementation of Vlf Control
This section discusses the implementation details, which include the organization of hardware and software. Debugging of the software is also addressed.

3.3.1 The Hardware Organization
Figure 3-6 shows an overview of the hardware required to implement the control scheme illustrated in Figure 3-5. DSP is the core ofthe control system. Three analog to digital converter (ADC) channels of DSP are used to sense stator currents ( ia , ib ) of the motor and the bus DC voltage Vnc of the voltage source inverter (VSI). The DSP uses their measured values to estimate the rotor speed. Six PWM output signals from the DSP are used to drive the VSI and implement the VIf control of an induction motor. An isolated transformer is employed to isolate the VSI from the utility. In the commissioning phase, a variac is also employed to increase the input AC voltage of VSI step by step.

Isol at or Transforl11lr

!liP

Level
Shi fter

VSI

Figure 3-6 Experimental Setup for Sensorless Speed Control System The major hardware components used in the experimental system are given as follows.

1- eZdsp TMLF2407 Board

21

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

eZdspTM LF2407 is the platfonn to develop and run software for the TMS320LF2407

digital signal processor (DSP). It allows the verification ofLF2407 code. With 64K words of onboard program/data RAM, it can solve a variety of problems. Its three expansion connectors are provided for any necessary evaluation circuitry not provided on the configuration. The C2000 Code Composer driver is used to simplify code development and shorten debugging time. Figure 3-7 shows its block diagram.

EX.
P6

P1 / P7 SRAM
64k

x 16 Program
IlIta
DDRESS

TMS32rLF2407

EX.
P9

PARALLEL
PCRT/JTAG
CCNI1UlER

P2
/ P8

Figure3-7: Block Diagram eZdspTM LF2407 The eZdspTM LF2407 board has the following features: · DevelopmentlEmulation environment: Code Composer (CC) C'2000 supports real-time debugging. · Onboard 7.3728-MHz oscillator for 30 MIPS operating speed. · Power by a 5-volt power supply. · 0 to 3.3V input and output signal · 16 channels of Analog to Digital interface, no Digital to Analog interface. · 16 channels of PWM interface connector

In the design of control scheme, DSP related settings are as follows.
· PWM frequency/period: 5kHzl200f.1s.

22

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

· PLL: 4.

· pWM mode: symmetrical with dead band 1.2f.ls.
· Interrupts: Tl underflow · Peripheral Usage: Timer!, PWM 1-6, 3 ADC channels

2- Voltage Source Inverter (VSI)

The power electronic inverter module Skiip® 342GD120-316CTV is employed to supply power to the motor. The inverter switches are rated at an input voltage (VCES ) of 1200V and a maximum line current of 120A. The inverter module consists of two parts. The first part of the inverter circuit is used to rectify AC power to DC power. The second part of the inverter circuit converts the DC power to the required AC power for motor operation using six power IGBTs driven onloffby the DSP controller.

3-Isolation Transformer

The inverter is isolated from the utility power system using a transformer. The rated power ofthe transformer is 23.4kVA, and the rated current is 28A.

4- Personal Computer

The PC is connected with DSP board through RS232 port. It has been installed with Code Composer (CC) C'2000 which is used to build, compile, debug and run the required software.

5- The Voltage Sensor and Current Sensor
The VIf control needs measuring the VSI dc bus and the two phase currents as input signals to the DSP controller. In the implementation, the current transducers (LEM type,
+1-lOA) measure the two currents and the voltage transducer sense the DC voltage. Since

the input and output signals of the DSP has the range of 0 to 3.3V, the output signal of

23

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

the sensors must therefore be adjusted to the same range. Since the output signal of the current sensors can be either positive or negative, 1.65V analog offset is required in order to allow the single voltage analog-to-digital converter (ADC) module to read both positive and negative values. To filter the harmonic components, a R-C filter is connected before AD conversion. The resistance is selected to 2kQ, and the capacitance is 0.1 IlF. The block diagram below shows of the implementation of current sensor.
1.65V Offset
LEM

Figure 3-8: Current Sensing Interface Block Diagram

6- Level Shifter

The output PWM signals of the DSP used are 3.3V. Since the switching signal of the IGBT needs 15V, a voltage-level shifter is required to amplify PWM signals. The chip MC14504 is used to implement the amplification (voltage level shift).

7- Induction motor

The induction motor used in this project experiments is a squirrel cage three phase Yconnected motor from TEeD-WESTINGHOUSE. The parameters and rated values of this motor are listed in Appendix A.

3.3.2 The Software Organization
The modular strategy is adopted in the development of the software package for the control of induction motor [15]. The standard modules are investigated and have been modified to meet the objective ofthis project [10]. DLOG_VIEW module [7] is employed to display two graphical waveforms in real time. The package consists of the

24

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

initialization module and the run module, which are written in assembly language. The former is performed only once at the beginning of operation. A typical incrementalsystem-build process is developed in this module to reduce the debugging time. There are five phases for debugging in the main program. The second module is based on a waiting loop interrupted by the PWM underflow. The complete VIf algorithm is computed within the PWM Interrupt Service Routine (ISR).

The DSP Controller Full Compare Unit is used to generate the necessary pulsed signals to the level shifter board. The phase lock loop (PLL) unit is set to 4, so that the CPUCLK runs at 30MHz. It is programmed to generate symmetrical complementary PWM signals at a frequency of 5kHz, with the timer TIMERI as the time base and with the dead time of 1.2IJs. The sampling period (T) of 200 IJS can be established by setting the timer period TIPER to 3000 (PWMPRD=3000). Figure 3-9 illustrates the time diagram for the initialization and the operating system. Figure 3-10 illustrates the software flowchart. Figure 3-11 depicts the software modules for the VIf control system as follows. The software modules meet the design requirements: flexibility, compatibility and expandability, which are listed in Appendix B.

Sampling period 200 uS TICNT

UF

Initialization

Algorithm Time

Waiting Time

SIW Start

Figure 3-9 The Software Initialization and Operating System

25

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Calculate Speed

Figure 3-10: VIf Control Software Flowchart

,r-!--'--'-+--. V.S ./

Cur.I'

eZdsp TMLF2407

1M

Figure 3-11: DSP Based Instrumentation for the VIf Control Scheme

26

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

The software modules for the V/f control system are as follows. 1- NO ----ADC module converts the stator currents (i a , i h ) of the induction motor, and the bus DC voltage VDC of the inverter VSI into digital representations.2- Cur_Tr---Clarke's transformation converts the balanced 3-phase currents into 2-phase (a,B) currents. 3- Vol_Tr----This module calculates three-phase voltages applied to the motor. The three phase voltages are reconstructed from the DC-bus voltage and three switching functions of the upper switching devices of the inverter. In addition, this module also includes the Clarke's transformation that converts three-phase voltages into two-phase stationary
(a,B) voltage.

4- MRAS----This module is a speed estimator module for the 3-phase induction motor, based on the reactive power model reference adaptive system. 5- PID----Digital PID controller regulates the slip speed. 6- RAMP_ CNTL----This module implements a ramp up and ramp down function to make the output equal to the input in designed ramp time. 7- V/f----This module generates an output command voltage for a specific input command frequency according to the specific VIf profile. 8- SVGEN---- This module calculates the appropriate duty ratios needed to generate a given stator reference voltage using space vector PWM technique. The stator voltage is described by its magnitude and frequency. 9- PWM_DRV---- This module generates the PWM outputs. 10- DATA LOG---- This module stores the real-time values of two selected variables for displaying in two graphs. 11- SYS_INT ----Initialization of system.

3.3.3 Debugging of the Software
In the debugging phase, the incremental-system-build process is used to decompose the debugging task into several small ones. There are totally five phases for debugging in the VIf control system described as follows.

27

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

r,
I

f

Table3-1 Five Phases for Debugging

:******************************************************************************
Phasel_ inc_build phase2_)nc_build phase3_inc_build phase4_inc_build phase5_inc_build · set · set · set · set · set
0 0 0 0 1

V/Hz profile test SV GEN and FC PWM tests Currents and DC-bus volt measurement tests Speed measurement and MRAS speed estimator tests Sensor less closed-loop V/f system test

:******************************************************************************
For simplicity, only Phase 4 is explained in the following as an example. The other phase debugging procedure can be found in the main program vfmars.asm

Goal 0/ the Phase 4

Assuming phase 3 is completed successfully, the purpose of this section is to verify speed estimation by means of the MRAS technique.

Building the interconnections

Figure 3-12 shows the block diagram in this phase. An open loop V/f control method is employed. The speed of induction motor is controlled by adjusting the reference frequency (OJ ref ) of the stator voltage.

The VIf module generates an output voltage command for a specific input command frequency according to the specified VIf profile. The module SVGEN calculates the appropriate duty ratios Ta, Tb and Tc needed to generate a given stator reference voltage, with the use of the space vector PWM technique. The stator reference voltage is described by its magnitude and frequency. The module PWM_DRV uses the duty ratio information to generate the PWM signals for the control of the power electronic inverter that drives the induction motor.

28

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

The digital-to-analog (D/A) module provides a 3-channel analog-to-digital conversion. The converted results represent the load currentsia ,
ib

and the DC-bus voltage VDC ' The

Clarke's transformation module ofCur_Tr converts the balanced three phase currents into balanced two phase (a,~) quarature quantitiesia and i p . The module ofVol_Tr calculates the three phase voltages applied to the three-phase induction motor and also converts the three phase voltages into two stationary (a,~) voltages Va and Vp. The (a,~) voltage and currents Va' Vp , ia and i p ,are fed into MRAS module to estimate the motor speed
nest.

A

tacheometer is used to measure the motor speedn meas , which is used to compare with the estimated speed
nest'

The DATA_LOG module provides a dual memory buffer to display

two graphical waveforms in real time. This module can be used to show any interested variables such as ia ,ip ' Va and Vp or PWM outputs.

eZdspTM LF2407
lAC

Cu~p

ACI
Tacheometer

Figure3-12: Experimental System Blocks for the Speed Identification Using MRAS

Debugging in phase 4

· Set

OJ ref

to a suitable value, for example 0.3 pu.

29

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

· Set reCmodel_ and adt_model_ to 1, and set pi_mras_ to O. · Compile/load/run program with real time mode and then increase input AC voltage to generate the appropriate DC-bus voltage. · Set wr_hat_mras to 0.29 pu (assuming the slip is O.Olpu). · Compare the reactive power q in the reference model with CLhat in the adaptive model. They should be equal if wr_hat_mras is the actual speed. · Try different values of aJ re( to test CLhat and q. · Reduce the input AC voltage to zero, halt the program and stop real time mode. · Set pi_mras_ to 1, compile, load and run program with real time mode and then increase input AC voltage to generate the appropriate DC-bus voltage again. · Adjust the gains of Kp, Ki_high and Ki_Iow such that the estimated speed measured speed nmear ·
nest

with the

3.3.4 Other Considerations

3.3.4.1 Numerical Considerations

The numeric format between any two modules is such that 1 bit is dedicated to the integer part and 15 bits are dedicated to the fractional part. This numeric format is denoted by 1.15 or Q15. The resolution for this format is:
1 15 = 0.000031 2

With the sign extension mode set, the link between the real quantity and its 1.15 representation is illustrated by Figure 3-13.

A generic x.y format uses x bits for the integer part and y bits for the fractional part. The resolution is2- Y · Ifz is the per unit value to implement, then its software value is

z·2-Y in x.y format. In a specific module, the numeric formats for different variables
may be different. The selection ensures that the software values can handle each drive control quantity, not only during the steady state operation but also during the transient operation.
30

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Q15 Rep.

32767 f - - - - - "

0.999929

Real Val.

IL......._ _-j

-32768

Figure 3-13: Q15 Format Correspondence Diagram

3.3.4.2 The VIf Profile Design

In the software implementation, the stator voltage to frequency ratio is calculated using the rated per unit values of these two variables. For the three speed ranges of the V/f profile, compensation region, linear region and field-weakening region, specific considerations are presented as follows.

The base frequency is specified at 1.1 times the rated frequency (60Hz). This will allow the motor running in the field-weaking region at a speed not more than 1.1 times the rated frequency to avoid the possible over speed in the commissioning operation. The cutoff frequency is specified at 0.2 times the base value. Figure 3-14 shows the VIf profile used in the software module.
V(PU)

1.0 f - - - - - - - . . , . . . . . . . ,

com pensatio ,region

field weakening region

0.2

linear region

o

O. 2

1. 0 1. 1

r (PU)

Figure 3-14 VIf Profile Configuration Based on the VIf profile of Figure 3-14, the output voltages corresponding to a few frequency values are shown in Table 3-2. The maximum output voltage value is assigned to be 32765 to avoid the possible resulting value over 32767 that means a negative value.

31

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Table 3-2 Resulting Output Voltage vs. Frequency for the V/fProfile Frequency
Actual Value(pu} QI5(Dec)

Output Voltage
Actual Value(pu) Q15(Dec)

0.1 0.2 0.3 0.9 1.0

3277 6553 9830 29490 32765

0.2 0.2 0.31 1.0 1.0

6553 6553 10298 32765 32765

3.3.4.3 Slip Speed PID Controller Design

A conventional propotional-integration-differention (PID) controller shown in Figure 315 is employed [10].
OJ ref
+

e

PID

u

Figure3-15: PID Controller Block Diagram The equation for PID controller is given as follows:

u(t) = Kpe(t)+K[

.I>

re(t)dt+KD de(t)
dt

(3-5 )

where:
u(t) : the output of PID controller e(t) : the error between the reference and feedback variables.
(1Jr~r
:

the reference variable the feedback variable the proportional gain of PID controller the integral gain of PID controller

OJ til :

Kp

:
:

KI

K D : the derivative gain ofPID controller

32

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Applying the Laplace transform to equation (3-5) with zero initial condition, this yields:

U(S)=[K p +
By substituting s = 1 Z -I

~I +KDS]E(S)

( 3-6 )

T

,where T is the sampling period, Eq. (3-6) can be transformed

to be a difference equation:

U(Z)=[K p +

1-z

KI~1 + KD (l-z-I)]E(Z)
T

( 3-7)

Eq. (3-7) can be rewritten in the discrete time-domain as,

( 3-8 )

whereu(k),u(k-l)arethe kth and k-l

th

outputofPID controller, e(k),e(k-l)and

e(k - 2) are the k th , k -1 th and k -2 th error between the reference and feedback variables, respectively.

3.3.4.4 Load Design
Experiments are performed to study and verify the steady state and transient performance of the complete control system designed in this project. During the tests, the motor has been mounted on to a test bench connecting with a set of self-excited generator as its load. Figure 3-16 shows the connection.

Motor

Self-excited Generator

Figure3-16: Motor and Self-excited Generator Unit

33

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

The self-excited generator is the same type of induction machine as the prime motor to be controlled. The generator connects with a bank of capacitors and resistors and acts as a load to the prime motor. Its ratings are given in Appendix A.

When the induction machine is driven by the prime motor, the residual magnetism in the rotor produces a small voltage in the stator windings, which causes a current to flow into the capacitor. This resulting current provides a positive feedback that causes a further increase in the voltage. The voltage is eventually limited due to the magnetic saturation of the machine. The load of the prime motor will be changed when the resistance RL is changed.

In Figure3-16, the bank of three-phase capacitors is delta-connected. The rating of each capacitor is selected as follows: Cex is 56f..lF and its maximum line to line voltage is 370V.

In this chapter, the speed sensorless V/fcontrol has been developed with the MRAS speed estimator. The hardware and the software have been designed to implement the control schemes.

34

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Chapter 4 Field Oriented Control Using MRAS
The field oriented control (FOe) of induction motors is a vector control method based on transformations of a three-phase time-dependent motor model into a two-coordinate (d and q coordinates) time invariant model. The model rotates at the rotor flux speed or synchronous speed. These transformations lead to a structure similar to that of a selfexcited DC motor drive control, of which the flux and the torque of the motor can be controlled separately.

In this chapter, the space vector PWM is introduced first. This vector is used to produce appropriate signals that drive the voltage source inverter (VSI). Then the vector FOe of induction motors using DSP eZdspTM LF2407 as controller is discussed in detail. An experimental system is built. This chapter presents the technique used to the implement the proposed Foe speed sensorless control scheme for induction motors using the MRAS estimator.

4.1 Space Vector Pulse Width Modulation
The space vector pulse-width-modulation (SVPWM) is employed to control the switching of the VSI controller. This special switching scheme for the power devices
produce~

3 pseudo sinusoidal currents in the stator phases. The SVPWM modulation

generates smaller harmonic distortion in the output voltages or currents in the windings of the motor and provides more efficient use ofthe DC supply voltages as compared with the direct sinusoidal modulation technique [11].

35

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Figure 4-1 shows a basic 3-phase voltage source inverter circuit. Its input is a DC voltage
VDC ' and its outputs are 3-phase AC voltages. The inverter has six IGBT switches, which

follows the conditions . · Three of the switches are always ON and other three are always OFF. · The upper and the lower switches of the same leg are driven with two complementary gate signals with dead band to avoid any short-circuit condition occurred in the inverter.

There are eight (2 3 ) possible combinations for the switch commands, which determine eight phase voltage combinations. The results are eight basic vectors including six nonzero vectors and two zero vectors in (a,f3) stationary reference frame as shown in Figure 4-2. For example in Figure 4-2, 100 represents the switch command, which means the
I E
'0

status ofthe switches, a, band c, are ON, OFF and OFF.

I I
I
I
0'

I
i
& f

!

N

Figure 4-1 Three-phase Voltage Source Inverter

U 12o (OlO)

pt

I I
i
!

I I

Figure 4-2: Basic Space Vectors

i

36

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

The objective of the space vector PWM technique is to represent a given stator reference voltage vector U 0111 by combination of the switching pattern corresponding to the basic space vectors. The vectors divide the plane into six sectors. Depending on the sector that the reference voltage is in, two adjacent vectors are chosen. The binary representations of two adjacent basic vectors differ in only one bit. Therefore, only one of the upper transistors switches when the switching pattern moves from one vector to the adjacent one. The two vectors are time weighted in a sample period T to produce the desired output voltage.

For example, assuming that the reference vector U otll in the sector shown in Figure 4-3, the output voltageUolI1 is represented by two vectors U o andU6o ' Therefore,

!2. Tu

60

-..a

1,-u

o

Ua Uo (100)

Figure 4-3: Reference Vector as a Combination of Adjacent Vectors

(4-1) (4-2)
where ~ and 1; are the dwell times for the vectors Uo and U 60 , respectively. To is the time duration for which the null vector is applied. When U 0111 and the sample period T are known, the time duration for each switching combination can be determined by follow equations:

~ =Tmasin(7r -e)
3

(4- 3)

1; = Tma sine
1'o=T-~-r;

(4- 4) (4- 5)

37

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

where m a is the modulation index. m

a

= J3u V

Ollt

·

DC

The generated space vector PWM waveforms are symmetrical with respect to the middle of each PWM period [8]. The diagram 4-4 shows a typical seven-segment switching sequence for the reference vector U Ollt in the example presented above.

Te
Tb Ta

;:-Z;Z~ 1----;-- Sr:::::.-

/f'-...-

. -..

_--

PIIIM1

-

L--

PIIIM3

PIIIM5
~
4

!...!.- !:...L.
2 2

~
4

~
4

!>..
2

+
2

~
4

-

T

.

Figure 4-4: Pattern ofSVPWM in the sector contained by U o and U 60

4.2 Background of FOC Control of Induction Motor
The Field Orientation Control (FOC) consists of controlling the stator currents of an induction motor. With Clarke and Park transformations, a three-phase time and speed dependent model can be transformed into a two co-ordinate (d and q co-ordinates) time invariant model. These transformations resolve the stator currents into two components: the flux producing component isd and the torque producing componentiSq
'

I

As in the (d, q) reference frame, the rotor flux 'If r and torque Te have relationship with
'If r oc isd

(4-6) (4-7)

Te oc'lfrisq

the flux producing component isd and the torque producing componentiSq as follows. By maintaining the amplitude of the rotor flux 'If, at a fixed value, there is a linear relationship between the torque Te and the torque component isq . The torque can be controlled by adjusting the torque component of the stator current vector. In other words,
38

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

if isd is kept constant,

isq

can be independently controlled. Therefore the torque of the

induction motor can be controlled.

Both

isd

and

isq

have only DC components in steady state because the relative speed with

respect that of the rotor field is zero. Therefore they are ideal for use as control variables. The field oriented control needs two constants as input references: the torque-producing component iqref and the flux-producing componentidr~r. As the FOC is based on the threephase to two-phase transformation, the control structure handles instantaneous values. This achieves an accurate control in both the steady state and the transient operation.

4.3 The Basic Scheme for the FOe

Figure 4-5 shows the basic scheme of the motor torque control using the FOC control [13].

Two motor phase currents are measured and fed to the Clarke transformation module. The output of this module becomes input of the Park transformation module that produces the currentsisd and i sq in the (d, q) rotating reference frame. These (d,q) currents are compared to the references idref (the flux reference) iqref (the torque reference). The outputs of the current regulators are applied to the inverse Park transformation. The outputs of this transformation are va and vp which are the components of the stator vector voltage in n,
~

stationary orthogonal reference frame.

Va

and vp are also the inputs of the space vector PWM. The outputs of this control block provide the signals that drive the inverter. Both Park and inverse Park transformations need the data of the rotor flux position.

39

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

if/ref

+

sv
v
PWM

3-phase

Inverter

i. i
Park t.

ia ip
Clarke t.

i i

Figure 4-5: Basic Scheme ofFOC for AC Motor

4.4 Proposed Speed Sensorless FOC Control Scheme Usil1g MRAS
The conventional FOC control scheme with a speed sensor is shown in FigureI-2. In this scheme, a speed sensor is used to measure the rotor speed. The speed is fed to a speed regulator comparing with the user designed reference speed. The output is used as torque command iqref · Rotor flux position B is estimated by using the current module of
Cur M [11].

The speed of the induction motor can be computed using the MRAS estimator. Figure 4-6 shows the proposed speed sensorless FOC control scheme using the MRAS speed estimator.

Isolator Transform er

DSP

( a ) Hardware Configuration

40

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

------------------------------------------------------------

()

eZdspTM

LF2407

( b ) Software Module Configuration of Open loop FOC Control

-----------------------------------v
. T.

v

(i}r

MRAS

i
()

ue M

~-+--------'

Park

----------------------------_._-----------------eZdspTM

LF2407

( c ) Software Module Configuration of Closed Loop FOC Control

Figure 4-6: FOC Control Scheme Using MRAS Speed Estimator

41

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

I
I
I

i
I

!>'

Figure 4-6 (a) shows the hardware configuration, which is similar to that discussed in Section 3.3.2. Figure 4-6 (b) shows the software module configuration of the open-loop FOC control. Figure 4-6(c) shows the proposed closed-loop FOC control of induction motors proposed in this project.

I
I

I

To implement the closed-loop control shown in Figure4-6(c), the two-phase currents

ia and ib from the output of ND module are fed to the Clarke transformation module
Cla_Tr which is used to convert three phase stationary frame to two phase (a,

B)

stationary frame. The outputs are ia and ip .

These two a,

Bcurrent components are fed to the input of the MRAS module that

estimates the rotor speed. This module also need the two-phase (a,B) stationary voltage
Va

and vp from the outputs ofthe module VoCTr. The module VoCTr calculates the

three phase voltages and converts them into two stationary (a-B) voltages using the DCbus voltage VDC and three switching functions of the upper power switching devices of the inverter.

The MRAS estimated speed

(iJr

is fed to PI _sp regulator module where it is compared

with the reference speed spd _ ref. The output of the speed regulator is the quadratureaxis stator current reference i qref in the (d, q) frame.

The outputs, ia and i p' are also inputs of the Park transformation that produces the current in the (d, q) rotating reference frame. The components id and iq are compared to the references i dref (the flux reference) and i qref (the torque reference) using PI_q and PI_d module respectively. The outputs of the PI controllers are applied to the inverse Park module I

Pk.

42

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

The outputs of module I _ Pk are va and vp which are the components of the stator vector voltage in (a,~) stationary orthogonal reference frame. These are the inputs of the space vector PWM. The outputs of this block are the signals that drive the inverter.

Both Park and inverse Park transformations need the rotor flux positionB. The position is calculated by the module Cur _M. The estimated speed are inputs to this module.
OJr ,

the components id and iq

Figure 4-6(b) shows the open-loop FOC control of rotor speed. This is a necessary commissioning phase to complete the proposed close-loop speed sensorless FOC control. In this phase, the estimated speed
OJr

is not fed to the regulator module PI _ sp. The

reference rotor flux position OOis generated by the module Ram _ Gen using a given reference speed.

4.5 Software Implementation of the Proposed FOe Scheme

The software organization is similar to that of VIf control strategy described in the Section 3.3.3. A modular strategy is adopted to develop the software package written in assembly language [15].

The DSP Controller Full Compare Unit is used to generate the necessary pulse switching signals to the level shifter board. It is programmed to generate symmetrical complementary PWM signals at a frequency of 5 kHz, with TIMERl as the time base and with the dead time of 1.2,....s. The sampling period (T) is 200 ,....s. Figure 4-7 illustrates the software flowchart. The program is listed in Appendices C.

43

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Hardware Initialization

SWVariabIes Initialization

Figure 4-7: Sensorless Speed FOC Control Software Flowchart

In this chapter, the speed sensorless FOC control has been developed with the MRAS
speed estimator. The hardware and the software have been designed to implement the control schemes.

44

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Chapter 5

Experimental Results
In this chapter, experiments are carried out to verify the capability of the speed sensorless control schemes proposed in this project. Typical results are given to demonstrate the performance of the control system. First, the test of speed identification using MRAS estimator is presented in Section 5.1. Then the VIf control behavior in both open loop and closed loop operating are described in Section 5.2 and 5.3. Finally, the open loop FOe control performance is discussed in section 5.4.

5.1 Speed Identification Using the Proposed MRAS Estimator
In order to verify the proposed reactive power MRAS speed estimator, an experimental motor drive system shown in Figure3-12 was built and tested. The results are described in this section.

Result 1: No load test

Table 5-1 shows the relative speed error at different speeds. In this table, the relative speed error is defined as follows.
e(%)

= nref -n est 100%
n ref

(5-1)

In above expression, the measure speed n ref is measured by a tachometer, and the estimated speed the results.
nest

is estimated by MRAS. Figure 5-1 (a) and Figure 5-1 (b) also show

45

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Table 5-1 Speed Identification Using MRAS
Reference speed n ref (rpm) Estimated speed Relative Error e(%)

nest (rpm)
152 273 573 881 1058 1179 1301 1483 1663 1724 1753

177 296 593 890 1067 1187 1306 1484 1662 1722 1752

14.1 7.8 3.4 1.0 0.8 0.7 0.4 0.06 0.06 0.12 0.06

2000

E
.§: 1500
'0
(I) (I)

- - - - - - - -+ - - - - - - I I I

-1- -

-

_

-

-

-

-

..... -

_

-

-

-

-

-

I I I

I I

~I - - - ,
I,

-

-"*"~'-'::"":':--~ - - _____ I
-

.,.-¥

~ 1000
~

a:: 500
0 0

(5

0

-------1--------;--- -- - -

~.~
~
I

I.~

-- --------;-------I

~~~~.w"

I

~
~

¥""<
10
I

~~.?<~ -: -

Ref.

Speed~'

- - - - - - -

- - -- - - -

,

- - - - - - - -;- - - - - - - -

I

Estima.ed Speed 20 (a)

: 30

'

:
I

40 50 60 Frequency of Stator Voltage(Hz)

100 80
-------4-------~--------~-------~--------~-------

I
I

I
I I

I
I I

"*

60

- - - - - - - I - - - - - - _______
~

-1- -

-

-

-

- -

-

r - - - - - - - -, - - - - - - - -,- - - - - - - ~

Ql 40
20 0 0

I I _______

~

I I ________ L _______ I

I I I ________ I I
I I I

~

______ _

I
I I
~I

I
I I I

- - - - - - - "'T - - - - - - - -,- - - - - - - -

r - - - - - - I

I I

"1 - - - - - - - -,- - - - - - - -

r--_----:.-.
10 20

I

30

(b)

40 50 60 Frequency of Stator Voltage(Hz)

Figure 5-1: (a) Speed Identification Using MRAS (b) Relative Error

Results 2: Load test

In order to do the load test, the induction motor is mounted on to a test bench connecting with a set of self-excited generator as its load as shown in Figure 3-16. When the load

46

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

i

I

>

resistance RL is changed, the load of the prime motor will change, and therefore the stator current will change. During the test, RL was changed three times such that the stator current changes from 2.5A to 3A, then from 3A to 4.5A and from 4.5A to 6A. In each time the rotor speed is measured by a tachometer and is estimated by MRAS. The results are listed in Table 5-2, as well as in Figure 5-2 respectively. Table 5-2: Speed Identification Test Result 2
Load Case (stator current, A) Measure speed n meas (rpm) Estimated speed
nest (rpm)

Relative Error e(%)

2.5 3.0 4.5 6.0

1484 1476 1462 1443

1483 1477 1460 1449

0.07 0.07 0.14 0.42

10,-----,-----,------,-----,-----,-----,-----,
I I I I

9

------~-----~------i------}------~-----------I I I I I

8
7

------------~------{------~------~-----~------ - - - _1- _ _ _ _ _

I

....J _ _ _ _ _ _ ..l _ _ _ _ _ _
I I

I

I

L

I

______ L

I

I _ _ _ _ _ _ 1_ _ _ _ _ _

I

I

I

I

'af

~

6
5

------~-- ___ ~-- ____ 1- _____ ~
I I I I

______ ~-----~-----f
I I I -1- --

- - - - -

-1- -

-

-

-

-

I
I

-i I
I

-

-

- -

-

-+ - - - - - - +- - - - - - -/- - - - - I
I

I
I

I
I

I
I

4
3 2
1

------~-----,------~------r------r-----~-----I

r

I

I

I

I

- - - - - -:- - - - - - -: - - - - - - ~ - - - - - - ~ - - - - - - :- - - - - - -: - - - - - I I I I I I

------~-----~------i------~------~-----~------ - - - - -'- - - - - I
I I I I I 1
!

-1 ______ J. ______ L ______ ,_______ , _ - - - - I I I

o~====±=====~====~====~~==-===-~~-=-~---~~------~· ~s 3 as 4 ~S S ~S 6

Stator Current (A)

Figure5-2 Relative Error e(%) with Different Loads The above results show that the MRAS speed estimator performed well in estimating the motor speed, especially when the frequency of stator voltage is above 50 Hz. Since a motor usually runs under the rated frequency, the MRAS speed estimator can be used to implement the speed sensorless motor control schemes.

5.2 Open Loop Speed VIf Control

47

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

With the experimental system shown in Figure3-12, an open-loop speed VIf control is

I I
I i

carried out to check whether the relationship between the stator voltage and frequency agrees with the designed Vlfprofile of Figure 3-14. The software modules were checked and modified in this phase. During the tests, the stator current keeps constant except in the compensation region and the field-weakening region. The results are shown in Figure 5-3.
I
I

I
I I

I

I
I

I
I I

I
I /'"

/

I
I

I

0.9 - - - -'-.- - - ~ - - - - ~ - - - -:- - - - ~ - - - - ~ - - - -:- - - -f~: Solid line: Designed I I I I ,,* I
0.8 0.7 - - Dotted line: Actual
-1- I I I I I I I

- - - +- - -I

-

-

--I -

-

-

-

t- - - - -1- - I I

-, I

- -

-

t- - - -"..;",-r- - - - -I - - - I // I I

I",~'
I I
I

I

+I

I

r
t

_ _ _ _ 1_ _ _ _ ...1 _ _ _ _ L _ _ _ _ 1 _ _ _ _ ..J _ _ _

I

I

-"..f'/____
,N'I
I

I

..;.- -;'"

1 _ _ _ _ _I _ _ _ _

I I
I

.J. ___ _
I
I

I

S
~ b ~

I
I

I
I

I
I

I
I

I
I

«]<'

~ 0.6
0.5 0.4 0.3

- - - -,- - - -1 - - - I I I I

I

I

r - - - -,- -- - -,?{- - - I I

I

I

r f'

T - - - -,- - - - -,- - - -1·' - - I I I I I

I

I

I

I

- - - -1- - - - ;
I t I
I

-

- - - t- - - I ...

7. - - - -t I I
I

I /.:'" I ,,'

I

r

- - -

+- - I
I

-1- I
I

- - -1- - - I
I

+- - - I
I

I I

_ _ _ _ 1_ _ _ _ ...1 ____
I t

~/~ ___

I/"I

,_ _ _ _ ..J ____ 1. ____ ,_____1 _ _ _ _ .L ___ _
I I I I I I I I I I

I " ......, I,," I

- - - -:- - - - J/~
I '" ~ I
,;./)( I I

-- ~ ----:- --- ~ ---- +- - - -:- - - - -: - - - - +- - - I
I 1 1 I I 1

I I

I
I

I
I 1

I
I

0.2

- -

I I

*··:::;1··..;£ - - ;
I I

- - - - t- - - - -1- - - - ""1 - - I

T I

- - -1- 1

- - -1- - - 1

+- - - I

o. 1

I

'---~-'--~-'-~--'-~~-'----~-'--~--L~---'~~-'---~-'-~---'

0.1

0.2

0.3

0.4

0.5 0.6 0.7 Frequency (pu)

0.8

0.9

1.1

Figure5-3: Stator Voltage Vs Test Frequency This result shows that designed V-Hz relationship has been verified. Both hardware and software performance are confirmed.

5.3 Closed-loop Speed V/f Control
The control was operated in the closed speed loop mode with the circuit configuration shown in Figure 3-11. Two types of tests were carried out to verify the performance of the control scheme using the speed sensorless MRAS estimator designed in this project. One is a step change in load and another is an abrupt change in reference speed.

Result 1: Step Change in Load

A test was conducted with a step change of load. At first, the motor runs at a reference speed with the self-excited generator unit disconnecting from the resistive load as shown

48

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

in Figure 3-16. Then the load is connected to the generator unit. After the motor runs at the speed in a steady state, the load is suddenly disconnected with the generator unit. Table 5-3 shows the motor speeds measured by speed sensor and by MRAS speed estimator in steady state in the test. Figure 5-4 shows the waveform of the stator current

ia in the dynamic state and Figure 5-5 shows the waveforms of the stator currents in the
steady state. The results show that the MRAS has good performance in the closed loop speed VIf control. Table 5-3: Load Test in Closed Loop Speed Control Item Tachometer MRAS estimator No-load 1365 1365 On-load 1364 1364 No-load 1365 1365

Motor Speed(rpm)

0.6

0.4

0.2

i

0

-0.2
I
I I ,I I ! I

-0.4

~

_____

~

____ L_4 ____ _

I

o

1

2

3

4

567

8 Time (5)

Figure5-4: The Waveform of Stator Current ia in the Dynamic State

49

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

(a) No-load
/~
I

o

----~-

- - _1- _ I

--t-\jj- -t---~d--" I / ' \ I

I

-!...~- I

~.50~---1~0----2~0----~30~--~4LO----5LO----6~0----~70~--~80

0.5,-----r----,----,-----.---,---,--,----,

(b) On-load Figure 5-5: Three-phase Stator Steady Currents

Result 2: Step Change in Speed

Tests were conducted with several step changes of the reference speed. During this test, the motor runs at a reference speed with the self-excited generator unit shown in Figure316, and then the reference speed is changed. After the motor runs in a steady state, the reference speed is changed back again. Table 5-4 shows the motor speed changes during the test. Figure 5-6 shows the waveform of the stator current ill in the dynamic state. Figure 5-7 shows the waveforms of three-phase stator currents in the steady states. The result shows even with 40.7% speed change the control can achieve steady state after a

50

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

period of dynamic state. Therefore, the control designed in this project has good performance under abrupt changes of the reference speed. Figure 5-4 Speed Change Test in Closed-loop Mode Item Tachometer MRAS estimator No-load 881 881 On-load 1485 1485 No-load 881 881

Motor Speed(rpm)

O.S 0.6 0.4 0.2

- - - - - I" - - _. _.- - - - - - I - - - - - - - - - - ___
~

I

I

I

I

_, I

I I I _ .L _ _ _ _ _ 1 _____ .J _ _ _ _ _ _ 1 _ _ _ _ _ _ t _ _ _ _ _ _ L _____

1 ____ _
t

I
I
t- -

I
I
-1- -

I
I
- I- - - -

+ - - - - -

I

I
-t -

-1- -

t- -- - - - -

i

0 -0.2 -0.4 -0.6 -O.S
t- -

+- - - - I

'1 - - - - - -1- - - - - -1- - - - - - t- - - - - - t- - - - - I I
I

I
I

I
I

I

I

I

-----r-----T-----'-----~------r-----r-----r-----

I

I

I
I

I I I I I f ------------------------------~-----f-----r-----

-10:------L------2~-----3~----~4------~5------~6~----~7~--~S TIme (s)

Figure 5-6: The Waveform of Stator Currents ia in the Dynamic State When the Reference Speed Changes

0.5r------,I------~,------T,------,I------'I------,------,-------

o - - - - ~--~-:-~~- - - - - ~~~ -:- - - - - -:- --- - -~~- ~ - - - --

I

'_______. I

I

J

I

L---'- ,
I
I
I

I

I

'i-----------L------------I I

I

I

t I

I

I

-O.50:-----~1~0~--~2~0~--~3~0~----4~0~--~5~0~--~6~0~--~7~0~--~SO
0.5
:
,

~

0

""-,.-=-:::~:.~~~-:::. ---:- --~~~:~~~~
I I I I I I I

i i i I _---+----_ I

i I

i I

-3
.

45

o
1
..

10
"

20

30

40
"

50

60
~.----.

70
,

so

0.5

~

0

-.: : r----~ -:::2-~~~=_=_=-=-=-=~+ -----~ --'':.~~~~:.::~
I I I I I I I

-~.----:
10

~- .. --.~-----:
60

-0.5 0

20

30

40
llme(ms)

50

70

so

(a)

51

0:".' :I

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

~.50~---1~0~--~20~--~3~0----~4~0--~5~0~--~SO~--~7=0----~ao

-o.5 o '--------'.1o-----2'-o----3..L.0--T"R"T-4LO----5...J..0----S'-0--7..L.----'ao 0 0.5,----,----,-----,-----,----,----,---,----,

~.50~----L10~--2'-0---3..L.0-----4LO--5...J..0---~S'-0-~7~0-----'ao
Time(ms)

Figure 5-7: Three-phase Stator Steady Currents (a) Rotor speed =881rpm (b) Rotor speed=1485 rpm

5.4 Open Loop Speed FOC Control
Tests were carried out to check the correct operation of PWM generator module SVGEN, and the current regulators PI _ d and PI _ q under no-load condition. The speed estimator designed in this project was also checked. The control scheme has been shown in Figure 4-6(b).

During the test, the reference frequency is changed to different values while the reference flux-producing component
idr~r is

kept at 0.152pu and the reference torque-producing

componentiqref is kept o. The results of a test are presented as follows.

Step 1:

The reference speed spd _ref is set to 0.776 (pu). In this case, the motor runs at a speed of 1358 rpm. Figure 5-8 shows the waveforms of the referent components of the stator current and their responding feedback. Figure 5-8 presents waveforms of actual rotor speed and that of estimated speed using the MRAS speed estimator designed in this project.

52

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

I

0.2r----,-----,-----.----~----,_----,_--_.----_,

I
I
I
_

I

f

-s .eo 0.1
:2
OL---~L_

o
0.1
.~

__

~

10

____ ____ ____ ____ 20 30 40 50 60
~ ~ ~

_ J _ _ _ _~ _ _ _ _ ~

70

80

O,.j~L~~~l~l:L.~j~~J
I I I I I I I

I

-0.1

r

I I
I

I I
I

I I
I

I I

I I

I I
1

10 20 30 40 50 60 70 80 1450,----,-----,-----,-----,-----,-----,-----,-----,

o

I

------------1- _ _ ---'-

~

~ 1400 - - - - -,- - - - - , - - - - - r - - - - -,- - "i 1350 - .. .--J~~_ ,'-----. --'---~~_~.
I

- -

'j'

-,

..

-

-1- -

-

-

-

t

I

I

-~--:--- --~I I

-- -.~~ - - I

--:- I

~----- ~---;---I I I

..'.~~~.L"-'-./,.

I

I

I
I ....

~_.~~

1300L---~~--~----~----~----~----~----~----~

o

10

20

30

40

50

60

70

lime(ms)

80

Figure 5-8: Waveforms of id,iq and that of Rotor Speed in Case ofspd _reJ=O.776{pu)

Step 2:

The reference speed is changed from O.776pu to O.970pu. In this case, the motor runs at 171Orpm.
0.2
~

"'5' 0.1 - - - :2

I I .1 I I I I .v/"'-'"'-",+'~ -v-0",,,,-,," 0-v".r'\..~~~"'.~-y~'''''',--.rr. . .~/
I I I I I I I _1- _ _ _ _ _1 _ _ _ _ _ .J. _ _ _ _ _ .L _ _ _ _ _ L _ _ _ _ _ 1_ _ _ _ _ _1 _ _ _ _ _

,
~

:

I

I

I

I

I

I

OL-____ ____ o 10 20
I I I I I I

_ L_ _ _ _~_ _ _ _ _ _~_ _ _ __ L_ _ _ _ _ L_ _ _ _ _ _L -_ _ _ _~

30

40
I I I

50
I I

60
I I I

70
I I

80

0.1r-----.-----.-----r-----~----.-----.-----.-----,

,
I I

o ;.yv/'v"-¥'-,./'\.v·"", J....I~,·,M.·t-...Jv'"'v'"v~.A.<'...i,J v..r"'j·...·VT'.._/'~,
I

,.-

J

i'_.l'....."'V

-0. 1 L...-_ _- - '_ _ _ _- - I ._ _ _ _- - ' -_ _ _ _- - ' -_ _ _ _- ' -_ _ _ _- ' -_ _ _ _- " -_ _ _ _~ 10 o 20 30 40 70 80 50 60

E
-

11650
(J)

17l~ -~~ n~_~-_:~~t_-L._, e- 1700 - - - - -,- - - - - -,- - - - - ,- - - - - T - - - - -;- - - - - -,- - - - - -,- - - -- - - - -:- - - - - ~ - - - - - ~ - - - - - ~ - - - - - ~ - - - - -:- - - - - -: - - - - : : : : : : :
I I I I I I I

.

1600

o

10

20

30

-----'-----'-40 50

60

70

80

lime(ms)

Figure 5-9: Waveforms of id,iq and that of Rotor Speed in Case ofspd _reJ=O.970{pu)

53

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

r
i '"
The results are shown by Figure 5-9, which illustrates wavefonns of referent components of the stator current and their responding feedback. This figure also shows the wavefonns

I

f

of actual rotor speed and that of estimated speed using MRAS speed estimator. Figure510 shows the duty ratios To , Tband
~

I

I

i I

of PWM1, PWM3 and PWM5, respectively.

\: /V\ rV---\:/+~J \--~ I i-'\---~/-- -_\~\----/t---\ \--"j "'-J
1

T-~.
1
I I

·

,~,T- J~~
1
I
_~--------..-L-_

-1

1
I

o

I

_~~J
I

~'--)

1

10

20

30

40

50

60

70

80

1,---~~--~----~--~----~----~--~--~~

f=

0

- - ; - -: - - - - - :

_1~

o

__

/:\\1:r(V\ :--(:r\: ---: \--- :----: t: ---, -:-/'-"J.-....)
-,~ ~
1
~

____

1

~

____

1 L -_ _

~I _ _ _ _- L_ _ _ _
~

1

~

__

~

____

~

10

20

30

40

50

60

70

80

~ :\\---.-.l~1-.-FV.A...J --/n\-.. -;-r\~.
--I

-1

,'/'.. )

1

'.h /

1

\,1

1

./'..'..-1

--'----~

o

_ _____L _ _

1

\.

",j

10

20

30

40

50

60

70

Time(ms)

80

Figure 10 duty ratios To' Tb and Tc As shown in Figure 5-8 to Figure 5-10, the following results are obtained.

1) The feedback flux-producing component idand the feedback torque-producing componentiq are close to DC currents, which can be used to control the flux and the torque of the induction motor. 2) The perfonnance of the speed control, the flux-producing component id control and the torque-producing componentiq are good. 3) The duty ratios To' Tb and Tc are correct. To leads Tb 120 degrees and Tb leads ~ 120 degrees. The outputs of PWM generator module SVGEN can be used to drive the voltage source inverter.

5.5 Summary

54

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

The experimental results show the high performance of the designed reactive power MRAS speed estimator designed in this project and the speed sensorless VIf control scheme proposed in this research using the MRAS speed estimator. The designed VIf profile has been verified. Even with a large sudden change of the load or the reference speed, the system can achieve the expected steady state in a short period of time. This type of change is one of the worst conditions, as normally the maximum typical change is in the range of 10% to 15%.

The experimental results also show the high performance of current regulator design in the proposed speed sensorless FOe control scheme. Both the flux current component and the torque current component can be controlled separately. The experiments have shown the MRAS as an excellent speed estimator.

55

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Chapter 6 Conclusions
This project report presents an efficient speed sensorless scalar VIf control and the speed sensorless vector FOe control of induction motors using MRAS speed estimator. The MRAS speed estimator shows very good performance. The speed sensor, which usually is needed in traditional variable speed drives of induction motors, is eliminated with the use ofMRAS speed estimator.

A dynamic model is used to design the drive for the induction motor. Equations are developed to describe the principle of the MRAS speed estimator, which shows the speed estimation system is completely robust to the stator resistance variations due to change of temperature.

The modularity strategy used in this project design has been shown great flexibility to develop the software packages for the control of induction motors. The experimental system is built by using DSP eZdspTM LF2407 as controller and verified experimentally.

6.1 Main Work in This Project
The main work that has been accomplished in this project is summarized as follows:

1- The MRAS control method to induction motor drives has been developed.

In this project, the reactive power MRAS technique has been successfully applied to induction motor drives as a speed estimator. An appropriate induction motor model for the design of the drive has been established. Equations have been developed for the design of the MRAS speed estimator. An experimental system has been built to
56

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

verify the performance of the MRAS as a speed sensor. The experimental results have shown the very good performance from the MRAS speed estimator developed in this project. The speed sensor, which usually is needed in traditional variable speed drives of induction motors, has been eliminated with the use of MRAS speed estimator.

2- The control structure for speed sensorless control of induction motors has been developed.

Both the speed sensorless VIf control and the FOC control schemes have been developed with the MRAS speed estimator. The hardware and the software have been designed to implement the control schemes. All required hardware components, including DSP control processor, VSI power electronic inverter, voltage sensor, current sensor, level shifter and the induction motor have been investigated or designed. These include

a). Made the outputs of voltage sensor box and current sensor box to match the input requirements of the DSP. b). Designed a level shifter to amplify the DSP output PWM signals to the corresponding level for IGBT power module. c). Conducted tests to determine the parameters of the induction motor to be used in the experimental verification. d). Designed a self-excited generator unit as the load of the induction motor, which has shown great flexibility during the tests.

The DSP is the core of control system. All the control operation is implemented using software in the DSP TMS320 LF2407.

3- Program software modules have been developed with use of modularity strategy.

Following the modularity rule, the software has been programmed in modules to implement the software control. The modules are written in assembly language.

57

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

DLOG_ VIEW module is employed to display two graphical waveforms in real time. The software modules meet the requirements of flexibility, compatibility and expandability .

4- The hardware has been fully checked and the software has been completely debugged with the use of incremental system builds process.

This process has decomposed the debugging task into several small ones. This has been greatly shorten the developing time and has reduced the chance of making mistake.

5- The experimental system has been built and various tests have been carried out to verify the control developed in this project.

The test items have included the speed identification by using the designed MRAS speed estimator, for both open-loop and closed-loop Vlf control under on-load condition, and the open-loop FOC control. The experimental results have shown the high performance of the designed reactive power MRAS speed estimator and the proposed speed sensorless VIf control scheme using MRAS speed estimator. The designed V/fprofile has been verified. Even with a large sudden change of the load or the reference speed, the system can achieve the expected steady state in a short period of time. The experimental results have also confirmed the feasibility of the proposed speed sensorless FOC control scheme using MRAS speed estimator. The current regulators have been successfully designed. Both the flux-producing current component and the torque-producing current component can be controlled separately.

6.2 Suggestion for the Future Work
This report has provided detailed information in the speed sensorless control of induction motors using the MRAS speed estimator. The following gives recommendations for future.

58

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

1- Improvement of the proposed close-loop speed sensorless FOe control scheme.

At present, the current regulators have been designed. Both the flux current component and the torque current component can be controlled separately. However, the estimated rotor flux position still shows a small difference with the referent rotor flux position that causes a small oscillation during the tests in the speed closed loop control mode. Therefore, a further study is needed to achieve an absolutely stable speed-close-loop control.

2- Low-speed sensorless control of induction motor with MRAS speed estimator.

The designed reactive power MRAS speed estimator has a very good performance in estimating the motor speed in rated speed range but slightly poor when the stator frequency is under 2Hz. Different self-adaptive sets of initial constants (i.e., Kl to K 7 ) may be needed to improve this condition.

3- Simulation work.

Detailed simulation is needed to verify all aspects of the MRAS speed estimator designed in this project.

59

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Bibliography
[1] Kaushik Rajashekara et" Sensorless Control of AC Motor Drives", IEEE Press, Piscataway, NJ, 1996 [2] T. Ohtami et "Vector control of induction motor without shaft encoder", IEEE Trans. Indus. Appli. Vo1.28, No.1, 1992. [3] Colin Schander , "Adaptive speed induction motors without rotor rotational transducers. IEEE Trans. Indus. Appli. Vo1.28, No.1, 1992. [4] Joachim Holtz, "Sensorless speed and position control of induction motors", 27'IECON, 2001. [5] Y. Hori and T. Umeno, "Implementation of robust flux observer based field orientation controller for induction machines", In Proc. 1989 lAS. [6] A.Abbondanti and M.B. Brennen, "Variable speed induction Motor Drives Use Electronic Slip Calcutator Based on Motor Voltage and Currents," IEEE Trans. Indus. Appli. VoLIA-l1, No.5, 1975. [7] R. Jortten and G. Maeder, "Control Mthods for Good Dynamic Performance Induction Motor Drives Based on Current and Voltage as Measured Quantities," IEEE Trans. Indus. Appli. Vol.IA-19, No.3, 1983. [8] F.Z Peng and T. Fukao, "Robust speed identification for speed -sensorless vector control of induction motors", IEEE Trans. Indus. Appli. Vo1.28, No.1, 1994. [9] TI documenta SPRU 444, "Sensored Field Oriented Control(FOC) of Three Phase AC induction motorl". [10] Paul C. Krause et "Analysis of Electric Machinery", IEEE Press, Piscataway, NJ, 1996 [11] TI document SPRU 485, "Digital motor control software library". [12] TI document SPRU 443, "sensorless variable speed 3-phase AC induction motor with closed loop speed control". [13] TI document BPRA073, "Field Orientation Control of3-Phase AC-Motors".

60

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

[14] TI document BPRA076, "Implementation ofa speed field orientated control of three phase AC induction motor using TMS320F240". [15] TI document SPRA701, "A software modularity strategy for digital control systems". [16] L.Zhang, C. Wathanasam, F. Hardan, "An efficient Microprocessor-Based Pulse Width Modulator using Space Vector Modulation Strategy", IEEE 1994.

61

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Appendix A
The Parameters of the Induction Machine
The induction machine used for the experimental system is a squirrel cage machine with the following ratings: Rated voltage Rated current Rated frequency Rated power Rated speed Number of Poles 230Volts, rms, line-to-line 12.7Amps, rms 60Hz 5 hp 1750 rpm 4

By field test and compared with data of the manufacturer, the parameters are determined as follows. Rotor resistance rr Stator leakage inductance Lsi Rotor leakage inductance Lrl Magnetizing inductance Lm Stator self inductance Ls Rotor self inductance Lr 0.30970 1.304mH 1.6337mH 74.38mH 75.684mH 76.014mH

62

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Appendix B Software Package for Vlf Control Scheme
; File Name: vfmras.asm ; Description: Sensorless control of Induction Motor by VoltslHertz technique using MRAS speed estimator ; Originator: Digital control systems Group - Texas Instruments ; Modifier: Chaozheng Ma, Ryerson University,Toronto,Canada. ; Target dependency: DSP eZdspTM LF2407, use 5kHz sampling frequency ; May 15~2003

,
reaCtime phaseCinc_build .set phase2_inc_build .set phase3_inc_build .set phase4_inc_build .set phase5_inc_build .set .set 1

SYSTEM OPTIONS ; 1 for real time mode, otherwise set 0 ; V1Hz profile test ; SV_GEN and FC_PWM tests ; Currents and DC-bus volt measurement tests ; Speed measurement and MRAS speed estimator tests ; Sensorless closed-loop V1Hz system test

.****************************************************************************** , .****************************************************************************** ,

o o o o
1

;-----------------------------------------------------------------------------

; External references
;-----------------------------------------------------------------------------

.include "x24x_app.h" .global MON_RT_CNFG .ref SYS_INIT ; Added by C. Ma .ref DATA_LOG, DATA_LOG_INIT ;function call .ref dlogjptrl, dlog...iptr2 ;Inputs trig...value ;Inputs .ref ;done .ref RAMP_CNTL, RAMP_CNTL_INIT ; function call .ref targeCvalue ; Inputs .ref rmp_dly_max, rmp_Io_limit ; Input Parameters .ref rmp_hUimit ; Input Parameter .ref setpt3alue, s3q_Cflg ; Outputs .ref V_Hz_PROFILE, V_Hz_PROFILE_INIT ;function call vhzjreq ;Inputs .ref .ref v_out ;Outputs .ref .ref .ref .ref .ref SVGEN_MF, SVGEN_MF_INIT ;function call sv_offset, sv_freq;Inputs Ta, Th, Tc ;Outputs
sv~ain,

FC_PWM_DRV, FC_PWM_DRV_INIT ;function call Mfunc31, Mfunc_c2, Mfunc_c3, Mfunc_p ;Inputs

63

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

.ref CLARKE, CLARKE_INIT ;function call .ref clark_a, clark_b ;Inputs .ref clark_d, clark_q ;Outputs ;Changed by C. Ma .ref ILEG2DRV, ILEG2DRV_INIT ;function call .ref Ia....gain,Ib....gain,Ia_offset,Ib_offset ;Inputs .ref la_out, Ib_out,lc_out ;Outputs .ref Vdc_meas....gain, Vdc_meas....gain_l ;Inputs .ref Vdc_meas_offset ;Inputs ;done .ref PHASE_VOLTAGE_CALC .ref PHASE_VOLTAGE_CALC_INIT .ref Mfunc_VI, Mfunc_V2 .ref Mfunc_V3, DC_bus .ref Vphase_A,Vphase_B,Vphase_C .ref Vdirect,Vquadra ;Changed by C. Ma .ref ACCMRAS, ACCMRAS_INIT .ref ualfa_mras, ubeta_mras .ref ialfa_mras, ibeta_mras wchaCmras, wchaCrpm_mras .ref .ref wccal,wchaCmrasl ;done PID_REG!, PID_REGI_INIT .ref .ref pid_fb_regl, pid_reCregl .ref pid_ouCregl .ref .ref BC_INIT,BC_CALC BC_IN,BC_OUT ;function call ;function call ;Inputs ;Inputs ;Outputs ;Outputs ;function call ;Inputs ;Inputs ;Outputs

;function call ;Inputs ;Output ;function call ;Inputs/Outputs

;-----------------------------------------------------------------------------

; Local Variable Declarations

,----------------------------------------------------------------------------.def .def .def .def .def .def .bss .bss .bss .bss .bss .bss .bss .bss .bss .bss .bss GPRO GPRI GPR2 GPR3 GPR4 COMCON GPRO,1 GPRI,1 GPR2,1 GPR3,1 GPR4,1 freq_testing, I freCJ-testing..,rpm, 1 speed_ref, 1 speed_reCrpm, 1 syn_speed,l cUlag,l ( including RT monitor traps) ;General purpose registers.

;General purpose registers .

; V E C TOR TAB L E

.include "c200mnrt.i" ; Include conditional assembly options.

64

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

.sect "vectors" .def _c_intO RESET INTI INT2 INT3 INT4 INT5 INT6 B B B B B 3_intO PHANTOM TlUF_ISR PHANTOM PHANTOM PHANTOM PHANTOM ; 00 ; 02 ; 04 ; 06 ; 08 ;OA ;OC

B
B

.include "rtvecs.h" ; M A INC 0 D E - starts here .text 3_intO: CALL ;added by C. Ma CALL ;done CALL CALL CALL CALL CALL CALL CALL CALL CALL CALL SYS_INIT DATA_LOG_INIT RAMP_CNTL_INIT V_Hz_PROFILE_INIT SVGEN_MF_INIT FC_PWM_DRV_INIT ILEG2DRV_INIT ;changed by C. Ma PHASE_VOLTAGE_CALC_INIT CLARKE_INIT ACCMRAS_INIT PID_REGCINIT BC_INIT

;---------------------------------------------------------; Initialise the Real time monitor
;----------------------------------------------------------

;For Real-Time
;----------------------------------------------------------

; System Interrupt lnit.
;----------------------------------------------------------

POINT_EV ;Event Manager SPLK #0000001000000000b,IMRA ;Enable Tl Underflow Int (i.e. Period) ;5432109876543210 SPLK . #OFFFFh,IFRA ; Clear all Group A interrupt flags SPLK #OFFFFh,IFRB ; Clear all Group B interrupt flags SPLK #OFFFFh,IFRC ; Clear all Group C interrupt flags ;changed by C. Ma POINT_PGO SPLK #000000000100001 Ob,IMR ;En Int lvl 2,7 (Tl ISR) ;5432109876543210 SPLK #OFFFFh, IFR ;Clear any pending Ints EINT ;Enable global Ints POINT_PF2 LACC OCRA AND #OBFFFh SACL OCRA ;Select Secondary function IOPB6 LACC PBDATDIR OR #04000h

65

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

SACL PBDATDIR LACC PBDATDIR AND #OFFBFh SACL PBDATDIR ;done

;Set IOPB6 as output ;Set IOPB6 low, Enable PWM

;---------------------------------------------------------

;SYSTEM PHASE INCREMENTAL BUILD OPTIONS - Initialization
;---------------------------------------------------------

.if (phase I_inc_build) ;changed by C. Ma SPLK #15000, freCI-testing ;done .endif

; 45.45% of66 Hz (30 Hz)

,--------------------------------------------------------.if (phase2_inc_build) SPLK #15000, freq_testing ; 45.45% of66 Hz (48 Hz) LDP #rmp_dly_max ; for Ramp control SPLK #l,rmp_dly_max ;added by C. Ma LDP #dlogjptrl; SPLK #Ta, dlolLiptr 1; SPLK #Tc, dloILiptr2 ; done .endif ,--------------------------------------------------------.if (phase3_inc_build) SPLK #15000, freq_testing ; 45.45% of66 Hz (30 Hz) LDP #rmp_dly_max ; for Ramp control SPLK #4,rmp_dly_max ;added by C. Ma LDP #dlolLiptrl; SPLK #Ta, dlolLiptrl; * SPLK #ipark_q, dloILiptr2 * SPLK #rmp_out, dloILiptr2 SPLK #Tc, dioILiptr2 ;done .endif
;---------------------------------------------------------

.if (phase4_inc_build) SPLK #15000, freq_testing ; 45.45% of 66 Hz (30 Hz) #rmp_dly_max; for Ramp control LDP SPLK #I,rmp_dly_max ;added by C. Ma LDP #dlolLiptrl; SPLK #Ta, dlolLiptrl; SPLK #rmp_out, dioILiptr2 ;done .endif

,--------------------------------------------------------.if (phase5 _inc_build) ;Changed or added by C. Ma SPLK #15000, freq_testing SPLK #14850h, speed_ref SPLK # I, cUlag ; 45.45% of 66 Hz (30 Hz) ; 40.905% of 66 Hz(27 Hz)

66

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

LDP SPLK

#rmp_dly_max #2,rmp_dly_max

; for Ramp control

LDP #dlo~iptrl; SPLK #Ta, dlo~iptrl; SPLK #rmp_out, dlo~iptr2 ;done .endif MAIN: ;Main system background loop

B

MAIN

; Routine Name: TlUF_ISR ; Modifier: Chaozheng Ma ; Last Update: May 15,2003 TlUF_ISR: MAR ; Save context *,ARI *+ ; point to a guaranteed unused location MAR SST #1, *+ ; save STl SST #0, *+ ; save STO SACH *+ ; save acc high ; save acc low SACL *+ ;changed by C. Ma SAR AR6,*+ ; save AR6 (used by DAC) ;done POPD *+ ; save TOS to free h/w stack POINT_EV SPLK #OFFFFh,IFRA ; Clear all Group A interrupt flags (Tl ISR) SETC XF SETC SXM ; set sign extension mode CLRC OVM ; clear overflow mode ;Start main section of ISR .if (phase l_inc_build) #vhzjreq BLDD #freq_testing, vhzjreq CALL V_Hz_PROFILE .endif

LDP

;--------------------------------------------------------.if (phase2_inc_build) LDP #targeCvalue BLDD #freq_testing,targeCvalue CALL RAMP_CNTL LDP #vhzjreq BLDD #setpCvalue,vhzjreq CALL V_Hz_PROFILE LDP #svjreq BLDD #Vhz_freq,svjreq BLDD #V_out,sv~ain CALL SVGEN_MF

67

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

LDP #Mfunc31 BLDD #Ta,Mfunc31 BLDD #Th,Mfunc32 BLDD #Tc,Mfunc_c3 CALL FC_PWM_DRV ; added by C. Ma CALL DATA_LOG ; done .endif
;---------------------------------------------------------

.if (phase3_inc_build) POINT_BO LDP #targeCvalue BLDD #freq_testing,targeCvalue CALL RAMP_CNTL LDP #vhz3req BLDD #setpCvalue, vhz3req CALL V_Hz_PROFILE LDP #sv_freq BLDD #vhz_freq,sv3req BLDD #v_out,sv....,gain CALL SVGEN_MF LDP #Mfunc_c I BLDD #Ta,Mfunc_c1 BLDD #Th,Mfunc32 BLDD #Tc,Mfunc_c3 FC_PWM_DRV CALL CALL ILEG2DRV ;ILEG2_DCBUS_DRV ; Clarke module LDP #Clark_a BLDD #Ia_out,clark_a BLDD #Ib_out,clark_b CALL CLARKE LDP #DC_bus ;addbyC. Ma BLDD . #Vdc_meas_I,DC_bus BLDD #Ta,Mfunc_VI BLDD #Th,Mfunc_V2 BLDD #Tc,Mfunc_V3 CALL PHASE_VOLTAGE_CALC LDP #Ualfa_mras BLDD #Vdirect,ualfa_mras BLDD #Vquadra,ubeta_mras BLDD #clark_d,ialfa_mras BLDD #clark_q,ibeta_mras CALL ACCMRAS ; LDP #BC_IN ; BLDD #wr_haCmras 1,BC_IN CALL DATA_LOG ; CALL DAC_VIEW_DRV .endif ;--------------------------------------------------------;---------------------------------------------------------

POINT_BO LDP #targecvalue

68

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

BLDD #freq_testing,targeCvalue CALL RAMP_CNTL LDP #vhzjreq BLDD #setpCvalue, vhzjreq CALL V_Hz_PROFILE #svjreq LDP BLDD #Vhzjreq,svjreq BLDD #V_out,sv....gain SVGEN_MF CALL LDP #Mfunc_cl BLDD #Ta,Mfunc_cl BLDD #Tb,Mfunc32 BLDD #Tc,Mfunc33 FC_PWM_DRV CALL

CALL LDP BLDD BLDD CALL LDP BLDD BLDD BLDD BLDD CALL LDP BLDD BLDD BLDD BLDD

ILEG2DRV ;ILEG2_DCBUS_DRV #clark_a #Ia_out,clark_a #Ib_out,clark_b CLARKE #DC_bus #Vdc_meas_l ,DC_bus #Ta,Mfunc_VI #Tb,Mfunc_V2 #Tc,Mfunc_V3 PHASE_VOLTAGE_CALC #Ualfa_mras #Vdirect,ualfa_mras #Vquadra,ubeta_mras #clark_d,ialfa_mras #clark_q,ibeta_mras

CALL . ACCMRAS LDP #BC_IN BLDD #wchaCmrasl,BC_IN ; CALLBC_CALC ; LDP #dlogjptrl CALL DATA_LOG ; CALL DAC_VIEW_DRV . .endif

;--------------------------------------------------------.if (phaseS_inc_build)

;--------------------------------------------------------; checking the close-loop flag here LACC cCflag BCND CLOSE_LOOP,GT OPEN_LOOP SPLK #7EB8h,GPRO LT freq_testing MPY GPRO PAC ; ready to be close-loop? ; Branch for the close-loop system
; It is 0.99, assuming slip is 1%

69

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

SACH LDP BLDD BLDD

CALL LDP LACC ADD POINT_BO SACL syn_speed ; here is syn. speed LDP #targeCvalue BLDD #freq_testing,targeCvalue CALL RAMP_CNTL LDP #Vhz_freq BLDD #setpCvalue,vhzjreq B SKIP_CL CLOSE_LOOP LDP BLDD CALL LDP BLDD BLDD

speed_ref,l #pid_reCregl #speed_ref,pid_reCreg 1 #wchaCmrasl,pid_tb_regl ; for sensorless BLDD #BC_OUT,pid_tb_regl ; for sensorless (averaged) PID_REGI #pid_oucreg I pid_ouCregl ; pid_ouCregl is compensating slip ; add reference speed here pid_reCregl

#targeCvalue #speed_ref,targeCvalue RAMP_CNTL #pid_reCregl #setpCvalue,pid_reCregl #wchaunras I ,pid_tb_reg I ; for sensorless BLDD #BC_OUT,pid_tb_regl ; for sensorless (averaged) BLDD #speed_prd,pid_fb_regl ; for sensor CALL PID_REG I LDP #pid_ouCregl LACC pid_ouCregl ; pid_ouCregl is compensating slip ADD pid_reCregl ; add reference speed here POINT_BO syn_speed SACL ; here is syn. speed ; update freq_testing for smoothly returning open-loop freq_testing SACL #vhz_freq LDP #syn_speed, vhzjreq BLDD POINT_BO SKIP_CL V_Hz]ROFILE CALL #sv_freq LDP #vhzjreq,svjreq BLDD #v_out,sv~ain BLDD SVGEN_MF CALL #Mfunc31 LDP #Ta,Mfunc31 BLDD #Tb,Mfunc32 BLDD #Tc,Mfunc_c3 BLDD FC_PWM_DRV CALL SKIP_SPEED CALL LDP BLDD BLDD CALL LDP

ILEG2DRV #clark_a #Ia_out,clark_a #Ib_out,clark_b CLARKE #DC_bus

70

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

BLDD #Vdc_meas_l,DC_bus BLDD #Ta,Mfunc_VI BLDD #Tb,Mfunc_V2 BLDD #Tc,Mfunc_V3 CALL PHASE_VOLTAGE_CALC LDP #Ualfa_mras BLDD #Vdirect,ualfa_mras BLDD #Vquadra,ubeta_mras BLDD #clark_d,ialfa_mras BLDD #clark_q,ibeta_mras CALL ACCMRAS LDP #BC_IN BLDD #wr_haCmrasl,BC_IN ; CALL BC_CALC CALL DATA_LOG .endif
;---------------------------------------------------------

; Change synchronous speed from pu value to rpm value (Q 15 -> QO) POINT_BO SPLK #28800, GPRI ; GPRI = base speed (3600 rpm) (Q3) LT GPRI ; TREG = GPRl (Q3) MPY freq_testing ; PREG = GPRI *freq_testing (Q18) (Q18) PAC ; ACC = GPRI *freq_testing SFR ; ACe = GPRI *freq_testing (Q 17) SFR ; ACC = GPRI *freq_testing (Q16) ; freq_testin~rmp = GPRI *freq_testing SACH freq_testin~rpm ; Change reference speed from pu value to rpm value (Q 15 -> QO) MPY speed_ref ; PREG = GPRI *speed_ref (Q18) (Q 18) PAC ; ACC = GPRI *speed_ref (Q 17) SFR ; ACC = GPRI *speed_ref (Q16) SFR ; ACC = GPRI *speed_ref (QO) SACH speed_reCrpm ; speed_reCrpm = GPRI *speed_ref ;End main section of ISR ;Context restore regs

(QO)

MAR MAR

*,ARI

*-

; make stack pointer active ; point to top of stack

;More context restore if needed PSHD *AR6,*LAR LACL *ADD *-,16 LST #0, *LST #1, *EINT RET ;ISR - PHANTOM PHANTOM PHANTOM 1
B B

; restore TOS ; restore AR6 ; Restore Acc low ; Restore Acc high ; Restore STO ; Restore ST 1 and pointer

PHANTOM PHANTOM 1

71

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

PHANTOM2 PHANTOM3 PHANTOM4 PHANTOM5 PHANTOM6

B B B

B
B

PHANTOM2 PHANTOM3 PHANTOM4 PHANTOM5 PHANTOM6

Module Name: CLARKE
; Module Name: CLARKE ; Description: Converts balanced three phase quantities into balanced two phase quadrature quantities. (a,b,c) -> (d,q) Transformation clark_d=clark_a clark_q = (2 * clark_b + clark_a) / sqrt(3) 1----->0 clark_d clark_a 0------>1 clark_b 0------>1 CLARKE 1 1----->0 clark_q clark3* 0------>1 .include "x24x_app.h" ; Variables clark_a clark_b clark_d clark_q sqrt3inv
cl~temp

.usect "clarke",l .useet "clarke",! .useet "clarke",l .useet "clarke", 1 .useet "clarke",! .useet "clarke",l

; lIsqrt(3)

; sqrt3inv = (lIsqrt(3))=O.577350269 ldp #sqrt3inv SPLK #Ol8830,sqrt3inv RET CLARKE: SPM SETC ;clark_d =
clar~a

; lIsqrt(3) (Ql5)

1 SXM

; Set SPM for Ql5 math ; Sign extension mode on

ldp #clark_a ; ACC = clark_a LACC clark_a ; clark_d = clark_a SACL clark_d ;clark_q = (2 * clark_b + clark_a) / sqrt(3) ; ACC = clark_al2 SFR ; ACC = elark_al2 + clark_b ADD clark_b ; clk_temp = clark_al2 + clark_b SACL clk_temp ; TREG = clark_al2 + clark_b clk_temp LT ; PREG = (clark_al2 + clark_b)*(lIsqrt(3)) MPY sqrt3inv ; ACC = (clark_al2 + clark_b)*(lIsqrt(3)) PAC ; ACC = (clark_a + clark_b*2)*(lIsqrt(3)) SFL ; clark_q = (clark_a + clark_b*2)*(lIsqrt(3)) SACH ; SPM reset SPM RET

72

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Module Name: IV2DRV-M
, .*************************************************************
; Description: Configures and starts ADC for converting two analog inputs with programmable gains and offsets. Cch_sel °------->1 1 la~ain o------->IQ13 aEG2DRV QI51----->0 la_out Ib~ain o------->IQ13 QI51----->0 Ib_out la_offset 0------->IQI5 1 Ib_offset 0------->IQI5 I

; Notes on Configuration
;-----------------------------------------------------------

; 1. Ix~ain has range of -3.999999 --> +3.99999 (i.e. Q13) ; 2. Ix_offset has range -0.999999 --> +0.99999 (i.e. Q 15) ; 3. Ix_out has range -0.999999 --> +0.99999 (i.e. Q15) 1.0 x (VrefHi - VrefLo) = +0.999999 (7FFFh) (OOOOIFFFFh) ; 0.5 x (VrefHi - VrefLo) = 0 ; 0.0 x (VrefHi - VrefLo) = -0.999999 (8000h) ; Cch_sel HEX values vs Channels selected:

; Global Definitions

;----------------------------------------------------------.def .def .def ;added by C Ma .def .def .def .def ;done ;Inputs Vdc_meas...gain_l Vdc_meas_offset ;Inputs Vdc_meas, Vdc_meas_1
Vdc_meas~ain

ILEG2DRV, ILEG2DRV_INIT
la~ain,lb~ain,la-offset,lb-offset

la_out, lb_out,Ie_out

;function call ;Inputs ;Outputs

******************************************************

* Defme Peripherals

******************************************************
.include "x24x_app.h"

* Variables
Cch_sel la...gain Ib...gain la_offset Ib_offset la_out Ib_out Ie_out Ctemp

******************************************************
.usect "ileg2drv", 1 .usect "ileg2drv",1 .usect "ileg2drv", I .usect "ileg2drv", 1 .usect "ileg2drv",1 .usect "ileg2drv", 1 .usect "ileg2drv", 1 .usect "ileg2drv",1 .usect "ileg2drv", 1 .usect "ileg2drv", 1 .usect "ileg2drv",1 .usect "ileg2drv",1 .usect "ileg2drv",1 .usect "ileg2drv",1

******************************************************

Vdc_meas...gain Vdc_me as_offset Vdc_meas ; added by C Ma Vdc_meas...gain_l Vdc_meas_l

73

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

; done ****************************************************** * Configuration Parameters ****************************************************** Cch_sel.set OC32h ; Select Ch3(Phase B),2(Phase A) ; Select Ch13(Vdc) ACQ_PS_ 000Ib ; Acquisition elk p/s=l/2*(conv pis) -> Acuisition win=4*elk .set ; Conversion clk p/s= 111 CON_PS_ 0 .set CAL_ ; Calibration register = 0 .set 0 ; Offset introduced by XOR -200 Ia_offsec .set Ib_offset_ .set -130 Vdc_offseC .set 0 ; gain=1.02 (Q13) 8215 la~ain_ .set .set ; gain=1.02 (Q13) 8215 Ib~ain_ Vdc....gain_ .set 8258 Vdc....gain_l_ ;gain=0.69(Q 13) .set 5500 ;done ILEG2DRV_INIT LDP #Cch_sel SPLK #Cch_seLCch_sel ; Set channel select SPLK #Ia~ain_,Ia~ain ; Set gains SPLK #1b~ain_,Ib~ain SPLK #Ia_offseC,Ia_offset ; Set offsets SPLK #1b_offseC,Ib_offset SPLK #Vdc_offsec,Vdc_meas_offset ; Set offsets SPLK #Vdc~ain_, V dc_meas~ain SPLK #Vdc~ain_l_, V dc_meas~ain_l Idp #GPTCON»7 ; Set Tl UF as ADC trigger splk #OOOOh, GPTCON LDP SPLK SPLK SPLK #CALIBRATION»7 ; Configure CALIBRATION #CAL_,CALIBRATION ; Set Calibration register #4000h,ADCL_CNTLI ; Reset entire Module #0010000101010000b,ADCL_CNTLI ;Acq = 4 x Clks,Cascaded mode ; continuous run

;changed by C Ma SPLK #2,MAXCONV ; 3 conversions #Cch_sel,CHSELSEQI ; Configure channel select bldd ;done SPLK #0010000000000000b,ADCL_CNTL2 ; Start the conversions from stop position ret ILEG2DRV: Idp #ADCL_CNTL2»7 ; Check SEQ_BSY bit

*

LACC ADC_RESULTO #8000h XOR #Ia_out ldp SACL la_out LT la~ain la_out MPY PAC la_offset, 13 ADD neg SACH la_out,3

; Read 1st converted value ; Convert to Q 15

; la~ain in Q13 ; Q 13 x Q 15 = Q28 ; add offset in Q28 ; positive => going into motor ; Convert final result to Q 15

74

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

*

LDP LACC XOR Idp SACL LT MPY PAC ADD neg SACH bldd LACC ADD NEG SACL

#ADC_RESULT 1»7 ; Read 2nd converted value ADC_RESULTl #8000h ; Convert to Q 15 #Ib_out Ib_out Ib~ain ; Ib~ain in Q13 Ib_out ;Q13xQI5=Q28 ; add offset in Q28 ; positive => going into motor Ih_out,3 ; Convert final result to Q15 Cch_sel,#CHSELSEQ 1 ; Reconfigure channel select la_out ;Calculated value for Imeas3 (i.e. Phase W) Ib_out ;ACC = Imeas_a + Imeas_b ;ACC = - (lmeas_a + Imeas_b) ;Imeas_c = - (Imeas_a + Imeas_b) Ic_out

; added by C Ma ;Read 3rd converted value (Vdc_meas) LDP #ADC_RESULT2»7 LACC ADC_RESULT2 ;Ch2 (default) is for DC_bus voltage SFR ;Convert to Q15 (Unipolar signal) AND #7FFFh ;Convert to Q15 (Unipolar signal) LDP #Vdc_meas SACL Vdc_meas LT Vdc_meas~ain ;Vdc_meas~ain in Q13 MPY Vdc_meas ;Q13 x Q15 = Q28 PAC ;add offset in Q28 Vdc_meas_offset, 13 ADD ;convert final result to Q15 SACH Vdc_meas,3 Vdc_meas~ain_l ;Vdc_meas~ain in Q13 LT ;Q13 x Q15 = Q28 MPY Vdc_meas PAC ;convert final result to Q15 SACH ;done RET

Module Name: PHASE_VOLTAGE_CALC
; Description: Calculates the 3 Phase Motor voltages and stationary dq-axis voltages based on the PWM modulating function & DC bus voltage measurement. 1----->0 Vphase_A 1 Mfunc_Vl 0---------->1 1----->0 Vphase_B Mfunc_V2 0---------->1 PHASE_VOLTAGE_CALC 1----->0 Vphase_C MfuncV3 0---------->1 Q 15 / Q 15 1 DC_bus 0---------->1 1----->0 Vdirect 1----->0 Vquadra

;Module definitions for external reference. ;function call PHASE_VOLTAGE_CALC .def ;function call PHASE_VOLTAGE_CALC_~T .def ;Inputs Mfunc_Vl,Mfunc_V2 .def ;Inputs Mfunc_V3, DC_bus .def Vphase_A, Vphase_B, Vphase_C ;Outputs .def

75

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

.def

V direct, Vquadra

;Outputs

ouCoCphase_ .set 0 ; set 1 for the out of phase correction if ; * Mfunc_VI is out of phase with PWMl, Mfunc_V2 is out of phase with PWM3, * MfuncV3 is out of phase with PWM5; otherwise, set 0 if their phases are correct. .include x24x_app.h Mfunc_Vl .usect "voICcal",l Mfunc_V2 .usect "voICcal",l Mfunc_V3 .usect "voICcal",1 DC_bus .usect "voICcal",1 Vphase_A .usect "voICcal",1 Vphase_B .usect "voICcal",1 Vphase_C .usect "volt_cal", 1 Vdirect .usect "voICcal",l Vquadra .usect "voICcal",1 one_third .usect "voICcal",1 ; 113 .usect "voICcal",1 ; 1Isqrt(3) sqrt3inv .usect "voICcal",1 ; temporary variable tmp_volt

; 113 = 0.33333 => 0.33333*2 A lS = 10923 LDP #one_third SPLK #I0923,one_third;7FFFh x 0.33333... (QIS) ; l/sqrt(3) = 0.577350269 => 0.S773S0269*2 A I5 = 18919 SPLK#018919,sqrt3inv ;7FFFh x 0.577350269 ... (QI5) RET

SETC SXM .if (ouCoCphase_) LACC Mfunc_VI NEG SACL Mfunc_VI LACC Mfunc_V2 NEG SACL Mfunc_V2 LACC Mfunc_V3 NEG SACL Mfunc_V3 .endif ;scale the incomming Modulation functions ;Input 1 #Mfunc_Vl LDP Mfunc_VI LT MPY DC_bus PAC SACH Mfunc_Vl,1 ;Input 2 LT Mfunc_V2 DC_bus MPY PAC SACH Mfunc_V2,1 ;Input 3 LT Mfunc_V3

with the DC_bus value:

;Mfunc_VI is in Q15 ;DC_bus is in Q15 ;P = Mfimc_VI * DC_bus ;shift 1 to restore Q 15 format ;Mfunc_VI is in QIS ;DC_bus is in QlS ;P = Mfunc_VI * DC_bus ;shift 1 to restore Q 15 format ;Mfunc_VI is in QlS

76

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

MPY DC_bus ;DC_bus is in QlS PAC ;P = Mfunc_VI * DC_bus SACH Mfunc_V3, I ;shift I to restore QI5 format ;Calculate the 3 Phase voltages: SPM 1 ;Phase A LT ; TREG = one_third (Q IS) MPY ; PREG = one_third*Mfunc_VI (QlS) PAC ; ACC = one_third*Mfunc_VI (QlS) SFL ; ACC = 2*one_third*Mfunc_VI (QlS) MPY ; PREG = one_third*Mfunc_V2 (QIS) SPAC ; ACC = (2/3)*Mfunc_Vl-(l/3)*Mfunc_V2 (QIS) MPY Mfunc_V3 ; PREG = one_third*Mfunc_V3 (QlS) SPAC ; ACC = (2/3)*Mfunc_VI-(1I3)*Mfunc_V2-(l/3)*Mfunc_V3 (QlS) SACH Vphase_A ;Phase B MPY Mfunc_V2 ; PREG = one_third*Mfunc_V2 (QlS) PAC ; ACC = one_third*Mfunc_V2 (QIS) SFL ; ACC = 2*one_third*Mfunc_V2 (QlS) MPY Mfunc_VI ; PREG = one_third*Mfunc_VI (QlS) SPAC ; ACC = (2/3)*Mfunc_V2-(l/3)*Mfunc_VI (QI5) MPY Mfunc_V3 ; PREG = one_third*Mfunc_V3 (QlS) SPAC ; ACC = (2/3)*Mfunc_V2-(l/3)*Mfunc_VI-(l/3)*Mfunc_V3 (QlS) SACH Vpbase_B ;Pbase C MPY Mfunc_V3 ; PREG = one_third*Mfunc_V3 (QlS) PAC ; ACC = one_third*Mfunc_V3 (QIS) SFL ; ACC = 2*one_third*Mfunc_V3 (QlS) ; PREG = one_third*Mfunc_VI (QlS) MPY Mfunc_VI SPAC ; ACC = (2/3)*Mfunc_V3-(l/3)*Mfunc_VI (Q1S) MPY Mfunc_V2 ; PREG = one_third*Mfunc_V2 (QIS) SPAC ; ACC = (2/3)*Mfunc_V3-(1I3)*Mfunc_Vl-(1/3)*Mfunc_V2 (QIS) SACH Vpbase_C ; Voltage transformation (a,b,c) -> (Direct, Quadrature) ; Direct-axis (QIS) LACC Vphase_A ; ACC = Vpbase_A ; Vdirect = Vphase_A (QlS) SACL Vdirect ; Quadrature-axis SFR (QIS) ; ACC = Vpbase_N2 Vphase_B ADD ; ACC = Vphase_N2 + Vphase_B (QIS) SACL tmP30lt ; tmp_volt = Vpbase_N2 + Vphase_B (QlS) ; TREG = Vphase_N2 + Vphase_B (QlS) LT tmp_volt MPY ; PREG = (Vphase_N2 + Vphase_B)*(lIsqrt(3» (Q30) sqrt3inv PAC ; ACC = (Vphase_N2 + Vphase_B)*(l/sqrt(3» (Q30) SFL (Q31) ; ACC = (Vphase_N2 + Vphase_B)*(l/sqrt(3» SACH Vquadra; Vquadra = (Vphase_A + 2*Vphase_B)*(lIsqrt(3» (QIS) SPM o CLRC SXM RET

; Module Name:
,
; Description: Digital PID controller without anti-windup correction pid_reCreg 1 o--------->IQ IS PID_REG 1 Q ISI----->o pid_ouCreg 1 pid_fb_regi o--------->IQlS 1

77

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

.def .def .def Kp_REGl_ Ki_HCREGI Ki_LO_REGl Kd_REGl PID_OUT_MAX_ PID_OUT_MIN_ .include

PID_REGl, PID_REGl_INIT pid_fb_regl, pid_reCregl pid_ouCregl 20866 .set .set 80 -1000 .set 5997 .set 300 .set .set OOOOh "x24x_app.h"

;funetion call ;Inputs ;Output

; for Kp_regl ; for Ki_high_regl (Ki=O for PD) ; for Ki_low_regl (Ki=O for PD) ; for Kd_reg 1 (Kd=O for PI) ; for pid_ouCrnax ; for pid_ouCrnin

;Variable Definitions for PID_REGI module

,--------------------------------------------------------------------------Kp_regl Ki_Iow_regl Ki_high_regl Kd_regl KO_Iow_regl KO_high_reg 1 Kl _reg 1 pid_fb_regl pid_reCregl pid_out_reg 1 pid_outl_regl pid_eO_regl pid_eCregl pid_e2_reg 1 tmpl_low_regl tmpl_high_regl tmp2_low_reg 1 tmp2_high_reg 1 tmp3_regl abs_eO_regl sign_regl PID_OUT_MAX PID_REGI _INIT: LDP #Kp_regl SPLK #Kp_REG1_,Kp_reg1 SPLK #Ki_LO_REG 1_,Ki_Iow_reg 1 SPLK #Ki_Hl_REG 1_,Ki_high_reg 1 SPLK #Kd_REGl_,Kd_regl SPLK #O,pid_el_regl SPLK #0,pid_e2_regl SPLK #O,pid_outCreg1 #PID_OUT_MAX_, PID_OUT_MAX .useet .useet .useet .useet .useet .useet .usect .useet .useet .useet .useet .useet .useet .usect .usect .useet .useet .useet .useet .useet .usect .useet "pid_reg 1" , 1 "pid_reg 1", 1 "pid_reg 1",1 "pid_reg 1", 1 "pid_reg 1",1 "pid_regl ",1 "pid_reg 1",1 "pidJeg 1",1 "pid_reg 1",1 "pid_reg 1",1 "pid_regl ",1 "pid_reg 1",1 "pid_reg 1", 1 "pid_regl ",I "pid_reg 1", 1 "pid_reg 1",1 "pid_reg 1", 1 "pid_regl ",1 "pid_reg 1", 1 "pid_reg 1",1 "pid_reg 1",1 "pid_reg 1",1 ; Kp=Q15 ; Ki =Q31 ; Ki =Q31 ; Kd=Q15 ; KO =Q31 ; KO=Q31 ;Kl =Q15

SPLK RET PID_REGI:

SETC SETC

SXM OVM

; Sign extension mode ; Overflow mode

78

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

SPM Reset SPM ; Converting from Kp, Ki, Kd to KO, Kl (Note: K2 = Kd) LDP #Kp_regl LACC Ki_high_regl,16 ; ACC = Ki (Q31) ADDS Ki_Iow_regl ; ACC = Ki (Q31) (Q31) ADD Kp_regl,16 ;ACC=Kp+Ki (Q31) ADD Kd_regl,16 ; ACC = Kp + Ki + Kd SACH KO_high_regl ; KO = Kp + Ki + Kd (Q31) (Q31) SACL KO_Iow_regl ; KO = Kp + Ki + Kd (Q15) LACC Kd_regl,16 ; ACC = Kd (Q15) SFL ; ADD = 2*Kd (QI5) ADD Kp_regl,16 ; ACC = 2*Kd+Kp (QI5) ; Kl = 2*Kd+Kp SACH Kl_regl ; e(k) = ref(k)-fb(k) => Q15 = Ql5 - Ql5 LACC pid_reCregl ; ACC = pid_reCregl (QI5) SUB pid_fb_regl ; ACC = pid_reCregl - pid_tb_regl (Q15) ; e(k) = pid_reCregl - pid_fb_regl (QI5) SACL pid30_regl ; tmpl = -KI *e(k-I)+K2*e(k-2) => Q31 = -QI5*QI5 + Q15*Q15 LT Kd_regl ;TREG=K2 (QI5) (Q30) MPY pid32_regl ; PREG = K2*e(k-2) (Q30) PAC ; ACC = K2*e(k-2) (Q15) LT KI_regl ; TREG = KI (Q30) MPY pid_el_regl ; PREG = KI *e(k-l) (Q30) SPAC ; ACC = -KI*e(k-I)+K2*e(k-2) (Q31) tmpl_high_regl,l ; tmpl = -Kl *e(k-l)+K2*e(k-2) SACH (Q31) SACL tmpl_10w_regl,1 ; tmpl = -Kl*e(k-I)+K2*e(k-2) ; tmp2 = KO*e(k) => Q31 = Q31 *Q 15 ; check sign for "error" only LACC pid_eO_regl ; ACC=e(k) SACL sign_reg 1 ; take absolute for "pid_e2_regl" only because "KO" is always positive ABS ; ACC = le(k)1 SACL abs_eO_regl ; le(k)1 = ACC low ; now they're positive. LT abs_eO_regl ; TREG = le(k)1 MPYU KO_Iow_regl ; PREG = KO_Iow*le(k)1 tmp2_low_regl ; tmp2_low = PREG high SPH ; PREG = KO_high*le(k)1 MPYU KO_high_regl PAC ; ACC = KO_high*le(k)1 ADDS tmp2_low_regl ; ACC = KO_high*le(k)1 + tmp2_low ; tmp2_high = ACC high (Q31) SACH tmp2_high_reg I, I ; tmp2_low = ACC low (Q31) SACL tmp2_low_regl,1 ; check the sign condition ; ACC = sign LACC sign_reg I ; Check sign = positive? BCND DONE_REGl, GT ; ACC high= tmp2_high LACC tmp2_high_regl,16 ; ACC low = tmp2_low ADDS tmp2_low_regl ; Make the result negative NEG ; tmp2_high = ACC high SACH tmp2_high_regl ; tmp2_low = ACC low SACL tmp2_10w_regl DONE_REG I ; tmp2 + tmpl = tmp3 => Q31 + Q31 = Q15 LACC tmpChigh_regl,16 ; ACC high = tmpl_high (Q31) ADDS tmpl_Iow_regl ; ACC low = tmp I_low (Q31) (Q31) ADDS tmp2_low_regl ; ACC = tmp 1_low+tmp2_low ; ACC = tmp l_high+tmp2_high (Q31) ADDH tmp2_high_regl

°

;

79

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

SACH tmp3_regl (QI5) ; u(k) = u(k-l) + tmp3 => Q15 = Q15 + Q15 LACC pid_outl_regl,16; ACC =u(k-l) (QI5) ADD tmp3_regl,16 ; ACC = u(k-l)+KO*e(k)-Kl *e(k-l)+K2*e(k-2) (QI5) SACH pid_ouCregl ; u(k) = u(k-l)+KO*e(k)-KI *e(k-I)+K2*e(k-2) (QI5) ; Ifu(k) > u_max, u(k) = u_max. Ifu(k) < u_min, u(k) = u_min. LACC pid_ouCregl ; ACC = u(k) (QI5) #PID_OUT_MAX_ ; ACC = u(k)-u_max (QI5) ; SUB SUB #PID_OUT_MAX_ SAT_MAX,GT ; Branch if saturated at max BCND LACC pid_oucregl ; ACC = u(k) (QI5) #PID_OUT_MIN_; ACC = u(k)-u_min (QI5) SUB BCND SAT_MIN,LT ; Brnch if saturated at min B REG I_END #PID_OUT_MIN_,pid_ouCregl B REG I_END ; u(k) = u_min (QI5) (QI5)

SAT_MAX SPLK #PID_OUT_MAX_,pid_oucregl ; u(k) = u_max REG I_END ; Updating the errors e(k-l), e(k-2) and output u(k-l) LACC pid31_regl ; ACC = e(k-l) SACL pid_e2_regl ; e(k-2) = e(k-l) ; ACC = e(k) LACC pid30_regl ; e(k-l) = e(k) SACL pid31_regl LACC SACL CLRC RET pid_ouCregl pid_outl_regl SXM ; ACC =u(k) ; u(k-l) = u(k)

(QI5) (QI5) (QI5) (QI5) (QI5) (QI5)

; Module Name:
; Description: Reactive Power Model Reference Adaptive System (MRAS) Speed Estimator of Induction Motor ualfa_mras 0----->IQI5 ubeta_mras 0----->IQI5 ACCMRAS QI51----->0 wr_haCmras QOI----->o wchaCrpm_mras ialfa_mras 0----->IQI5 I ibeta_mras o----->IQ 15 ;Module definitions for external reference . .def ACCMRAS, ACCMRAS_INIT ;function call .def ualfa_mras, ubeta_mras ;Inputs .def ialfa_mras, ibeta_mras ;Inputs ;Outputs .def wr_haCmras, wr_haCrpm_mras .def wr_cal,wr_haCmrasl reCmodel_ adCmodel_ pi_mras_ motor4 motor5 .if (motor4) KI K2.set .set .set .set .set 1 1 1 0 1 ; set 1 to activate reference model, otherwise set 0 ; set 1 to activate adaptive model, otherwise set 0 ; set 1 to activate PI controller, otherwise set 0 ; 5-Hp motor (WH) ; 5-Hp motor (WH)

.set .set

6000 1500

; for Kl (QlO) ; for K2 (Q15)

80

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

14400 ; for base_rpm (Q3) .include x24x_app.h ualfa_mras .useet "mras_aei",1 ; Measured alfa-axis voltage at k (pu) ubeta_mras .useet "mras_aei",l ; Measured beta-axis voltage at k (pu) ialfa_rnras .useet l mras_aei",l ; Measured alfa-axis current at k (pu) ibeta_mras .useet "mras_aei",l ; Measured beta-axis current at k (pu) wchat_mras .useet "mras_aei", I ; Estimated rotor speed at k (pu) Wf_haCmras 1 .useet"mras_aci",l wr_hat_rpm_mras .useet "rnras_aei",l ; Estimated rotor speed at k (rpm) ialfa_old .useet "mras_aei",l ; Measured alfa-axis current at k-l (pu) ibeta_old .useet "mras_aei",l ; Measured beta-axis current at k-l (pu) ealfa .useet "mras_aei",l ; Alfa-axis back emf (pu) ebeta .useet "mras_aei",l ; Beta-axis back emf (pu) imalfa_high .useet "mras_aci",l ; Alfa-axis magnetizing current at k (pu) imalfa_low .useet "mras_aei",l ; Alfa-axis magnetizing current at k (pu) imbeta_high .useet "mras_aei",l ; Beta-axis magnetizing current at k (pu) imbeta_Iow .useet "rnras_aei",l ; Beta-axis magnetizing current at k (pu) imalfa_old_high .useet "mras_aei",l ; Alfa-axis magnetizing current at k-l (pu) imalfa_old_low .useet "mras_aei",l ; Alfa-axis magnetizing current at k-l (pu) imbeta_old_high .useet "mras_aei",1 ; Beta-axis magnetizing current at k-1 (pu) imbeta_old_low .useet "mras_aei",l ; Beta-axis magnetizing current at k-l (pu) .useet "mras_aci",l ; Reactive power in reference model (pu) q q_hat .useet "mras_aci",l ; Reactive power in adaptive model (pu) error .useet "mras_aei",l ; Reactive error (pu) .useet "rnras_aei",l ; Constant using in reference model K1 .useet "mras_aci",l ; Constant using in adaptive model K2 .useet "mras_aei",1 ; Constant using in adaptive model K3 .useet "mras_aei",1 ; Constant using in adaptive model K4 .useet "mras_aci",l ; Constant using in adaptive model K5 K6 .useet "mras_aei",1 ; Constant using in adaptive model .useet "mras_aei",1 ; Constant using in adaptive model K7 .useet "mras_aei",1 ; PI proportionnal constant Kp .useet "mras_aei",1 ; PI integral constant (high 16 bit) KLhigh .useet "mras_aei",l ; PI integral constant (low 16 bit) KUow tmpChigh .useet "mras_aei",1 ; 32-bit temporary variable (high 16 bit) tmp1_low .useet "rnras_aei",1 ; 32-bit temporary variable (low 16 bit) tmp2_high .useet "mras_aei",1 ; 32-bit temporary variable (high 16 bit) tmp2_low .useet "mras_aei",l ; 32-bit temporary variable (low 16 bit) tmp3_high .useet "mras_aei",1 ; 32-bit temporary variable (high 16 bit) tmp3_low .useet "mras_aei",1 ; 32-bit temporary variable (low 16 bit)

K3 K4_ K5_ K6_ K7_ .endif .if (motorS) KI K2_ K3_ K4_ K5_ K6_ K7_ wceal_ .endif BASE_RPM_ .set

.set .set .set .set .set

23684 7 32740 600 28

; forK3 (Q8) ; for K4 (QI5) ; for K5 (Q15) ; for K6 (QI5) ; for K7 (Q15)

.set .set .set .set .set .set .set .set

2350 1538 23684 93 32740 2475 35 30200

; for K1 (QlO) ; for K2 (Q15) ; forK3 (Q8) ; for K4 (Q15) ; for K5 (Q15) ; for K6 (QI5) ; for K7 (QI5) ;(QI5)

81

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

tmp4 tmp5 sign I sign2 sign3 base_rpm VVT_cal

.usect

.usect "mras_aci", I .usect "mras_aci",l .usect "mras_aci",1 .usect "mras_aci",1 .usect "mras_aci",1 .usect "mras_aci",l "mras_aci",1

; 16-bit temporary variable ; 16-bit temporary variable ; Checking sign variable for Q31 multiplication ; Checking sign variable for Q31 multiplication ; Checking sign variable for Q31 multiplication ; Base motor speed in rpm (Q3 signed)

LDP #KI SPLK #KC,Kl ; Kl = (Ls-LmA2ILr)*Ib/(T*Vb) (Qll) SPLK #K2_,K2 ; K2 = LmI\2*Ib/(Lr*Tr*Vb) (QIS) SPLK #K3_,K3 ; K3 = Tr*Wb (Q8) (QIS) SPLK #K4_,K4 ; K4 = (Wb*T)A212 SPLK#KS_,KS ; KS = I-TlTr+T"2/(2*TrA2) (QIS) SPLK #K6_,K6 ; K6 = Wb*(T-T"2ITr) (QI5) SPLK#K7_,K7 ; K7 = TlTr-T"2/(2*Tr"2) (QIS) SPLK #BASE_RPM_,base_rpm ; Base motor speed in rpm (Q3) SPLK #wccaL,wccal SPLK #OOOOh,q ; Initial value of q in reference model SPLK #OOOOh,<I-hat ; Initial value of q_hat in adaptive model SPLK#OOOOh,ialfa_old ; Initial value ofialfa SPLK #OOOOh,ibeta_old ; Initial value of ibeta SPLK#OOOOh,imalfa_old_low ; Initial value ofimalfa (low 16 bit) SPLK#OOOOh,imalfa_old_high ; Initial value ofimalfa (high 16 bit) SPLK#OOOOh,imbeta_old_low ; Initial value ofimbeta (low 16 bit) SPLK#OOOOh,imbeta_old_high ; Initial value ofimbeta (high 16 bit) ; Initial value of angular speed SPLK #OOOOh, VVT_haCmras ; Initial value of error of reactive power SPLK #OOOOh,error SPLK #2S,Kp ; PI proportionnal constant (Q1S) SPLK#30,Ki_high ; PI integral constant (high 16 bit) (Q31) SPLK #ODEADh,Ki_Iow ; PI integral constant (low 16 bit) (Q31) RET ACCMRAS: SPM 0 SETC SXM SETC OVM LDP #ibeta_old .if (reCmodeU ;RELMODEL: ; ------------------------ Start reference model section ---------------------------; KI *(ibeta(k)*ialfa(k-l )-ialfa(k)*ibeta(k-l» = tmp I => Q I O*(Q IS*Q IS-Q IS*Q IS) = Q31 ibeta_old LT ; TREG = ibeta(k-I) (Q15) ialfa_mras (Q30) MPY ; PREG = ialfa(k)*ibeta(k-l) (Q30) PAC ; ACC = ialfa(k)*ibeta(k-I) NEG ; Make result negative ialfa_old ; TREG = ialfa(k-l) LT (QIS) MPY ibeta_mras ; PREG = ibeta(k)*ialfa(k-I) (Q30) (Q30) APAC ; ACC = ibeta(k)*ialfa(k-l )-ialfa(k)*ibeta(k-l) SACH sign I ; Keep sign for ibeta(k)*ialfa(k-l )-ialfa(k)*ibeta(k-l) ABS ; ACC = libeta(k)*ialfa(k-l )-ialfa(k)*ibeta(k-I)1 (Q30) ; Reset product mode ; Set sign extension mode ; Set overflow mode

82

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

SACH tmp I_high, I ; tmp I_high = libeta(k)*ialfa(k-l )-ialfa(k)*ibeta(k-I)1 (Q31) SACL tmp I_low, I ; tmp I_low = libeta(k)*ialfa(k-l )-ialfa(k)*ibeta(k-I)1 (Q31) ; now they're positive. (QIO) LT ; TREG=KI KI MPYU tmpl_low ; PREG = KI *tmpl_low SPH tmp4 ; tmp4 = PREG high (save partial result) SPL tmp5 ; tmp5 = PREG low MPYU tmpl_high ; PREG = Kl *tmp I_high PAC ; ACC = KI*tmpLhigh ; ACC = KI *tmpl_high + tmp4 ADDS tmp4 ; tmpl_high = ACC high (Q31) SACH tmp l_high,6 = ACC low (Q31) SACL tmpLlow,6 ; ACC=tmp5 LACC tmp5 ; Pick MSB 6 bits in low 16 bits ofKl *tmpl_low AND #OFCOOh ; tmp5 = MSB 6 bits in low 16 bits ofKI *tmpLlow SACH tmp5,6 LACL tmp5 ; ACC=tmp5 ; tmpl_low = MSB 6 bits in low 16 bits ofKl *tmpl_1ow + tmpl_low ADDS tmp Llow ; tmp I_high = ACC low SACL tmp I_low ; check the sign condition LACC sign 1 ; ACC = signl ; Check signl = positive? BCND DONEO, GT LACC tmp Lhigh, 16 ; ACC high = tmp I_high ; ACC = tmpl_high tmp3_low tmpLlow ADDS ; Make the result negative NEG SACH tmp I_high ; tmp Lhigh = ACC high SACL tmp I_low ; tmp I_low = ACC low DONEO ; ialfa(k)*ubeta(k)-ibeta(k)*ualfa(k) = tmp2 => QI5*QI5-QI5*QI5 = Q31 LT ibeta_mras; TREG = ibeta(k) (Q15) MPY ualfa_mras ; PREG = ibeta(k)*ualfa(k) (Q30) (Q30) PAC ; ACC = ibeta(k)*ualfa(k) NEG ; Make result negative ialfa_mras; TREG = ialfa(k) (QI5) LT MPY ubeta_mras ; PREG = ialfa(k)*ubeta(k) (Q30) APAC ; ACC = ialfa(k)*ubeta(k)-ibeta(k)*ualfa(k) (Q30) SACL tmp2_low,1 ; tmp2 = ialfa(k)*ubeta(k)-ibeta(k)*ualfa(k) (L 16 bit) (Q31) SACH tmp2_high,1 ; tmp2 = ialfa(k)*ubeta(k)-ibeta(k)*ualfa(k) (H 16 bit) (Q31) ; tmp4 = q(k) = tmp2 - tmpl => Q15 = Q31 - Q31 Q LACC tmp2_high,16 ; ACC high = tmp2_high (Q31) ; ACC low = tmp2_1ow (Q31) ADDS tmp2_1ow ; ACC = tmp2_1ow-tmpl_low (Q31) SUBS tmp I_low SUBH tmpl_high ; ACC = tmp2_high-tmpLhigh (Q31) ; tmp4 or q(k) = tmp2_high-tmpl_high (QI5); SACH tmp4 ;Averaging the reactive power => (q(k)+q(k-l»/2 (Q15) LACC tmp4 ;ACC =q(k) (QI5) ; ACC = q(k)+q(k-l) ADD q ; ACC = (q(k)+q(k-I»/2 (QI5) SFR (Q15) ; q(k) = (q(k)+q(k-l»/2 SACL q ; Update ialfa(k-l) = ialfa(k) and ibeta(k-l) = ibeta(k) LACC ialfa_mras ; ACC low = ialfa(k) (QI5) SACL ialfa_old ; ialfa(k-l) = ialfa(k) (QI5) LACC ibeta_mras ; ACC low = ibeta(k) (QI5) (QI5) SACL ibeta_old ; ibeta(k-l) = ibeta(k) ; ------------------------- End reference model section ---------------------------.endif

83

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

.if (adCmodeU

; ------------------------ Start adaptive model section ---------------------------IM_ALFA ; K5-K4*wchat*wr_hat = tmpl => Q15-Q15*Q15*Q15 = Q31 LT wr_haCmras ; TREG = wr_hat(k) (Q15) MPY wr_haUnras ; PREG = wr_hat(k)*wr_hat(k) (Q30) PAC ; ACC = wr_hat(k)*wchat(k) (Q30) SACH tmp I_high, 1 ; tmpl_high = wr_hat(k)*wr_hat(k) (Q15) LT tmpl_high ; TREG = wr_hat(k)*wchat(k) (Q15) ; PREG = K4*wr_hat(k)*wr_hat(k) (Q30) MPY K4 PAC ; ACC = K4*wr_hat(k)*wr_hat(k) (Q30) ; ACC = -K4*wr_hat(k)*wr_hat(k) (Q30) NEG SFL ; rotate to left 1 bit (SXM=l) (Q31) ADDH KS ; ACC = KS-K4*wr_hat(k)*wr_hat(k) (Q31) SACH tmpl_high ; tmpl_high = KS-K4*wr_hat(k)*wr_hat(k) (Q31) SACL tmpClow ; tmpClow = K5-K4*wr_hat(k)*wr_hat(k) (Q31) ; wr_hat(k)*K6 = tmp4 => Q15*Q15 = Q15 ; TREG = wr_hat(k) (Q15) LT wchat_mras ; PREG = K6*wr_hat(k) MPY K6 (Q30) PAC ; ACC = K6*wChat(k) (Q30) ; tmp4 = K6*wr_hat(k) SACH tmp4,1 (Q15) ; tmp 1*imalfa(k-l) = tmp2 => Q31 *Q31 = Q31 ; check sign for "imalfa_old" and "tmpl" LACC tmpChigh ; ACC = tmpChigh XOR imalfa_old_high , SACLsignl ; Sign (0=+,1=-) for tmpl *imalfa(k-l) ; check sign for "imbeta_old" and "tmpl" LACC tmp I_high ; ACC = tmpl_high XOR imbeta_old_high SACL sign2 ; Sign (O=+,l=-) for tmpl *imbeta(k-l) ; check sign for "imalfa_old" and "tmp4" LACC tmp4 ; ACC=tmp4
XOR

SACL sign3 ; take absolute for "imalfa_old" and "tmpl" LACC tmp I_high, 16 ADDS tmp Clow

; Sign (0=+,1 =-) for tmp4*imalfa(k-l) ; ACC high = tmpChigh ; ACC = tmpChigh tmpl_low ; tmp Clow = ACC low ; tmpl_high = ACC high ; ACC high = imalfa(k-lLhigh ; ACC = imalfa(k-lLhigh imalfa(k-1Uow ; imalfa(k-1Uow = ACC low ; imalfa(k-1Lhigh = ACC high ; TREG = imalfa(k-1Uow ; PREG = imalfa(k-lUow*tmpl_low ; tmp5 = PREG high (save partial result) ; PREG = imalfa(k-1Uow*tmpl_high ; TREG = imalfa(k-lLhigh, ACC = PREG ; PREG = imalfa(k-lLhigh*tmpl_low (PREG_old) ; ACC = imalfa(k-l Uow*tmp I_high + tmp5

ABS
SACL SACH LACC ADDS tmpClow tmpl_high imalfa_0Id_high,16 imalfa_old_low

ABS
SACL imalfa_old_low SACH imalfa_old_high ; now they're positive. imalfa_old_low LT MPYU tmpl_low SPH tmp5 MPYU tmpChigh LTP imalfa_old_high MPYU tmpl_low ADDS tmp5

84

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

MPYA tmpl_high SACH tmpS SPLK # I h,tmp2_low BCND NO_CI ,NC B CHECK I NO_CI

; ACC = ACC + PREG_old, PREG_new = imalfa(k; 1Lhigh*tmp Lhigh ; tmpS = ACC high ; tmp2_low = 1 (carry bit) ; Carry bit = 0 ? ; Branch to CHECK 1 if carry bit = 1

SPLK #Oh,tmp2_low ; tmp2_low = 0 (no carry bit) CHECK I PAC ; ACC = imalfa(k-ILhigh*tmpl_high ADDS tmp5 ; ACC = imalfa(k-ILhigh*tmpLhigh + tmpS ADDH tmp2_low ; ACC = imalfa(k-ILhigh*tmpl_high + tmp5 + tmp2_low (Canybit) SACH tmp2_high, I ; tmp2_high = ACC high (Q31) SACL tmp2_low,1 ; tmp2_low = ACC low (Q31) ; check the sign condition LACC sign I ; ACC = signl BCND DONE I , GT ; Check signl = positive? LACC tmp2_high,16 ; ACC high = tmp2_high ADDS tmp2_low ; ACC = tmp2_high tmp2_low NEG ; Make the result negative SACH tmp2_high ; tmp2_high = ACC high SACL tmpLlow ; tmp2_low = ACC low DONE 1 ; imbeta_old*tmp4 = tmp3 => Q31 *QIS = Q31 ; check sign for "imbeta_old" and "tmp4" LACC tmp4 ; ACC=tmp4 XOR , SACL sign 1 ; Sign (0=+,1=-) fortmp4*imbeta(k-l) ; take absolute for "imbeta_old" and "tmp4" LACC tmp4 ; ACC=tmp4 ABS ; ACC = Jtmp4J ; tmp4 = ACC low SACL tmp4 ; ACC high= imbeta(k-ILhigh LACC imbeta_old_high,16 ; ACC = imbeta(k-l) ADDS imbeta_old_low ABS ; ACC = Jimbeta(k-l)J SACL imbeta_old_low ; imbeta(k-ILlow = ACC low SACH imbeta_old_high ; imbeta(k-ILhigh = ACC high ; now they're positive. LT ; TREG=tmp4 tmp4 MPYU imbeta_old_low ; PREG = imbeta(k-lUow*tmp4 tmp3_low SPH ; tmp3_low = PREG high MPYU imbeta_old_high ; PREG = imbeta(k-lLhigh*tmp4 PAC ; ACC = imbeta(k-ILhigh*tmp4 ADDS tmp3_low ; ACC = imbeta(k-ILhigh*tmp4+tmp3_low SACH tmp3_high,1 ; tmp3_high = ACC high (Q31) SACL tmp3_low,1 ; tmp3_low = ACC low (Q31) ; check the sign condition LACC sign 1 ; ACC = sign 1 BCND DONE2, GT ; Check signl = positive? LACC tmp3_high,16 ; ACC high= tmp3_high ADDS tmp3_low ; ACC = tmp3_low ; Make the result negative NEG SACH tmp3_high ; tmp3_high = ACC high SACL tmp3_low ; tmp3_low = ACC low DONE2

85

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

; tmp2 - tmp3 = tmp3 => Q3I - Q3I = Q3I LACC tmp2_high,I6 ; ACC high = tmp2_high ADDS tmp2_low ; ACC low = tmp2_low SUBS tmp3_low ; ACC = tmp2_low-tmp3_low SUBH tmp3_high ; ACC = tmp2_high-tmp3_high SACL tmp3_low ; tmp3_low = tmp2_low-tmp3_low (L 16-bit) SACH tmp3_high ; tmp3_high = tmp2_high-tmp3_high (H 16-bit) ; ialfa(k)*K7 = tmp2 => QI5*QI5 = Q3I LT ialfa_rnras (QI5) ; TREG = ialfa(k) (Q30) ; PREG = ialfa(k)*K7 MPY K7 PAC (Q30) ; ACC = ialfa(k)*K7 SACH tmp2_high,I ; tmp2_high = ACC high (Q31) ; tmp2_low = ACC low SACL tmp2_low, I (Q31) ; imalfa(k) = tmp3 + tmp2 => Q3I = Q3I + Q31 ; ACC high = tmp3_high LACC tmp3_high,16 ADDS tmp3_low ; ACC low = tmp3_low ADDS tmp2_low ; ACC = tmp3_low+tmp2_low ADDH tmp2_high ; ACC = tmp3_high+tmp2_high SACL imalfa_low ; imalfa_low = tmp3_low+tmp2_low (L 16-bit) ; imalfa_high = tmp3_high+tmp2_high (H I6-bit) SACH imalfa_high 1M_BETA ; tmp 1*imbeta(k-I) = tmp2 => Q3I *Q3I = Q3I ; already checked sign for "imbeta_old" and "tmpI" kept in sign2 ; already took absolute for "imbeta_old" and "tmpI" ; now they're positive. LT imbeta_old_low ; TREG = imbeta(k-IUow MPYU tmpLlow ; PREG = imbeta(k-I Uow*tmp I_low SPH tmp5 ; tmp5 = PREG high (save partial result) MPYU tmpl_high ; PREG = imbeta(k-lUow*tmpl_high LTP imbeta_old_high ; TREG = imbeta(k-iLhigh, ACC = PREG MPYU tmpl_low ; PREG = imbeta(k-iLhigh*tmpI_Iow (PREG_old) ADDS tmp5 ; ACC = imbeta(k-1Uow*tmpI_high + tmp5 MPYA tmp Lhigh ; ACC = ACC + PREG_old, PREG_new = imbeta(k;1Lhigh*tmp I_high ; tmp5 = ACC high SACH tmp5 ; tmp2_low = 1 (carry bit) SPLK # Ih,tmp2_low BCND NO_C2,NC ; Carry bit = 0 ? B ; Branch to CHECK2 if carry bit = 1 CHECK2 NO_C2 ; tmp2_low = 0 (no carry bit) SPLK #Oh,tmp2_low CHECK2 ; ACC = imbeta(k-iLhigh*tmpLhigh PAC ; ACC = imbeta(k-iLhigh*tmpLhigh + tmp5 ADDS tmp5 ADDH tmp2_low ; ACC = imbeta(k-iLhigh*tmpI_high + tmp5 + tmp2_low (Carry bit) SACH tmp2_high,I ; tmp2_high = ACC high (Q3I) SACL tmp2_low,I ; tmp2_low = ACC low (Q3I) ; check the sign condition ; ACC = sign2 LACC sign2 ; Check sign2 = positive? BCND DONE3, GT ; ACC high = tmp2_high LACC tmp2_high,16 . ; ACC = tmp2_high tmp2_low ADDS tmp2_low ; Make the result negative NEG ; tmp2_high = ACC high SACH tmp2_high ; tmp2_low = ACC low SACL tmp2_low DONE3

86

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

; imalfa_old*tmp4 = tmp3 => Q31 *Q15 = Q31 ; already checked sign for "imalfa_old" and "tmp4" kept in sign3 ; already took absolute for "imalfa_old" and "tmp4" ; now they're positive. LT tmp4 ; TREG=tmp4 MPYU imalfa_old_low ; PREG = imalfa(k-1LJow*tmp4 SPH tmp3_low ; tmp3 _low = PREG high ; PREG = imalfa(k-ILhigh*tmp4 MPYU imalfa_old_high PAC ; ACC = imalfa(k-ILhigh*tmp4 ; ACC = imalfa(k-ILhigh*tmp4+tmp3_low ADDS tmp3_low SACH tmp3_high, I ; tmp3_high = ACC high (Q31) SACL tmp3_low,1 ; tmp3_low = ACC low (Q31) ; check the sign condition LACC sign3 ; ACC =sign3 BCND DONE4, GT ; Check sign3 = positive? LACC tmp3_high,16 ; ACC high= tmp3_high ADDS tmp3_low ; ACC = tmp3_low ; Make the result negative NEG SACH tmp3_high ; tmp3_high = ACC high SACL tmp3_low ; tmp3_low = ACC low DONE4 ; tmp2 + tmp3 = tmp3 => Q31 + Q31 = Q31 LACC tmp3_high,16 ; ACC high = tmp3_high ADDS tmp3_low ; ACC low = tmp3_low ADDS tmp2_low ; ACC = tmp3_low+tmp2_low ADDH tmp2_high ; ACC = tmp3_high+tmp2_high SACL tmp3_low ; tmp3_low = tmp3_low+tmp2_low (L 16-bit) SACH tmp3_high ; tmp3_high = tmp3_high+tmp2_high (H 16-bit) ; ibeta(k)*K7 = tmp2 => Q15*Q15 = Q31 ; TREG = ibeta(k) (QI5) LT ibeta_mras K7 ; PREG = ibeta(k)*K7 (Q30) MPY ; ACC = ialfa(k)*K7 (Q30) PAC (Q31) ; tmp2_high = ACC high SACH tmp2_high,1 (Q31) SACL tmp2_low,1 ; tmp2_low = ACC low ; imbeta(k) = tmp3 + tmp2 => Q31 = Q31 + Q31 ; ACC high = tmp3_high LACC tmp3_high,16 ; ACC low = tmp3_1ow ADDS tmp3_low ADDS tmp2_low ; ACC = tmp3_low+tmp2_low ADDH tmp2_high ; ACC = tmp3_high+tmp2_high ; imbeta_Iow = tmp3_low+tmp2_low (L 16-bit) SACL imbeta_Iow ; imbeta_high = tmp3_high+tmp2_high (H 16-bit) SACH imbeta_high ; update imbeta(k-l) LACC imbeta_high,16 ; ACC high = imbeta(kLhigh ADDS imbeta_Iow ; ACC = imbeta(k) SACL imbeta_old_low ; imbeta(k-1LJow = imbeta(kLlow SACH imbeta_old_high ; imbeta(k-ILhigh = imbeta(kLhigh ; update imalfa(k-l) LACC imalfa_high,16 ; ACC high = imalfa(kLhigh ADDS imalfa_low ; Ace = imalfa(k) ; imalfa(k-1LJow = imalfa(kLlow SACLimalfa_old_low ; imalfa(k-ILhigh = imalfa(kLhigh SACH imalfa_old_high E_ALFA ; ialfa(k) - imalfa(k) = tmp I_low => Q 15 - Q31 = Q IS LACC ialfa_mras,16 ; ACC high = ialfa SUBS imalfa_low ; ACC low = ialfa_low-imalfa_low SUBH imalfa_high ; ACC high = ialfa_high-imalfa_high

87

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

SACH tmpl_low ; trnpLlow = ialfa_high-imalfa_high (H 16-bit) ; ibeta(k) - imbeta(k) =trnpl_high => Ql5 - Q31 = Q15 LACC ibeta_mras,16 ; ACC high = ibeta SUBS imbeta_Iow ; ACC low = ibeta_Iow-imbeta_low SUBH imbeta_high ; ACC high = ibeta_high-imbeta_high SACH tmpl_high ; trnpLhigh = ibeta_high-imbeta_high (H 16-bit) ; wchat(k)*imbeta(k) = trnp4 => Q15*Q31 = Q15 ; check sign for "wchat" and "imbeta" kept in signl LACC wchaCmras ;ACC=wchat XOR imbeta_high , ; Sign (0=+,1=-) for wr_hat*imbeta(k) SACL sign 1 ; take absolute for "imbeta" and "wr_hat" (tmp5 = Iwr_hatl) ; ACC = wr_hat LACC wr_haCmras ABS ; ACC = Iwr_hatl SACL tmp5 ; tmp5 = Iwr_hatl LACC imbeta_high,16 ; ACC high= imbeta(kLhigh ; ACC = imbeta(k) ADDS imbeta_Iow ABS SACL imbeta_Iow ; imbeta(kUow = ACC low SACH imbeta_high ; imbeta(kLhigh = ACC high ; now they're positive trnp5 LT (QI5) ; TREG = Iwchat(k)I ; PREG = wchat(k)*imbeta(kUow MPYU imbeta_Iow SPH ; trnp4 = PREG high tmp4 MPYU imbeta_high ; PREG = wr_hat(k)*imbeta(kLhigh PAC ; ACC = wr_hat(k)*imbeta(kLhigh ADDS tmp4 ; ACC = wr_hat(k)*imbeta(kLhigh+trnp4 SACH trnp4,1 ; tmp4 = wr_hat(k)*imbeta(k) (Q15) ; check the sign condition LACC sign 1 ; ACC = sign 1 BCND DONE5, GT ; Check sign 1 = positive? LACC tmp4 ; ACC=tmp4 ; Make the result negative NEG ; tmp4 = ACC low (QI5) SACL trnp4 DONE5 ; K3 *trnp4 = trnp4 => Q8*Q 15 = Q9 LT ; TREG=K3 (Q8) K3 (Q23) MPY tmp4 ; PREG = tmp4*K3 (Q23) PAC ;ACC = tmp4*K3 SACH tmp4,2 ; tmp4 = trnp4 *K3 (Q9) ; trnpl_low - trnp4 = tmp4 => Q15 - Q9 = Q9 (Q9) LACC tmpl_low,lO ; ACC high = trnp Llow SUBH trnp4 ; ACC = trnpl_low-tmp4 (Q9) (Q9) SACH trnp4 ; trnp4 = tmpl_low-tmp4 ; ealfa(k) = tmp4*K2 => Q15 = Q9*Q15 LT K2 (QI5) ; TREG=K2 MPY tmp4 ; PREG = trnp4*K2 (Q24) PAC ;ACC = tmp4*K2 (Q24) SACH ealfa,7 ; ealfa = tmp4*K2 (QI5) E_BETA ; wr_hat(k)*imalfa(k) = trnp4 => Q15*Q31 = Q15 ; already took absolute for "wchat" kept in trnp5 ; check sign for "wr_hat" and "imalfa" kept in sign2 ; ACC = wr_hat LACC wr_haCmras XOR imalfa_high , ; Sign (0=+,1 =-) for wr_hat*imalfa(k) SACL sign2

88

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

; take absolute for "imalfa" (tmp5 = Iwchatl) LACC imalfa_high,16 ; ACC high= imalfa(kLhigh ADDS imalfa_low ; ACC = imalfa(k)

ABS
SACL imalfa_low SACH imalfa_high ; now they're positive LT tmp5 MPYU imalfa_low SPH tmp4 MPYU imalfa_high ; imalfa(kLlow = ACC low ; imalfa(kLhigh = ACC high (QI5) ;REG = Iwr_hat(k)1 ; PREG = wr_hat(k)*imalfa(kLlow ;tmp4 = PREG high ; PREG = wr_hat(k)*imalfa(kLhigh

PAC ; ACC = wr_hat(k)*imalfa(kLhigh ;ACC = wchat(k)*imalfa(kLhigh+tmp4 ADDS tmp4 SACH tmp4,1 ; tmp4 = wr_hat(k)*imalfa(k) (QI5) ; check the sign condition LACC sign2 ; ACC =sign2 BCND DONE6, GT ;Check sign2 = positive? LACC tmp4 ;ACC=tmp4 NEG ; Make the result negative SACL tmp4 ; tmp4 = ACC low (QI5) DONE6 ; K3*tmp4 = tmp4 => Q8*Q15 = Q9 (Q8) LT K3 ;TREG=K3 MPY tmp4 (Q23) ; PREG = tmp4*K3 PAC (Q23) ; ACC = tmp4*K3 SACH tmp4,2 (Q9) ; tmp4 = tmp4 *K3 ; tmpl_high + tmp4 = tmp4 => Ql5 + Q9 = Q9 ; ACC high = tmp I_high LACC tmpLhigh,IO (Q9) (Q9) ADDH tmp4 ; ACC = tmp Lhigh+tmp4 SACH tmp4 (Q9) ; tmp4 = tmp Lhigh+tmp4 ; ebeta(k) = tmp4*K2 => Ql5 = Q9*Q15 (QI5) LT K2 ; TREG=K2 MPY tmp4 (Q23) ; PREG = tmp4*K2 (Q23) ; ACC =tmp4*K2 PAC (QI5) SACH ebeta,7 ; ebeta = tmp4 *K2 Q_HAT ; q_hat(k) = ialfa(k)*ebeta(k)-ibeta(k)*ealfa(k) => Ql5 = QI5*QI5-Q15*QI5 LT ibeta_mras ; TREG = ibeta(k) (QI5) MPY ealfa ; PREG = ibeta(k)*ealfa(k) (Q30) PAC ; ACC = ibeta(k)*ealfa(k) (Q30) NEG ; Make result negative LT ialfa_mras ; TREG = ialfa(k) (QI5) MPY ebeta i PREG = ialfa(k)*ebeta(k) (Q30) APAC ; ACC = ialfa(k)*ebeta(k)-ibeta(k)*ealfa(k) (Q30) SACH q_hat,l ; q_hat = ialfa(k)*ebeta(k)-ibeta(k)*ealfa(k) (QI5) ; ------------------------ End adaptive model section ---------------------------.endif .if (pi_mras_) ; --------------- Start conventional PI controller section -----------------------

,
;PCMRAS:

,
; tmpl = Kp*error(k-l) =>Q31 =QI5*QI5 LT Kp MPY error ; TREG = Kp (QI5) ; PREG = Kp*error(k-l) (Q30)

89

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

PAC ; ACC = Kp*error(k-l) SACH tmpChigh,1 ; tmpl_high = Kp*error(k-l) SACL tmpl_Iow,l ; tmpl_Iow = Kp*error(k-l) ; error(k) = q - q_hat => Q15 = Q15 - Q15 LACC q ; ACC = q (QI5) SUB q_hat ; ACC = q - <I-hat (QI5) SACL error ; error = q - q_hat (Q15) ;Kp+Ki=tmp2 => Q15+Q31=Q31 LACC Ki_high,16 ; ACC high = Ki_high ADDS Ki_Iow ; ACC = Ki_Iow (Q31) (Q31) ADDH Kp ; ACC high = Ki_high + Kp SACH tmp2_high ; tmp2_high = Ki_high + Kp (Q31) SACL tmp2_low ; tmp2_low = Ki_Iow + Kp (Q31) ; tmp2*error = tmp2 => Q31 *Q15 = Q31 ; check sign for "error" only LACC error ; ACC = error SACL signl ; Sign (O=+,l=-) for (Kp+Ki)*error ; take absolute for "error" only because "tmp2" is always positive ABS ; ACC = lerrorl SACL error ; error = ACC low ; now they're positive. ; TREG = error LT error ; PREG = tmp2_low*error MPYU tmp2_low tmp2_low ; tmp2_low = PREG high SPH ; PREG = tmp2_high*error MPYU tmp2_high ; ACC = tmp2_high*error PAC ; ACC = tmp2_high*error + tmp2_low ADDS tmp2_low SACH tmp2_high,1 ; tmp2_high = ACC high (Q31) SACL tmp2_low,1 ; tmp2_low = ACC low (Q31) ; check the sign condition ; ACC = signl LACC sign 1 BCND DONE7, GT ; Check sign 1 = positive? LACC tmp2_high,16 ; ACC high= tmp2_high ; ACC low = tmp2_low ADDS tmp2_low ; Make the result negative NEG ; tmp2_high = ACC high SACH tmp2_high ; tmp2_low = ACC low SACL tmp2_low DONE7 ; tmp2 - tmpl = tmpl_high => Q31 - Q31 = Q15 LACC tmp2_high,16 ; ACC high = tmp2_high (Q31) ADDS tmp2_low ; ACC low = tmp2_low (Q31) SUBS tmp I_low ; ACC = tmp2_low-tmp Clow (Q31) SUBH tmpl_high ; ACC = tmp2_high-tmpl_high (Q31) SACH tmpl_high ; tmpl_high = tmp2-tmpl (QI5) ; wchat(k) = wchat(k-l) + tmpl_high => Q15 = Q15 + Q15 (update wchat) LACC wchacmras ; ACC = wr_hat(k-l) (Q15) ADD tmpl_high ; ACC = WT_hat(k-I)+tmpChigh (Q15) ; wr_hat(k) = wr_hat(k-l)+tmpl_high (Q15) SACL WT_haCmras .endif ; --------------- End conventional PI controller section ----------------------; Change motor speed from pu value to rpm value (Q15 -> QO signed) LT base_rpm ; TREG = base_rpm (Q3) MPY WT_haCmras ; PREG = base_rpm*WT_haCmras (QI8) PAC ; ACC = base_rpm*WT_haCmras (Q18) SFR ; ACC = base_rpm*WT_haCmras (Q 17) SFR ; ACC = base_rpm*WT_haCmras (QI6)

(Q30) (Q31) (Q31)

90

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

SACH LT

MPY
PAC SACH RET

wchaCrpm_mras wccal wr_haCmras wchaCmras 1,1

; wchat_rpm_mras = base_rpm*wchaCmras (QO) ; TREG = wccal (QI5) ; PREG = (Q30) (Q30) ; ACC =

; Module Name:
'-

PID_REGl

; Description: Digital Pill controller without anti-windup correction pid_reLregl o--------->IQI5 Pill_REG! QI51----->o pid_ouCregl ; pid_fb_regl o--------->IQI5 I .def .def .def Pill_REG 1, Pill_REG I_INIT pid_fb_regl, pid_reLregl pid_ouCregl ;function call ;Inputs ;Output

,
.set 20866 80 .set .set -1000 .set 5997 PID_OUT_MAX_ 300 .set PID_OUT_MIN_ .set OOOOh .include "x24x_app.h" Kp_REGL Ki_HCREGlKi_LO_REGL Kd_REGl; for Kp_regl ; for KUow_regl (Ki=O for PD) ; for Ki_high_regl (Ki=O for PD) ; for Kd_regl (Kd=O for PI) ; for pid_ouCmax ; for pid_ouCmin

,
;Variable Definitions for Pill_REG 1 module

;--------------------------------------------------------------------------Kp_regl KUow_regl Ki_high_reg 1 Kd_regl KO_Iow_regl KO_high_regl Kl_regl pid_fb_regl pid_reCreg 1 pid_out_regl pid_outl_reg 1 pid_eO_regl pid_e I_reg 1 pid_e2_regl tmpLlow_regl tmpl_high_regl tmp2_low_reg 1 tmp2_high_reg 1 tmp3_regl
a~s_eO_regl

slgn_regl PID_OUT_MAX PID_REG I_INIT: LDP SPLK SPLK

.usect .usect .usect .usect .usect .usect .usect .usect .usect .usect .usect .usect .usect .usect .usect .usect .usect .usect .usect .usect .useet .usect

"pid_reg 1",1 "pid_reg 1", 1 "pid_regl ",1 "pid_regl ",1 "pid_regl",1 "pid_regl ",1 "pid_regl ",1 "pid_reg 1",1 "pid_reg 1", 1 "pid_reg 1",1 "pid_regl ",1 "pid_reg 1", 1 "pid_reg 1", 1 "pid_reg 1", 1 "pid_regl ",1 "pid_regl ",1 "pid_regl ",1 "pid_reg 1",1 "pid_reg 1",1 "pid_regl ",1 "pid_reg 1" , 1 "pid_reg 1",1

; Kp =Q15 ; Ki=Q31 ; Ki =Q31 ;Kd=QI5 ; KO=Q31 ; KO=Q31 ; Kl =Q15

#Kp_regl #Kp_REG 1_,Kp_regl #Ki_LO_REG 1_,Ki_Iow_reg 1

91

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

SPLK #Ki_HCREG1_,Ki_high_reg1 SPLK #Kd_REGl_,Kd_regl SPLK #0,pid31_regl SPLK #0,pid32_regl SPLK #O,pid_outLreg1 SPLK #PID_OUT_MAX_,PID_OUT_MAX RET

SETC SXM ; Sign extension mode SETC OYM ; Overflow mode SPM 0 ; Reset SPM ; Converting from Kp, Ki, Kd to KO, Kl (Note: K2 = Kd) LDP #Kp_regl (Q3l) LACC Ki_high_regl,16 ; ACC = Ki ; ACC = Ki (Q31) ADDS Ki_low_regl ;ACC=Kp+Ki ADD Kp_regl,16 ADD Kd_regl,16 ; ACC = Kp + Ki + Kd ; KO = Kp + Ki + Kd SACH KO_high_regl SACL KO_low_regl ; KO = Kp + Ki + Kd LACC Kd_reg 1,16 ;ACC=Kd ; ADD =2*Kd SFL (Ql5) ADD Kp_regl,16 ; ACC = 2*Kd+Kp ; Kl = 2*Kd+Kp (QI5) SACH KLregl ; e(k) = ref(k)-fb(k) => Q15 = Q15 - Q15 LACC pid_reCregl ; ACC = pid_reCregl (QI5) SUB pid_fb_regl ; ACC = pid_reCregl - pid_fb_regl (QI5) ; e(k) = pid_reCregl - pid_fb_regl (Ql5) SACL pid30_regl ; tmpl = -Kl *e(k-l)+K2*e(k-2) => Q31 = -QI5*QI5 + Q15*Q15 LT Kd_regl ; TREG = K2 MPY pid_e2_regl ; PREG = K2*e(k-2) PAC ; ACC = K2*e(k-2) KLregl ; TREG = KI LT MPY pid_el_regl ; PREG = Kl *e(k-l) (Q30) SPAC ; ACC = -Kl *e(k-l)+K2*e(k-2) tmpLhigh_regl,l ; tmpl = -Kl *e(k-l)+K2*e(k-2) SACH (Q31) SACL tmpl_low_regl,l ; tmpl = -Kl *e(k-l)+K2*e(k-2) (Q31) ;tmp2=KO*e(k) => Q31=Q3l*QI5 ; check sign for "error" only LACC pid_eO_regl ; ACC = e(k) SACL sign_regl ; Sign (0=+,1=-) for KO*e(k) ; take absolute for "pid_e2_regl" only because "KO" is always positive ABS ; ACC = le(k)1 SACL abs_eO_regl ; le(k)1 = ACC low ; now they're positive. LT abs_eOJegl ; TREG = le(k)1 ; PREG = KO_low*le(k)1 MPYU KO_Iow_regl ; tmp2_low = PREG high tmp2_low_reg 1 SPH MPYU KO_high_reg 1 ; PREG = KO_high*le(k)1 ; ACC = KO_high*le(k)1 PAC ADDS tmp2_low_regl ; ACC = KO_high*le(k)1 + tmp2_low ; tmp2_high = ACC high (Q31) SACH tmp2_high_reg 1,1 SACL tmp2_low_regl,1 (Q3l) ; tmp2_low = ACC low ; check the sign condition LACC sign_regl ; ACC = sign

(Q31) (Q31) (Q31) (Q31) (QI5) (QI5)

(QI5) (Q30) (Q30) (QI5) (Q30)

92

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

BCND LACC ADDS NEG SACH SACL

DONE_REG I, GT tmp2_high_regl,16 tmp2_low_regl tmp2_high_regl tmp2_low_regl

; Check sign = positive? ; ACC high= tmp2_high ; ACC low = tmp2_low ; Make the result negative ; tmp2_high = ACC high ; tmp2_low = ACC low

DONE_REG I ; tmp2 + tmpl = tmp3 => Q31 + Q31 = Q15 LACC tmpChigh_regl,16 ; ACC high = tmpl_high (Q31) ADDS tmp I_low_reg 1 ; ACC low = tmpl_Iow (Q31) ADDS tmp2_low_regl ; ACC = tmp Llow+tmp2_low (Q31) ADDH tmp2_high_regl ; ACC = tmpLhigh+tmp2_high (Q31) SACH tmp3_regl ; tmp3 = tmpLhigh+tmpl_high (QI5) ; u(k) = u(k-l) + tmp3 => Q15 = Ql5 + Ql5 LACC pid_outCregl,16; ACC =u(k-l) (Q15) ADD tmp3_regl,16 ; ACC = u(k-l)+KO*e(k)-Kl *e(k-l)+K2*e(k-2) (Q15) SACH pid_ouCregl ; u(k) = u(k-l)+KO*e(k)-Kl *e(k-l)+K2*e(k-2) (Q15) ; Ifu(k) > u_max, u(k) = u_max. Ifu(k) < u_min, u(k) = u_min. LACC pid_ouCregl ; ACC = u(k) (Q15) SUB #PID_OUT_MAX_; ACC = u(k)-u_max (Q15) #PID_OUT_MAX_ SUB BCND SAT_MAX,GT ; Branch if saturated at max LACC pid_ouCregl ; ACC = u(k) (QI5) SUB #PID_OUT_MIN_ ; ACC = u(k)-u_min (QI5) BCND SAT_MIN,LT ; Brnch if saturated at min B REG I_END SAT_MIN SPLK #PID_OUT_MIN_,pid_ouCreg I ; u(k) =u_min (Q15) REG I_END B SAT_MAX SPLK #PID_OUT_MAX_,pid_ouCregl (QI5) REG I_END ; Updating the errors e(k-l), e(k-2) and output u(k-l) pid_eCregl ; ACC = e(k-l) LACC (Q15) SACL pid32_regl ; e(k-2) = e(k-l) (Q15) LACC pid_eO_regl ; ACC = e(k) (Q15) SACL pid_el_regl ; e(k-l) = e(k) (QI5) pid_ouCregl; ACC = u(k) LACC (QI5) pid_outCregl; u(k-l) = u(k) SACL (Q15) CLRC SXM RET

; Module Name:
; Description:

RAMP_CNTL

This module implements a ramp up and ramp down function. The output flag variable s_eq_cflg is set to 7FFFh when the output variable setpt_value equals the input variable target_value.

, ;Module definitions for external reference . RAMP_CNTL, RAMP_CNfL_INIT ; function call .def .def target_value ; Inputs .def rmp_dly_max, rmp_Io_limit ; Input Parameters .def rmp_hi_Iimit ; Input Parameter .def setpt_value, s_eq_Cflg ; Outputs

93

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

.,
targeCvalue .usect "nnp_cntl",l setpcvalue .usect "nnp_cntl",l s_eq_Cflg .usect "nnp_cntl",l nnp_delay_cntr .usect "nnp_cntl",l nnp_dly_max .usect "nnp_cntl",l nnp_Io_limit .usect "nnp_cntl",l nnp_hClimit .usect "nnp_cntl",l RAMP_CNTL_INIT: LDP #setpCvalue SPLK #Oh,setpt_value SPLK #Oh,nnp_delay3ntr SPLK #1,nnp_dly_max SPLK #0300h,nnp_Io_limit SPLK #07500h,nnp_hUimit RET #targeCvalue LDP LACC targeCvalue setpCvalue SUB BCND SET]LG,EQ LACC nnp_delay_cntr ADD #1 SACL nnp_delaY3ntr nnp_dly_max SUB BCND SRC_EXIT, LT CHNG_VALUE: LACC targeCvalue setpCvalue SUB BCND INC_VALUE, GT LACC setpcvalue #1 SUB SACL setpcva1ue nnp_Io_limit SUB BCND SRC_l,GEQ LACC nnp_Io_limit SACL setpcvalue SRC_l B LACC setpCvalue ADD #1 SACL setpCvalue nnp_hUimit SUB BCND SRC_l,LEQ LACC nnp_hUimit SACL setpCvalue

; If Set point = target ; set s_eq_Cflg = 7FFFh then exit

DEC_VALUE

INC_VALUE

RET

SET]LG SPLK RET #7FFFh, s_eq_Cflg

94

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

; Module Name:
; Description: This module generates the output command voltage for a specific input command frequency according to specified voltslhertz profile. This is used for variable speed implementation of AC induction motor drives. vhzjreqo------>I V_Hz]ROFILE I-~--->o v_out

;Module definitions for external reference . .def V_Hz_PROFILE, V_Hz]ROFILE_INIT ;function call .def vhzjreq ;Inputs .def v_out ;Outputs .def FL, FH, Fmax, Vmax, Vrnin, vCslope ;Parameters ; Config Information: For FL = 20%, FL = .2 x 32767 = 6553 For FH = 90%, FH = .9 x 32767 = 29490 For Vrnin = 20%, Vrnin = .2 x 32767 = 6553 VF_SLOPE = (Vmax - Vrnin)/(FH - FL) x 4096 = (1 - 0.2)/(0.9 - 0.2) x 4097 = 4681 .include x24x_app.h ;User configurable default parameter values FL_ .set 6553 ;Low Freq point on profile(QI5) FH_ .set 29490 ;High Freq point on profile(QI5) Fmax_ .set 7FFFh ;Max value (i.e. 0.999 .. in Q15) VF_SLOPE_ .set 4681 ;VoltslHz slope 2.67 in Q12 format Vmax_ .set 32765 ;0.9999 in Q15 Vrnin_ .set 6553 ;0.200 .. in Q15 (This is also the offset) ;User configurable default parameter values ;FL_ .set 6553 ;Low Freq point on profile(QI5) ;FH_ .set 16384 ;High Freq point on profile(Q 15) ;Fmax_ .set 7FFFh ;Max value (i.e. 0.999 .. in Q15) ;VF_SLOPE_ .set 10243 ;VoltslHz slope 2.67 in Ql2 format ;Vmax_ .set 31129 ;0.95 in Ql5 ;Vrnin_ .set 6553 ;0.200 .. in Ql5 (This is also the offset)
;---------------------------------------------------------------------------------

.'-

~?-f"_

vhzjreq .usect "vhz_prof',1 v_out .usect "vhz_prof',1 vCslope .usect "vhz_prof',l FL .usect "vhz_prof',l FH "vhz_prof',l .usect Fmax .useet "vhz_prof",l Vmax .usect "vhz_prof",l Vrnin .useet "vhz_prof",l GPRO_vhz .useet "vhz_prof",l ;---------------------------------------------------------------------;----------------------------------------------------------------------

LDP SPLK splk splk splk splk splk

#vhzjreq #VF_SLOPE_, vCslope #FL_, FL #FH_,FH #Fmax_, Fmax #Vmax_, Vmax #Vrnin_, Vrnin

95

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

RET
;---------------------------------------------------------------------;----------------------------------------------------------------------

PROFILE 1

PROFILE2

PROFILE3

LDP LACC SUB BCND LACC SACL B LACC SUB BCND LACC SUB SACL LT MPY PAC SACH LACC ADD SACL B LACC SACL RET

#vhz_freq vhzjreq ;Is Freq<=FL FL PROFILE2, GT Vrnin v_out ;V is in Q15 V_Hz_END vhz_freq FH PROFILE3, GT vhzjreq ;Acc = FREQ_IN FL ;Acc = FREQ_IN - FL GPRO_vhz GPR03hz vLslope ;P = vLslope * (FREQ_IN - FL) ;Q12 * Q15 --> Q27 v_out,4 ;convert result to Q 15 format v_out ;Offset is in Q15 Vrnin v_out ;v_out = vLslope * (FREQ_IN - FL) + Vrnin V_Hz_END Vmax ;v_out is in Q15 v_out

; Module Name:
; Description: This module calculates the appropriate duty ratios needed to generate a given stator ; reference voltage using space vector PWM technique. The stator reference voltage is described by it's ; magnitude and frequency. sv~ain 0------>1 1----->0 Ta sv_offseto----->I SVGEN_MF 1----->0 Tb 1----->0 Tc svjreqo------->I ;Module definitions for external reference . .def SVGEN_MF, SVGEN_MF_INIT sv~ain, sv_offset, sv_freq .def .def Ta, Th, Tc .def sv_freq_max .set .set .include ALPHA_SV .usect STEP_ANGLE_SV ENTRY_NEW .usect ENTRY_OLD .usect

;function call ;Inputs ;Outputs

2359 ;corresponds to 120Hz frequency . ;(7FFFh = 120Hz) 20kHz PWM 5190 ;corresponds to 66Hz frequency . ;(7FFFh = 66Hz) 5kHz PWM

x24x_app.h "svgen_mf",1 .usect "svgen_mf",1 "svgen_mf",1 "svgen_mf",1

96

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

SR_ADDR SECTOR_PTR dx dy T Ta Tb Tc sv-sain sv_offset sv_freq sv_freq_max

.usect .usect .usect .usect .usect .usect .usect .usect .usect .usect .usect .usect

"svgen_mf", I "svgen_mf",1 "svgen_mf",l "svgen_mf", I "svgen_mf",1 "svgen_mf",l "svgen_mf", I "svgen_mf", I "svgen_mf", I "svgen_mf", I "svgen_mf",l "svgen_mf",l

SVGEN_MF_INIT: Idp SPLK SPLK SPLK SPLK SPLK SPLK SPLK SPLK RET #ALPHA_SV #7FFFh, T ;T = 100% #0, ALPHA_SV ;Start at 0 deg #0, ENTRY_NEW ;Clear Sine Table Pointer #0, SECTOR_PTR ;Clear Sector Pointer #STEP_ANGLE_SV_MAX, svjreq_max #3FFFh, sv-sain ;Init amplitude to 0.5 #Oh, sv_offset ;Init offset to 0 #3FFFh, svjreq ;Init freq to 50%

;Normalise the freq input to appropriate step angle Idp #sv_freq svjreq LT ;svjreq is in Q15 MPY sv_freq_max ;svjreq_max is in QO PAC ,P = QO x Q15 = Q15 (in 32bit word) SACH STEP_ANGLE_SV,l ;shift 1 to restore QO fonnat ;Calculate new angle ALPHA LACC ENTRY_NEW SACL ENTRY_OLD LACC ALPHA_SV STEP_ANGLE_SV ADD ;Inc angle. SACL ALPHA_SV LACC ALPHA_SV,8 .SACH ENTRY_NEW LACC #STABLE60 ADD ENTRY_NEW TBLR dy ;dy=Sin(ALPHA) LACC #OFFh ;ACC=60deg ENTRY_NEW SUB ADD #STABLE60 ;dx=Sin(60-ALPHA) TBLR dx ;Determine which Sector LACC ENTRY_NEW SUB ENTRY_OLD BCND BRNCH_SR, GEQ ;If negative need to change Sector ;If positive continue MODIFY_SEC_PTR: LACC SECTOR_PTR

97

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

SUB BCND LACC ADD SACL B SPLK LACC ADD TBLR LACC BACC

#05h PISRl,EQ SECTOR_PTR #Olh SECTOR]TR BRNCH_SR #00, SECTOR_PTR #SECTOR_TBL SECTOR_PTR SR_ADDR SR_ADDR

;Check if at last sector (S6) ;If yes, re-init ARI = I st Sector (S 1) ;If no, select next Sector (Sn->Sn+ 1) ;i.e. inc SECTOR]TR ;Reset Sector pointer to 0

,------------------------------------------------------------------;Sector 1 calculations - a,b,c --> a,b,c
;-------------------------------------------------------------------

LACC SUB SUB SFR SACL ADD SACL LACC SUB SACL

T dx dy

;Acc=T ;Acc =T-dx ;Acc = T-dx-dy ;Acc = Ta = 1I2(T-dx-dy) <A> <B>

B ;------------------------------------------------------------------;Sector 2 calculations - a,b,c --> b,a,c & dx <--> dy

Ta ;Acc = Tb = dx+Ta dx Tb ;ACC=T T Ta ;ACC = T-Ta Tc ;ACC = Tc = T-Ta SV_END

<C>

,------------------------------------------------------------------LACC SUB SUB SFR SACL ADD SACL LACC SUB SACL
B

T dx dy

;Acc=T ;Acc =T-dx ;Acc = T-dx-dy ;Acc = Tb = 1I2(T-dx-dy) <A> <B>

Tb ;Acc = Ta = dy+Tb dy Ta ;ACC=T T Tb ;ACC = T-Tb ;ACC=Tc=T-Tb Tc SV_END

<C>

,-------------------------------------------------------------------

;Sector 3 calculations - a,b,c --> c,a,b
;-------------------------------------------------------------------

LACC SUB SUB SFR SACL ADD SACL LACC SUB

T

;Acc=T ;Acc =T-dx ;Acc = T-dx-dy ;Acc = Tc = 1I2(T-dx-dy) <A> ;Acc = Ta = dx+Tc ;ACC=T ;ACC=T-Tc <B>

dx dy Tb dx Tc T Tb

98

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

;ACC = Tb = T-Tc

<C>

;------------------------------------------------------------------;Sector 4 calculations - a,b,c --> c,b,a & dx <--> dy ;------------------------------------------------------------------;Acc=T LACC T ;Acc =T-dx SUB dx ;Acc = T -dx-dy dy SUB ;Acc = Tc = 1I2(T-dx-dy) <A> SFR SACL Tc <B> ;Acc = Tb = dx+Ta ADD dy SACL Tb ;ACC=T LACC T Tc ;ACC=T-Tc SUB <C> ;ACC = Ta = T-Tc SACL Ta SV_END B ;------------------------------------------------------------------;Sector 5 calculations - a,b,c --> b,c,a

,------------------------------------------------------------------LACC T ;Acc=T ;Acc =T-dx SUB dx ;Acc = T-dx-dy SUB dy ;Acc = Tb = 1I2(T-dx-dy) <A> SFR SACL Tc <B> ;Acc = Tc = dx+Ta ADD dx SACL Ta ;ACC=T LACC T Tc ;ACC = T-Tb SUB <C> SACL Tb ;ACC=Ta=T-Tb SV_END B
,-------------------------------------------------------------------

;Sector 6 calculations - a,b,c --> a,c,b & dx <--> dy ;------------------------------------------------------------------LACC T dx SUB dy SUB SFR SACL Ta dy ADD SACL Tc LACC T Ta SUB SACL Tb ;Acc =T ;Acc =T-dx ;Acc = T -dx-dy ;Acc = Ta = 1I2(T-dx-dy) <A> ;Acc = Tc = dx+Ta ;ACC=T ;ACC=T-Ta ;ACC = Tb = T-Ta <B>

<C> SV_END: ;Multiply by 2 & modify Ta output with input gain & offset LACC Ta SUB #3FFFh SACL Ta,1 ;Ta is in Q15 LT Ta ;sv~ain is in Q15 MPY sv~ain ;P = s~ain * Ta PAC ;shift 1 to restore Q 15 format SACH Ta,1 ;add offset value to Ta

99

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

LACC Ta ADD sv_offset SACL Ta ;Multiply by 2 & modify Th output with input gain & offset LACC Th SUB #3FFFh SACL Th,1 LT Th ;Tb is inQI5 MPY sv~ain ;sv~ain is in Q15 PAC ;P = suain * Tb SACH Th,1 ;shift I to restore Q 15 format ;add offset value to Th LACC Tb ADD sv_offset SACL Tb ;Multiply by 2 & modify Tc output with input gain & offset LACC Tc SUB #3FFFh SACL Tc,1 LT Tc ;Tc is in Q15 MPY sv~ain ;sv~ain is in QI5 PAC ;P = suain * Tc SACH TC,I ;shift I to restore QI5 format ;add offset value to Th LACC Tc ADD sv_offset SACL Tc RET ;------------------------------------------------------;SVPWM Sector routine jump table - used with BACC inst.
;-------------------------------------------------------

SECTOR_TBL: SRO .word SECTOR_SRI SRI .word SECTOR_SR2 SR2 .word SECTOR_SRJ SR3 .word SECTOR_SR4 SR4 .word SECTOR_SR5 SR5 .word SECTOR_SR6 ;------------------------------------------------------;-------------------------------------------------------

;Sine table (0 - 60 deg) used for Space Vector Generator. ;No. Samples 256 Angle Range 60 ;------------------------------------------------------Index Angle Sin(Angle) SlNVAL STABLE60: .word 0 0 0 0.00 .word I 0.23 134 0.00 0.Ql 268 2 0.47 .word .word 402 3 0.70 0.01

.................................................... .word 252 28106 .word 28175 253 .word 28243 254 .word 28311 255

59.06 59.30 59.53 59.77

0.86 0.86 0.86 0.86

100

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

; Module Name:
; Description: This module uses the duty ratio information and calculates the compare values for ; generating PWM outputs. The compare values are used in the full compare unit in 24x124xx event ; manager(EV). This also allows PWM period modulation. ; Mfunc31 0------>1 1----->0 CMPR1 (EV register) ; Mfunc32 0------>1 FC_PWM_DRV 1----->0 CMPR2 (EVregister) 0------>1 1----->0 CMPR3 (EV register) ; Mfunc33 ; Mfunc_p 0------>1 1----->0 TlPER (EV register) ; n_period 0------>1 _ _ _ _ __

,
; Define Related Peripherals
,----------------.----------------

.include "x24x_app.h" ; Default PWM Period
;------.------------------

;PWM_PERIOD .set PWM_PERIOD .set ;------.-----------------; Global Definitions
,-------------------------

SO 200

; PWM period in uS (20KHz) ; PWM period in uS (SKHz)

.def FC_PWM_DRV,FC_PWM_DRV_INIT .def Mfunc31 ,Mfunc32,Mfunc_c3,Mfunc_p .def n_period MfunC31 .usect "pwm_drv",l ; Phase 1 mod function QlS Mfunc_c2 .usect "pwm_drv",l ; Phase 2 mod function QlS MfunC_c3 .useet "pwm_drv",l ; Phase 3 mod function QlS Mfunc_p .usect "pwm_drv",l ; Period mod function Q1S n_period.useet "pwm_drv",l ; Norminal period/compare value m_period .usect "pwm_drv",l ; Modulated period
;------------------------------

;function calls ;Inputs ;Input

; Configuration parameters
;------------------------------

TlPER....set TlCON_ DBTCON_ ACTR... COMCON_

.ifx2407 PWM_PERIOD*IS ; *1000nS/(2*33nS) .set 1000100001000000b ; Symmetric PWM .set 09E8h ; DIB = U8uS @ 33nS clk .set 01 1001 1001 lOb ; 1/3/S Active Hi, 2/4/6 Active Lo .set 1000001 OOOOOOOOOb ; Compare Cnt! .endif

;----------------------------------------------------------------------

; Initialization
;-------------------------------------------.------------.--------.--.-

FC_PWM_DRV_INIT LDP #TlPER»7 SPLK #TlPER_,TlPER SPLK #TlCON->TlCON SPLK #DBTCON_,DBTCON SPLK #ACTR_,ACTR SPLK #COMCON_,COMCON .ifx240 SPLK #COMCON_+8000h,COMCON .endif .if x2431x2407

101

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

ldp LACC OR SACL .endif ldp SPLK SPLK RET ; Driver Routine

#OCRA»7 OCRA #00001 1111 1000000b OCRA #n_period #TlPER_,n_period #7FFFh,Mfunc_p

; Configure pins

,----------------------------------------------------------------------

FC_PWM_DRV: ldp LT MPY PAC add SACH ldp sach ldp LT MPY PAC add ldp SACH ldp LT MPY PAC add ldp SACH ldp LT MPY PAC add ldp SACH RET #Mfunc_p ; modulate period Mfunc_p n_period;Mfunc_p*n_periodl2 n_period,15 m_period #TlPER»7 TlPER #Mfunc31 Mfunc31 m_period m_period,15 #CMPRl»7 CMPRI #Mfunc32 Mfunc_c2 m_period m_period,15 #CMPR2»7 CMPR2 #Mfunc33 Mfunc_c3 m_period m_period,15 #CMPR3»7 CMPR3 ; offset by n_periodl2 ; save for later reference ; save ; Modulate channel one ; Mfunc31 x m_periodl2 ; offset by m_periodl2 ; save ; Modulate channel two ; Mfunc_c2 x m_period/2 ; offset by m_periodl2 ; save ; modulate channel three ; Mfunc_c3 x m_periodl2 ; offset by m_periodl2 ; save

I
I

Module Name: S Y SIN I T
; Description: Initializes F24x1xx devices .include x24x_app.h .def SYS_INIT .ref GPRO stack_size .set 20h stack_start .usect "stack",stack_size SYS_INIT: ;---target dependancy--------------.if (x2407)

I I
I
t
f

102

t

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

POINT]GO SETC INTM ;Disable interrupts SPLK #Oh, IMR ;Mask all Ints SPLK #OFFh, IFR ;Clear all Int Flags ;Init PDP interrupt flag after reset LDP #PIRQRO»7 LACC PIRQRO ; Clear pending PDP flag AND #OFFFEh SACL PIRQRO LACC PIRQR2 ; Clear pending PDP flag AND #OFFFEh SACL PIRQR2 POINT_EV LACC EVAIFRA ; Clear PDPINTA flag #OOOlh OR SACL EVAIFRA #EVBIFRA»7 LDP ; Clear PDPINTB flag LACC EVBIFRA #OOOlh OR SACL EVBIFRA POINT_PGO CLRC SXM ;Clear Sign Extension Mode CLRC OVM ;Reset Overflow Mode ;Config Block BO to Data memo CLRC CNF SPM 0 ;Init s/w stack pointer LAR AR 1, #stack_start MAR ·,ARI POINT_BO SPLK #OOCOh, GPRO ;Set 1 wait states for 110 space OUT GPRO, WSGR POINT_PFl .if (x4_PLL) SPLK #0085h, SCSRI ; x4 PLL, ADC en, EVI en, elr III Addr flg .endif .if (x2_PLL) SPLK #0285h, SCSRI ; x2 PLL, ADC en, EVI en, elr III Addr flg .endif ;Comment out ifWD is to be active SPLK #006Fh, WD_CNTL ;Disable WD ifVCCP=5V KICK_DOG RET .endif

; Module Name:
; Description: Stores the realtime values of two user selectable s/w variables in the external data RAM ; provided on the 24x124xx EVM. Two s/w variables are selected by configuring two module inputs, ;dlogjptrl and dlo~iptr2, point to the addressofthe two variables. The starting addresses of the two ;RAM locations, where the data values are stored, are set to 8000h and 8400h. Each section allows ;logging of 400 data values. dlo~iptr 1 0------>1 dlo~iptr2 0------>1 DATA_LOG/ Data RAM

0------>1
;Module definitions for external reference.

103

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

.def .def .def

DATA_LOG, DATA_LOG_INIT ;function call dlogjptrl, dlogjptr2 ;Inputs tri8.-value ;Inputs

.include x24x_app.h DLOG_PRESCALE .set 1 DL_BUFFER1_ADR .set 08000h DL_BUFFER2_ADR .set 08400h DLOG_CNTR_MAX .set 400 dlo8.-iptrl .usect "data_log", 1 dlo8.-iptr2 .usect "data_log", 1 dlo8.-skip_cntr .usect "data_Iog",l dl08.-cntr .usect "data_log", 1 task_ptr .usect "data_Iog",l graph_ptrl .usect "data_log", 1 graph-ptr2 .usect "data_log", 1 tri8.-value .usect "data_log",l

; 1 gives 50uS log rate

;----------------------------------------------------------------------------;----------------------------------------------------------------------------LDP SPLK SPLK SPLK SPLK SPLK SPLK SPLK SPLK RET #task_ptr #POS_TRIG_Sl, task_ptr #DL_BUFFERLADR, graph_ptrl #DL_BUFFER2_ADR, graph_ptr2 #300h, dlo8.-iptrl #300h, dlo8.-iptr2 ;Set trig point to Oh #Oh, tri8.-value #Oh, dlo8.-skip_cntr ;cIear Data log skip counter ;cIear Data log counter #Oh, dlo8.-cntr

;--------------------------------------------------------------------------------;---------------------------------------------------------------------------------

LDP #task_ptr MAR *,AR5 SETC SXM LACC task_ptr BACC POS_TRIG_Sl: ;(Positive trigger, detect Negative signal) LAR ARS, dlo8.-iptrl LACC *,1 SUB tri8.-value, 1 BCND DL_EXIT, GEQ ;If not Neg return SPLK #POS_TRIG_S2, task_ptr B DL_EXIT POS_TRIG_S2: ;(Positive trigger, detect Positive signal) LAR ARS, dlo8.-iptrl LACC *,1 SUB tri8.-value,l BCND PTS2_l, LT ;IfNeg, return to Sl SPLK #DL_TRIGGERED, task_ptr B DL_EXIT PTS2_l: SPLK #POS_TRIG_Sl, task_ptr B DL_EXIT DL_TRIGGERED: LACC dlo8.-skiP3ntr ;Check if time to Log

I
I

I

104

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

ADD #1 SACL dlo~skip_cntr SUB #DLOG]RESCALE BCND DL_EXIT, NEQ ;Data is logged here LAR ARS, dlo~iptrl LACC * LAR AR5, graph_ptrl SACL *+ SAR AR5, graph_ptr1 LAR ARS, dlo~iptr2 LACC * LAR ARS, graph_ptr2 SACL *+ SAR AR5, graph_ptr2 SPLK #0, dlo~skip3ntr LACC dlo~cntr ;Check if Data buffer full ADD #1 SACL dlo~cntr SUB #DLOG_CNTR_MAX BCND DL_EXIT, NEQ SPLK #0, dlo~cntr SPLK #POS_TRIG_Sl, task_ptr SPLK #DL_BUFFER1_ADR, graph_ptr1 SPLK #DL_BUFFER2_ADR, graph-ptr2 CLRC RET SXM

105

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Appendix C Software Package for FOC Control Scheme
.-----------------------------------------------------------------------------,-----------------------------------------------------------------------------File Name: FOC_MRAS.ASM

"-----------------------------------------------------------------------------.
: May15,2003

Description: Sensorless control of Induction Motor by FOC technique using MRAS speed estimator Originator: Chaozheng Ma, Ryerson University, Toronto, Canada. Target dependency: DSP eZdspTM LF2407, use 5kHz sampl ing frequency

.-----------------------------------------------------------------------------,-----------------------------------------------------------------------------.****************************************************************************** ,
SYSTEM OPTIONS

, .******************************************************************************
real_time .set .set .set .set .set .set .set .set .set .set .set .set
0

; 1 for real time mode, otherwise set 0 ; Ramp and sine_wave signal generation ; open_loop start up ; current measurement chain checking ; current measurement chain checking ; current measurement chain checking ; current regulation implementation ; current regulation implementation ; Mras estimation ; Mras estimation ; Mras estimation ; use RAMP ; PWM period in uS (5KHz) ; *1000nS/(2*33nS)

phase_conunissioning 1 phase3onunissioning2 phase_conunissioning3 phase3onunissioning3l phase3ommissioning32 phase3ommissioning3c phase3ommissioning4 phase3onunissioning5 phase_conunissioning5a phase3ommissioning5b phase3onunissioning5c

0 0 0 0 0 0 1 0 0 0

PWM_PERlOD .set 200 TlPER_ .set PWM]ERlOD*15

I
I I I
(

, .******************************************************************************
.if (phase3onunissioning3) currenCobservation .set 1 ; check ofIa_outlIb_out, clark_dlclark_q *Park_and_speed .set 0 ; check ofpark_D/park_Q and speedjrq .endif .if (phase_commissioning4) constanCcurrent .set 0 ; ThetaITheta_ip switch (0 or rmp_out). park_sign .set 0 ; check ofpark_D/park_Q sign .endif .if (phase3onunissioning5) currencmod .set 0; ThetaiTheta_ip switch (rmp_out or cur_mod). ; O--rmp_out I--theta3ur_mod ;constant3urrent .set 0 ; 1--iq_ref=O,O--iq_ref=my_i~ref .endif

1 I

106

l

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

.if (phase_commissioning5b) loop_cntl_ .set 10000 ; 100; IOOP3nt2_ .set .endif
;-----------------------------------------------------------------------------

; External references
;-----------------------------------------------------------------------------

.include "x24x_app.h"

.ref .ref .ref .ref .ref .ref .ref .ref .ref ; AddbyC. Ma .ref .ref .ref .ref .ref .ref .ref .ref .ref ;done .ref .ref .ref

SYS_INIT RAMP_GEN,RAMP_GEN_INIT rrnp~ain, rrnp_offset, rrnp_freq step_angle_max rrnp_out CPARK, I]ARK_INIT ipark_D, ipark_Q, theta_ip isin_theta,icos_theta ipark_d, iparLq DATA_LOG,DATA_LOG_INIT dlo~iptr I, dlo~iptr2
tri~value

;function call ;Inputs ;Input ;Outputs ;function call ;Inputs ;Inputs ;Outputs ;function call ;Inputs ;Inputs ;function call ;function call ;Inputs ;Inputs ;Outputs ;Outputs ;function call ;Inputs ;Outputs ;function calls ;Inputs ;Input ;function call ;Inputs ;Outputs Vdc_meas ;function call ;Inputs ;Outputs ;function call ;Inputs ;Inputs

PHASE_VOLTAGE_CALC PHASE_VOLTAGE_CALC_INIT Mfunc_Vl, Mfunc_V2 Mfunc_V3, DC_bus Vphase_A,Vphase_B,Vphase_C Vdirect, Vquadra SVGEN_DQ,SVGEN_DQ_INIT Ualfa,Ubeta Ta,Tb,Tc

.ref FC_PWM_DRV,FC_PWM_DRV_INIT .ref Mfunc31,Mfunc_c2,Mfunc33,Mfunc_p .ref n_period .ref .ref .ref ; add byC. Ma .ref .ref ;done .ref .ref .ref .ref .ref .ref CLARKE,CLARKE_INIT clark_a, clark_b clark_d, clark_q PARK, PARK_INIT park_d, park_q, theta_p psin_theta,pcos_theta Vdc_meas_offset,
Vdc_meas~ain, Vdc_meas~ain_l,
~EG2DRV,~EG2DRV_INIT

la~ain,Ib~ain,la_offset,lb_offset

la_out, Ib_out, Ic_out

Vdc_meas_l

107

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

.ref park_D, park_Q .ref D_sign, Q_sign .ref .ref .ref .ref .ref .ref .ref .ref .ref .ref .ref .ref ;addbyC. Ma .ref .ref .ref .ref ;done .ref .ref .ref .ref .ref .ref .ref .ref .ref .ref ; addbyCMa .ref .ref ;done
;----------------------------------------------------------------------------pid_re~id,pid_re~id_init

;Outputs

idjdb,id_ref,Kp_d,Ki_d,Kc_d ud_int ud_out
pid_re~iq,pid_re~iq_init;

; function call ; Inputs ; Input ; Outputs

function call iqjdb,iq_ref,Kp_q,Ki_q,Kc_q ; Inputs uq_int ; Input uq_out ; Outputs

CURRENT_MODEL,CURRENT_MODEL_INIT; function call i3ucmod_DLcucmod_Q ; Inputs spd_cucmod ; Input theta3ur_mod ; Outputs ACCMRAS, ACCMRAS_INIT ualfa_mras, ubeta_mras ialfa_mras, ibeta_mras wchaCmras, wchacrpm_mras ;function call ;Inputs ;Inputs ;Outputs

theta_est,theta3sCinit; function call psiRal,psiRbe ; Inputs sinTeta_est,cosTeta_est ; Outputs
pid_re~spd,pid_re~spd_init

spdjdb,spd_ref spd_out ramp_theta

; function call ; Inputs ; Outputs ; add ;function call ;Inputs ;Outputs ;function call ;Inputs/Outputs

CCLARKE, CCLARKE_INIT Iclark_d, Iclark_q Iclark_a, Iclark_b, Iclark3 BC_INIT,BC_CALC
BC_IN,~C_OUT

; Variable Declarations
;-----------------------------------------------------------------------------

.def ; add by C Ma

GPRO

;General purpose registers .

*
;done

.def .def .bss .bss

loop_cntI,loop3nt2 theta_esCmod ;l--rmp_out / 0-- theta_est looP3ntI, 1 loop3nt2,1 ;General purpose register

.bss GPRO,l .bss my_iq_ref,l .bss my_id_ref,l .bss speed_reference, 1

; VEe TOR TAB L E ( including RT monitor traps)

108

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

.include "c200rnnrt.i" ; Include conditional assembly options . .sect "vectors" .def 3_intO RESET B 3_intO ; 00 INTI B PHANTOM ; 02 INT2 B Tl_PERIOD_ISR ;04 INT3 B PHANTOM ; 06 INT4 B PHANTOM ; 08 INT5 B PHANTOM ;OA INT6 B PHANTOM ;OC .include "rtvecs.h"

.,

;MAIN COD E - starts here .text

3_intO: SYS_INIT FC_PWM_DRV_INIT ; Here is defined the Timer ;frequency (5KHz), it is thus mandatory CALL DATA_LOG_INIT .if (phase_commissioning 1) CALL RAMP_GEN_INIT CALL CPARK_INIT ;add byCMa LDP #dlog...iptrl SPLK #ipark_d, dlog...iptrl; SPLK #rrop_out, dlog...iptr2 ;done .endif .if (phase3ommissioning2) CALL RAMP_GEN_INIT CALL I ]ARK_INIT CALL SVGEN_DQ_INIT LDP #dlog...iptrl SPLK #Ta, dlog...iptrl; SPLK #ipark_q, dlog...iptr2 .endif .if (phase3ommissioning3) CALL RAMP_GEN_INIT CALL CPARK_INIT CALL SVGEN_DQ_INIT CALL CLARKE_INIT CALL P ARK_INIT ;changed by C Ma CALL ILEG2DRV_INIT CALL PHASE_VOLTAGE_CALC_INIT LDP #dlog...iptrl SPLK #Ta, dlog...iptrl; SPLK #Ib_out, dlog...iptr2 .endif .if (phase_commissioning31) CALL RAMP_GEN_INIT CALL CP ARK_INIT CALL SVGEN_DQ_INIT CALL CALL

109

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

CALL ILEG2DRV_lNIT CALL CLARKE_INIT CALL PARK_lNIT CALL PHASE_VOLTAGE_CALC_lNIT LDP #dl0R-iptrl SPLK #Ta, dl0R-iptrl; SPLK #Ib_out, dl0R-iptr2 .endif .if (phase_commissioning32) CALL RAMP_GEN_INIT CALL CPARK_INIT CALL SVGEN_DQ_INIT CALL ILEG2DRV_INIT CALL CLARKE_INIT CALL PARK_INIT CALL PHASE_VOLTAGE_CALC_INIT CALL ACCMRAS_lNIT CALL BC_INIT LDP #dl0R-iptrl; SPLK#Ta, dl0R-iptrl; SPLK #Ib_out, dl0R-iptr2 ;done .endif .if (phase3ommissioning4) CALL RAMP_GEN_lNIT CALL CP ARK_INIT CALL SVGEN_DQ_lNIT CALL ILEG2DRV_lNIT CALL CLARKE_INIT CALL PARK_lNIT CALL pid_reR-id_init CALL pid_reR-iq_init LDP #dl0R-iptrl; add by C Ma SPLK #nnp_out, dl0R-iptr2; splk #Ia_out, dl0R-iptrl .endif .if (phase3ommissioning5) CALL RAMP_GEN_lNIT CALL CPARK_INIT CALL SVGEN_DQ_lNIT CALL ILEG2DRV_lNIT CALL CLARKE_INIT CALL P ARK_lNIT CALL pid_reR-id_init CALL pid_reR-iq_init CALL CURRENT_MODEL_INIT ;add by C. Ma CALL PHASE_VOLTAGE_CALC_INIT CALL ACCMRAS_INIT CALL BC_lNIT LDP #dl0R-iptrl SPLK #nnp_out, dl0R-iptr2; splk #Ia_out, dl0R-iptrl ;done .endif

110

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

.if (phase_commissioning5a) CALL RAMP_GEN_INIT CALL CPARICINIT CALL SVGEN_DQ_INIT CALL ILEG2DRV_INIT CALL CLARKE_INIT CALL PARK_INIT CALL pid_reg.jd_init CALL pid_reg.jq_init CALL CURRENT_MODEL_INIT ;add byC. Ma CALL PHASE_VOLT AGE_CALC_INIT CALL ACCMRAS_INIT CALL BC_INIT CALL pid_reg...spd_init LDP #dlog...iptrl; SPLK #Ia_out, dlog...iptr2; splk #Ta, dlog...iptrl ;done .endif .if (phase_commissioning5b) CALL RAMP_GEN_INIT CALL CP ARK_INIT CALL SVGEN_DQ_INIT CALL ILEG2DRV_INIT CALL CLARKE_INIT CALL PARK_INIT CALL pid_reg...id_init CALL pid_reg...iq_init CALL CURRENT_MODEL_INIT ;add byC. Ma CALL PHASE_VOLTAGE_CALC_INIT CALL ACCMRAS_INIT CALL BC_INIT CALL pid_reg...spd_init LDP #dlog...iptrl SPLK #rmp_out, dlog...iptr2; splk #Ia_out, dlog.jptrl ;done .endif .if (phase_commissioning5c) CALL RAMP_GEN_INIT CALL CPARK_INIT CALL SVGEN_DQ_INIT CALL ILEG2DRV_INIT CALL CLARKE_INIT CALL PARK_INIT CALL pid_reg...id_init CALL pid_reg_jq_init CALL CURRENT_MODEL_INIT ;add bye. Ma CALL PHASE_VOLTAGE_CALC_INIT CALL ACCMRAS_INIT CALL BC_INIT CALL pid_reg...spd_init

111

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

LOP #dlogjptrl; SPLK #Ia_out, dlo!Liptr2; splk #Ta, dlo!Liptrl ;done .endif ;---Real Time option--------------.if (reaUime ) CALL MON_RT_CNFG .endif
;-----------------------------------

;For Real-Time

;

Variables initialization LOP #rmp_freq SPLK #5000,rmpjreq; 60Hz frequency for RAMPGEN(5kHz)/=25770d SPLK # 12884,rmpjreq; 60Hz frequency for RAMPGEN( 1OkHz)/=25770d ldp #theta3sCmod splk #1,theta_esCmod ;1--rmp_out I 0-- theta_est .if (phase_conunissioning5b) ldp #IOOP3ntl splk #looP3ntl_, IOOP3ntl ldp #loop_cnt2 splk #IOOP3nt2_,loop_cnt2 .endif LOP #my_iq_ref SPLK #OOOOh,my_iq_ref LOP #my_id_ref SPLK #5000,my_id_ref ; LOP #speed_reference ; SPLK #OOOOh,speed_reference .if (phase_conunissioning6) POINT_BO SPLK #0500h,my_id_ref .endif

;----------------- ... ----------------

* * *

;---------------------------------------------------------; System Interrupt lnit. ;---------------------------------------------------------;Event Manager POINT_EV SPLK #0000001000000000b,IMRA ;Enable Tl Underflow Int (i.e. Period) SPLK #000OOOOOOOOOOI00b,IMRC ;Enable CAP3 int (i.e. QEP index pulse) * ;5432109876543210 SPLK #OOOOOOOOOOOOOOOOb,IMRC ;Oisable CAP3 int (i.e. QEP index pulse) SPLK #OFFFFh,IFRA ; Clear all Group A interrupt flags SPLK #OFFFFh,IFRB ; Clear all Group B interrupt flags SPLK #OFFFFh,IFRC ; Clear all Group C interrupt flags ;C2xx Core POINT_PGO ;---Real Time option -------------------------------------------------.if (real_time) ;En Int Iv13,7 (T2 ISR) SPLK #OOOOOOOOOlOOOOlOb,IMR ;5432109876543210 .endif .if(reaUime != 1) SPLK #000000000000001 Ob,IMR ;Oisable Int lvl 4 (CAP3/QEP ISR)

I
1
(

f

112

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

.endif SPLK #OFFFFh, IFR EINT POINT_BO MAIN: M_I NOP NOP NOP CLRCXF B MAIN ; Routine Name: Tl_PERIOD_ISR ; Description: ; Originator: Chaozheng Ma - Ryerson University II-Mar 03 ; Last Update: Tl_PERIOD_ISR: ;Context save regs MAR *,ARI MAR *+ SST #1, *+ SST #0, *+ SACH *+ SACL * Routine Type: ISR ;Main system background loop ;Clear any pending Ints ;Enable global Ints

;====================

;ARI is stack pointer ;skip one position ;save STI ;save STO ;save acc high ;save acc low

;NOTE: should use "read-modify-write" to clear Int flags & not SPLK! POINT_EV SPLK #OFFFFh,IFRA ; Clear all Group A interrupt flags (TI ISR) XF SETC ; set sign extension mode SXM SETC CLRC OVM ; clear overflow mode ;Start main section of ISR .if (phase_commissioning I) ; Ramp_Generation module CALL RAMP_GEN ; Inverse Park Module #theta_ip LDP BLDD #rmp_out,theta_ip CALL LPARK ;PWMdriver CALL FC_PWM_DRV ; called just to set the PWM period to 5kHz .endif

******************************************
.if (phase_commissioning2) ; Ramp generation module CALL RAMP_GEN ; Inverse-Park module #theta_ip LDP BLDD #rmp_out,theta_ip CALL LPARK ; Space-Vector DQ module LDP #Ualfa

113

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

BLDD #ipark_d,Ualfa BLDD #ipark_q,Ubeta CALL SVGEN_DQ ;PWMdriver LDP BLDD BLDD BLDD CALL .endif #Mfunc31 #Ta,Mfunc_cl #Th,Mfunc32 #Tc,Mfunc33 FC_PWM_DRV

******************************************
.if (phase3ommissioning3) ; Current leg measurement, Ileg2drv module CALL ILEG2DRV ; Clarke module LDP #clark_a BLDD #Ia_out,clark_a BLDD #Ib_out,clark_b CALL CLARKE ; PARK module LDP #park_d BLDD #Clarlcd,parlcd BLDD #Clark_q,park_q BLDD #rmp_out,theta-p CALL PARK ; Ramp generation module CALL RAMP_GEN ; Inverse-Park module #tbeta_ip LDP BLDD #nnp_out,theta_ip CALL CPARK ; Space-Vector DQ module LDP #Ualfa BLDD #ipark_d,Ualfa BLDD #ipark_q,Ubeta CALL SVGEN_DQ ;PWMdriver LDP #Mfunc31 BLDD #Ta,Mfunc_cl BLDD #Th,Mfunc_c2 BLDD #Tc,Mfunc33 CALL FC_PWM_DRV .endif

******************************************
.if (phase3ommissioning31) ; Current leg measurement, Ileg2drv module CALL ILEG2DRV ; Clarke module LDP #clark_a BLDD #Ia_out,clark_a BLDD #Ib_out,clark_b CALL CLARKE ; PARK module LDP #park_d BLDD #Clark_d,park_d BLDD #Clark_q,park_q

114

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

BLDD #nnp_out,theta_p CALL PARK. ; Ramp generation module CALL RAMP_GEN ; Inverse-Park module #theta_ip LDP BLDD #rmp_out,theta_ip CALL CPARK. ; Space-Vector DQ module #Ualfa LDP BLDD #ipark_d, Ualfa BLDD #ipark_q, Ubeta CALL SVGEN_DQ ;PWMdriver #Mfunc_cI LDP BLDD #Ta,Mfunc3I BLDD #Tb,Mfunc_c2 BLDD #Tc,Mfunc33 CALL FC_PWM_DRV ;addbyC. Ma #DC_bus LDP BLDD #Vdc_meas_I ,DC_bus BLDD #Ta,Mfunc_VI BLDD #Tb,Mfunc_V2 BLDD #Tc,Mfunc_V3 CALL PHASE_VOLTAGE_CALC ;done .endif

******************************************
.if (phase3ommissioning32) ; Current leg measurement, neg2drv module CALL ILEG2DRV ; Clarke module LDP #Clark_a BLDD #Ia_out,clark_a BLDD #Ib_out,clark_b CALL CLARKE ; PARK. module LDP #park_d BLDD #Clarlcd,park_d BLDD #Clarlcq,parlcq BLDD #nnp_out,theta_p CALL PARK. ; Ramp generation module CALL RAMP_GEN ; Inverse-Park module #theta_ip LDP BLDD #rmp_out,theta_ip CALL CPARK. ; Space-Vector DQ module #Ualfa LDP BLDD #ipark_d, Ualfa BLDD #ipark_q,Ubeta CALL SVGEN_DQ ; PWMdriver LDP

115

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

BLDD BLDD BLDD CALL ;addby C. Ma LDP

#Ta,Mfunc_c1 #Th,Mfunc_c2 #Tc,Mfunc33 FC_PWM_DRV

#DC_bus BLDD #Vdc_meas_I,DC_bus BLDD #Ta,Mfunc_VI BLDD #Th,Mfunc_V2 BLDD #Tc,Mfunc_V3 CALL PHASE_VOLTAGE_CALC LDP

#ualfa_mras BLDD #Vdirect,ualfa_mras BLDD #Vquadra,ubeta_mras BLDD #Clark....d,ialfa_mras BLDD #Clark_q,ibeta_mras CALL ACCMRAS #BC_IN LDP BLDD #wchaCmras,BC_IN BC_CALC CALL ;done .endif .if (phase_commissioning4) ; Current leg measurement, Ileg2drv module CALL ILEG2DRV ; Clarke module LDP #Clark_a BLDD #Ia_out,clark_a BLDD #Ib_out,clark_b CALL CLARKE ; PARK module #Park....d LDP BLDD #Clark_d,park_d BLDD #Clarlcq,park....q .if constanCcurrent ; here we apply 0 or nnp_out SPLK #OOOOh,theta-p; check the internal phase_commissioning option .else BLDD #nnp_out,theta_p .endif CALL PARK ; D-axis current regulator LDP #id_ref BLDD #my_id_ref,id_ref; lEB8h gives a current of2.5A peak BLDD #park_D,id_fdb CALL pid_re~id ; Q-axis current regulator LDP #iCl-ref .if conStanCcurrent ; here we apply 0 or my_iq_ref (user) SPLK #OOOOh,i<J-ref ; check the internal phase_commissioning option .else BLDD #my_iq_ref,iq_ref .endif BLDD #park_Q,i<J-fdb CALL pid_re~iq ; Ramp generation module

116

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

CALL RAMP_GEN ; Inverse-Park module LDP #ipark_D BLDD #Ud_out,ipark_D BLDD #U<I-out,ipark_Q ; here we apply 0 or nnp_out .if constanCcurrent ; check the internal phase_commissioning option SPLK #OOOOh,theta_ip .else BLDD #nnp_out,theta_ip .endif CALL CPARK ; Space-Vector DQ module LDP #Ualfa BLDD #ipark_d,Ualfa BLDD #ipark_q, Ubeta CALL SVGEN_DQ ;PWMdriver LDP #MfunC31 BLDD #Ta,Mfunc_cl BLDD #Th,Mfunc_c2 BLDD #Tc,Mfunc_c3 CALL FC_PWM_DRV .endif

******************************************
.if (phase_commissioning5) ; Current leg measurement, Ileg2drv module CALL ILEG2DRV ; Clarke module LDP #clark_a BLDD #Ia_out,clark_a BLDD #Ib_out,clark_b CALL CLARKE ; PARK module LDP #park_d BLDD #Clark_d,park_d BLDD #Clark_q,park_q .if currenCmod SPLK #theta3ucmod,theta_p .else BLDD #nnp_out,theta_p .endif CALL PARK ; D-axis current regulator LDP Hid_ref BLDD #my_id_ref,id_ref; 5000d gives a current of 1.52A rms BLDD #park_D,id3db CALL pid_re~id ; Q-axis current regulator LDP #i<I-ref ; check the internal phase_commissioning option BLDD #my_i<I-ref,i<I-ref BLDD #park_Q,i<I-fdb CALL .pid_re~iq ; Ramp generation module .if currencmod .else

117

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

CALL RAMP_GEN .endif ; Inverse-Park module LDP #ipark_D BLDD #Ud_out,iparlcD BLDD #u<I-out,ipark_Q ; here we apply 0 or rmp_out .if currenCmod ; check the internal phase_commissioning option SPLK #theta3ucmod,theta_ip .else BLDD #rmp_out,theta_ip .endif CALL CPARK ; Space-Vector DQ module LDP #Ualfa BLDD #iparLd, Ualfa BLDD #ipark_q, Ubeta CALL SVGEN_DQ ;PWMdriver LDP #Mfunc31 BLDD #Ta,Mfunc31 BLDD #Th,Mfunc_c2 BLDD #Tc,Mfunc33 CALL FC_PWM_DRV ;addbyC.Ma #DC_bus LDP BLDD #Vdc_meas_I,DC_bus BLDD #Ta,Mfunc_VI BLDD #Th,Mfunc_V2 BLDD #Tc,Mfunc_V3 PHASE_VOLTAGE_CALC CALL #ualfa_mras LDP BLDD #Vdirect,ualfa_mras BLDD #Vquadra,ubeta_mras BLDD #ClarLd,ialfa_mras BLDD #Clark_q,ibeta_mras CALL ACCMRAS #BC_IN LDP BLDD #wr_haCmras,BC_IN CALL ;done * CURRENT MODEL LDP #spd3ucmod BLDD #wr_haCmras,spd3UCmod BLDD #BC_OUT,spd3uCmod BLDD #park_D,Lcucmod_D BLDD #park_Q,i3uCmod_Q
CALL CURRENT_MODEL

.endif

******************************************
.if (phase_commissioning5a) ; Current leg measurement, lleg2drv module CALL ILEG2DRV ; Clarke module LDP #clark_a BLDD #Ia_out,clark_a

118

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

BLDD #Ib_out,clarlcb CALL CLARKE ;Loop control ; PARK module LDP #parlcd BLDD #Clarlcd,parlcd BLDD #Clarlcq,parlcq BLDD #theta3ucmod,theta....p CALL PARK * CURRENT MODEL LDP #spd_cucmod BLDD #wchaCmras,spd3uC mod BLDD #BC_OUT,spd_cur_mod BLDD #park_D,i_cur_mod_D BLDD #park_Q,i_cur_mod_Q CALL CURRENT_MODEL ; SPEED REGULATION LDP #spd_ref bldd #speed_reference,spd_ref bldd #BC_OUT,spdjdb bldd #wchaCmras,spdjdb CALL pid_relLspd ; D-axis current regulator LDP #id_ref BLDD #my_id_ref,id_ref; 5000d gives a current of 1.52A rms BLDD #park_D,idjdb CALL pid_relLid ; Q-axis current regulator LDP #i'l-ref BLDD #spd_out,i'l-ref BLDD #park_Q,iqjdb CALL pid_relLiq ; Ramp generation module CALL RAMP_GEN ; Inverse-Park module #iparlcD LDP BLDD #Ud_out,iparlcD BLDD #U'l-out,ipark_Q BLDD #theta3ur_mod,theta_ip CALL CPARK ; Space-Vector DQ module #Ualfa LDP BLDD #ipark_d, Ualfa BLDD #ipark_q,Ubeta CALL SVGEN_DQ ;addby C. Ma LDP #DC_bus BLDD #Vdc_meas_I,DC_bus BLDD #Ta,Mfunc_VI BLDD #Tb,Mfunc_V2 BWD #Tc,Mfunc_V3 CALL PHASE_VOLTAGE_CALC #ualfa_mras WP BLDD #Vdirect,ualfa_mras BLDD #Vquadra,ubeta_mras BLDD #clark_d,ialfa_mras

119

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

BLDD #Clark_q,ibeta_mras CALL ACLMRAS #BC_IN BLDD #wchaunras,BC_IN CALL BC_CALC ; PWMdriver LDP BLDD BLDD BLDD CALL #Mfunc31 #Ta,Mfunc31 #Tb,Mfunc_c2 #Tc,Mfunc33 FC_PWM_DRV LDP

.endif .if (phase_commissioning5b) ; Current leg measurement, Ileg2drv module CALL ILEG2DRV ; Clarke module LDP #Clark_a BLDD #Ia_out,clark_a BLDD #Ib_out,clarlcb CALL CLARKE ;Loop control #loop_cnt2 ldp lacl loop_cnt2 bcnd loop_Ioop,LEQ #loop3ntl ldp lacl loop_cntl bcnd rmp_Ioopl,LEQ #1 sub sacl loop_cntl b rmp_Ioop2 rmp_Ioopl ldp #IOOP3ntl splk #loop_cntl_,loop_cntl ldp #loop_cnt2 lacl loop_cnt2 bcnd loop_Ioop,LEQ #1 sub sacl loop_cnt2 rmp_Ioop2 ; PARK module LDP #parlcd BLDD #Clarlcd,park_d BLDD #Claricq,pariCq BLDD #rmp_out,tbeta-p CALL PARK ; D-axis current regulator LDP #idJef BLDD #my_id_ref,id_ref; 5000d gives a current of 1.52A rms BLDD #park_D,id3db CALL pid_regjd ; Q-axis current regulator LDP #i'l-ref ; here we apply 0 or my_i'l-ref(user) BLDD #my_i'l-ref,iq_ref

120

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

BLDD #park_Q,iqjdb CALL pid_re~iq ; Ramp generation module CALL RAMP_GEN ; Inverse-Park module LDP #ipark_D BLDD #Ud_out,ipark_D BLDD #U£I-out,ipark_Q ; here we apply 0 or rmp_out BLDD #rmp_out,theta_ip CALL CPARK b svpwm loop_loop ; PARK module LDP #park_d BLDD #Clark_d,park_d BLDD #Clark_q,park_q BLDD #theta3ucmod,theta_p BLDD #rmp_out,theta_p CALL PARK ; CALL BC_CALC ;done * CURRENT MODEL LDP #spd_CUf_mod BLDD #wr_haCmras,spd3uCmod BLDD #BC_Our,spd_cucmod BLDD #park_D,Lcucmod_D BLDD #park_Q,i_cucmod_Q CALL CURRENT_MODEL ; D-axis current regulator LDP Hid_ref BLDD #my_id_ref,id_ref ; SOOOd gives a current of 1.52A rms BLDD #park_D,id_fdb CALL pid_re~id ; Q-axis current regulator LDP #i£I-ref BLDD #spd_out,i£I-ref BLDD #park_Q,iqjdb CALL pid_re~iq ; Inverse-Park module #ipark_D LDP BLDD #Ud_out,ipark_D BLDD #Uq_out,ipark_Q ; here we apply 0 or rmp_out BLDD #theta3ur_mod,theta_ip CALL CPARK ; SPEED REGULATION LDP #spd_ref bldd #speed_reference,spd_ref * bldd #spd3ur_mod,spdjdb bldd #wr_haCrpIlLmras,spdjdb CALL pid_re~spd
svpwm

; Space-Vector DQ module LDP #Ualfa BLDD #ipark_d,Ualfa

121

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

BLDD #ipark_q,Ubeta CALL SVGEN_DQ ;addbyC. Ma LDP #DC_bus BLDD #Vdc_meas_I,DC_bus BLDD #Ta,Mfunc_VI BLDD #Tb,Mfunc_V2 BLDD #Tc,Mfunc_V3 CALL PHASE_VOLTAGE_CALC LDP #ualfa_mras BLDD #Vdirect,ualfa_mras BLDD #Vquadra,ubeta_mras BLDD #Clark_d,ialfaJMls BLDD #clarlcq,ibeta_mras CALL ACCMRAS LDP #BC_IN LDP BLDD BLDD BLDD CALL #Mfunc_cl #Ta,Mfunc31 #Tb,Mfunc_c2 #Tc,Mfunc33 FC_PWM_DRV

; PWMdriver

.endif .if (phase_commissioning5c) ; Current leg measurement, Deg2drv module CALL ILEG2DRV ; Clarke module LDP #clark_a BLDD #Ia_out,clarlca BLDD #1b_out,clllI'lLb CALL CLARKE ;Loop control * Ramp_Gen Module LDP #rmpjreq BLDD #ramp_theta,rmpjreq BLDD #BC_OUT,spd_cur_mod CALL RAMP_GEN ; PARK. module LDP #parlcd BLDD #Clark_d,park_d BLDD #Clarlcq,park_q BLDD #rmp_out,thefa-p CALL PARK. ; SPEED REGULATION LDP #spd_ref bldd #speed_reference,spd_ref * bldd #sPd3uCmod,spdjdb bldd #wchaCmras,spdjdb CALL pid_re~spd ; D-axis current regulator LDP #id_ref BLDD #my_id_ref,id_ref; 5000d gives a current of 1.52A rms BLDD #park_D,idjdb CALL pid_re~id ; Q-axis current regulator

122

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

LDP #iq_ref BLDD #spd_out,iq_ref BLDD #park_Q,iqjdb CALL pid_regjq ; Ramp generation module CALL RAMP_GEN ; Inverse-Park module #ipark_D LDP BLDD #Ud_out,iparlcD BLDD #Uq_out,iparlcQ BLDD #rmp_out,theta_ip CALL CPARK. ; Space-Vector DQ module LDP #Ualfa BLDD #ipark_d,Ualfa BLDD #ipark_q,Ubeta CALL SVGEN_DQ ;addbyC.Ma LDP #DC_bus BLDD #Vdc_meas_I,DC_bus BLDD #Ta,Mfunc_VI BLDD #Tb,Mfunc_V2 BLDD #Tc,Mfunc_V3 PHASE_VOLTAGE_CALC CALL LDP #ualfa_mras BLDD #Vdirect,ualfa_mras BLDD #Vquadra,ubeta_mras BLDD #Clark_d,ialfa_mras BLDD #Clark_q,ibeta_mras ACI_MRAS CALL #BC_IN LDP BLDD #wchaCmras,BC_IN BC_CALC ; CALL ;done ; PWMdriver LDP #Mfunc_cl BLDD #Ta,Mfunc_cl BLDD #Tb,Mfunc_c2 BLDD #Tc,Mfunc_c3 CALL FC_PWM_DRV .endif ;End main section of ISR ;Context restore regs END_ISR:

MAR *,ARI ;make stack pointer active ;Restore Acc low LACL *;Restore Acc high ADDH *LST ;load STO #0, *LST #1, *;load STl

PHANTOM

EINT RET B

PHANTOM

123

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Module Name: I_CLARKE
; Description: Converts balanced two phase quadrature quantities into balanced three phase quantities. (d,q) -> (a,b,c) Transfonnation Iclark_a = Iclark_d Iclark_b = (-Iclark_d + sqrt(3) * Iclark_q) / 2 Iclark_c = (-Iclark_d - sqrt(3) * Iclark_q) / 2

1----------------1 1----->0 Iclark_a 1 CCLARKE 1----->0 Iclark_b Iclarlcq 0------>1 1----->0 Iclark3
Iclark_d 0------>1
1 I

;Module definitions for external reference . .def CCLARKE, CCLARKE_INIT .def Iclark_d. Iclark_q .def Iclark_a, Iclark_b, Iclark3 .include x24x_app.h Iclark_d .usect "Cclarke",l Iclark_q .useet "Cclarke",1 Iclark_a .useet "Cclarke",l Iclark_b .usect "Cclarke",l Iclark_c .useet "Cclarke",l halCsqrt3 .usect "Cclarke",1

;function call ;Inputs ;Outputs

ldp SPLK RET CCLARKE:

#halCsqrt3 ; Variables data page #28377,haICsqrt3; Set constant sqrt(3)*O.5 in Ql5 fonnat

; Variables data page #IclarLd ldp ; SPM set for Ql5 multiplication SPM 1 SETC SXM ; Sign extension mode on ;Iclark_a = Iclark_q LACC Iclark_q ; ACC = Iclark_q SACL Iclark_a ; Iclark_a = Iclark_q ;Iclark_b = (-Ubeta + sqrt(3) * Ualfa) / 2 LT Iclark_d ; TREG = Iclark_d MPY halCsqrt3 ; PREG = Iclark_d * halCsqrt3 PAC ; ACC high = Iclark_d * halCsqrt3 SUB Iclark_q, 15 ; ACC high = Iclark_d * halCsqrt3 + Iclark_q/2 ; IclarLb = Iclark_d * halCsqrt3 + Iclark_q/2 SACH IclarLb ;Iclark3 = (-Ubeta - sqrt(3) * Ualfa) / 2 PAC ; ACC high = Iclark_d * halCsqrt3 NEG ; ACC high = - Iclark_d * halCsqrt3 SUB Iclark_q, 15 ; ACC high = - Iclark_d * halCsqrt3 - Iclark_q/2 ; Iclarlcc = - Iclark_d * halCsqrt3 - Iclark_q/2 SACH Iclark3 SPM 0 ; SPM reset CLRC SXM ; Sign extension mode off RET

124

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Module Name: PARK
; Description: This transfonnation converts vectors in balanced 2-phase orthogonal stationary system into orthogonal rotating reference frame. id = ialfa · cos_teta + ibeta · sin_teta iq = -ialfa ·sin_teta + ibeta · cos_teta

park_d 0------>/ /----->0 park_D PARK park_q 0------>/ / theta_p 0------>/ /----->0 park_Q or psin_theta pcos_theta Note: 0 < theta-p < 7FFFh (i.e. equivalent to 0 < theta_p < 360 deg )
1 - /_ _ _ _ _ _ _

1-----------------1

1

,
;Module definitions for external reference. ;function call .def PARK, PARLINIT .def park_d, park_q, theta-p ;Inputs ;Jnputs .def psin_theta,pcos_theta park_D, park_Q .def ;Outputs .def D_sign, Q_sign ;D,Qsign High_precision theta_esCmod negtive_sign .set .set .set

1

o

1

;Set to 1 for High prec / Set to 0 for low prec ; l--nnp_out / 0-- theta3st

park_d park....q theta-p park_D park_Q Cptr ip_val cos_theta sin_theta nxCentry delta_angle GPRO_park psiILtheta pcos_theta D_sign Q_sign

.ref SINTAB_360 .usect "park",l .usect "park",l .usect "park", I .usect "park",l .usect "park",1 .usect "park", I .usect "park",l .usect "park",l .usect "park", I .usect "park",1 .usect "park",1 .usect "park",l .usect "park", 1 .usect "park",l .usect "park",1 .usect "park", I

RET

PARK: ldp #theta_esCmod .if theta_esCmod ;Calculate Cos(theta-p) ;--- High""precision option -----·

125

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

.if (High_precision) ;see park for its definition ;Higher precision using look-up + interpolation method ldp #theta_p LACC theta..,p ADD #8192 AND· #07FFFh SACL ¥RO_park
LAC~RO_Park,9

;add 90 deg, i.e. COS(A)=SIN(A+90) ;Force positive wrap-around ;here 90 deg = 7FFFhl4=8192d

SACH Cptr

SFR
AND SACL LACC ADD TBLR ADD TBLR LACC #07FFFh ip_val #SINTAB_360 t..,ptr cos_theta #Ih nxCentry nxCentry cos_theta delta_angle delta_angle ip_val ip_val,1 ip_val cos_theta cos_theta

;Table pointer ;Convert Interpolation value(ip_val) to QI5 ;Force ip_val to a positive number

;cos_theta = Cos(theta) in QI5 ;Inc Table pointer ;Get next entry i.e. (Entry + I) ;Find Delta of 2 points

SUB
SACL LT

MPY
PAC SACH LACC ADD SACL .endif

;iP3al = interpolation value

;cos_theta = Final interpolated value

;---------------------------------

;-- Normal precision option ------.if(High..,precision 1= I) ;Normal precision with simple 256 word look-up ldp LACC ADD AND SACL LACC SACH LACC ADD TBLR .endif
;-----------------------------------

#theta_p theta..,p #8192 #07FFFh GPRO_park GPRO_park,9 Cptr #SINTAB_360 Cptr cos_theta

;add 90 deg, i.e. COS(A)=SIN(A+90) ;Force positive wrap-around ;here 90 deg = 7FFFh/4

;cos_theta = Cos(theta..,p) in QI5

;Calculate Sin(theta_p) ;--- High..,precision option ------.if (HigJLprecision) ;Higher precision using look-up + interpolation method LACC theta_p,9 ;Table pointer SACH t..,ptr ;Convert Interpolation value(ip_val) to QI5 SFR ;Force ip_val to a positive number AND #07FFFh

126

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

SACL LACC ADD TBLR ADD TBLR LACC

SUB
SACL LT MPY PAC SACH LACC ADD SACL .endif

ip_val #SINTAB_360 Cptr sin_theta #lh nxCentry nxCentry sin_theta delta_angle delta_angle ip_val ip_val,l ip_val sin_theta sin_theta

;sin_theta = Sin(theta) in Q15 ;Inc Table pointer ;Get next entry i.e. (Entry + 1) ;Find Delta of2 points

;ip_val = interpolation value

;sin_theta = Final interpolated value

;-------------------------------;--- Nonnal precision option -----.if (High_precision != 1) ;Lower precision simple 256 word look-up LACC theta_p,9 SACH Cptr LACC #SINTAB_360 ADD Cptr TBLR sin_theta ;sin_theta = Sin(theta-p) in Q15 .endif ;----------------------------------.else Idp #theta-p splk #psin_theta, sin_theta splk #pcos_theta, cos_theta .endif ;Calculate the Park transform ; SPM set for Q15 multiplication SPM 1 ZAC ; Reset accumulator LT park_q ; TREG = ibeta MPY sin_theta ; PREG = ibeta * sin_teta park_d ; ACC = ibeta * sin_teta and TREG = ialfa LTA cos_theta MPY ; PREG = ialfa * cos_teta ; ACC = ibeta*sin_teta + ialfa*cos_teta and MPYA sin_theta PREG=ialfa*sin_teta SACH park_D ; id = ialfa * cos_teta + ibeta * sin_teta ; Clear ACC LACC #0 LT park_q ; TREG = ibeta ; ACC = -ialfa*sin_teta and PREG = ibeta*cos_teta MPYS cos_theta APAC ; ACC = -ialfa *sin_teta + ibeta * cos_teta SACH park_Q ; iq = -ialfa *sin_teta + ibeta * cos_teta .if (negtive_sign) LACC park_D BGEZ D_neg NEG SACL park_D SPLK #1,D_sign D_neg

127

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

SPLK #O,D_sign LACC park_Q BGEZ Q_neg NEG SACL park_Q SPLK #1,Q_sign Q_neg SPLK #O,Q_sign .endif SPM 0 ; SPM reset RET

Module Name: I_PARK
; Description: ; id = ialfa * cos_teta - ibeta * sin_teta ; iq = ialfa *sin_teta + ibeta * cos_teta ; ipark_D 0---->1 1----->0 ipark_d ; ipar~Q 0--->1 CPARK 1 ; theta_ip 0---->1 1----->0 ipark_q or isin_theta 11-_____ 1 icos_theta ; Note: O<theta_ip<7FFFh (i.e. equivalent to O<theta_ip<360 deg )

,
;(To use this Module, copy this section to main system file) .ref CPARK,CPARK_INIT .ref ipark_D,ipark_Q,theta_ip .ref isin_theta,icos_theta .ref ipark_d,ipark_q ;Module deftnitions for external reference. .def CPARK,CPARK_INIT .def ipark_D,ipark_Q,theta_ip; Inputs .def isin_theta,icos_theta ; inputs .def ipark_d.ipark_q ; function call ; Inputs ;Inputs ; Outputs

; funetion call

; Outputs

;Options High_precision .set 0 ; Set to 1 for High prec / Set to 0 for low prec theta_esCmod .set 1 ; l--rmp_out / 0-- theta_est .ref SINTAB_360 * .ref theta_esCmod ipark_d .useet "Cpark",1 ipark_q .useet "t.,park",1 theta_ip .useet "Lpark",1 ipark_D .usect "Lpark", 1 ipar~Q .useet "t.,park",1 isin_theta .usect "Cpark", 1 icos_theta .useet "Cpark", 1 Cptr ip_val cos_theta sin_theta .usect "Lpark",l .useet "Lpark",l .useet "Cpark",l .useet "Lpark",l ; Sine table

128

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

nxCentry delta_angle GPRO_ipark

.usect "Cpark",l .usect "Cpark",1 .usect "I_park", 1

#ipark_D ldp SPLK #3FFFh, ipark_D SPLK #3FFFh, ipark_Q SPLK #OOOOh, theta_ip RET CPARK: ldp #theta3sCmod .if theta_esCmod ;Calculate Cos(theta-p) ;--- High_precision option -----.if (High_precision) ;Higher precision using look-up + interpolation method ldp #theta_ip LACC theta_ip ;add 90 deg, i.e. COS(A)=SIN(A+90) ADD #8192 ;Force positive wrap-around AND #07FFFh ;here 90 deg = 7FFFhl4=8192d SACL GPRO_ipark LACC GPRO_ipark,9 ;Table pointer SACH Cptr ;Convert Interpolation value(ip_val) to Q15 SFR ;Force ip_val to a positive number AND #07FFFh SACL ip_val LACC #SINTAB_360 ADD t-ptr ;cos_theta = Cos(theta) in Q15 TBLR cos_theta ;Inc Table pointer ADD #lh ;Get next entry i.e. (Entry + 1) TBLR nxCentry LACC nxCentry cos_theta ;Find Delta of2 points SUB SACL delta_angle delta_angle LT ip_val ;ip_val = interpolation value MPY PAC SACH ip_val,1 LACC ip_val ADD cos_theta ;cos_theta = Final interpolated value SACL cos_theta .endif ;--------------------------------;-- Normal precision option ------.if (High_precision != 1) ;Normal precision with simple 256 word look-up ldp #theta_ip LACC theta_ip ;add 90 deg, i.e. COS(A)=SIN(A+90) ADD #8192 ;Force positive wrap-around AND #07FFFh ;here 90 deg = 7FFFhl4 SACL GPRO_ipark LACC GPRO_ipark,9

*

129

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

SACH LACC ADD TBLR .endif

t-ptr #SINTAB_360 Cptr cos_theta

;cos_theta = Cos(theta-p) in Q 15

;---------------------------------;Calculate Sin(theta-p) ;--- High-precision option ------.if (High-precision) ;Higher precision using look-up + interpolation method LACC theta_ip,9 ;Table pointer SACH Cptr ;Convert Interpolation value(ip_val) to Q 15 SFR ;Force ip_val to a positive number AND #07FFFh SACL ip_val LACC #SINTAB_360 ADD ;sin_theta = Sin(theta) in Q15 TBLR ;Inc Table pointer ADD ;Get next entry i.e. (Entry + 1) TBLR nxCentry LACC nxCentry ;Find Delta of 2 points SUB sin_theta SACL delta_angle delta_angle LT MPY ip_val ;ip_val = interpolation value PAC SACH ip_val,1 LACC ip_val sin_theta ADD ;sin_theta = Final interpolated value SACL sin_theta .endif ;---------------------------------;--- Normal precision option -----.if (Hi~precision != 1) ;Lower precision simple 256 word look-up LACC theta_ip,9 SACH t-ptr LACC #SINTAB_360 ADD t-ptr TBLR siJLtheta ;sin_theta = Sin(theta_p) in Q15 .endif ;----------------------------------.else ldp #theta_ip splk #isin_theta, sin_theta splk #icos_theta, cos_theta .endif ;Calculate the Inverse Park transfonn SETC SXM ; Sign extension mode SPM 1 ; SPM set for Q 15 multiplication ;park_q = ipark_Q * cos_theta + ipark_D * sin_theta

LACC LT MPY LTA

#0 ipark_D sin_theta ipark_Q

; ClearACC ; TREG = Udref ; PREG = Udref * silLtheta ; ACC = Udref*sin_theta and TREG=Uqref

130

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

MPY cos_theta MPYA sin_theta TREG=Uqref*sin_theta SACH ipark_q ;park_d = ipar~D * cos_theta - ipark_Q LACC #0 LT ipark_D MPYS cos_theta APAC SACH ipark_d SPM O.

; PREG = Uqref * cos_teta ; ACC = Uqref*cos_theta + Udref*sin_theta and

* sin_theta

; Ubeta = Uqref*cos_theta + Udref*sin_theta

; ClearACC ; TREG = Udref ; ACe = -Uqref*sin_theta and PREG = Udref*cos_theta ; Ace = -Uqref*sin_theta + Udref*cos_theta ; Ualfa = -Uqref*sin_theta + Udref*cos_theta ; SPMreset

RET

Module Name: SVGEN_DQ
; Description: This module calculates the appropriate duty ratios needed to generate a given stator reference voltage using space vector PWM technique. The stator reference voltage is described by it's (a,b) components, Ualfa and Ubeta. 1----->0 Ta Ualfa 0---->1 1 SVGEN_DQ 1----->0 Tb 1----->0 Tc Ubeta 0---->1

; ReferencelPrototype
;--------------------------------------------------------------------

.ref .ref .ref

SVGEN_DQ,SVGEN_DQ_INIT Ualfa,Ubeta Ta,Tb,Tc

;function call ;Jnputs ;Outputs

;--------------------------------------------------------------------; Select Processor and Define Related Peripherals
;---------------------------------------------------------------------

.include "x24x_app.h" ;-----------------------------------------------------------------------; Global Definitions ;------------------------------------------------------------------------SVGEN_DQ,SVGEN_DQ_INIT .def .def Ualfa, Ubeta .def Ta,Tb,Tc ouCoCphase_ .set

;function call ;Jnputs ;Outputs

;----------------------------------------------------------------------; Variables ;-------------_ ... ---------------------------------------------------------Ualfa .usect "svgen_dq",l .usect "svgen_dq",l Ubeta Va .usect "svgen_dq",l Vb .usect "svgen_dq",l Vc .usect "svgeo_dq",l Ta .usect "svgen_dq",l .usect "svgen_dq",l Tb Tc .usect "svgen_dq",l sector .usect "svgen_dq",l ;SVPWM sector ;SVPWMTl .usect "svgen_dq",l t1 ;SVPWMT2 t2 .usect "svgen_dq",l .usect "svgen_dq",l ;SQRT(3) * 0.5 halCsqrt3

131

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

;Alias Variable declaration (to conserve .bss locations) X .set Va Y .set Vb Z .set Vc SR_ADDR .set sector

ldp SPLK RET

#halCsqrt3 #28378,halCsqrt3; Set constant sqrt(3)*0.5 in QI5 format

;INV_CLARKE: ; SPM set for Q15 multiplication SPM 1 ; Sign extension mode on SETC SXM ;Va=Ubeta ldp #Ubeta ; ACC=Ubeta LACC Ubeta ; Va=Ubeta SACL Va ;Vb = (-Ubeta + sqrt(3) * Ualfa) 12 LT Ualfa ; TREG = Ualfa MPY halCsqrt3 ; PREG = Ualfa * halCsqrt3 PAC ; ACC high = Ualfa * halCsqrt3 SUB Ubeta,15 ; ACC high = Ualfa * halCsqrt3 +Ubetal2 SACH Vb ; Vb = Ualfa * halCsqrt3 +Ubetal2 ;Vc = (-Ubeta - sqrt(3) * Ualfa) / 2 PAC ; ACC high = Ualfa * halCsqrt3 NEG ; ACC high = - Ualfa * halCsqrt3 SUB Ubeta,15 ; ACC high = - Ualfa * halCsqrt3 -Ubeta/2 SACH Vc ; Vc = - Ualfa * halCsqrt3 -Ubeta/2
;------------------------------------------------------; 60 degrees sector determination ; sector = rl + 2*r2 + 4*r3 ; rl=l ifVa>O ; r2=1 ifVb>O ; r3=1 ifVc>O

;--------------------------------------------------------SPLK LACC BCND LACC OR SACL LACC BCND LACC OR SACL LACC BCND LACC OR #O,sector Va vrefl_neg,LEQ ;IfVa<O do not set bit 1 of sector sector #1 sector Vb vref2_neg,LEQ ;IfVh<O do not set bit 2 of sector sector #2 sector Vc vref3_neg,LEQ ;If V c<O do not set bit 3 of sector sector #4

132

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

SACL

sector

;-------------------------------------------------------;X,Y,Z calculation: ;----------------------------------------------------------

;X=Ubeta LACC Ubeta SACL X ;Y = (0.5 · Ubeta) + (sqrt(3) · 0.5 · Ualfa) LT Ualfa ; TREG = Ualfa MPY halCsqrt3 ; PREG = Ualfa · halCsqrt3 PAC ; ACC high = Ualfa · halCsqrt3 ADD Ubeta,15 ; ACC high = Ualfa · halCsqrt3 + Ubetal2 SACH Y ; Y = Ualfa · halCsqrt3 + Ubetal2 ;Z = (0.5 · Ubeta) - (sqrt(3) · 0.5 · Ualfa) PAC ; ACC high = Ualfa · halCsqrt3 NEG ; ACC high = - Ualfa · halCsqrt3 ADD Ubeta,15 ; ACC high = - Ualfa· halCsqrt3 + Ubetal2 SACH Z ; Z = - Ualfa · halCsqrt3 + Ubeta/2
;--------------------------------------------------------------

;Seetor calculations ("case statement")
;----------------------------------------------------------

LACC ADD sector TBLR SR_ADDR LACC SR_ADDR BACC ;sector I: lacc sael lacc sael lacc sub sub sfr sael add sael add t1=Z and t2=Y, (abc --> Th, Ta, Tc) Z t1 Y t2 #7FFFh tl t2 Th tl Ta t2

;Load 1 (QI5) ;taon=(l-tl-t2)/2

;tbon=taon+t1 ;teon=tbon+t2

;sector 2: lace sacl laec neg sael lace sub sub sfr

t1=Y and t2=-X, (abc --> Ta, Te, Th) Y tl X t2 #7FFFh tl t2

;Load 1 (QI5) ;taon=(l-tl-t2)/2

133

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

sacl add sacl add

Ta tl Te t2

;tbon=taon+t 1 ;teon=tbon+t2

SECTOR_SR3: tl=-Z and t2=X, (abc --> Ta, Th, Te) ;sector 3: Z lace neg sacl tl lace X sael t2

lace sub sub sfr sacl add sacl add

#7FFFh t1 t2 Ta t1 Th t2

;Load 1 (Q15) ;taon=(l-tl-t2)/2

;tbon=taon+t1 ;teon=tbon+t2

;seetor4: tl=-X and t2=Z, (abc --> Te, Th, Ta) lace X neg sacl tl lace Z sacl t2 lace sub sub sfr sacl add sacl add #7FFFh t1 t2 Te t1 Th t2 ;Load I (QI5) ;taon=( l-tl-t2)/2

;tbon=taon+tl ;teon=tbon+t2

tl=X and t2=-Y, (abc --> Th, Te, Ta) ;sector 5: lace X sacl tl lace Y neg sacl t2 lace sub sub sfr sacl #7FFFh t1 t2 Th ;Load I (QI5) ;taon=(l-tl-t2)/2

134

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

add t1 sael Te add t2

;tbon=taon+t1 ;teon=tbon+t2

t1 =-Y and t2=-Z, (abc --> Tb, Te, Ta) ;seetor 6: y lace neg sael t1 lace Z neg sael t2 ;Load I (QI5) lace #7FFFh sub t1 ;taon=(l-tl-t2)/2 sub t2 sfr sael Te ;tbon=taon+t1 add t1 sael Ta ;teon=tbon+t2 add t2 sael Tb SV_END: ;Multiply Ta by 2 & offset by 112 LACC Ta SUB #3FFFh ;mpyby2 SACL Ta,l ;Multiply Tb by 2 & offset by 112 LACC Tb SUB #3FFFh ;mpyby2 SACL Tb,l ;Multiply Te by 2 & offset by 112 LACC Te SUB #3FFFh SACL Te,! .if (oucof-phase_) LACC Ta NEG 8ACL Ta LACC Tb NEG SACL Tb LACC Te NEG SACL Te .endif SPM 0 DUMMY

;mpyby2

; SPMreset

;.---------------------------------------------------;SVPWM Sector routine jump table - used with BACC inst. ;-----------------------------------------------------_ .... SECTOR_TBL: SROO .word DUMMY SRO .word SECTOR_SRI SRI .word SECTOR_SR2

RET

135

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

SR2 SR3 SR4 SRS

.word .word .word .word

SECTOR_SR3 SECTOR_SR4 SECTOR_SRS SECTOR_SR6

Module Name: S Y SIN I T
; Description: Initializes F24x/xx devices ARI is used as stack pointer .include .def .ref .set .usect x24x_app.h SYS_INIT GPRO 20h "stack",stack_size

stack_size stack_start SYS_INIT:

POINT_PGO ;Disable interrupts SETC INTM ;Mask all Ints SPLK #Oh, IMR ;Clear all Int Flags SPLK #OFFh, IFR ;Init PDP interrupt flag after reset LDP #PIRQRO»7 LACC PIRQRO ; Clear pending PDP flag AND #OFFFEh SACL PIRQRO ; Clear pending PDP flag LACC PIRQR2 AND #OFFFEh SACL PIRQR2 POINT_EV LACC EVAlFRA ; Clear PDPINTA flag OR #OOOlh SACL EVAIFRA LDP #EVBIFRA»7 ; Clear PDPINTB flag LACC EVBIFRA OR #OOOlh SACL . EVBIFRA POINT_PGO CLRC SXM CLRC OVM CLRC CNF SPM 0 ARI, #stack_start LAR MAR *,ARI POINT_BO SPLK #OOCOh, GPRO OUT GPRO, WSGR POINT_PFI .if (x4_PLL) SPLK #0085h, SCSRI ; x4 PLL, ADC en, EVI en, clr III Addr flg .endif

;Clear Sign Extension Mode ;Reset Overflow Mode ;Config Block BO to Data mem. ;Init s/w stack pointer

;Set 3 wait states for 110 space

136

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

l

1
.if (x2_PLL) SPLK #0285h, SCSRI ; x2 PLL, ADC en, EV! en, clr mAddr fig .endif ;Comment out ifWD is to be active SPLK #006Fh, WD_CNTL ;Disable WD ifVCCP=5V KICK_DOG RET

1-----------1 ; ijdb 0------>1 1 ; i_ref 0------>1 pid_reg 1---->0 u_out ; u_int 0------>1 1
;Kp ; Ki ;Kc

; Description:

PI current regulator with integral correction for d and q axes

0------>1

1

1

1

,

·····························································

· D-Axis PI Current Regulator

·····························································
;-----------------------------------------------------------

; ReferencelPrototype
;-----------------------------------------------------_...

.ref .ref .ref .ref

pid_reg...id,pid_reg...id_init; function call id3db,id_ref,Kp_d,Ki_d,Kc_d ; Inputs ud_int ; Input ud_out ; Outputs

;--------------------------------------------------------

; Global Definitions ,-----------------------------------------------------.def pid_reg...id,pid_reg...id_init; function call .def idjdb,id_ref,Kp_d,Ki_d,Kc_d ; Inputs .def ud_int ; Input .def ud_out ; Outputs
;----------------------------------------------------------

; Variable Definitions
;-----------------------------------------------------------

id_fdb .usect "pid",! id_ref .useet "pid",! ud_out .useet "pid",! ud_int .usect "pid",l uintlo_d .usect "pid",! .usect "pid",! .usect "pid",! .useet "pid",! id_error .useet "pid",! uprsacd .useet "pid",! saterr_d .useet "pid",! tmp_d .usect "pid",!

; current feedback ; current reference ; control voltage output ; error integral

; proportional gain ; integral gain ; integral correetion gain ; current error ; control voltage prio saturation ; saturation error ; temp scrach

137

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

;----------------------------------------------------------; Default parameters ; Parameter spreadsheet: pid.x1s ;----------------------------------------------------------Kp_d_ 783;554 ;783; 388 ; Qll, proportional gain 0.189d .set Ki_d_ 2542;3630;5133; 2542; 1271 ; Q25, integral gain 0.37878*0.0002d .set Kc_d_ 32767 ; Q14, saturation correction gain 2d .set

Umax_d_ 07000h ; maximum U(0.875PU) .set Umin_d_ ; minimum U(-0.875PU) .set 08FFFh ;-_ ... _ ..._----------------------------------------------------; Initialization ;--------------------------------------------------------pid_re~id_init

ldp #Kp_d SPLK #Kp_d_,Kp_d SPLK #Ki_d_,KCd SPLK #Kc_d_,Kc_d SPLK #O,ud_int SPLK #O,uintlo_d RET ;--------------------_.. _ ..._---------------------------------; Routine ;-------------------------------------------------------pid_re~id

; zero integral term

setc setc

SXM OVM

; Allow sign extension ; Set overflow protection mode

ldp #id ref LACC id_ref,16 SUB id3db,16 SACH id_error lacl add spm 2

; Use ACCH for OV protection ; Q 15 id_ref - id3db

; 32-bit Q30 ; product lis 4 for accumulation id3rror ; QI5*QII -> 32-bit Q26 uprsaCd ; 32-bit Q30 uint + id_error*Kp_d ; save as QI4 uprsacd

LT
mpy Kp_d apac SACH sacl tmp_d adds tmp_d add sach lacc sub

; Q30 -> Q31 with OV protection ; save to tmp_d as QI5 tmp_d #Umin_d_ ; Continue iftmp_d>=U_min ; otherwise, saturate

bcnd U~nd,GEQ lacc #Umin_d_ B Nextd U....gmind lacc tmp_d sub #Umax_d_ BCND U_lmaxd,LEQ lacc #Umax_d_

; Continue iftmp_d<=U_max ; otherwise, saturate

138

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

~ I

I

b Nextd U_lmaxd tmp_d lacc Nextd ud_out sad Inuennd ; Use ACCH for OV protection ud_out,15 lacc SUB uprsacd,16 ; save as Q14 saterr_d = ud_out-uprsaCd satercd sach It id_error Ki_d ; Q15·Q25 -> Q40 mpy ; Q40->Q44 pac tmp_d sach ; Q44 -> Q28 (rls 16 bits) tmp_d lacc saterr_d LT MPY Kc_d ; Q14·Q14 -> Q28 saterr_d · Kc_d ; Q28 Ki_d·id_error + Kc_d·saterr_d APAC nonn ; Q28 -> Q30 (with OV protection) nonn · ADDS uintlo_d ADD ud_int,l6 SACH ud_int ; save as 32-bit Q30 SACL uintlo_d RET ···END D-Axis PI Current Regulator

·

I
I

~. ~

····························································· · Q-Axis PI Current Regulator ·····························································
;---------------------------------------------------------

I

; ReferencelPrototype ;-------------------------------------------------------.ref pid_reg...iq,pid-reg...i~init; function call i~fdb,i~ref,Kp-q,Ki-q,Kc-q ; Inputs .ref u~int ; Input .ref u~out ; Outputs .ref ;-------------------------------------------------------; Global Definitions ;----------------------------------------------------------.def pid_reg...iq,pid-reg...i~init; function call .def i~fdb,i~ref,Kp_q,Ki_q,Kc-q ; Inputs .def u~int ; Input .def u~out ; Outputs ;---------------------------------------------------------; Variable Definitions ;--------------------------------------------------------; current feedback iq3db .usect "pid",l ; current reference i~ref .useet "pid",l ; control voltage output uq-out .useet "pid",l ; error integral u~int .useet "pid",l uintlo_q .usect "pid",l Kp_q .useet "pid",l ; proportional gain ; integral gain Ki_q .useet "pid",l Kc_q .useet "pid",l ; integral correetion gain ; current error i~error .usect "pid",l ; control voltage prio saturation uprsaCq.usect "pid",l

139

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

saterr_q .usect "pid",1 ; saturation error tmp_q .usect "pid",1 ; temp scrach ;-------------.. _----------------------------------------; Default parameters ; Parameter spreadsheet: pid.xls

;---------------------------------------------------------1108 ;1566; 776 ; Qll, proportional gain 0.3789d .set Kp-<15446 ;7700; 3814 ;1907 ; Q25, integral gain 0.56833*0.0002d Ki-<1.set Kc_q_ 24576 ; Q14, saturation correction gain 1.5d .set 07000h ; maximum U .set Umax_<l08FFFh ; minimum U .set Umin_<l;--------------------------------------------------------; Initialization ;--~-----------------------------------------------------pid_re8-i<1-init Idp #Kp_q SPLK #Kp-<1-,Kp-q SPLK #Ki_<l-.Ki_q SPLK #Kc_<l-,Kc_q ; zero integral term SPLK #O,u<1-int SPLK #O,uintlo_q RET ;------------------------------------------------------; Routine ;---_.._----------------------------------------- ..-------SXM setc OVM Idp #i<1-ref LACe i<1-ref,16 SUB i<l-fdb,16 SACH i<1-error lael uintlo_q u<1-int, 16 add spm 2 ; Allow sign extension ; Set overflow protection mode ; Use ACCH for OV protection

; 32-bit Q30 ; product lis 4 before accumulation ; Q15*Qll -> 32-bit Q26 ; 32-bit Q30 uint + i<1-error*Kp_q ; save as Q14 uprsaCq

LT
mpy Kp_q apac SACH uprsaCq sael tmp_q adds tmp_q add uprsaCq,16 sach tmp_q lacc tmp_q sub #Umin_q_ bcnd U....,gminq,GEQ lacc #Umin_<lB Nextq
U~q

; Q30 -> Q31 with OV protection ; save to tmp_q as Q15

; Continue iftmp_q>=U_min ; otherwise, saturate

lacc tmp_q sub #Umax_<lBCND U_lmaxq,LEQ lacc #Umax_<lb Nextq U_lmaxq lacc tmp_q

; Continue iftmp_q<=U_max ; otherwise, saturate

140

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

1 I

Nextq sacl InUermq lacc SUB sach uq....out uq....out.15 uprsaCq.16 saterr_q iq....error Ki-q tmp-q tmp-q saterr_q ; Use ACCH for OV protection ; save as Q14 saterr_q = uq_out-uprsaCq ; Q15*Q26 -> Q40 ;Q40->Q44 ; Q44 -> Q28 (rls 16 bits) ; Q14*Q14 -> Q28 saterr_q * Kc_q ; Q28 Ki_q*i~error + Kc_q*saterr_q

It
mpy pac sach lacc LT MPY Kc_q APAC norm norm ADDS ADD SACH SACL RET

uintlo_q uq,jnt.16 uq....int uintlo_q

* *

; Q28 -> Q30 (with OV protection)

; save as 32-bit Q30

This module uses the duty ratio information and calculates the compare values for generating PWM outputs. The compare values are used in the full compare unit in 24x124xx event manager(EV). This also allows PWM period modulation. ; Mfunc31 0------>1 1----->0 CMPRI (BV register) ; Mfunc_c2 0------>1 FC_PWM_DRV 1----->0 CMPR2 (BVregister) ; Mfunc33 0----->1 1---->0 CMPR3 (BV register) ; Mfunc_p 0------>1 1----->0 TlPER (BV register) n_period 0----->1 I ; Target: x2407 Event Manager Timer! & F Compares

; Description:

; ReferencelPrototype ;---------------------.refFC_PWM_DRV.FC_PWM_DRV_INIT ;function calls ;Inputs .refMfunc_cl.Mfunc32.Mfunc33.Mfunc_p .ref n_period ;Input ; Defme Related Peripherals ;--------------------------------.include "x24'Capp.h" ; Default PWM Period ;-----------------------;PWM_PERIOD .set 100 ; PWM period in uS (10KHz) .different from focl.asm? PWM_PERIOD .set 200 ; PWM period in uS (5Khz)
;------------------------

·

; Global Defmitions ;------------------------.defFC_PWM_DRV,FC_PWM_DRV_INIT .def Mfunc_c I.Mfunc_c2.Mfunc_c3,Mfunc-p .def n_period ;Input

;function calls ;Inputs

141

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

Mfunc_c1 .usect "pwm_drv",l ; Phase 1 mod function Q15 Mfunc32 .usect "pwm_drv",l ; Phase 2 mod function Q15 Mfunc_c3 .usect "pwm_drv",l ; Phase 3 mod function Q15 Mfunc...,p .usect "pwm_drv",l ; Period mod function Q15 n...,period.usect "pwm_drv",l ; Nonninal period/compare value m_period .usect "pwm_drv",l ; Modulated period ;----------------... _----------; Configuration parameters ;---------------------------.ifx2407 TlPER_.set PWM]ERIOD*15 ; *1000nS/(2*33nS) TlCON_ lOOOlOOOOlOOOOOOb ; Symmetric PWM .set DBTCON_ .set 09E8h . ; DIB = U8uS @33nS elk ACTR_ OllOOllOOllOb; 1/3/5 Active Hi, 2/4/6 Active Lo .set COMCON_ .set 100000 1OOOOOOOOOb ; Compare Cntl .endif
;---------------------------------------------------------------------

; Initialization ;----------------------------------------------------------------FC_PWM_DRV_INIT LDP #TlPER»7 SPLK #TlPER_,TlPER SPLK #TlCON-->TlCON SPLK #DBTCON_,DBTCON SPLK #ACTR_,ACTR SPLK #COMCON_,COMCON .ifx2407 ldp #OCRA»7 LACC OCRA OR #OOOOlllllI000000b SACL OCRA .endif #n...,period ldp SPLK #TIPER_,n...,period SPLK #7FFFh,Mfunc_p

; Configure 6-pwm pins

RET
;--------------------------------------------------------------------

; Driver Routine
;-------------------------------------------------------------------

FC_PWM_DRV: ldp LT MPY PAC add SACH Idp sach Idp LT MPY PAC add Idp SACH #Mfunc...,p ; modulate period Mfunc...,p n...,period; Mfunc_p*n_period/2 n...,period,15 llLperiod #TlPER»7 TlPER #Mfunc_cl Mfunc_cl m_period m_period,15 #CMPR1»7 CMPRI ; offset by n...,period/2 ; save for later reference ; save ; Modulate channel one

; offset by m_period/2 ; save

142

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

,
f
ldp LT MPY PAC add ldp SACH ldp LT MPY PAC add ldp SACH RET #Mfunc_c2 Mfunc32 m_period m_period,l5 #CMPR2»7 CMPR2 #Mfunc33 Mfunc_c3 m_period m_period, 15 #CMPR3»7 CMPR3 ; Modulate channel two ; Mfunc_c2 x m_period/2 ; offset by m_periodl2 ; save ; modulate channel three ; Mfunc33 x m_period/2 ; offset by m_period/2 ; save

; Module Name:
; Description: Current model for field oriented control of an AC induction machine ; Ccur_mod_d ->1 1 ; i_cucmod_q ->1 CURRENT_MODEL 1-----> theta_cur_mod ; spd_cuuIlod-->1 1
;----------------------------------------------------------

; Global Definitions
;----------------------------------------------------------

.def .def .def .def .def fs

CURRENT_MODEL,CURRENT_MODEL_INIT; function call Ccur_mod_D,i_cur_mod_Q ; Inputs spd_cur_mod ; Input theta_cur_mod ; Outputs

;---------------------------------------------------------

; Variable Definitions ;---------------------------------------------------------;public variables Ccur_mod_D .usect "cur_mod",l Ccur_mod_Q .useet "cur_mod", I spd_cur_mod .usect "cur_mod", I theta_cur_mod .usect "cur_mod",l ;private variables iSd .usect "cur_mod",l ;stator current flux component iSq ;stator current torque component .usect "cur_mod",l .usect "cur_mod",l ;rotor mechanical speed .useet "cur_mod", 1 ;rotor flux position i_mr .usect "cur_mod",l ;magnetizing current .usect "cur_mod",l fs ;rotor flux electrical speed tetaincr .useet "cur_mod",! ;electrical angle variation within .usect "cur_mod",l Kr ;Q12 .usect "cur_mod", 1 ;Q12 Kt .usect "cur_mod",! K ;QO .usect "cur_mod",l myK my_fs .usect "cur_mod",l .usect "cur_mod", 1 p ;one sampling period

143

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

;temporary variable tmp .usect "cur_mod",1 ;temporary variable tmpl .usect "cur_mod",1 Teta_cml .usect "cur_mod",1 ;vizualisation variable ;----------_ ... _---------------------------------------------; Default parameters ;.:.-------------------------------------------------------

; Parameters of the motor used with the Encoder .set .set Oeh ;must be calculated according to the 1bOh ;motor parameters (check out .xIs sheet) .set 148h

; Parameters of the motor used with the Tachometer .set .set .set .set .set .set 3h ;must be calculated according to the 62h ;motor parameters (check out .xIs sheet) 148h 3 ;must be calculated according to the 46 ;motor parameters (check out .xIs sheet) 786

;--------------------------------------------------------; Initialization ;--------------------------------------------------------

ldp #n splk #OOOOb,n #OOOOh,i_mr splk splk #Kc,Kr splk #KC,Kt splk #K_,K splk #3FFFh,theta_cur_mod splk #OOOOb,Ccucmod_D splk #OOOOb,i3ucmod_Q splk #OOOOh,spd3ur_mod splk #OOOOb,iSd splk #OOOOb,iSq splk #OOOOb,Teta3m splk #OOOOb,fs splk #OOOOb,tetaincr splk #OOOOh,tmp splk #OOOOb,tmp 1 splk #OOOOb,Teta_cml splk #Pole_pairs_number,p ret ; Current model with Cmr on 16 bit CURRENT_MODEL ; Tuning from Q15 (input variables format) to Q12 (working variables) Idp #i3ur_mod_D lacc Ccur_mod_D

sft
sfr

sft

144

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

1
1
ldp #iSd sacl iSd ldp #i_cur_mod_Q lacc Ccur_mod_Q sfr sft sfr #iSq ldp sacl iSq ldp #SPd3uCmod lacc spd_cucmod ;QI5, 1800rpm as pu sft ; add by C.MA sfr sfr ; check this conversion depending on your nominal speed #n Idp sacl n ;QI2, 225rpm as pu

··············································· · Current Model ···············································

!
I
1

I

J

t

ldp #iSd lacc iSd Cmr sub sacl tmp tmp It mpy #Kr pac tmp,4 ;add by C. Ma sach lacc tmp add Cmr i_mr ;i_mr=i_mr+Kr·(iSd-Cmr), 4.12 f sacl i_mrnotzero,NEQ bcnd lacc #0 ;if Cmr=O then tmp=iSq/Lmr=O tmp sacl b Lmrzero Lmrnotzero ··· division (iSq/Lmr) Lmr lacc bcnd i_mrzero,EQ sacl tmpl lacc iSq abs tmp sacl tmp,12 lacc #15 rpt tmpl subc tmp ;tmp=iSq/i_mr sacl lacc iSq iSqpos,GT bcnd lace tmp neg sacl tmp ;tmp=iSq/Lmr, 4.12 format iSqpos Lmrzero ··· END division ··· It tmp #Kt mpy

145

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

pac sach tmp,4 ;slip frequency, 4.12 format tmp ;load tmp in low ACC lacc add n ; RPT #(Po1e_pairs_number-1) changed by Ma ;sfr changed by Ma sael fs ;rotor flux speed, 4.12 format, ;fs=n+Kt*(iSqli_mr) *** rotor flux position calculation *** lacc fs abs sael tmp It tmp mpy #K pac sach tetaincr,4 fs,O bit fs_neg,TC bcnd lael tetaincr Teta_cm adds sael Teta3m b fs~s fs_neg Teta_cm lael tetaincr subs Teta_cm sael ;Teta3m=Teta3m+K*fs=Teta3m+tetaincr ;(0;360)<->(0;65535) #theta3ur_mod ldp sfr ; add by Ma and #7FFFh sael theta_cur_mod *********************************************** * END Current Model *********************************************** ret

Module Name: theta_estimation model
; Description: Theta estimation model for field oriented control of an AC induction machine 1--->sinTeta_est psiRal->1 1 theta_est 1 1-->cosTeta_est psiRbe ->1 1 model 1 ; Variable Definitions ;-----------------------------------------------------_.. ;public variables psiRal .usect "theta_es",l psiRbe .useet "theta_es",l sinTeta_est .usect "theta_es",l cosTeta_est .usect "theta_es",l ;private variables tmp .useet "theta_es",l

·

146

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

tmpl Index psiR_est psiR_estl psiRal_estl psiRbe_estl

.usect "theta_es",l .usect "theta_es",l .usect "theta_es",l .usect "theta_es",1 .usect "theta_es",l .usect "theta_es",1

;-----------------------------------------------------------

; Default parameters
,-----------------------------------------------------------

Ksqrt .set 2751 Pole_pairs_nwnber .set 2
;------------------------------------------------------------

; Initialization
;------------------------------------------------------------

theta_esCinit

CURRENT_MODEL_nnT
Idp splk splk ret #psiRal #OOOOh,sinTeta_est #7FFFh,cosTeta_est

···············································
· Rotor flux amplitude calculation · psiR_est theta_est ldp splk splk lacc sfr sfr sfr sael lacc sfr sfr sfr sael
mar

···············································
#psiRal #psiRal,psiRaCestl #psiRbe,psiRbe_estl psiRal_estl ;change to 4.12 format

psiRbe

·,ARS

;ARP->ARS

spm 2 ;automatic <<2 for 4.12 multiplications ;Preg is eleared to zero mpy #0 zac ;Acc is cleared to zero sqra psiRal ;Preg=(psiRaCest)2 ;Acc=(psiRal_est)2 in 4.12 format (spm=2) pac ;tmp=(psiRal_est)2 sach tmp sqra psiRbe ;Preg=(psiRbe_est)2 ;Acc=(psiRbe_est)2 in 4.12 format (spm=2) pac ;tmp 1=(psiRbe_est)2 sach tmpl lacc tmpl add tmp ;tmp=(psiRaCest)2 + (psiRbe3st)2 still in 4.12f sael tmp spm o ;no automatic shift anymore ;Treg=tmp It tmp ;Preg=tmp·Ksqrt mpy #Ksqrt ;Acc=Preg, the two index digits are located in the high Acc pac sach Index ;store the two interesting digits into Index (->8.8f)

147

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

................-------------------------1
lace Index ;Aee=Index ;Acc=Index+sqrt table address add #sqrUab sael tmp ;tmp= Index+sqrt table address lar AR5,tmp ;load in AR5 the content of tmp lacc * ;Acc= sqrt(psiRal_est2+psiRbe_est2) in 8.8 fonnat saelpsiR_est,4 ;psiR_est=sqrt(psiRaCest2+psiRbe_est2) 4 left shift -> 4.12f sael psiR_estl,7 ;psiR_estl=sqrt(psiRal_est2+psiRbe_est2) 7 left shift -> U5f

I I
J

I

I

***********************************************

* input in f 1.15 * output (cosTeta3st, sinTeta_est) in f 4.12
***********************************************
lace psiR_est ;Aee=psiR_est bend modnotzero,NEQ lacc #0 sael tmp mCHizero b modnotzero ;If rotor flux module <> 0 lacc psiRaCestl ;Acc=psiRaCestl a comp of the rotor flux in 1.15 format ;Acc=abs(siRaCestl), unsigned numbers division abs ;tmp=abs(psiRaCestl ) sael tmp ;store abs(psiRal_estl) in high side of Acc lace tmp,15 rpt #15 ;AccL=psiRal_estl/psiR_estl, res in 1.15 fonnat sube psiR_estl sft * sfr * ;three right shifts -> division result in 4.12 fonnat sft * ;store 1.15 res (=psiRal_estl/psiR_estl) in cosTeta_est sael eosTeta_est lace psiRaCestl bend cospos,GT ;If psiRaCestl <0 then cosTeta3st<0 lace eosTeta_est neg modzero sael cosTeta_est cospos lace psiR3st ;cosTeta_est=psiRaI_estl/psiR_estl, 4.12 format bend modnotzero 1,NEQ lace #0 sael tmp b modzerol modnotzero 1 ;If rotor flux module <> 0 ;Acc=psiRbe3stl b comp of the rotor flux in 1.15 fonnat lacc ;Acc=abs(psiRbe_estl), unsigned numbers division abs ;tmp=abs(psiRbe_estl ) sael tmp ;store abs(psiRbe_estl) in high side of Ace lace tmp,15 rpt #15 ;AccL=psiRbe_estllpsiR_estl, res in 1.15 fonnat subc psiR3 stl * sft * sft ;three right shifts -> division result in 4.12 format * sft sael sinTeta_est ;store 1.15 res (=psiRbe_estl/psiR_estl) in sinTeta_est lacc psiRbe_estl bcnd sinpos,GT ;IfpsiRbe_estl<O then sinTeta_est<O lace sinTeta_est

* divisions psiRaCestl/psiR_estl * psiRbe_estllpsiR_estl

I

148

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

,
neg modzerol sacl sinpos sinTeta_est ;sinTeta_est=psiRbe3stl/psiR_estl, 4.12 format

* END divisions
ret

*******************************

*

*******************************

; Module Name:
; Description:
nnp~ain

RAMP_GEN
0----->1 0------>1 0------>1
RAMP_GEN

This module generates ramp output of adjustable gain frequency and dc offset.

nnp_offset nnpjreq .def .def .def .def

1 1----->0 1

nnp_out

RAMP_GEN,RAMP_GEN_~T

;function call ;Inputs ;Input ;Output

nnp_offset, nnpjreq step_angle_max nnp_out .set

nnp~ain,

1000 ;Corresponds to 305.2Hz for fs=20kHz ; or l52.6Hz for fs=lOkHz, or 76.3Hz for fs=5KHz ;See related doc for details

alpha_rg.useet "rampgen",l step_angle_rg .usect "rampgen",l step_angle_max .usect "rampgen",l nnp-..,gain .usect "rampgen",l nnp_offset .useet "rampgen",l nnpjreq .useet "rampgen",l nnp_out .usect "rampgen",l nnp_ouCabs .usect "rampgen",l
RAMP_GEN_~:

LDP SPLK SPLK SPLK SPLK SPLK RET RAMP_GEN: SPM 0 LDP LT

#alpha_rg #0, alpha_rg #STEP_ANGLE_RG_MAX, step_angle_max #3FFFh, nnp~ain #3FFFh, nnp_offset #3FFFh, nnpjreq

MPY step_angle_max PAC SACH step_angle_rg,1 ;QO LACC alpha_rg ADD step_angle_rg ;QO SACL alpha_rg ;scale the output with gain(user specified)

;Nonnalized frequency nnp_freq ;is in Ql5 ;Q15 xQO ;QO x Q15 = Q15 (32bit) ;QO ;QO+QO

149

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

LT MPY PAC SACH LACC SACL

alpha_rg rmp...,gain rmp_ouCabs,1 rmp_ouCabs rmp_out

;QO ;QO x QI5

;P = rmp...,gain * alpha_rg
;QO ;QO ;QI5**

**
;In the last two instructions the variables rmp_ouCabs and rmp_out contain ;the same value which is the result of the preceeding multiply operation. ;Although they have the same value, by representing rmp_out with a ;different Q format(QI5) than rmp_ouCabs(QO), we have essentially performed ;an implicit normalization(division) operation. The normalized ramp output, ;rmp_out(in QI5), and the absolute ramp output, rmp_ouCabs (in QO), are ;related by, ;rmp_out = rmp_oucabsI7FFFh. ;The output of this module(rmp_out) is normalized (expressed in Q15) since ;in many other slw modules, where this is used as input, require the input ;be provided in Q 15 format.
;add offset value LACC rmp_out rmp_offset ADD SACL rmp_out

;Q15 ;QI5+QI5 ;Q15

RET

150

Reproduced with permission of the copyright owner. Further reproduction prohibited without permission.

