OPTIMIZED SWITCH-LEVEL SOFT ERROR DETECTION BASED ON ADVANCED SWITCH-LEVEL MODELS

by

JaiaI Mohammad Chikhe

Maitrise de science de la modelisation, de l'information et des systemes Mention Electronique, electrotechnique, automatique et systemes University of Paul Sabatier, Toulouse, France, 2007

A project report presented to Ryerson University in partial fulfillment of the requirements for the degree of Master of Engineering in the Program of Electrical and Computer Engineering Toronto, Ontario, Canada, 2010

ЕJa\al Mohammad Chikhe 20 I 0

PRO?Gll"f CF .~
RYEF:&m~ :":~H~!313rrv U3RAm'

AUTHOR'S DECLARATION

I hereby declare that I am the sole author of this project or dissertation. I authorize Ryerson University to lend this project or dissertation to other institutions or individuals for the purpose of scholarly research.

~~.-..

I further authorize Ryerson University to reproduce this project or dissertation by photocopying or by other means, in total or in part, at the request of other institutions or individuals for the purpose of scholarly research.

iii

ABSTRACT
Project Title:
Optimized switch-level soft error detection based on advanced switch-level models

Project submitted by:
Jalal Mohammad Chikhe Optimization Problems Research and Applications Laboratory (OPR-AL) Master of Engineering, Ryerson University, 2010

Project Directed by:
Dr. Reza Sedaghat

Due to the reduction of transistor size, modem circuits are becoming more sensitive to soft errors. The development of new techniques and algorithms targeting soft error detection are important as they allow designers to evaluate the weakness of the circuits at an early stage of the design. This project presents an optimized implementation of soft error detection simulator targeting combinational circuits. The developed simulator uses advanced switch level models allowing the injection of soft errors caused by single event-transient pulses with magnitudes lesser than the logic threshold. The ISCAS'85 benchmark circuits are used for the simulations. The transients can be injected at drain, gate, or inputs of a logic gate. This gives clear indication of the importance of transient injection location on the fault coverage. Furthermore, an algorithm is designed and implemented in this work to increase the performance of the simulator. This optimized version of the simulator achieved an average speed-up of 310 compared to the nonalgorithm based version of the simulator.

iv

ACKNOWLEDGEMENT

At first I would like express my gratitude to Dr Sedaghat for his advice, guidance and patience. I am grateful to have him as a mentor because his support helped me progress in my research. Being part of Optimization Problems Research and Applications Laboratory (OPR-AL) was one a most creative and energetic experience. I would like to thank the members of the (OP-RAL) for making me very comfortable when joining the team and for offering their help and support.

I dedicate this project to my parents. Their love and encouragement helped me through this journey.

v

TABLE OF CONTENTS
i\llstract ................................................................................................... i"
Acknowledgement ....................................................................................... v Table of Contents ....................................................................................... vi List of Tables ............................................................................................. ix List of Figures ............................................................................................xii

Nomenclatu re .......................................................................................... xiv Chapter 1

Introduction ........................................................................ 1

1.1. Background ........................................................................ 1 1.2. Motivation ......................................................................... 3 1.3. Summary of Contribution ..................................................... 3 1.4. Project Organization ............................................................ 4 Chapter 2

Main Functions of the Simulator................................................ 5

2.1. Verilog Strength and Logic Levels ........................................... 6 2.2. Switch-Level Functions ......................................................... 9 2.2.1. funC Function ....................................................... 9 2.2.2. funN Function ..................................................... 10 2.2.3. funP Function ..................................................... 11 2.2.4. Capacitance Functionality ..................................... 12 2.2.5. Example of Transient Injection at Drain of a Switch Applied to NAND2 Gate ......................................... 13 Chapter 3 Fundamental Architecture and Data Structure of the Simulator.....и 15

3.1. Programming Language ...................................................... 15 3.2. Simulation Environment ...................................................... 16 3.2.1. Data Input ............................................................ 17 3.2.2. Simulator Flow Diagram ....................................... 18 3.2.3. Data Output. ...................................................... 20
vi

3.2.4. Processing Module ................................................ 23 3.3. Data Structure of Netlist Gate-Level
(netlist~) .........................

24

3.4. Processing and Storing Arrays of Gate-LeveL ............................ 26 3.5. Data Structure of Netlist Switch-Level (netlist_s) ........................ 28 3.5.1. Coding Architecture of netlist_s .................................. 28 3.5.2. NOT Gate ............................................................. 29 3.5.3. BlTFFER Gate ..................................................... 32 3.5.4. NAND2 - AND2 Gates ........................................... 33 3.5.5. NAND3 - AND3 Gates .......................................... 36 3.4.6. NOR2 - OR2 Gates ............................................... 38 3.4.7. NOR3 - OR3 Gates .............................................. 40 3.5.8. Data Structure Switch-Level of C17 Circuit ................. 43 3.6. Processing and Storing Arrays of Switch-LeveL ........................ 46

Chapter 4

Detailed Representation of SimVI Simulator....ииииии.и.и..ии...ииииии... 48

4.1. Flow Diagram ofSimV........................................................ 48 4.2. Flow Diagram of.Module 1. ................................................... 52

Chapter 5

Detailed Representation of SimV2 Simulator и..........и.иии...и....иии.ии 57

5.1. Gate-Level Resolution Function .............................................. 57 5.3. Switch-Level Data Input Organization ...................................... 63 5.3. Concept ofthe Algorithm Used in SimVl Simulator ...................... 63 5.3.1. 1st Solution Based on C17 Circuit Example ................. 67 5.3.2. 2nd Solution Based on C17 Circuit Example ................. 69 5.3.3. 3rd Solution Based on C17 Circuit Example ................. 70 5.3.4. 4th Solution Based on C17 Circuit Example ................. 71

Chapter 6

Experimental Results ............................................................ 75

6.1. Overview of the Simulation Applied Data ................................ 75 6.1.1. Benchmarks ....................................................... 75 6.1.2. Information on the Applied Data ............................. 77
vii

6.2. Fault Coverage Due to Transient Injection at Different Location types ..................................................................... 77 6.2.1. Injection at Gate of a Switch ................................... 77 6.2.2. Injection at Drain of a Switch ...................................... 81 6.6.3. Injection at Inputs of a Logic Gate ............................ 83 6.3. Fault Coverage Versus Applied Test Vectors ............................. 85 6.4. Timing Results ................................................................... 87 6.6.1. Matlab Profile of SimVt and SimV2 Simulators ............ 87 6.6.2. Timing Results of SimVI Simulator ........................... 88 6.6.3. Timing Results of SimV2 Simulator ............................ 90 6.6.4. Performance Study of the Developed the Simulators ....... 93

Chapter 7

Conclusion ......................................................................... 96

Publications ............................................................................................... 98 Bibliography ................................................................................................................................. a ... a ................ 99

viii

LIST OF TABLES
Table 1: Verilog coding representation oflogic and strength levels and their decimal Representation ..................................................................................... 7 Table 2: map_det ofC17 circuit .......................................................................... 21 Table 3: map_detATV ofC17 circuit .................................................................... 23 Table 4: Coding of the gate types ......................................................................... 25 Table 5: Data structure of C17 netlist gate-level (netlist_g) before and after net reorganisation .................................................................................................................. 26 Table 5(a): Data structure ofC17 netlis gate-level before net reorganisation ....................... 26 Table 5(b): Data structure of C 17 netlist gate-level after net reorganisation ....................... 26 Table 6: The main storing and indexing arrays needed to process C17 circuit gate-level ......... 27 Table 7: Coding of the switch-level functions .......................................................... 29 Table 8: Coding and data structure of switch-level NOT gate ........................................ 32 Table 9: Coding and data structure of switch-level BUFFER gate .................................. 33 Table 10: Data structure of switch-level NAND2 and AND2 gates .................................. 34 Table 11: Coded data of switch-level NAND2 and AND2 gates .................................... 35 Table 12: Data structure of switch-level NAND3 and AND3 gates .................................. 36 Table 13: Coded data of switch-level NAND3 and AND3 gates ..................................... 37 Table 14: Data structure of switch-level NOR2 and OR2 gates ...................................... 39 Table 15: Coded data of switch-level NOR2 and OR2 gates ......................................... 40 Table 16: Data structure of switch-level NOR3 and OR3 gates ...................................... 41 Table 17: Coded data of switch-level NOR3 and OR3 gates ......................................... 41 Table 18: Data structure ofnetlist switch-level ofC17 circuit ........................................ 45
ix

Table 19: Array of the storing processed data ofC17 circuit switch-level ......................... 47 Table 20: Architecture of ArraYinjD drain location array applied to NAND3 ....................... 56 Table 21: Example of gate-level resolution function applied to NAND2 gate: Gate) of C 17 circuit covering the effect of the flipping bit of the output of the logic gate on the circuit for a set of 12 test vectors ................................................................ 61 Table 22: Data structure of collected data gate-level based on the resolution function applied to C17 circuit ........................................................................................... 63 Table 23: Structure of the collected data of NOT gate applied to SimV)* simulator ............ 65 Table 24: Example of how the algorithm applied to SimV2 simulator builds the solution maps map_ det and map_ detA TV for C 17 circuit .................................................... 73 Table 25: map_det and map_detATV maps for C17 circuit ............................................ 74 Table 26: Detailed logic gate information ofISCAS'85 benchmark circuits ....................... 76 Table 27: Information on ISCAS'85 benchmark circuits ............................................. 77 Table 28: Simulation results for injection at gate ofa switch for C5315 circuit ................... 80 Table 29: Simulation results ofFcov for transient injection at gate of a switch for ISCAS'85 benchmark circuits ................................................................................. 81 Table 30: Simulation results for transient injection at drain of a switch for C5315 circuit ....... 82 Table 31: Simulation results ofFcov for transient injection at drain of a switch for ISCAS'85 benchmark circuits ................................................................................. 83 Table 32: Simulation results for transient injection at inputs of a logic for C5315 circuit ........ 84 Table 33: Simulation results ofFcov for transient injection at inputs of a logic gate for ISCAS'85 benchmark circuits ................................................................................. 84

x

Table 34: Timing results extracted from SimV I simulator based on transient injection at drain of a switch...... . . . . .. .. . . . . . . . . . .. . . . . . . . . . . . . . . . . . . .. . . . . . . . . . . . . . . . . . . . .. . . . . . . . ...... . . . . .... . .. 89 Table 35: Timing results extracted from SimV2 simulator ............................................ 91 Table 36: Performance and speedup ofSimV2 versus SimV 1 based on all applied test vectors and based on transient injection at drain of a switch ................................................ 94 Table 37: Performance and speedup ofSimV2 versus SimV 1 based on one test vector and based on transient injection at drain of a switch ....................................................... 95

xi

LIST OF FIGURES

Figure 1: Strength levels versus Voltage levels adapted from [16] .................................... 8 Figure 2: Flow Diagram of funC Function .............................................................. 10 Figure 3: Flow Diagram offunN Function .............................................................. 11 Figure 4: Flow Diagram offunP Function ............................................................... 12 Figure 5: Example ofNAND2 gate in switch-level ................................................... 13 Figure 6: Example ofNAND2 gate in switch-level where the transient "11111" is injected at the drain of PI: PMOS ................................................................................. 14 Figure 7: Flow diagram of the simulation environment ............................................... 17 Figure 8: The simulator data input for C17 Circuit .................................................... 18 Figure 9: Flow diagram of the Simulator ................................................................ 20 Figure 10: C 17 Circuit before and after net reorganisation ............................................ 24 Figure lO(a): C17 Circuit - Before net reorganisation .................................................. 24 Figure 1O(b): C17 Circuit - After net reorganisation ................................................... 24 Figure 11: How the function code "4" processes the data ............................................. 29 Figure 12: Switch-Level of BUFFER and NOT ........................................................ 31 Figure 13: Switch-Level ofNAND2 and AND2 ........................................................ 35 Figure 14: Switch-Level ofNAND3 and AND3 ....................................................... 38 Figure 15: Switch-Level ofNOR2 and OR2 ............................................................ 39 Figure 16: Switch-Level ofNOR3 and OR3 ............................................................ 43 Figure 17: Flow diagram of SimV I simulator ........................................................ '" 51 Figure 18: Flow diagram of the transient injection and detection Module 1 ....................... 55
xii

Figure 19: Structure of the 3D array of gate-level resolution function applied to C17 circuit ... 62 Figure 20: Data structure of some logic gates extracted from SimV \ * simulator .................. 66 Figure 21: Fcov for gate, drain ofa switch and inputs ofa logic gate for ISCAS'85 benchmarks circuits ............................................................................................... 85 Figure 22: Plot of Fcov based on transient injection at drain of a switch versus applied test vectors for C499, C2670, C3515 and C7552 benchmarks circuits ................................... 86 Figure 23: Matlab Profile Display showing the execution time ofSimV\ functions .............. 88 Figure 24: Matlab Profile Display showing the execution time ofSimV2 functions .............. 88 Figure 25: SimV\ Simulation time for ISCAS'85 benchmark circuits based on transient injection at drain of a switch .................................................................................. 90 Figure 26: SimV2 Simulation execution time for ISCAS'85 benchmark circuits ................... 92

xiii

NOMENCLATURE

SET SEE CUT SimVt SimVl

Single-Event Transient Single-Event Effects Circuit Under Test Non-algorithm based soft error detection simulator Algorithm based soft error detection simulator (Optimized Simulator)

funC funN funP SignallL

The function resolving the connection node The function representing the NMOS switch The function representing the PMOS switch Logic code of incident signal 1 (Same topology for Signal 2) Strength code of incident signal 1 (Same topology for Signal 2) State code of output of funC Strength code offunC output Logic code of funC output Logic code of the signal at drain Strength code of the signal at drain Logic code of the signal at gate Strength code of the signal at gate of a switch Logic code of the signal at source of a switch Strength code of the signal at source of a switch

Sign ails
OutC OutCs OutC L DraiuL Drains GateL Gates SourceL Sources

xiv

I

Orgm SimV.* Profm * Profm map_det map_detATV

Reorganizing, coding and parsing program of data inputs SimVI simulator applied to all the logic gate types independently Profiling maps generated by SimV I or SimV2 The 3D profiling maps generated by SimV 1* The 2D Profiling map of fault detection The 2D Profiling map of the record of test vectors achieving transient detection

I

T Loc

Transient location Transient logic code

I
TL Ts
netlist~ Data_in~

I
Transient strength code Array based netlist gate-level

I
Array of the addresses of the primary inputs Array of the addresses of the primary outputs Storage array of the values of the connection links of CUT Status of the content of the corresponding address (i.e. 0 or 1) Array based netlist switch-level Capacitance value at the node Updated capacitance value at the node
-"

Data_out_g
Data_inout~

Statv netlist_s Capv Caps Add incl

-l

Incrementation start address of a logic gate of CUT (i.e. used to determine the address ofVDD and GND).

Addinc2

The remainder address incrementation of a logic gate of CUT without VDn and GND address

Outg

Output of a gate -

xv

Inca

The first incrementation address of the links of the switch-level data structure

Add cg

The last address of the last link corresponding to the previous logic gate

Data_inout_s

Storage array of the values of the connection links of CUT switchlevel

Cape Ls LL var f

The capacitance value exists for 1 and does not exist for 0 value Strength code of a link Logic code of a link Variable of injected transient types The maximum number of injected transient types Variable oflocations of transient injection The maximum number locations of transient injection Variable of index of the used test vector The maximum number of applied test vectors Initializes var_fto 1. Initializes var_l to 1. Initializes var_v to 1. Initialzes initr, initt and inity

-

nF

!
I

var I nL var v nV Inite Initl Initv initaJl det(var f,var I)

IdetATV(var_f,var_l)
,
Comp init ns

I

-

-

Coefficients of map_det Coefficients of map_detATV The results of comparing faulty and non-faulty CUT Initializes var_ ns, block Bland B2 of Module 1 of SimV I

xvi

ArraYinjD var os

The 2D array of transient injection locations of drain location array Variable representing the row indexes of netlist_s The maximum number of rows in netlist s Array of gate-level resolution function used in Sim V2 Decimal representation of logic combination + 1 Logic value at the output of the logic gate Flipped bit of logic value at the output of the logic gate Status of the primary output due to OutGF Multiplication of !nG by Statpo Number of logic gates in CUT Number of progressive logic gates in CUT The index of applied test vector similar to var_v

,
I

oS

Logicc
lOG OutG OutGF Statpo MultislnG Og
Npg

TVn map_det*

I

The 3D Profiling map of fault detection for a switch-level logic gates

map_detATV*

The 3D Profiling map of the record of the output of a switch-level logic gate

nT.d

Total number of injected transients based on test vectors elimination
~

nT.aU
Fcov

Total number of injected transients without test vectors elimination The fault coverage or soft error coverage
I

OLd

The number of transient injection locations corresponding to detection

I

T(Parameter)

Execution time of the parameter number

xvii

T cycle

Execution time to run the simulator for one transient injection and at one transient injection location and for one test vector

T(RFGate-level) T(PAlgorithm)

The simulation execution time of the resolution function gate-level The simulation execution time to apply the algorithm

xviii

Chapter 1 Introduction

1.1.

Background

As the dimension of transistors are reduced to nanometre scale, modem integrated circuits have the advantage of operating at low power and can achieve high speed characteristics, thus they are becoming more sensitive to external radiation [1]. This work focuses on soft errors in combinational circuits caused by single-event transients (SETs) which belong to Single-Event Effects (SEEs) category. When a vulnerable node within a combinational logic is hit by a cosmic particle, the produced disturbance might propagate to the primary output of the circuit [2]. This can create a soft error if the faulty output data are latched. The developed simulator in this work assumes that the faulty output data are always latched. Furthermore, this work does not apply to sequential circuits; it is mainly developed for combinational circuits. Moreover, due to the reduction of technology scaling, the internal electrical
~asking

and latching-window masking

are diminishing as modem digital circuits operate at a higher clock frequency compared to their predecessor. Due to the susceptibility of modem digital circuits to SETs, the research trend has shifted toward SETs in combinational logic.

1

The developed simulator for soft error detection in this work, operates by injecting a fault at certain location of the circuit under test (CUT), applies a set of test vector at the primary inputs of CUT and by comparing the faulty and non-faulty primary outputs of CUT, the simulator can determine whether there is a fault detection or not. There are different levels of abstraction that can be used for soft error detection including gate-level, electrical-level and switch-level. Gatelevel soft error detection models are bit-flip based [3] [4] and the inputs of a logic gate are used as transient injection location [4] [5]. These models can't mimic the complex analog behavior of the transient propagation as the internal nodes of CUT can't be accessed [6]. As a result the simulators based on these models can be very fast and less reliable in terms of accuracy. The simulators for soft error detection based on electrical-level are reliable in terms of accuracy and very time consuming in terms of simulation speed but not feasible for complex digital circuits. There are examples of electrical-level simulators of soft error detection in the literature such as [7]. Switch-level soft error simulation based models can be a tradeoff between gate-level abstraction and electrical-level abstraction. Switch-level can model important characteristics in MOS circuits such as charge sharing and variation in driven strengths [8] [9]. The switch-level models used in this work are based on Verilog strength and logic levels and are provided by Verilog Hardware Descriptor Language Reference Manual [10]. These models can imitate important phenomena of electrical-level such as variations in driven strengths due to different voltage levels induced by SETs and the effect of the storage strength of the node capacitance. These switch-level models were previously used in different work such as in [11] where static faults are injected at gate of a switch.

2

1.2.

Motivation

Due to progress in technology, modem circuits are becoming more sensitive to soft errors. The use of simulation based soft error detection is important as it allows detection of design weakness at early stage of the design. The use of switch-level models for soft error detection simulation is an alternative to electrical-level and gate-level models. Simulation soft error detection based on switch-level models can overcome the speed limitation and feasibility of complex digital circuits of electrical-level models and the accuracy limitation of gate-level models. Several soft error simulators using various techniques are available in the literature such as [12] [13]. The developed simulator in this work uses Verilog strength and logic levels models to simulate transient injection in combinational circuits. The developed simulator is array based and is programmed in Matlab scripting language. Furthermore, an algorithm is developed to significantly speed up the simulation process when compared to the non-algorithm based simulator based on the same switch-level models.

1.3.

Summary of Contribution

The objective of this project is to present a soft error switch-level based simulator. This simulator has the ability to inject SETs of different strengths at different locations of a combinational circuit. The contribution to the project is summarized as following: и Coding the main switch-level functions that allow modeling of CUT. These functions use models based on Verilog strength and logic levels [10] allowing the injection of transients of different logic levels and strength levels. These transients are classified in 23 types. и и Parsing the netlist gate-level of CUT expressed in Verilog into data structure gate-level. Parsing the data structure gate-level of CUT into switch-level data structure. 3

и

The developed simulator can inject the transients at different location types such as drain, gate or inputs of a logic gate. The soft error coverage (or fault coverage) can be determined for any of these location types. This feature of the simulator shows the effect of the transient injection location type on the soft error coverage.

и

The results of the simulation are stored in arrays called the profiling maps. These maps allow the determination of the status of the transient injection location versus the injected transient type and the test vector used to detect the corresponding transient.

и

The created profiling maps are used to build statistical results based on the used test vectors. The progress of the fault coverage due to injected transients can be plotted against the order of the applied test vectors allowing the evaluation of the efficiency of the applied test vectors.

и

Development of an algorithm allowing the design of new soft error detection simulator SimV2. This simulator achieved a significant speed-up compared to SimV j non-algorithm based developed in this work as well

и

Timing equations are determined based on run time of the developed simulators SimV I and SimVl

и

Analytical study is conducted based on the experimental results of fault coverage and simulation run time.

1.4.

Project Organization

The remainder of the chapters is organized as follows: Chapter 2 discusses the main switchlevel models implemented in this work. Chapter 3 explains the coding of CUT in gate-level and switch-level data structures and provides a large view of the simulation environment. Chapter 4 describes the architecture of the non-algorithm based simulator SimVI. Chapter 5 explains how

4

the developed algorithm is applied to SimV2 simulator and describes its architecture. Chapter 6 presents the results of the experiments extracted from SimV I and SimV2 simulators. Chapter 7 presents the conclusion of this work followed by a cited publication and references.

5

Chapter 2 Main Functions of the Simulator

2.1. Verilog Strength and Logic Levels
The switch-level soft error models in this work use the Verilog strength and logic levels [10]. Table 1 [14] shows how the logic levels and strength levels are structured and coded. There are 3 logic levels 0, 1, U, called respectively logic 0, logic 1, and unknown. These logic levels are associated with 7 levels of strength varying from small to supply. The 2-bit logic code represents the logic level and the 3-bit strength code represents the strength level. The state code combines the logic level and strength level codes and they are coded in 5-bit. This represents the state of the signals of the switch-level models. Logic levels Z and X have special significance. The logic code xx means that the logic of the signal has no significance as the strength level is below small strength level, thus the state codes associated to Z and X are respectively 00000 and 10000 representing "High Impedance" and the OFF state of CMOS switch. In addition, table 1 shows the decimal representation of the logic and strength codes. This representation is used for the simulation program.

6

Table 1: Veri log coding representation of logic and strength levels and their decimal representation
Decimal Representation Logic Strength Code Code

Logic Level

Verilog Strength Level Supply Strong Pull Large Weak Medium Small Supply Strong
I

Logic Code

Strength Code

State code

0 0 0 0 0 0 0 1
1

00 00 00 00 00 00 00 01 01 01 01 01 01 01
11
11

111 110 101 100
011

00111 00110 00101 00100 00011 00010 00001 01111 01110 01101 01100 01011 01010 01001
11111

0
0

7

6
5

0 0 0

4

3
2
1

010 001

0
0

III
110 101 100
011

1
1
1 I

7

6
5

1 1 1 1
1

Pull Large Weak Medium Small Supply Strong Pull Large Weak Medium Small HighZ Don't care

4

1
1 1

3
2 1 7

010 001

U U U U U U U
Z X

III
110 101 100 011 010 001 000 000

3 3
3 3 3 3 3 0

11110 11101 11100 11011

6
5

11 11
11

4

3
2 1

11
11 xx xx

llOlO
11001 00000 10000

0

2

0

Voltage levels and strength levels of signals are related as shown in figure 1. There is a direct relationship between voltage levels and strength levels for 1.8 V supply voltage [16]. Switchlevel strength-based models using Verilog logic and strength levels were previously used in 7

different works such as [11] where static faults are injected at gate of a switch. Similar switchlevel models are used to study the delay introduced by resistive faults [14]. These switch-level models were used for soft error detection for the first time in the cited publication [15].

Large 1

Log-it 1
Weakl
Medium 1
u

Small 1

;,;. 5
VI -0

"0

:::

eli

S

Vi
oS!

:Ai
~

High-Z 1 lUgh-Z 0

~
~

OS

= z
cc

<5
;...-

c:::

.~ til

Voltage threshold

Medium 0

Logic 0

Strong 0

Supply 0

Figure 1: Strength levels versus Voltage levels adapted from [16].

8

2.2. Switch-Level Functions
The signals processed by the switch-level models are based on 5-bit coding representing the state code which combines the logic and strength levels as shown in Table 1. In the absence of transients, the strength code of all signals are assumed to be at Supply strength level "Ill" .The switch-level models in this work are based on Verilog signal resolution rules described as follows: и When a switch is OFF, the signal at drain of a switch takes the state code "10000" and hence this signal does not participate in resolving the output at the connection node. и When a switch is ON, the signal at drain of a switch will take the state code of the signal at the source of this switch. и When the signal at gate of a switch has a logic code unknown (i.e. U) or state code of high impedance, then the state code of the signal at drain of this switch will be "11111" which is the unknown logic code and supply strength code.

2.2.1. funC Function
The flow diagram shown in Figure 2 describes the functionality of the connection node. This function resolves the output of the connection node for two incident signals presented at this node, Signall and Signal2. Signalh and Signal2L represent respectively the logic code of the incident signals 1 and 2 at the node. Signall s and Signal2s represent respectively the strength code of the incident signals 1 and 2 at the node. OutC represents the output of fune. OuteL and OutCs represent respectively the logic and strength codes of fune output.

9

Yes

I OutC

= "10000"

I

OutC = Signal2

OutC = Signall

No

Figure 2: Flow Diagram of funC Function OutCL! Logic code of funC output; OutCs ! Strength code of funC output; Signalh, Signal2 L : Logic code of the incident signals 1 and 2 at the node Signalls , Signal2s : strength code of the incident signals 1 and 2 at the node

2.2.2. funN Function
This function is modeled based on Verilog rules described earlier. The flow diagram shown in Figure 3 describes the functionality of funN which represents the NMOS switch. DrainL and

10

Drains represent respectively, the logic and strength code of the signal at drain. GateL and Gates represent respectively the logic and strength code of the signal at gate. SourceL and Sources represent respectively the logic and strength code of the signal at source

DrainL = "10" Drains = ''000''

DrainL = SourceL Drains = Sources

DniinL = "11" Drains = Sources

Figure 3: Flow Diagram offunN Function GateL, DrainL, SourceL: Logic code of signals at gate, drain and source respectively Gates, Drains, Sources: Strength code of signals at gate, drain and source respectively

2.2.3. funP Function
Similarly, funP function is modeled based on Veri log rules described earlier. The flow diagram shown in Figure 4 describes the functionality of funP which represents the PMOS switch.

11

DrainL == "10'" Drains = "000"

DrainL = SourceL Drains = Sources

DrainL ="11" Drains == Sources

Figure 4: Flow Diagram offunp Function GateL, DrainL, SourceL: Logic code of signals at gate, drain and source respectively. Gates, Drains,. Sources: Strength code of signals at gate, drain and source respectively.

2.2.4. Capacitance Functionality
Due to technology scaling and the shrinking size of transistors, the charge of capacitance values are weak [10]. The modeled capacitance in this work takes the strength code "001" (i.e. strength level "small"). The logic value of a capacitance takes the logic value of the output of the resolved connection node.

12

2.2.5.

Example of Transient Injection at Drain of a

Switch Applied to NAND2 gate
Figure 5 shows NAND2 gate translated in switch-level. The main functions used to resolve the output Y of NAND2 gate are funP, funN and funC. The capacitance values C 1 and C2 are updated after applying funC at the node.

"01111"

A ="01111"

I>-------____r - - -"10000"

"01111" == B

funC: "10000"-

~~=':=::::~~-r-=='=~~
:fun~

funC: "00111"

funC: "00111" Y=="00111"

L - - . - - - - l Nt

t
_ funC: "00111" "00111" _

...------1

N2: funN

1"

tC ="OOOOI"
j

"00111"

Figure 5: Example ofNAND2 gate in switch-level

Figure 6 shows the same example ofNAND2 gate when a transient "11111" is injected at the drain of PI : PMOS switch. This transient injection results in soft error as the resolved output Y of the NAND2 gate changes to "11111". This example shows how the capacitance values are updated. According to the capacitance functionality, the capacitance strength code is "001" and its logic takes the logic of the resolved connection node. The "Before" transient injection and

13

"After" transient injection values of C 1 and C2 show an example of how these capacitances update their values.

"01111"

A

= "OllII" - - . - - - - - H I
Injected transi~ "11111" V'V'"F
L=~----1r-~=-.I

"01111"=B

funC : "11111"-

~

funC: "11111"

funC: "11111"
~

~
)

~

Y="lllll"

~-------------~ Nl:funN

T

t C2 = "00001": Before C2 = "11001": After

t
_ funC: "00111" "00111"

-t
"00111"

.--------1 N2:funN

T

t C2

"00001": Before C2="00001":After

Figure 6: Example ofNAND2 gate in switch-level where the transient "11111" is injected at the drain of PI: PMOS

14

Chapter 3 Fundanlental Architecture and Data Structure of the Simulator

This chapter explains in details the architecture and the data structure of the simulation environment. The simulator is array based and a coding structure is used to code CUT in gate and switch-level. Examples are provided along this chapter to clarify the idea of how the data structures are coded.

3.1. Programming Language
All the programs developed in this work are coded in Matlab using m-file format. A large amount of data is processed through the simulation and the use of an optimized programming language is important. Matlab scripting language is a combination of different languages offering simple, efficient and optimized functions targeting array based applications and offers different tools such as the Profile option.. This tool allows the user to optimize the code as it offers a detailed execution time report for the full program line by line. This option along other tools, help improve the speed of the developed program.
15

3.2. Simulation Environment
The flow diagram in Figure 7 presents a large view of the simulation environment. There are three stages for the simulation and can be classified as follows: и Data Input: Contains the files representing CUT, the test vectors and the injected transient types. The test vectors in this work are based on compaction algorithm [18] and are design for gate-level circuits. These test vectors are used for the first time on the switch-level models used in this work for the purpose of soft error simulation. There are different formats and are loaded into the simulator (i.e. Block Program). A detailed explanation ofthe content of these files is provided in section 3.2.1.

и

Program: Represents the processing part of the simulation environment and is coded
entirely in Matlab scripting language. Different sections are dedicated for this block.

и

Statistical Results: Represents the different results extracted from the simulation. These detailed results are used to conduct statistical study on the performance of the simulator, test vectors and the effect of transient injection location type on the fault coverage. Chapter 6 is based on these results.

16

Data Input r--N-et-lis-t-G-at-e--L-e~Ve~I-[-*-.v--]~1
Injected Transients

q
S d
$....e

I

Orgm

[

*. mat ]

-C1
Simulator
SimV,1 SimV2

I

r *. txt Test Vectors r *. vee 1

1

-C1
Data Output
TilIUng,Profm [ *.mat ]

Of. 0
~
$....e

-C1

! Processing Module I
Figure 7: Flow diagram of the simulation environment

q

Statistical Results [ *. txt )
'----------I

3.2.1. Data Input
The different file formats shown in figure 8 target the C17 benchmark circuit. Any other combinational circuit can be loaded into the simulator similarly as long as its format is expressed in the same manner as the C17 sample. These files are as follows: и C17_TV. vec: Represents the test pattern for the C 17 circuit. Number 5 indicates the number of inputs of the circuit. The notation END indicates the end of the test vectors. This data is accessed line by line where the most significant bit is devoted to the first input of the circuit. Every bit of the data input is expressed in decimal and represent the logic level. The strength level is assumed to be "111" which is 7 in decimal. The inputs of CUT are then formatted in a logic and strength level format. и C17_netlistJ.v: Represents the netlist gate-level of C17 circuit expressed in Verilog format. Any circuit can be loaded into the simulator in the same format.

17

и

Transients.txt: Represents the decimal format of the transient types injected into CUT. The
logic and strength levels are represented respectively by the column on the left and right.

5 01111 00001 01101 10001 01110 10111 00101 10011 01101 10000 00011 01000

module c17 (N1,N2,N3,N6,N7,N22,N23) ; input N1,N2,N3,N6,N7; output N22,N23;

wire N10,Nl1,NI6,N19;
nand nand nand nand nand nand NAND2_1 NAND2_2 NAND2_3 NAND2_4 NAND2_5 NAND2_6 (NlO, (Nll, (N16, (N19, (N22, (N23, N1, N3); N3, N6) ; N2, NIl) ; Nll, N7) ; NlO, N16); N16, N19);

END

C17 TV.vec

endmodule C 17_ netlist_g. v

1 0 0 0 0 0 0 0 1 1 1 1 1 1 1 3 3

7 0 1 2

3
4 5

6
0 1 2 3 4 5

6
0 1 2 3 4 5 6 7

3
3

3 3
3

3

Transients.txt Figure 8: The simulator data input for C17 Circuit

3.2.2. Simulator Flo,v Diagram
The flow diagram in figure 9 shows a highlight of the simulation architecture. There are two developed simulators in this work; SimVl and SimV2. Chapter 4 and 5 provide respectively,

18

detailed explanation on SimV. and SimV2 и The various blocks of this flow diagram are as follows:
и и Data Input: Explained in section 3.2.1. Orgm: Reorganizes, parses and codes the data input. Sections 3.3, 3.4, 3.5 and 3.6 provide

detailed explanations of how these data structures are coded.

и и

Casel: Represents SimV\ non algorithm based version of the simulator. Case2: Represents SimV2 algorithm based version of the simulator. The block titled "Data
Storage RUN: ONCE" processes all the logic gate types (Le. AND2, NAND2, etc) independently by running SimVI * simulator on these gates. Exhaustive test vectors are applied for the simulation and the results are stored in 3D profiling maps (i.e. Profm*) in a *.mat format file. Detailed explanation of Profm *, SimV2 and SimV \* is provided in chapter 5. The block "Data Storage RUN: ONCE" will run only one time and generates a *.mat file that is used for any circuit simulated by SimV2, thus its run time is not part of the simulation time.

и

Data Output: Provides the results of the simulation in profiling maps arrays Profm and the

simulation execution time (i.e. Timing). Section 3.2.3 is dedicated to the structure of the profiling maps Profmи

19

Data Input

ISimV I~ ~ ....... t}........ l и I ~ .......~ .ии.и...и.и... ; I
l

: ... ~ Case 1 и

~

I.... ':и;

иииииииииииииииииииии

Orgm

Data Reorganization and Parsing

Data Storage
RUN: ONCE

SimVl*

и

Data Output

Lи .... и~ ......I ease 2 Iи""и"""""и"

и и : и и

SimV2

Profm*

I
3.2.3. Data Output

Data Output

I

Figure 9: Flow diagram of the Simulator

The data output of the simulators are stored in 2D arrays and are called profiling maps "Profm " due to the way these arrays store the results of the simulation. The C 17 circuit profiling maps are used as example of the data output. Table 2 shows the profiling map map_ det representing the fault detection due to transient injection at a drain of a switch. This table is organized as follows:

и

TLoc: Represents the location of drain or gate as transient injection location for C17 circuit.
There are 24 drains or gates in C 17 circuit where the transient can be injected.

и

T L! Represents the transient logic code expressed in decimal

20

и

T s: Represents the transient strength code expressed in decimal The values in table 2 are either 1 or 0 representing respectively, detection or non-detection of

the transient injection. For example: [Transient location: "TLoc = 5", Transient value: "TL:Ts" = "1:7", Results = ( 1 )] Explanation: The corresponding injected transient is detected at location (5). Table 2: map_ det of C 17 circuit

1 0 0 0 0 0 0 0 1 1 1 1 1 1 1 3 3 3 3 3 3 3 3

7 0 1
2

3 4 5 6 0 1
2

1 0 1 1 1 1
1

3 4 5 6 0 1
2

3 4 5 6 7

1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

1 1 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1 0 1 0 1 0 1 0 1 0 1 1 0

1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1

1 1 1

1

1

0 1 1 1 1 1 1 0
(I

0 0 0 0 0 0 1
1

1 1 -.1 1 1

1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 1 1 0 1 1 0 1 1 0 1 1 0 1 1 0 1 1 1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

ииииииииии

0 1 1 1

1 1 1
1

1
1 1 0 0 0 0 0 0 0 0
1 1

1 1 1 1
1

1 0 0 0 0 0 1
1

1 0 0 0 0 0 0 0 0 1 1 1
1

1

0 0 0 0 0 0 0 0 1 1 1
1

ииииииииии

1 1 1
1

1 1
1 1

1

1 1

1 1 0 1 1 1 1 1 1

1
1 0 1
1

1 1 1 1
1

1

21

Table 3 shows map_ detATV profiling map. This array is organized similarly to map_ det array. The results in this table represent the index of the test vector used to detect the injected transient in case of detection. For example: и [Transient location: "TLoc
th

= 5", Transient value: "TL:Ts" = "0:1", Results

= (

8 ) ]

Explanation: The 8 test vector detects the injected transient "0: 1" at location (5). и [Transient location: "TLoc
=

1", Transient value: "TL:Ts"

"0:0", Results

= (

12 ) ]

Explanation: All the 12 test vectors are used and the injected transient "0:0" at location (1) is not detected. map_ det shows (0) as results indicating a non detection of transient injection at this location. The sum of all the values of map_ detATV represents the number of times the circuit is simulated in other terms; this is called the total number of transients. The sum of all the values of map_ det represents the number of detected faults. The number of coefficient of map_ det array is called the number of injected faults. The soft error coverage is evaluated based on (EQ - 3 - 1 ) equation:

OL) _ Soft Error Coverage ( 70 -

Number of detected faults и Numberofinjectedfaults

100

(EQ - 3 - 1)

22

Table 3: map_detATV ofe17 circuit

1
0 0 0 0 0 0 0

7

0 1

2
3 4 5 6 0 1

1 1
1 1

2
3 4 5 6 0 1

1
1

1 3 3 3 3 3 3 3 3

2
3 4 5 6
7

1 12 1 1 1 1 1 1 12 12 12 12 12 12 12 12 1 1 1 1 1 1 1

1
4 4 4 4 4 4 4 4 4

4

12 12 12 12 12 12 12 12
6 6 6 6 6 6

12 12 12 12 12
4 4 4 4 4 4 4

12
6 6 6 6 6 6 4

1 2 12 12 12 8 12 8 12 8 12 8 12 8 12 8 12 12 6 12 6 12 6 12 6 12 6 12 6 12 12 12
6 6 6 6 6 6

2
3 3 3 3 3 3 3 3 3

12 12 12 12 12
3 3 3 3 3 3 3

8 8 8 8 8 8

1 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 1 1 1 1 1 1 1 I 1 1 1 1 12 12 1 1 1 1
1

1 1

1

1

1

1

1

1 1 1

1 1 1 1

2 12 12 12 ииииииииии 12 12 12 12 . 12 12 12 12 12 12 12 12 12 12 12 ииииииииии 12 12 12
1

2 2 2 2 2 2 2 2 2 2 12 12 12 12 12 2 2 2 2 2 2 2
1

1 1 12 121 12 12 12 12 12 12 12 12 12 12 12 12 12 12 1 1 1 1 1 1 1 1 1 1 1 1 12 12 1 1 1 1 1 1 1 1 1 1 1 1 1 1

3.2.4. Processing Module
This block processes the profiling maps; map_ det and map_detATV in order to calculate the soft error coverage and other statistical results. This module provides the Statistical Results mentioned in figure 7. All the results in chapter 6 are provided by this module.

23

3.3. Data Structure of Netlist Gate-Level (netlist_g)
This section explains the data structure and the coding architecture of gate-level netlist of CUT. The schematic ofCl7 circuit shown in figure IO(a) translates the Verilog netlist gate-level (i.e. input file of the simulator). Every logic gate is coded accordingly to table 4. Based on these codes, the first column of table 5(a) is code (11) representing a NAND2 gate and the second column represents the address of the output. Section 3.4 explains in detail how these addresses are used. Columns ini to inlO, are the addresses of the inputs of the logic gates. An address "0", indicates that the corresponding input does not exist. This structure is the main idea behind the simulation. Any combinational circuit can be parsed into this structure. There are 10 possible inputs indicating that this simulator can handle circuits built with up to 10 logic gates. Table 4 shows the different gate types and their corresponding codes.

N7

N6_~ 14~~23

~

N19

rV-'Nll Nl-tu:P N10

I

I

N1

L

r-t?r--

-f:\... N22

N2

&-!N16

Figure lO(a): Cl7 Circuit Before net reorganisation

Figure lO(b): C17 Circuit After net reorganisation

Figure lO: Cl7 Circuit before and after net reorganisation

Based on the information of Table 5(a), the maximum number of addresses in this 2D array is 23. The block Orgm mentioned in section 3.2.2. reorganizes these addresses in a way that their numbers will be minimized when there are gaps between these numbers. Figure 1O(b) and Table 5(b) show the results of the addresses reorganization. The maximum number of addresses after

24

reorganization is 11. This operation is useful as it reduces the size of the storage array and resulting in maximizing the speed of the simulation. The storage array Data_inout_g as shown in table 6, its size depends on the number of nets in the circuit and as the index of the number of the nets is reduced, the size of the storage array is reduced. Section 3.4. explains in detail the structure of this storage array. Table 4: Coding of the gate types

NANDI0 NAND9 NAND 8 NAND7 NAND6 NAND5 NAND4 NAND3 NAND2 NORI0 NOR9 NOR8 NOR7 NOR6 NOR5 NOR4 NOR3 NOR2

3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20

ANDIO AND9 AND8 AND7 AND6 AND5 AND4 AND3 AND2 ORlO OR9 OR8 OR7 OR6 ORS OR4 OR3 OR2 XOR2

21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39

:

25

Table 5: Data structure of C17 netlist gate-level (netlist~) before and after net reorganisation

Table 5(a): Data structure of C17 netlis gate-level before net reorganisation Gate Type 11 11 11 11 11 11 Output lO 11 16 19 22 23 inl 1 3 2 11 lO 16 in2 3 6 11 7 16 19 in3 0 0 0 0 0 0 in4 0 0 0 0 0 0 in5 0 0 0 0 0 0 in6 0 0 0 0 0 0 in7 0 0 0 0 0 0 in8 0 0 0 0 0 0 in9 0 0 0 0 0 0 inlO 0 0 0 0 0 0

Table 5(b): Data structure ofC!7 netlist gate-level after net reorganisation Gate TYQe 11 11 11 11 11 11 Output 6 7 8 9 lO 11 inl I 3 2 7 6 8 in2 3 4 7 5 8 9 in3 0 0 0 0 0 0 in4 0 0 0 0 0 0 in5 0 0 0 0 0 0 in6 0 0 0 0 0 0 in7 0 0 0 0 0 0 in8 0 0 0 0 0 0 in9 0 0 0 0 0 0 inl0 0 0 0 0 0 0

3.4. Processing and Storing Arrays of Gate-Level
This section explains how a circuit is processed and its primary output is resolved. Table 6 shows the following: и и и DataJn~: Contains the addresses of the primary inputs of C 17 circuit Data_out_g: Contains the addresses of the primary output ofCl7 circuit
Data_inout~: Contains the resolved values of every net of the circuit. Address Index is the

address of input or output of any logic gate as shown in Table 5(b). LL and Ls represent

26

respectively the logic and strength codes of CUT connection links. Statv represents the status of the content of the corresponding address. "Statv

=

1" indicates that the value

corresponding to this address is not resolved and similarly, when "Statv = 0", this indicates that the value corresponding to this address is resolved. The values of the address index from 1 to 5 represents the addresses of the primary inputs as shown in Data_in~ and the LL and Ls corresponding to these values are the first applied test vectors "0111" as shown in figure 8 and consequently the corresponding Statv values are filled by zeros.

This is the main idea of how the data is stored when processing the gate-level data structure. When a CUT is entirely processed and the primary outputs of the circuit are resolved all the values of Statv become "0",

Table 6: The main storing and indexing arrays needed to process C17 circuit gate-level Data inout g Data in g 1 2 3
4

I
10 11

1
2

5

3 4 5
6

7 8

0 0 0 0 0 1 1 1
1

0 1 1 1 1 0 0 0 0 0 0

7 7 7 7 7 0 0 0

9
10 11

1
1

0 0 0

27

3.5. Data Structure of NetIist Switch-Level (netlist_s) 3.5.1 Coding Architecture of netlist_s

The main idea of the coding structure of netlist switch-level is similar to the coding structure of netlist gate-level. The switch-level of CUT is composed of funP, funN and funC representing respectively the switches P, N and the function of the connection node. These functions were previously explained in chapter 2. The capacitance is represented by Capv (i.e. Capacitance value) and Caps represents the updated capacitance value at the node. Table 7 uses these notations and is organized as follows: и и Function Code: Represents the codes of the functions in column two. Function: Represents the main functions of the switch level funN, funP, funC and (funC + Caps). Function (funC + Caps) performs two operations as follows: o 1st operation: Resolves the connection node by applying funC on the input (in) and the previous value of the capacitance Capv (i.e. Capacitance value). The resolved output is represented by OutC. o 2
nd

operation: Updates the capacitance value Capv by Caps (i.e. Capacitance store)

value. The functionality of Caps is based on the explanation provided on the capacitance in section 2.2.4. Figure 11 shows a flow diagram of (funC + Caps) function where OutC is resolved by funC and the Capv is updated by Caps и и Data 1: Represents the output of the function (i.e Drain for funP and funN) Data 2, 3: Represents the inputs of the functions (i.e. the inputs funP, funN and funC).

28

Table 7: Coding of the switch-level functions Function Code
1 2

I!

Function funP funN funC funC + Caps

I I Data 1 I Data 2 I I
Drain Drain OutC OutC Gate Gate
Inl In
I

Data3 Source Source

3

4

Capv

In

funC Capacitance

OutC

-

1

Capv

I

J
I

Caps

~r-

Figure 11: How the function code "4" processes the data

A structure based on this coding architecture is created for every single logic gate of table 4 (Le. Gates type). Orgm
~lock

shown previously will build a switch-level netlist based on these

structures for any combinational circuit. The following sections of this chapter focus on providing detailed information on the logic gates switch-level coding structure.

3.5.2. NOT Gate
Figure 12 shows the switch-level of NOT gate. Table 8 shows the coding and data structure of switch-level NOT gate. The main concept is to affect addresses to the links created for the switch-level (i.e. D(Drain), G(Gate), S(Source), OutC, Capv, VDD and GND). These links represent the basic elements of the switch-level structure. The equation (EQ - 3 - 2) evaluates the incrementation start address for a logic gate.

29

Add incl = [Number ofinput(s) of the logic gate + 1 ]

(EQ-3-2)

Addinc1 represents the incrementation start address. The NOT gate shown in table 8 represents the organization of the data structure and the results of the coding of these structures. The numbers of "Coded Data" represent the addresses for Datal, Data2 and Data3. The "Function" column is similar to the structure created for gateиlevel and it is used to identify the operators. (Le. funN, funP,

fune

and (funC + Caps╗. The "Coded Data" and "Data structure" are organized as

follows:

и

(in) and (Outg) represent respectively the input and output of NOT gate. The addresses (1)
and (2) are respectively allocated to these elements.

и

vnD and GND (i.e. Supply and ground) get respectively the addresses (3) and (4) as the incrementation of the addresses starts from Addincl

= 2. The remainder incrementation of the

addresses of the links of the switch-level of this logic gate will start from Addinc2 as shown in (EQ - 3 - 3). Addinc2 represents the starting incermentation address for the remainder elements of this logic gate. Addinc2 = Addincl + 2 = 4 и The remainder elements of this table are coded as follows: o D[1], D[2]: Represents respectively the drains of P and N switches numbered by order of priority access. The order is important because of the dependency of the switches to resolve the output of the logic gate. As the program processes the information in sequence, it is important to have these functions in certain order for coherent results when resolving the output of the logic gate. (EQ-3 -3)

30

o

OutC [1]: Represents the output of funC function and it resolves the incident signals D[!] and D[2].

o o

Capv: The capacitance value at the node. The Asterix sign followed by a number ( i.e. * number) has a particular meaning as it helps construct the addresses order. For example the notation ( *1 D[l] ) indicates that the corresponding elements are increasingly numbered at these locations. The repeating elements in the table will simply keep their numbers. Once these numbers are completed, they will be assigned to the coded data table ( i.e. [(* number) + Addinc2 ]
)

starting from top to bottom and left to right Based upon this data structure

table, the program will be able to build the "Coded Data" table.
BUFFER - Switch-level NOT - Switch-level

t--t--Outg

Figure 12: Switch-Level of BUFFER and NOT

31

Table 8: Coding and data structure of switch-level NOT gate
NOT - Switch-level

Index

1
2

3
4 1 2
I

Function funP funN funC funC + Caps 1 2 3 4

Data 1 *10[1] *2 D[2] *30utC[l]
Outg

Data 2 in in 1 D [1] 30utC[1] 1 1 5

Data3 VDD
(iND

20 [2] *4 Capv[1] 3 4 6

5 6

3 4

7 2

7

8

3.5.3. BUFFER Gate
Figure 12 shows the switch-level of BUFFER gate. Table 9 shows the coding and data structure of switch-level NOT gate. This gate is coded similarly to NOT gate.

32

Table 9: Coding and data structure of switch-level BUFFER gate
BUFFER - Switch-level

Index 1 2 3 4 5

Function funP

Data 1 *1 D[l] *2 D[2] *30utC[l] *40utC[2] *6 D[3] *7 D[4] *80utC[3] Outg 5

Data 2 in

Data3

YDD
(;:\0

funN
funC funC + Caps
funP

in
1 D [1] 30utC[l] 40utC[2] 40utC[2] 6 D [3] 80utC[3] 1 1 5 7

2D [2] *5 Capv[1]

"DB
G:\D

6
7

funN
funC funC + Caps 1 2 3 4 1 2

7 D [4] *9 Capv[2] 3 4

8
1 2 3 4 5 6 7 8

6
7

8 10

6 9
3 4

11
12 2

3
4

8 8 10
12

11
13

3.5.4. NAND2 - AND2
Table 10 shows the data structure of switch-level NAND2 - AND2 gates. Table 11 shows the coded data of switch-level of NAND2 - AND2 gates. Figure 13 shows the switch-level of NAND2 - AND2 gates. These gates are coded in the same manner as NOT except minor changes. The reason these two gates are coded 'on the same table is because the only difference between NAND2 and AND2 is a NOT gate. The notation on the table indicates that starting from index 7, the two gates NAND2 and AND2 have different structures.

33

Furthermore, the notation S [1] is added to the data structure and it is used as input and output depending on the used function. This notation is added for logic gates that have switches in series (i.e. A drain of a switch close to the ground will become the source of the next switch).

Table 10: Data structure of switch-level NAND2 and AND2 gates
( NAND2 - AND2] - Switch-level

Index

1
2 3

Function funP funP funC funN funC + Caps funN funC funC + Caps funP funN funC funC + Caps

Data 1 *1 D[lJ *2 D[2] *30utC[l] *4 D[3] *5 S[I] *7 D[4] *80utC[2] *90utC[3] *11 D[5] *12 D[6] *13 OutC[4]
Outg

Data 2

Data3
VDO VDO

in) in2
1 D [1]

2 D [2J
G'\l)

4

in2
4D [4]

5 6
7

*6 Capv[IJ 5 S[I] 7D[6] *10 Capv[2]

in)
30utC[l] 80utC[2] 90utC[3] 90utC[3] 11 D [5] 13 OutC[4] 8 OutC[2]

8 9 10
11

vnu
G'\D

12 D [6] *14 Capv[3] *9 Capv[2]

12 8

I I funC + Caps

I I NAND2 I

34

Table 11: Coded data of switch-level NAND2 and AND2 gates

,--_A_N_D_2_-_Sw_i_tc_h_-I_ev_e_l

_---'I , . . .__ N_AN_D_2_-_S_w_it_c_h-_Ie_v_el_----'
Function Code Data 1 Data 2 1 2 Data 2 4 4 7 5 1l 10 12 14

Function Code

Data 1

Data 2 1 2

Data 2 4 4 7

1 2 3 4 5

1 1

6
7 8 9 10 12 13 14

1 1

6
7 8

3
2 4 2 3 4 1 2

6
2 9 1 8 13 14 14

3
2 4 2

6
2

5
1l
10 12

9
10 12 13

9
1 8 13

6
7

3
4

8 9
10 1l 12

15
4

3

16
17 18

5
17 19

3
4

16
18

3

NAND2 - Switch-level

AND2 - Switch-level

inl-1
~

p-in2
Out g

inl-1

p-in2
Outll

inl-1 in2-1

inl--1
-.

~

in2-1

Figure 13: Switch-Level ofNAND2 and AND2

35

3.5.5. NAND3 - AND3
Table 12 shows the data structure of switch-level NAND3 - AND3 gates. Table 13 shows the coded data of switch-level of NAND3 - AND3 gates. Figure 14 shows the switch-level of NAND3 - AND3 gates. These gates are coded in the same manner as NAND2 - AND2.

Table 12: Data structure of switch-level NAND3 and AND3 gates [ NAND3 - AND3 ] - Switch-level
I

Index

I

Function
funP funP funP funC funC
funN

Data 1
*1 D[l] *2 D[2] *3 D[3] *40utC[l] *50utC[2] *6 D[4] *7 S[I] *9 D[5] * 10 S[2] *12 D[6] *13 OutC[3] *140utC[4] *16 D[7] *17 D[8] *180utC[S] Outg Outg

Data 2

Data3
\'l)!J

I

1 2
3 4 5 6 7 8
9
10

in. inz in3
1 D [1] 3 D[3]

\'DD \'IH)

2 D [2] 40utC[l]
Gl\l)

in)
6D [4]

funC+ Caps
I

*8 Capv[1] 7 S[I] * 11 Capv[2]
10 S[2]

funN

inz
9 D [5]

funC + Caps
funN

in.
50utC[2] 13 OutC[3] 140utC[4] 140utC[4] 16 D [7] 180utC[5] 13 OutC[3]

11
12 13 14 15 16 12

funC funC + Caps funP funN ftmC funC + Caps

12 D[6]

*15 Capv[3]

von
G\D
17 D [8] *19 Capv[4] *14 Capv[3]

II

funC + Caps

I I NAND3 I

36

Table 13: Coded data of switch-level NAND3 and AND3 gates

'---_A_N_D_3_-_S_w_it_ch_-_le_v_el_---.J1 1'---_N_A_N_D_3_-S_w_i_tc_h_-I_ev_e_1_--'

Function Code Data 1 Data
2

Function Data
2

Code

Data 1

Data
2

Data
2

1 2
3

1

I

4 5 6 7 8 9
10 11 12 13

1 1 3 3

7 8 9
10 11

1 2
3

7 9
3

2 4 2 4 2
3

12
13

4
1

14 15 16

2 3 4

15 16 18 19 20 22 23 24 4

12 2 15 1
11

5 5 5 8 10 6 14
13
I

1

1
1

7 8 9
10
11

1

2
3

3 3

7 9
3

5 5 5 8
10

19 20 20 22 24

17 16 18 21 5
6

2 4 2 4 2
3 4

12
13

15 16 18 19 4

12 2 15 1
11

6 14
13
,

19

17 16 18 20

23 25

37

NAND3 - Switchиlevel

AND3 - Switch-level

inl-9

inl-9
,..-.------.~

Out,
~t---'0ut"

~

Figure 14: Switch-Level of NAND 3 and AND3

3.5.6. NOR2 - OR2
Table 14 shows the data structure of switch-level NOR2 - OR2 gates. Table 15 shows the coded data of switch-level ofNOR2 - OR2 gates. Figure 15 shows the switch-level ofNOR2 OR2 gates. These gates are coded in the same manner as NAND2 - AND2.

38

Table 14: Data structure of switch-level NOR2 and OR2 gates

[ NOR2 - OR2] - Switch-level
Index 1 2 Function I
I

Data 1
*1 D[I] *2 D[2] *30utC[1] *4 D[3] *5 S[l] *7 D[4] *80utC[2] *90utC[3] *11 D[5] *12 D[6] *13 OutC[4]
Outg Outg

funN funN funC funP

Data 2 int in2
1 D [1]

Data3
G:\D G'\D

3
I

2 D [2]
\'DO

4
5
I

int
4D [4]

funC+ Caps funP funC

*6 Capv[1] 5 S[I] 7 D[6] *10 Capv[2]
\"DD C;'\O

6 7

in2
30utC[l] 80utC[2] 90utC[3] 90utC[3] 11 D [5] 13 OutC[4] 80utC[2]

8 9
10

I
i

11 12

funC + Caps funP funN funC funC + Caps

o
I

12 D [6] *14 Capv[3] *9 Capv[2]

~

8

II

funC + Caps

II

NOR2

NOR2 - Switch-leyel

OR2 - Switch-level
inl-4

inl--4 in2--4
~------Out2

in2-1

inl-1

inl-I
Figure 15: Switch-Level ofNOR2 and OR2

39

Table 15: Coded data of switch-level NOR2 and OR2 gates

ORl - Switch-level

NORl - Switch-level

Function Code Data 1 1 2 2 2 3 1 4
1
6 7

Data 2 1 2 6 1 9 2

Data 2 5 5 7 4
11

3
4 5

8 9 10
12 13 14 16 17 18 3

2 2 3 1 4 1

6 7 8 9 10 12 13 3

t

1 2 6 1 9 2

6
7 8
I

10 12 15 4 5 17 19

5 5 7 4 11 10
12 14

9
10 11 12

3 4 1 2 3 4

I

8 13 14 14 16 18

3 4

8 13

3.5.7. NOR3 - OR3
Table 16 shows data structure of switch-level NOR3 - OR3 gates. Table 17 shows the coded data of switch-level ofNOR3 - OR3 gates. Figure 16 shows the switch-level ofNOR3 - OR3 gates. These gates are coded in the same manner as NAND2 - AND2.

40

Table 16: Data structure of switch-level NOR3 and OR3 gates

[ NORJ - ORJ J - Switch-level
Index Function
funN funN funN funC funC
funP

Data 1
*1 D[I] *2 D[2] *3 D[3] *40utC[I] *5 OutC[2] *6 D[4] *7 SrI] *9 D[5] * 10 S[2] *12 D[6] *13 OutC[3] *140utC[4] *16 D[7] *17 D[8] *180utC[5] Outg Outg

1 2 3 4 5 6
7

Data 2 int in2 in)
I D [1] 3 D[3]

Data3
(;,\1}

G:\D
G:\W

2D [2] 4 OutC[l]

int
6 D [4]

yun
*8 Capv[1] 7 Sri] * 11 Capv[2]

funC + Caps
funP

8 9 10 11
12

in2
9 D [5]

funC + Caps
funP

in3
50utC[2] 13 OutC[3] 140utC[4] 14 OutC[4] 16 D [7] 180utC[5] 13 OutC[3]

10 S[2]
12 D[6] *15 Capv[3]
\DB

funC funC + Caps

13
14 15

funP
funN funC funC + Caps

G]\I)

o

17 D [8] *19 Capv[4] *14 Capv[3]

~

16
12

I I runC + Caps

II

NORJ

41

Table 17: Coded data of switch-level NOR3 and OR3 gates

~__~O~R3~~~S~w~it~c~h-~le~v~el~~1 ~I__~N~O~R3~_~S~w_i_tc_h~-I~ev_e_l__~
Function Code Function Code

Data
1

Data

2
1 2 3 7 9 1 12 2 15 3 11 19

Data 2 6 6 6 8 10 5 14 13 17 16 18 21

Data
1

Data

Data

I
2 2 2 3 3 1 4 1 4 1 3 4

2
1 2 3 7 9 1 12 2 15 3

2
6 6 6 8 10 5 14 13 17 16 18 20

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16

2 2 2 3 3 1 4 1 4 1 3 4 1

7 8 9 10 11 12 13 15 16 18 19 20

l
I
!

7 8 9 10

11
12 13 15 16 18 19 4

11
19

2 3 4

22 23 24 4

20 20 22 24

5
6

23 25

42

NORJ - Switch-level
inl--9

ORJ - Switch-level

inl--9

in2--9

in2--9

t - - - - - - . . . - O u t2

~
inl-1 inl-1

Figure 16: Switch-Level ofNOR3 and OR3

3.5.8 Data Structure Switch-Level of C17 Circuit
Table 18 shows how C17 circuit is coded in switch-level. This circuit has 6 NAND2 gates. The coding of switch-level is based on incrementing the addresses of the gate level structure. The coding of the gates is slightly different. The following shows how C 17 circuit is coded: и Gate Type: Represents the logic gate types of the circuit (i.e. Number 11 indicates that the corresponding coded logic gate is NAND2 gate starting from address index 1 to address index 8). The zeros indicate simply that the corresponding switch-level codes are for the last logic gate type number. The zeros are user default values to fill the Gate Type arrays. It is simply for programming purposes. и First NAND2 gate [Address Index = [1:8]]:

43

Addincl (C17)= [Total Number of Gates + Primary inputs] = 11 Addinc2 = A<LIinl + 2 = 13 Inca = Addinc2 + 1 = 14 [ 2: Added addresses for VDD and GND ]

(EQ-3 -4) (EQ-3 -5) (EQ-3-6)

Inca: The first incrementation address of the links of the switch-level data structure и Second NAND2 gate: Addcg Inca

= 22 [The maximum address of the previous logic gate]
Addinc2 + 1 23

Addcg: Represents the last address of the last link corresponding to the previous logic gate. и The coding of the remaining logic gates is similar to "Second NAND2 gate" until all the logic gates are coded in switch-level. The program can process any combinational circuit and build the netlist switch-level coded data structure based on the same structure explained in this chapter.

44

Table 18: Data structure of netlist switch-level ofC17 circuit
Netlist 5 ( C17 )

Arrya Index

II

Function Code 1 1 3 2 4 2 3 4
1 1 3 2 4

I Data 1 I Data 2 I Data 3 I
14 15 16 17 18 20 21 6

Gate Type

1
2
I

i I

3 4 5
6 7 8

I

I

I

1 3 14 3 17 1 16 21 3 4 23 4 26 3 25 30

12 12 15 13 19 18 20 22 12 12 24 13 28 27 29 31

11
I

0 0 0 0 0 0 0

8 9 10 11 12 13 14 15
иииииииииии

23
24 25 26 27 29 30 7

11
0 0 0 0 0 0 0

2 3 4

ииииииииииииииииииииииииииииииииииии

и иииииииии
11
,

41 42 43 44 45 46 47 48

1 1 3 2 4 2 3 4

59 60 61 62 63 65 66 11

8 9 59 9 62 8 61 66

12 12 60 13 64 63 65 67

0 0 0 0 0 0 0

45

3.6. Processing and Storing Arrays of Switch-Level
The processing arrays used to store the values of the processed links of the switch-level circuit are stored in an array called: Datajnout_s. This array structure is similar to gate-level Datajnout_g. Table 19 shows Datajnput_s ofCl7 circuit. This array is in 3D and it is built as follows: и CaPe: Indicates that the value of the corresponding address index is a capacitance. CaPe = I Cape = 0 и [This address index corresponds to a capacitance] [This address index does not correspond to a capacitance]

Statv: Indicates that the corresponding value at this address index is resolved or calculated and stored

и

LL, Ls: As explained in section 3.4. These are respectively the logic and strength codes of a link. This represents the value at the corresponding link.

и

There are 12 arrays forming DatajnouCs. Every array corresponds to a test vector. There are 12 test vectors. The capacitance values are calculated and stored in Datajnout_s for every test vector. When a transient is injected, the previous values of the capacitances is ready to apply (funC + Caps) at the node.

46

Table 19: Array of the storing processed data of C 17 circuit switch-level Data inout s (C17)

!

Address Index 1 2 3 4 5 6 7 8 9 10 11 12
13

I

I
CaPe
I

Statv
1

LL SLl-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1

14 15 16 17 18 19 20 21 22
и и и и и и и и и и и al

0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1
0 0 0 0 0 1 0 0 1

1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0
1

................
1 1 1 1 1

1 0

59 60 61 62 63 64 65 66 67

o '.
1 1 0

0 0 0 0 0 0 0 0 0

0 0 0 0 0
1

I

:::::> 12th test vector

0 0 1

-

I;>

1st test vector

47

Chapter 4 Detailed Representation of SimVI Simulator

4.1. Flo\v diagram of SimV 1
Figure 17 shows the full flow diagram of SimV I. The different parameters and blocks in this flow diagram are as follows: и var_f: Represents the variable of injected transient types, this number varies from 1 to nF (i.e. nF = 23 is the maximum number of injected transient types) и var_1: Represents the variable of the locations of transient injection, this number varies from
1 to nL (i.e. nL is the maximum number of locations of transient injection, for C17 circuit

"nL = 24" ). и var_v: Represents the variable of index of the used test vectors, this number varies from 1 to nV (i.e. nV represents the maximum number of applied test vectors, for C 17 circuit "nV 24") и и initr, init" initv: Initialize respectively var_f, var_1 and var_v to "1" when they are called. initau: Initialize the blocks initr, initl and initv when it is called.
48

=

и

det(var_f,var_l), detATV(var_f,varJ): Represents the coefficients of the profiling mapping arrays Profm (Le. map_det and map_detATV) explained in section 3.2.3. Their values are updated based on the input information (i.e. var_f, varJ and var_v) as shown in their corresponding blocks in the flow diagram.

и

Modulel: Represents the heart of the simulator. This module receives at its inputs the transient types, the transient injection locations and the test vector. The output of this module is either 110 indicating detection or no detection based on the input parameters. The simulator can use the drain, gate and the inputs of a logic gate as transient injection location type. This chapter will focus on the drain only. A gate or inputs of a logic gate locations types are coded in similar manner to a drain as transient location type. The next section is dedicated for this module.

The program activates initall and the variables var_f, var_l and var_v are initialized then Module 1 will process these values for CUT and the results of the simulation will be 110. There are two options: и Comp Comp=

= 1:

Signifies that the injected transient is detected. The coefficient arrays take the

following values: det(l,l)=l and detATV(l,l)=l. This indicates that the first test vector detected the first transient type at the first location. Profm (i.e. map_ det and map_ detATV) maps are updated by det and detATV values: The cycle is ended by initializing var_f, var_l and var_v. This concept allows the simulation to run faster as the simulator will stop testing

.

the circuit for the remaining test vectors when a transient injection is detected. Module 1 will restart to process the next set of values of var f, var 1 and var v until all var f and var 1

-

-

-

--

values are processed. 49

и

Comp = 0: Signifies that the injected transient is not detected. The array coefficients are not updated until detection of transient injection. When all the test vectors are applied and "Comp = 0", the coefficient arrays will become: det( 1,1 )=0 and detATV(1 ,1 )=nV. This indicates that none of the test vectors detected the first transient type at the first location. The Profm (Le. map_det and map_detATV) maps are updated by det and detATV values. The cycle is ended by initializing var_f, var_l and var_v.

50

Module 1
Transient injection and detection of the switch-level circuit

No

Yes

No

Yes

det(varJ,varJ) = 0 detATV(varJ,varJ) = var_v

det(varj,varJ)= 1 detATV(varj,varJ) == var_v

Profm

No

No

Figure 17: Flow diagram ofSimVI simulator

51

4.2. Flow Diagram of Module!
This module is the main processing unit of the simulator SimV I. Its inputs are var_ f, varJ, var_v and initall . These variables represent respectively the transient type variable, the transient injection location variable, the index of the test vector variable and the initialization block of all these variables at the start of the program. The output of this module is either 110 indicating whether the injected transient is detected or not. Figure 18 shows the flow diagram of this module and its different blocks and its functionality are explained in detail as follows: и At the start of the simulation, initall initializes initns. This block initializes var ns, block B 1 andB2: o var_ns: Represents the index of a row of netlist_s array_ When this variable is initialized, its value is set to 1. o Block BI: Updates Data_inout_s array by storing the test vector indexed by var_v and updates the capacitances values corresponding to the processed test vector. Section 3.6 explains the structure ofDatajnout_s and shows an example of this array for C 17 circuit. When this block is initialized, a new var_v value is loaded and Data_inout_s is updated. o Block B2: Updates ArraYinjD based on the transient injection location varJ. ArraYinjD is shown in table 20. This table shows an example of NAND3 logic gate. There are 6 locations for transient injection in this example as shown in ArraYloc where this array shows the addresses of possible transient injection locations in

52

netlist_s. The program at every value of var_ns will check if at the specified array location var_I, the corresponding array [ArrayinjD (varJ(var_ns╗

= 1 ] is true. Then

the transient can be injected at the corresponding address in Data_inout_s. The remainder of the flow diagram will provide further explanation of this process of transient injection and detection. и Block B3, B4 and B5 Operate as follows: For the specified var_ns value, the corresponding netlist_s(var_ns) row is selected to be processed. varys determines the row to be accessed when B4 is called. The function of the selected row is then resolved and the output of this row is stored in Data mout s. и The remainder of the process is organized as follows: ArraYinjD(var_l(var_ns╗ determines

the transient injection location based on var_I location. The corresponding array of var_I as shown in figure 20, has zeros except at one index address. There are two options: o ArraYinjD(var_l(var_ns╗ = 1: Datajnout_s is updated by the transient value (var_f) at the corresponding address location. There are 2 options based on this solution: и var_ns f. nS: var_ns is incremented by 1. This indicates that the next row of netlist_s is going to be resolved. This process will be in loop until all the rows of netlist s are resolved. nS: Represents the last row ofnetlist_s.

и

var_ns

= nS:

The primary outputs of CUT are resolved. Block B7 is then

called to compare the 'results of the primary outputs with and without the transient injection. Detection and no detection status are represented

53

respectively by the codes 1 and O. After this stage, initns is called to restart the same process with a new set of var_ v, var_1 and var_f o ArraYinjD(var_l(var_ns╗) = 0: Data_inout_s of block B6 is bypassed. The remainder of the flow diagram is the same as the previous condition:

и и

var_ns t- nS: netlis_s is incremented (loop) ns= nS: B7 is called, initns is initialized and a new set ofvar_v, var_l and var_f are processed.

The functionality of SimVI explained in this chapter gives an idea of how this simulator is implemented. The different results of execution time, fault coverage and other statistical results based on the simulation are presented in Chapter 6.

54

Module 1

Update: DataJnout_s Cap, (var_v) Test Vector (var_v)

Update:
ArraYinjD

(var_1 )

Transient Injection Detection 0: Transient Injection not detected 1: Transient Injection detected

No

Figure 18: Flow diagram of the transient injection and detection Module 1

55

Table 20: Architecture of ArraYinjD drain location array applied to NAND3 NAND3 - Switch-level Function Code

Function Code

Data

Data

Data2

1

2 1 2 3
7 9 3 12 2 15 1 11 19 5 5 5 8 10 6 14 13 17 16 18 20

J

!

1
2

~

1
2 3

3 6
8 10

4 5 6
7 8 9 10 11 12

i

funP funP funP funC funC funN funC + Caps funN funC + Caps funN funC funC + Caps

1
1 1

3 3 2
4 2 4

2 3
4

7 8 9 10 11 12 13 15 16 18 19
4

~

Index I var os]

1
2

1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

0 0

,

3 4 5
6

1
0 0 0 0 0 0 0 0 0

I

0 0 0 0 0

1
0 0 0 0 0 0

7
I

I

8 9 10 11 12

1
0 0 0 0

0 0

1
0

0

56

Chapter 5 Detailed Representation of SimV 2 Simulator

SimV2 is an optimized version of SimV) simulator. An algorithm is designed for SimV2 to speed up its run time. This simulator is able to achieve a significant speedup in comparison to SimV). This chapter explains in detail the different modules of this simulator and the concept of the developed algorithm that allows the simulator to run faster than SimV l simulator. Section 5.1 and 5.2 gives detailed explanation of two types of data structures needed for the simulation. Section 5.3 explains the concept of the developed algorithm by providing a step by step simplified explanation based on C 17 circuit. SimV I is part of SimV2 simulator and it is used only one time in order to build the switch-level data for SimV2 simulator.

5.1. Gate-Level Resolution Function
This function is based on collecting detailed information on the logic gates of CUT. All the data processed at this level are in gate-level. The collected information is the main key for the applied algorithm. Table 20 shows the type of information collected through this stage. This

57

table shows an example of the first NAND2 logic gate of C17 circuit. The different parameters and the data structure of this array are explained as follows:

и

Logicc: Signifies that the corresponding array collects the logic combination at the inputs of the corresponding logic gate. At every applied test vector at the primary inputs of C17 circuit, this array will store the logic combination of the inputs of the corresponding logic gate.

и и

Gate1: Represents the first gate ofCl7 circuit. inl to inlO: Represents the possible inputs of a gate. For the NAND2 gate there are only 2 inputs, thus the first two inputs inl and in2 are used and the other inputs are left blank.

и

int and in2: Stores the logic combination of the inputs ofNAND2 gate for the 12 applied test vectors at the primary inputs of C 17 circuit.

и и

Array Row Index: Represents the index of the applied test vectors. InG: Represents: [Decimal representation of logic combination + 1]. This combination is shown in inl and in2.

и

Outo: Represents the logic value at the output of NAND2 gate based on the logic combination at the input of this gate.

и и

OutoF: Represents NOT(Outo). Statpo: Represents the status of the primary output of C17 circuit for the corresponding test vector when the output ofNAND2 gate is flipped for the same applied test vector. This value can be 1 or 0 corresponding to detection or no detection due to the flipped bit at the output of this NAND2 gate.

и

MultisInG :Represents the multiplication of InG by Statpoи

58

Figure 19 shows C17 circuit and the structure of the 3D arrays based on table 20 arrays. These arrays are generated by processing C17 circuit in gate-level and by applying the gate-level resolution function. There are different features implemented into the program that helped build these arrays faster. The use of gate level allows applying the test vectors as a set of bits. All the test vectors are applied at the same time to the circuit. Another feature that helped speed this process is called progressive gates. The following technique helped improve the speed of resolving the primary outputs of the circuit and builds Logicc arrays. This technique is based on reducing the number of processed gates by one every time a new Logicc array is built. For C17 circuit, the number of times these logic gates are processed is shown as follows: и Reduction of number of processed logic gate is applied:
ng(ng+l) + NPO 2 no 6(6+1) 2

+ 627 -

(EQ-5 -1)

Npo

= 6 + 6 + 5 + 4 + 3 + 2 + 1 = 27

Npg: Represents the number of progressive logic gates to be processed in order to
build all the Logicc arrays of CUT. The first "6" (i.e. ng = 6 ) logic gates are used as a reference solution in the program. The remainder of the logic gates is processed in a progressIve manner. и Reduction of number of processed gate is not applied:

(EQ-5-2)
There is a significant difference between the two calculations and this difference becomes more important for bigger circuits.

59

The main idea behind this process is based on how the resolved values of the outputs of the logic gates are stored in DatajnoutJ array. When the first gate is resolved, its output is stored in Datajnout_g and Logicc array of Gate 1 is created. For Gate 2, the only infonnation that has to be changed is the flipping bit at the output of Gate 2 in order to resolve Logicc array of Gate 2. This does not affect Gate 1, thus Gate 1 infonnation is pennanently stored in Data_inoutJ and it is used to resolve the primary outputs of the circuit and build Logicc array of Gate 2. The same concept is applied for the remainder of the logic gates and every time a new Logicc array is built, the number of processed gates is reduced by one. Table 22 shows the needed infonnation of Logicc arrays to be used for SimV 2 simulator. This table shows the data structure of collected data gate-level based on the resolution function applied to C17 circuit.

60

Table 21: Example of gate-level resolution function applied to NAND2 gate: Gate) ofe17 circuit covering the effect of the flipping bit of the output of the logic gate on the circuit for a set of 12 test vectors
Logicc - NAND2 gate: Gatel

Array

Column Index

15

I
I

Array
Row

I

inl
0 0

in2 1 0
I

in3

il4

ins

ill6

in?

il1g

in9

I Index
1
2

inlO'

lno 2

Outo
I

OutoF
0 0
0

StatPO
I

Multis1nG
2 1 0

1

1 1 1
I

1
0 1

3 4
5 6 7 8 9
10 11

0 1
0

2
3

0
I

0

3
2

2
4
2 3 3 3

0
I
0 0

I
0

I I
0

0 1
I I

1 I 1
1
1

4
2 3

1
I I

0
0

0
0

3
3

1 1 1

1

0
0

0
0

1

0 0

1
0

1
0

12

1

61

N5

tHO
NAND2 gate: Gate)

I

I

I

I

I

NAND2 gate: Gate, NAND2 gate: Gat.e2

NAND2 gate: Gate3 NAND2 gate: Gat.e4

NAND2 gate: Gates NAND2 gate: Gate(,
t-

i--

....r--

Figure 19: Structure of the 3D array of gate-le\иeJ .resolution function applied to e17 ,circuit

NAND2 gate: Gate6

,

I

I

NAND2 gate: Gates

NAND2 gate: Gate4

NAND2 gate: Gate3

I

NAND2 gate: Gate2

NAND2 gate: Gatej
Order of test vectors 1

1110 Multi s1nG
2
1 2

2
1

2 3 4
I I

3
2

5 6

4
2

0 3 2 4
2

7 8 9 10

3 3 3
1 1

11
12

3 3 3 I 0

Table 22: Data structure of collected data gate-level based on the resolution function applied to C17 circuit

5.2. Switch-Level Data Input Organization
This data is built based on SimVl* simulator. All the logic gate types are processed through SimV I simulator for transient injection and detection at switch-level. Every logic gate is processed as an independent circuit. This simulator is slightly different from SimVias when a fault is detected, the simulator will keep miming until all the test vectors are used. The test vectors applied to these logic gates are_exhaustive test vectors and their numbers can be 2 test vectors for NOT or BUFFER gates, and 1024 test vectors for NANDlO or ORlO gates. SimVl* will mn all the test vectors and injects the transients at all locations at every logic gate. The results of processing these gates are stored in 3D Profm'" arrays. These arrays are similar to Profm 63

arrays built through SimV I simulator at the exception of little modification based on how the data is stored. These arrays are 3D arrays as every array slice corresponds to the index of the applied test vector TVn (i.e. similar notation as var_v). It is the same analogy for map_detATV* and map_det*, the only difference with these maps and map_det and map_ATVdet are as follows: и map_detATV*: Stores the output value of the logic gate for every injected transient and every transient injection location. There is an array created for every TVn. и map_det*: Stores the status of the output of the logic gate as 110 corresponding to detection or no detection. There is an array created for every TVn.. This map is similar tomap_det Table 23 shows 2 slices of Profm * arrays corresponding to 2 test vectors. These arrays are based on applying 8 transient types. A NOT gate has only 2 transient injection locations, therefore, TLQc

= [1:2]. This table shows map_det of NOT gate as well.

This array can be built

from map_det*: 1 and 2. map_det = [map_det*: 1 ] OR [map_det*: 2]. map_ det of the logic gate is stored as it is needed for SimV2 as well. Every logic gate will generate 3 array types: map_ det, map_ det* and map_ det*. Figure 20 shows the structure of Profm* arrays for different logic gate types. Based on NOT logic gate example, TLQc= [1:2]. There are two slices of arrays for map_ det* and map_ detATV* as TVn = 2. Every logic gate has one array ofmap_det. For NAND3 logic gate example, TLQc = [1:6]. There are 8 slices of arrays for map_ det* and map_ detA TV* as TVn file and are used in SimV2 simulator.

= 8. These 3D arrays are all stored in a .*mat format

64

I
---

NOT-TVn:2
Tlo<:
I 2

I

I
I

TI
()

T~
r\

~
1 2
0 0

0

0 0

I
T,
0 0
T~

NOT-TVn: 1
TLne
I 2

I

0

0 0 0
0

0

0

3 3
1

I

TLoи
I

I

2

I

0

t t
I I

0
3

0

I

t
1

3

I

0

0

t
1
1

0 0

0
I

0 0

0
I

3
I 3
0

1
0
I I I

0

t
3
1

I
1

0 0
1
1

map detATV'" : 2

map det"': 2

I

:

I

7 7 6 6

3
3
1

3

3

0
I

0
I

1

0
0

I

0

I
,.и T
0 0

NOT Gate TLoc
1
2

I

map detATV'" : I

map det"': t

,T
0

0
0

0
0

t
I

t
3 7
3
0

7
6 6 0 0

rna det

Table 23: Structure of the collected data of NOT gate applied to SimVI* simulator

65

NOT ( T Loc = 2 )

BUFFER(TLoc=4 )

ииииииииииии
map_det"': 1 map_ detATV"': 1 map_det"': 1 map_detATV"': 1 map_det

I
I

map_det

NAND2 ( T Loc '" 4 )

I I

NAND3 ( TLoc = 6 )

иииии
map_det"': 1 map_detATV"': 1 map_det"': 1 map_detATV"': 1 map_det"': 1 map_detATV"': 1

Figure 20: Data structure of some logic gates extracted from SimV t * simulator

5.3. Concept of the Algorithm Used in SimV2 Simulator
This simulator uses the data generated from the gate-level resolution function mentioned in section 5.1 and the switch-level 3D array switch-level logic gates mentioned in section 5.2. This algorithm is able to trace back the information of transient injection and detection and build the same profiling maps (Le. map_det and map_detAT) generated by SimVt. The example of C17 circuit is used in this section showing how this concept is implemented in order to build map_ det and map_ detATV. Table 24 shows the different arrays used to resolve C17 circuit. This example shows how 4 different transients are injected into CUT and how they are detected in case of detection. Sections 5.3.1 to 5.3.4 give detailed explanation of these 4 transients. The steps of how the 66

transient detection is tracked are marked by different contrasts in the table for each one of these 4 transients. This allows better solution traceability and provides a clear explanation on how these map_det and map_detATV are built. C17 circuit has 6 NAND2 logic gates. This example traces 4 solutions for [ NAND2 - Gate, ] and it is the first logic gate of C17 circuit. The table [NAND2 - Gate, ] shows one of the arrays shown in table 22. [NAND2 Gate] table shows four arrays of map_det* and map_ detATV* and one array of map_ det. Each of these arrays has the same information on TLoc (i.e. TLoc = [1:4] corresponding to 4 locations). [map_detATV C17] table shows TLoc= [1 :24] and the contrasted positions on this table represent the solutions found by applying SimV2. The transient locations type for this example is drain of a switch and only 8 transient types are used. The simulator can run all the transient types. Based on the experiment results, some transients can be collapsed and be represented by one transient type, therefore these 8 transient types represents the 23 different transient types. The following sub-sections present four sample of transient injection at four drain locations of C17 circuit. The steps explained in these sub-sections provide detailed explanation on how the program resolves the profiling maps Profm of C17 circuit.

5.3.1 1sf Solution Based on C17 Circuit Example
TLoc: The location of the transient = 1. Array address of the transient type is 2, corresponding to TL= 0, T s= 1. For all the steps when referred to map_det, nap_detATV, map_det and map_detATV, all

-.
these arrays are accessed at the same T Loc and index of transient type. и Step 1: Check map_ det of [ NAND2 ] table

67

o

If the corresponding value is 0, then go to step 4. Solution: map_detATV = nY, map_det = O.

o и

If the corresponding value is 1, then go to Step 2.

Step 2 :Check the first map_ det* of [ NAND2 Gate] table that contains [1] as value o o o o 1st [1] value is at map_ det*: 2. This means that TYn = 2. The corresponding array location for [map_ detATY*: 2 ] array is value [3] Solutions are: map_det*: 2: [1] , map_detATY*: 2 : [3] Go to step 3.

и

Step 3: Check [NAND2 - Gatel ] table. o Ifmap_detATY* solution is [3] then check the columns: [ Order of test vectors] and [ InG] и и Find the first InG value where: InG = 2 Record the value of [ Order of test vectors] corresponding to the first [ InG 2 ] where 2 corresponds to TYn = 2. In this case:

Order of test vectors = 1 o Ifmap_detATY* solution is [0/1] then check the columns: [ Order of test vectors] and [ MultisInG] и. Step 4: Final solution map_det (Array address of the transient type, TLoc)

68

map_detATV (Array address of the transient type, T Loc)

Solution for C17: map_detATV (2,1) = 1 Solution for C 17: map_ det (2,1) = 1 These solutions are shown as well in table 25.

(AtTLoc= 1, TL=O, Ts= 1) (AtTLoc=2, TL=O, Ts= 1)

5.3.2. 2nd solution of based on C17 circuit example
T Loc: The location of the transient = 2. Array address of the transient type is 1, corresponding to T L= 0, Ts= 0. и Step 1: Check map_det of[ NAND2] table The corresponding value is 1. Go to Step 2. и Step 2 :Check the first map_ det* of [ NAND2 Gate] table that contains [1] as value o 1st [1] value is at map_det*: 3. This means that TVn = 3.

o The corresponding array location for [map_detATV*: 3 ] array is value [3] o Solutions are: map_det*: 3 : [1] , map_detATV*: 3 : [3]

o Go to step 3. и Step 3: Check [NAND2 - Gate, ] table. o Ifmap_detATV* solution is [3] then check the columns: [ Order of test vectors] and [ Ina] и Find the first Ina value where: InG = 3

69

и

Record the value of [ Order of test vectors ] corresponding to the flrst [InG 3] where 3 corresponds to TVn = 3. In this case:

Order of test vectors = 4 o и Go to step 4 for the flnal solution.

Step 4: Final solution map_ det (Array address of the transient type, T Loc) map_detATV (Array address of the transient type, T Loc) Solution for C17: map_detATV (1,2) = 4 Solution for C17: map_det (1,2) = 1 These solutions are shown as well in table 25. (AtTLoc=2, TL=O, Ts=O) (At TLoc = 2, TL = 0, Ts = 0)

5.3.3. 3rd Solution Based on C17 Circuit Example
TLoc: The location of the transient = 3. Array address of the transient type is 2, corresponding to T L= 0, Ts= 1. и Step 1: Check map_ det of [ NAND2 ] table If the corresponding value is 0, then go to step 4. Solution: map_detATV = nV = 12, map_det = 0. и и и Step 2 : Not applicable: NIA Step 3: Not applicable: N/A Step 4: Final solution

70

map_ det (Array address of the transient type, TLoc) map_detATV (Array address of the. transient type, T Loc )

Solution for C 17: map_ detATV (2,3) = 1 Solution for C17: map_det (2,3) = 1 These solutions are shown as well in table 25.

( At T Loc = 3 , TL = 0, Ts = 1 ) (AtTLoc=3, TL=O, Ts= 1)

5.3.4. 4th Solution Based on C17 Circuit Example
T Loc: The location of the transient = 4. Array address of the transient type is 8, corresponding to TL = 1, Ts= 6. и Step 1: Check map_ det of [ NAND2 ] table If the corresponding value is 1, then go to Step 2. и Step 2 :Check the first map_ det* of [ NAND2 Gate] table that contains [1] as value o 1st [1] value is at map_det*: 4. This means that TVn = 4.

o The corresponding array location for [map_detATV*: 4 ] array is value [1] o o и Solutions are: map_det*: 4 : [1] , map_detATV*: 4 : [1J Go to step 3.

Step 3: Check [NAND2 - Gate! ] ,table. Ifmap_detATV* solution is [011] then check the columns: [ Order of test vectors] and [ MultislnG]
71

o Find the first Multi slnG value where: Multi slnG

4

o Record the 'value of [ Order of test vectors] corresponding to the first [MultislnG = 4] where 4 corresponds to TVn = 4. In this case: Order of test vectors = 6 и Step 4: Final solution map_det (Array address of the transient type, TLoc) map_detATV (Array address of the transient type, TLoc) Solution for C17: map_detATV (6,3) Solution for C17: map_det (6,3) = 1 These solutions are shown as well in table 25. 6 (AtTLoc 3, TL = 1, Ts =6) 6)

( At TLoc = 3 , TL = 1, Ts

72

Table 24: Example of how the algorithm applied to SimV2 simulator builds the solution maps map_ det and map_ detATV for C 17 circuit
NAND2Gate

Array Address

TL

Ts

1 2 3
I

0 0 1 3
I

0
I 1 I 7 7

1

1 1
1

I 1 1

1 1 1
1

1 1

1 1

1 1 1

1

1 ~

1
1

1 1
1
I
I

0 0 0

0 0 0 0 0
3

0

0

1
1
1

~ 1

1 1
1

t
1

3 3
3 0 3 0

1

0 3 3

o
3 3 1 3

I
I

4 5 6 7

3 0
1

8

6 6

I 3 I 3 1 1 1 1 1 1 map. detATV*
1 3 3 1

l
I

3 3
1
1 :1

3 0 3 0

1

3 3 1

1 I 1 1

t
3 3 1

3 3 1

1 3 3 1

1 1 3 1

0 0 3 0

t
3

0

0

0

1 1 1 I map. detA TV* : 2

t 1 1 1 map. detA TV* : 3

0 0 ~F I map. detATV* : 4

I

Array и Address

l--""'I-/.;;;.rll=~-'---4-41 r-I-I.....'-2T"-i'I=~-r'-4-II I
TL Ts

1
2

0 0 1 3 I 3 0 1

0
1 I 1 7 7 6

I 0
0 0 0 1 1 0
0

0 0 0 0 1

0 0 0 0 0 0 0

0

0

0 0 0 0
t I

0
0 0 0 0 0 0

3
4 5 6 7

t
0

0 0 0 1 1 0

~
0
I I

0 0 0 0

0 0 0 0 I 1 0 0

::r:
t
1 1

0 0 0 0 1 1 0

0

0 0 0 0 0
1 0

0
0 0 0 0

0

0

1
I

t
1 1

1
I

0

0

0 0 0 0 1 0

0 1
1

0

t
1 1
1

t
0

t t
0

0

8

6

0 0 0 map det*: 1

0

0 0 0 map det*: 2

0 0 0 map det*: 3

0

0 l' t map det*: 4

NAND2 - Gate.

1
i

Array Address

TL

Ts

I

1 2 3

0 0 1 3
I

0
I

I
~
12

r--

.....
m_

1
1
7

4 5
6

..... .....
.....

7 8

3 0
I

7 6 6

..... .....

l6:'
e17

.....

r--r--r--r--r-r--r--

0

~
i

::1:
1

Order

0

0
0
1

of test vector i

Ina

MultislnG
2
)

I

0
I
)

0
1 1

1
1

t
1 1

1
1

1 1 0

1 1 1 0

~~ ~ 2 t

..

3

2

5

" 2
4
2

0 3
2

0

map_detATV

0 ill 1 map_det NAND2

;; '6'! I
7 8

II t4
2

U

3 3 3 1
1

9 10 )1
12

3 3 3
1

0

73

Table 25: map_det and map_detATV maps for C17 circuit

Array

~ I 1 12 1 3141 ..... 24
TLOC

Address
1

TL
0

TS
0 t t

12

2
3
4

0

12
12

1
3 1 3 0

5
6 7

I 7 7
6

4 4 4

12 12
6 6

-.... 12 иииии ! 12

I

0
0

6 6

4 4

1

12
~6

12
map_detATV C17

0

8

1

6

12

12

map_detATV C17

Section 5.3.1 to section 5.3.4 gave detailed examples of 4 transient injections of different transient types and at different drain locations. These examples reflect the concept of the algorithm and how CUT is resolved to build the profiling maps Profmи

74

Chapter 6 Experimental Results
The results of the experiments are based on ISCAS'85 benchmark circuits. Different experiments are presented in this chapter based on the simulation of transient injection at drain, gate and inputs of a logic gates. A performance analysis based on simulation execution time of SimV I and SimV2 simulators is conducted.

6.1. Overview of the Simulation Applied Data 6.1.1. Benchmarks
Detailed information on ISCAS'85 benchmark circuits [17] is shown in table 26. The parameters of this table are as follows: Gate Types: Represents the different logic gates of these circuits. Number of Gates: Represents the number of gates for each Gate Type.

75

Table 26: Detailed logic gate information ofISCAS'85 benchmark circuits

I

CI7

Gate Types Number of Gates Gate Types Number of Gates Gate Types Number of Gates Gate Types Number of Gates Gate Types Number of Gates

NAND2 6 NOT 40 XOR2
104

I C432 I C499 I C880

NAND2 64 AND2 40 AND3 12

NOR2 19 NOT 40 NAND2 60

AND9 3 AND4 8 NAND3 14

XOR2 18 OR4 2 AND2 105

NAND4 14 AND5 8 OR2 29

AND8
1

NAND3 1

NAND4

NOT 63

NOR2 61

13
BUFFER 26 NOT 277 AND4 2 BUFFER 272 NOR2 12 BUFFER 223 AND4
10

I C1908

Gate Types Number of Gates Gate Types Number of Gates

NAND2 347 NAND5 24 AND2 203
ANDS

BUFFER 162 AND5 16 NOT 321 OR3 2 OR2 35 OR3 56 NOT 581 ANDS 11 NOR2 2128

AND2 30 AND8 3 AND4
11

AND3 12 NOR2
I

NAND4 2

NAND3
I

NAND8 3

I C2670

Gate Types Number of Gates Gate Types Number of Gates

AND3 112

NAND2 254

OR2 51

OR4 22

OR5 2 AND2 410 NOR3 27 NAND2 454 OR5 8 NAND2 274 AND5 2 AND4 27 NOR3 6 NAND3 17 NOR8 16 OR2 95 NOR4 2 AND3 76 OR4
I

7 NOT 490 NAND4 7 AND2 319 NOR2 19 NOT 32

I C3540

Gate Types Number of Gates Gate Types Number of Gates

NOR2 25

I C5315

Gate Types Number of Gates Gate Types Number of Gates

BUFFER 313 OR4 61 AND2 256

AND3 359 AND9 2

OR3 50

rC6288

Gate Types Number of Gates

76

6.1.2. Information on the Applied Data
Table 27 shows detailed infonnation of ISCAS'85 benchmark circuits. The infonnation extracted from these circuits is provided by the simulator. The test vectors used for the simulations are based on compaction algorithm [18]. These test vectors are designed for logic-level circuits and are used for the first time in this work. Table 27: Infonnation on ISCAS'85 benchmark circuits
Number of Benchmarks
!

Number of primary outputs Number of Gates Number of switches

Number of test vectors

primary inputs

ISCAS'85 C17 C432 C499 C880 C1908 C2670 C3540 C5315 C6288 C7552

5 36 41 60 33 233 50 178 32 207

2 7 32 26 25 140 22 123 32 108

6 160 202 383 880 1269 1669 2307 2416 3513

24 896 2180 1802 3446 5668 7504 11262 14368 15400

12 27 52 16 106
44

84 37 12 73

6.2. Fault Coverage Due to Transient Injection at Different Location types
This work is pioneer in tenns of soft error detection based on switch-level models and there is no available data in the literature for comparison. The results in this work are based on the developed simulators.

-.

6.2.1. Injection at Gate of a Switch

77

The results of simulation of transient injection at gate of a switch applied to C5315 circuit are shown in table 28. The simulator processing unit has the ability to show detailed results for different injected transient types. The various parameters of this table are explained as follows: и nT.d: Represents the total number of injected transients for all transient locations and based on test vectors elimination (Le. When an injected transient is detected, the simulator stops, records the information of the injected transient and proceeds with the next transient injection location). This method is applied to SimV I simulator. SimV2 simulator has the ability to build the same information as it provides the same profiling maps as SimVI. nT.d is determined by (EQ - 6 - 1). The parameters of this equation are explained in previous sections at the exception ofvar_f. This parameter in this expression is constant and based on the calculation of one transient type. var_f takes one value between 1 and 23 which is the injected transient type used for the corresponding calculation in this expression.

nT.d

=

var J= [1:23 J, var 3 =1

I

nL

map_det (var -I, var J)

(EQ - 6 -1)

и

nT.aU: Represents the total number of injected transients for all transient locations and based on all applied test vectors without test vector elimination (i.e. When an injected transient is detected, the simulator doesn't stop, and records the information of the injected transient and when the last test vector is applied then the simulator proceeds with the next transient injection location). nT.aU is determined by (EQ - 6 - 2) for one transient type. The parameters of this expression are explained in previous sections.
nT.d

=

nV .nL

(EQ - 6 - 2)

78

и

FCOy: Represents the fault coverage corresponding to every transient type, applied to all transient injection locations and based on the applied test vectors.

и

nL: Represents the number of transient injection locations. This number is the same as the number of switches of CUT as shown in Table 27.

и

nLd: Represents the number of transient injection locations corresponding to detection. The FCOy can be determined based on nL and nLd for every transient type.

и

nT.dSeU: Represents the number of injected transients for all transient locations and based on test vector elimination. This parameter is similar to nT.d. This number applies only to the selected transient types. Table 28 shows that some transient types can be collapsed in one type as their results are equivalent. The equivalent transient types are differentiated in the table by different contrasts. Furthermore the 23 transient types based on the gate transient location type can be collapsed in 4 transient types resulting in a significant reduction of simulation execution time. The results of the remaining transient types are rebuilt based on these four selected transient equivalent types.

и

Total: Represents the results based on all the transient types or the selected transient types such as for nT.dSell.

и

T(Parameter): Represents the execution time needed to process the parameter variable.
(e.i. T(nT.d) represents the execution time to run nT.d). The simulation execution time is expressed in seconds.

Table 29 shows the fault coverage Fco~ for all the ISCAS'85 benchmark circuits for injection at a gate of a switch. Fcov is shown for every single fault type. The total shows the fault coverage for all the applied fault types.

79

Table 28: Simulation results for injection at gate of a switch for C5315 circuit
Gate-C5315
!

T,

T"

OT.d

DT.an

Fe""
0.9999\

DL

OLd

T(nI.J

T(OT.all)

OT.dSel

T(OTdSe.)

I

7 0
I

28521 17280 60186 60186 60186 60186 60186 60186 17280 86652 86652 86652 86652 86652 86652 17280 17280 17280 17280 17280 17280 17280 17280

416694 416694 416694 416694 416694 416694 416694 416694 416694 416694 416694 416694 416694 416694 416694 416694 416694 416694 416694 416694 416694 416694 416694

11262 11262 11262 11262 11262 11262 11262 11262 11262 11262 11262 11262 11262 11262 11262 11262 11262 11262 11262 11262 11262 11262 11262

11261 11262 11216 11216 11216 11216 11216 11216 11262 10732 10732 10732 10732 10732

28327.53 17162.78 59777.74 59777.74 59777.74 59777.74 59777.74 59777.74 17162.78 86064.21 86064.21 86064.21 86064.21 86064.21 86064.21 17162.78 17162.78 17162.78 17162.78 17162.78 17162.78 17162.78 17162.78

413867,42 413867.42 413867.42 413867,42 413867,42 413867.42 413867.42 413867,42 413867.42 413867.42 413867.42 413867,42 413867.42 413867.42 413867.42 413867.42 413867.42 413867,42 413867.42 413867.42 413867.42 413867.42 413867.42

28521 17280 60186 0 0 0 0 0 0 86652 0 0 0 0 0 0 0 0 0 0 0 0 0

28327.53 17162.78 59777.74 0.00 0.00 0.00 0.00 0.00 0.00 86064.21 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00

I 0
0 0 0 0 0 0 1 1 1

I
0.99592 0.99592 0.99592 0.99592 0.99592 0.99592

2 3 4 5 6 0 1 2 3 4 5 6 0 1 2 3 4 5 6 7

I
0.95294 0.95294 0.95294 0.95294 0.95294 0.95294 1 1 1
1

I
1 1

I
3

I

10732 11262 11262 11262 11262 11262 11262 11262 11262

3
3 3

3
3

1
1

3
3

1

I

Total

\1082349 \95839621 0.986651259026\255569\ 1075007.0619518950.74\192639\191332.261

80

Table 29: Simulation results of Fcov for transient injection at gate of a switch for ISCAS'85 benchmark circuits
Gate - Frey

I I

T .. I 0 0 0 0 0

Ts 7 0 1 2 3
4 5 6 0 1 2 3 4 5 6 0 1 2

C17 1 1 1 I 1 1 1 1
1

C432 1

1
0.9888 0.9888 0.9888 0.9888 0.9888 0.9888 1 0.8214 0.8214 0.8214 0.8214 0.8214 0.8214 1 1 1 1 1 1

C499 0.9885 1 0.9404 0.9404 0.9404 0.9404 0.9404 0.9404

C880 I 1 0.9878 0.9878 0.9878 0.9878 0.9878 0.9878 1 0.9417 0.9417 0.9417 0.9417 0.9417 0.9417 1 1 1

C1908 1 1 0.9997 0.9997 0.9997 0.9997 0.9997 0.9997 1 0.9689 0.9689 0.9689 0.9689 0.9689 0.9689 1 1 I 1 1

C2670 0.9915 0.9979 0.9287 0.9287 0.9287 0.9287 0.9287 0.9287 0.9979 0.8705 0.8705 0.8705 0.8705 0.8705 0.8705 0.9979 0.9979 0.9979 0.9979 0.9979 0.9979 0.9979 0.9979

C3540 0.9997 0.9999 0.9884 0.9884 0.9884 0.9884 0.9884 0.9884 0.9999 0.9428 0.9428 0.9428 0.9428 0.9428 0.9428 0.9999 0.9999 0.9999 0.9999 0.9999 0.9999 0.9999 0.9999

C5315 0.9999 1 0.9959 0.9959 0.9959 0.9959 0.9959 0.9959 I 0.9529 0.9529 0.9529 0.9529 0.9529 0.9529 1 1 1 1 1 t

C6288 0.3351 0.7415 0.1640 0.1640 0.1640 0.1640 0.1640 0.1640 0.7415 0.2233 0.2233 0.2233 0.2233 0.2233 0.2233 0.7415 0.7415 0.7415 0.7415 0.7415 0.7415 0.7415 0.7415

C7552 0.9928 0.9971 0.9719 0.9719 0.9719 0.9719 0.9719 0.9719 0.9971 0.9373 0.9373 0.9373 0.9373 0.9373 0.9373 0.9971 0.9971 0.9971 0.9971 0.9971 0.9971 0.9971 0.9971

I 0
0 I 1 1
i

I 1 1 1 3 3 3

0.9167 0.9167 0.9167 0.9167 0.9167 0.9167 t 1 1 1 1 1 1
1

I 0.8528 0.8528 0.8528 0.8528 0.8528 0.8528 I

3
3 3

3
4 5 6 7

1 1 1 1
1

1
1 1 1 1

3
3

1 I

1
1

1 1 1

1
I

Total

0.9783

I 0.9505 I 0.9455 I 0.9816 I 0.9918 I 0.9463 I 0.9820 I 0.9867 I 0.4380 I 0.9747 I

6.2.2. Inj ection at Drain of a Switch
Similarly the data of transient injection at drain of a switch is organized in a similar manner to transient injection at gate of a switch. Table 30 shows detailed results of C5315 for transient injection at drain of a switch. Table 31 shows the fault coverage circuits for injection at drain of a switch
Fcov

for ISCAS'85 benchmark

81

Table 30: Simulation results for transient injection at drain of a switch for C5315 circuit
Drain - C5315

T
0 0 0 0 0 2 3 236380 256505 256505 416694 0.49 0.49 6694 0.49 0.14 0.64 416694 251310 4 5 1 3 6 0 251310 251310 251310 367790 538tl 53811 53811 53811 53811 53811 13966 416694 416694 416694 416694 416694 416694 416694 416694 416694 0.5 0.5 0.5

nL
11262 11262 11262 11262 11262 11262 11262 11262 11262 11262 11262

nL
11261 1625 5623 5573 5573 5573 5573 5573 1625 7253 5627 151541.18 97396.08 105688.22 1 105688.22 105688.22 105688.22 151541.18 76316.94 103547.71 103547.71 103547.71 103547.71 103547.71 151541.18 22171.84 22171.84 171691.18 171691.18 171691.18 171691.18 171691.18 171691.18 171691.18 171691.18 171691.18 171691.18 171691.18 171691.18 171691.18 171691.18 171691.18 171691.18 0.00 171691. 171691. 0.00 0.00 0.00 0.00 171691.18 5754.44 0 0 0 0 0.00 0.00 0.00 0.00 367790 236380 256505 0 0 0 151541.18 97396.08 105688.22 0.00 0.00 0.00
i

11262 11262 11262 11262 11262

11251 11251 11251 11251 11262

22171.84 22171.84 22171.84 22171.84 5754.44

Total

4434321 1 9583962 1 0.63 1259026 1163780 11827081.32 1 3948897.24 113984261 576196.00 1

82

Table 31: Simulation results ofFcov for transient injection at drain of a switch for ISCAS' 85 benchmark circuits
Drain TL 1
0
I

Fcov

0 0 0 0 0 1 1 1

! 0

Ts 7 0 1 2 3 4
5

C17
1
0.25 0.5 0.5 0.5 0.5 0.5 0.5 0.25 0.75 0.5 0.5 0.5 0.5 0.5 0.25

C432
1 0.1942 0.4587 0.4554 0.4554 0.4554 0.4554 0.4554 0.1942 0.6942 0.4933 0.4933 0.4933 0.4933 0.4933 0.1942 0.9587 0.9587 0.9587 0.9587 0.9587 0.9587

C499
0.98624 0.1633 0.46468 0.44495 0.44495 0.44495 0.44495 0.44495 0.1633 0.64037 0.4578 0.4578 0.4578 0.4578 0.4578 0.1633 0.94174 0.94174 0.94174 0.94174 0.94174 0.94174

C880
1
0.1421 0.5 0.5 0.5 0.5 0.5 0.5 0.1421 0.6421 0.5 0.5 0.5 0.5 0.5 0.1421

Cl908
1 0.17847 0.49942 0.49739 0.49739 0.49739 0.49739 0.49739 0.17847 0.67847 0.49942 0.49942 0.49942 0.49942 0.49942 0.17847 0.99942 0.99942 0.99942 0.99942 0.99942 0.99942

C2670
0.9435 0.1251 0.4854 0.3553 0.3553 0.3553 0.3553 0.3553 0.1251 0.6159 0.373 0.373 0.373 0.373 0.373 0.1251 0.9762 0.9762 0.9762 0.9762 0.9762 0.9762 0.9989

C3540
0.9915 0.1349 0.4899 0.4603 0.4603 0.4603 0.4603 0.4603 0.1349 0.6264 0.4706 0.4706 0.4706 0.4706 0.4706 0.1349 0.9814 0.9814 0.9814 0.9814 0.9814 0.9814 0.999

C5315
0.9999 0.1443 0.4993 0.4948 0.4948 0.4948 0.4948 0.4948 0.1443 0.644 0.4996 0.4996 0.4996 0.4996 0.4996 0.1443 0.999 0.999 0.999 0.999 0.999 0.999 1

C6288
0.5702 0.0178 0.2037 0.0035 0.0035 0.0035 0.0035 0.0035 0.0178 0.1111 0.0003 0.0003 0.0003 0.0003 0.0003 0.0178 0.297 0.297 0.297 0.297 0.297 0.297 0.8854

C7552
0.9915 0.1349 0.4899 0.4603 0.4603 0.4603 0.4603 0.4603 0.1349 0.6264 0.4706 0.4706 0.4706 0.4706 0.4706 0.1349 0.9814 0.9814 0.9814 0.9814 0.9814 0.9814 0.999

1 1 1
1 3 3 3 3 3 3 3 3

6 0 1 2 3 4 5 6 0 t 2 3 4
5 6 7

.1
1 1

t 1
1 1

1
1

1 t

1

1

1 1 1

1

Total

I 0.652 I 0.6187 I 0.59763 I 0.6334 I 0.63886 I 0.5616 I 0.6111 I 0.6323 I 0.1576 I 0.61H

6.2.3. Injection at Inputs of Logic Gate
The data for transient injection at inputs of a logic gate are based on a bit flip where the logic level is flipped at the inputs of a gate. The signals considered for these experiments are of a logic code 0 or 1 and strength code 7. The injected transient is T L = 1 and Ts

=7

(Le. When this

transient is injected at an input of a logic gate and if the logic at this input is 0 then the logic will become 1 (Flipped) and similarly for logic 1, it becomes logic 0). This experiment will allow

83

comparing the fault coverage with transient injection at drain and gate of a switch. Basically at the location of the tested input of a logic gate, the logic level signal is flipped then the fault detection is determined based on the non-faulty and faulty information of the primary outputs of CUT. Table 32 shows detailed results of injection at inputs of a logic gate for C5315 circuit. Table 33 shows Fcov results for ISCAS'85 benchmark circuits.

Table 32: Simulation results for transient injection at inputs of a logic for C5315 circuit

I I

T 1"
1

I

I

Ts
7

I

I

Dr.d
20564

Dr.aU
162282

Fcov

nL
4386

0.99977

I I

nLd
4385

I 20553 I

I T(nTd) I T(nr.иu)
162191

T(nT.dSeI)
20552.5

Table 33: Simulation results ofFcov for transient injection at inputs ofa logic gate for ISCAS'85 benchmark circuits

I Inputs - Fcov - Bit Flip I
C499
1

C880
1

C2670
0.7997

C3540
0.98226

C6288
0.000833

C7552
0.9823

Figure 21 shows the results of Fcov for transient injection at drain, gate and inputs of a logic gate. The plot shows that for injection at gate of a switch and inputs of a logic gate, the fault coverage is very close, on the other hand, Fcov for injection at drain shows a significant difference compared to injection at drain of a switch and inputs of a logic gate. C6288 represents an exception in terms of fault coverage and does not follow the same trend as the remaining CUTs in this table. This circuit is a 240 full and half adder cells arranged in a 15x16 matrix. The number of fanouts in this circuit is very large and this makes the circuit redundant and less prone to transients as the results show in this table.

84

1

0.9 0.8
I>

0.7

I:.I.."

0

~J

cu 0.6
[]Gate

6 0
,!::i

.... 0.5

I:.I..

~

= 0.3
0.2

0.4

-Inputs

o Drain

0.1 0
<."V

-",:,:>'" ~

<J

~O)

9:J~ r,)'b <."CO <." ..... 01

oeo~~ ()"t;;..~ 0'"~<-, (j;V~'b o<?~'"

ISCAS'85 Benchmark Circuits

Figure 21: Fcov for gate, drain ofa switch and inputs ofa logic gate for ISCAS'85 benchmarks circuits

6.3. Fault Coverage Versus Applied Test Vectors
Figure 22 shows the efficiency of the applied test vectors on the fault coverage based on injection at drain of a switch for C499, C2670, C3540 and C7552. This feature of the simulator can be used to evaluate the performance of any applied test vectors.

85

65

60

55

50

45

"""' d=>
0

40

0' '-'

..
" 35

tJ;.

;U OL c;:;
u

~ 30 0

~ c;:;
I.x.o

o

10

20

30

40

50

60

70

80

90

Index of the applied test vector
. Figure 22: Plot of Fcov based on transient injection at drain of a switch versus applied test vectors for C499, C2670, C3515 and C7552 benchmarks circuits

86

6.4. Timing Results 6.6.1. Matlab Profile of SimVIand SimV2 Simulators
Figure 23 shows the main functions of SimV). This image is extracted from Matlab Profile Display showing the execution time for the main functions of this simulator. The parameter "calls" represents the number of times funC,
funp

and funN are called to run SimV I simulator.

The number of calls offunC can be determined as shown in CEQ - 6 - 3).
tunC Number of Calls nL

= nr.d * nL =
nr.d

139846

* 11262 = 1574945652 (EQ - 6 - 3)

= 11262

= 139846

Figure 24 shows the main functions of SimV 2. This image is extracted from Matlab Profile Display showing the execution time for the main functions of this simulator. This image shows that the main functions of SimV2 are very different of SimV I and there are no more switch-level functions. The parameter "calls" represent the number of times the corresponding functions are called in the program. The different functions of SimV 2 are as follows: и CgateJes: Represents the gate-level resolution function. This number is built based on the number of progressive gates: Npg и Cres_solution_out: Represents the number of ones of map_det based on all the independent switch-level logic gates. и The remainder of the functions is reserved for programming purpose.

87

Function Name Calls
funC funP
fun.~

Total Time

1.574907e+l0 157711.891 s
i.874537e+09 61772.127 s 7.874S37e+09 61640.323 s

mean

1

0.010 s

Figure 23: Matlab Profile Display showing the execution time of SimV I functions

Function Kame

Calls

Total Time

Circuit gate LeYel 1
f gate res

3857.081 s

2664585 1395.605 s 2664585 34.947 s 6.269 s
2A20 s

f nb In Gates

f res solution out 595i4 f bin.:!int !liQ!t 2307 85359

1.150 s

Figure 24: Matlab Profile Display showing the execution time ofSimV2 functions

6.6.2. Timing Results of SintVI Simulator
Table 34 shows the execution time for ISCAS'85 benchmark circuits based on transient injection at drain of a switch for "of = 8" and "of speedup of 3.2 of"nF = 8" versus "of
23". The speedup column shows an average

= 23". The execution time corresponding to

"nV = I"

(Le. One test vector) is used to plot the number of switches versus the simulation execution time

88

for one test vector as shown in Figure 25. The data of this plot are quadratic. (EQ - 6 - 4) shows the fitting equation extracted from Matlab ofthe quadratic curve.
TSimV1

= 3.1 * 10-4 * X2 -

7.6 * 10- 2 * X + 1.3

*

10 2

(EQ-6-4)

TsimVl: Represents the execution time X: Represents the number of switches in CUT

Table 34: Timing results extracted from SimV I simulator based on transient injection at drain of switch
nT.d nT.d

T(nF= 8) Tcycle 0.00205 0.03301 0.08312 0.06761 0.1342 0.21302 0.28719 0.41203 0.54873 0.58 T(nF= 8) 2.206688525 2945 33235.24 7361.11 154142.04 192071.61 592667.5 576196 580689.64 2091258.44 T(nF=23) 7.05359563 9570.73841 106900.87 23275.7591 490083.022 619285.182 1884857.23 1827081.32 1873519.18 6644837.28 nV= 1 0.3944918 236.58754 1449.6363 974.60358 3699.701 9659.2858 17240.535 37122.418 63072.859 71456

SpeedupnF 8 vs 23 3.196461825 3.249826284 3.216491597 3.161990393 3.179424783 3.224241114 3.180294561 3.170937182 3.226369219 3.17743477

Benchmarks C17 C432 C499 C880 C1908 C2670 C3540 C5315 C6288 C7552

nF=8 1074 89226 399840 108883 1148576 901650 2063684 1398426 1058249 3605618

nF=23 3433 289969 1286082 344287 3651811 2907137 6563123 4434321 3414302 11456616

89

:

/

i

I

i 'I r~t~r-1---i--t--t-+--t-+--+-+I- f--r--1f---jииии--.+-+---.f.- j 1

o

5000

10000

15000

20000

nL: Humber of switches

Figure 25: SimV I Simulation time for ISCAS'85 benchmark circuits based on transient injection at drain of a switch

6.6.3. Timing Results of SimV 2 Simulator
Table 35 shows the execution time for ISCAS'85 benchmark circuits based on transient injection at drain of a switch. The different parameters in this table are as follows: T(RFGate-leve1): Represents the simulation execution time of the resolution function gate-level T(PAlgorithm): Represents the simulation execution time needed apply the algorithm in order to build the profiling maps ofSimV2 simulator.
90

T(SimV2): The execution time to run SimV2 simulator for all test vectors. T(SimV2), nV=l: The execution time to runSimV2 simulator for one test vector. The execution time of T(PAlgorithm) is insignificant in comparison to T(RFOate-level) as shown in Table 35. Figure 26 shows the plot of T(SimV2) versus Npg (i.e. the number of progressive logic gates). This plot is not a good quadratic approximation due to different reasons. One of the reasons can be caused by accessing the arrays of the gates as the different processed gates have different sizes in terms of inputs and this can result in a large amount of data to access creating an irregularity of used gate types due to the type of CUT. Equation ( EQ - 6 fitting equation extracted from Matlab.
TSimV2

5) shows the

= 8.7 * 10-12 * X2 +

2.4 * 10-5

* X + 0.99

(EQ-6-5 )

TsimV2: Represents the execution time of SimV2 X: Represents Npg

Table 35: Timing results extracted from SimV2 simulator
Benchmarks

I T(RFOale.lcveI) I T(P
0.1 13.43 227.8 36.64 927.35 1721.74 4116.64 3857.41 1968.34 35222.64
.

AlgQrithm)

I T(SimV I nV I T(SimV
2)

2),

nV = I

C17 C432 C499 C880 C1908 C2670 C3540 C5315 C6288 C7552

0.16 1.06 2.12 1.47 3.91 4.3 6.79 7.98 7.21 lU5

0.26 14.49 229.92 38.11 931.26 1726.04 4123.43 3865.39 1975.55 35233.79

12 27 52 16 106
44

0.021666667 0.536666667 4.421538462 2.381875 8.785471698 39.22818182 49.08845238 104.47 164.6291667 482.6546575

27 27260 191889 73919 388520 807084 1395284 2664585 2922152 6175854

84 37 12 73

91

600

tI
i

I i L~-<

;

Ii!

iiLll

I

i

I

!

500

400

300

200

100

o

10

20

30

40

so

60

70

80

Npg+ Circuit: Number of progresive gates + number of gates of CUT

Figure 26: SimV2 Simulation execution time for ISCAS'85 benchmark circuits.

92

6.6.4. Performance Study of the developed Simulators
Table 36 shows the execution time for SimV I and SimV2 simulators based on all the applied test vectors and for transient injection at drain of a switch. The table shows an average speedup of 147 ofSimV2 versus SimV I . Table 37 shows the execution time for SimV. and SimV2 simulators based on one test vector and for transient injection at drain of a switch. The table shows an average speedup of 320 of SimV2 versus SimVI. The speedup of SimV2 versus SimVI seems to reduce when a larger set of test vectors is used. Even with a large number of test vectors, SimV2 achieves a significant speedup in comparison to SinV I simulator.

93

Table 36: Perfonnance and speedup ofSimV2 versus SimV\ based on all applied test vectors and based on transient injection at drain of a switch

Benchmarks
C17 C432 C499 C880 C1908 C2670 C3540 C5315 C6288 C7552

T (SimV))
2.20668853 2945 33235.24 7361.11 154142.04 192071.61 592667.5 576196 580689.64 2091258.44

T (SimV 2)
0.26 14.49 229.92 38.11 931.26 1726.04 4123.43 3865.39 1975.55 35233.79

Speed Up
8.487263558 203.2436163 144.5513222 193.1542902 165.5198763 111.2787711 143.7316748 149.0654242 293.9382147 59.35377488
147.232423

Average Speed Up

94

Table 37: Perfonnance and speedup ofSimV2 versus SimVt based on one test vector and based on transient injection at drain of a switch

Timing comparison based on one test vector
i i

Benchmarks
C17 C432 C499 C880 C1908 C2670 C3540 C5315 C6288 C7552

T (SimV t )
0.3944918 236.587542 1449.63632 974.603582 3699.70099 9659.28585 17240.5346 37122.4182 63072.859 71456

T (SimV 2)
0.021666667 0.536666667 4.421538462 2.381875 8.785471698 39.22818182 49.08845238 104.47 164.6291667 482.6546575

Speed Up
18.2073137 440.8463507 327.8579009 409.1749489 421.1158048 246.2333302 351.213651 355.3404635 383.1208059 148.0478825 310.115845

i
I

Average Speed Up

95

Chapter 7 Conclusion

The advanced switch-level models used in this work are implemented for soft error detection and can inject transients of different strength and logic levels at any location type in a combinational circuit. An algorithm is developed in this work to speed up the simulation execution time. The experiments conducted on ISCAS'85 benchmarks circuits led to the following conclusions: и The soft error coverage based on gate of a switch and Inputs of a logic gate are in the same range and achieved an average of 0.9. On the other hand and for transient injection at drain of a switch the average fault coverage is 0.6. и The developed algorithm based simulator in this work achieved a speedup of 310 for all the test vectors and 147 for one test pattern versus the developed non-algorithm based simulator in this work и The algorithm based simulator is divided into two modules, gate-level resolution function and the algorithm module. The execution time of the algorithm module is insignificant in comparison to the gate-level resolution function, thus the bottle-neck of this simulator is the

96

gate-level module. The execution time of the simulator can be improved as the literature is filled with various optimized gate-level based simulators and the combination of this algorithm with an optimized gate-level simulator can add a significant speedup to the simulation.

97

PlTBLICATIONS
1.

Kalkat, P.K.; Sedaghat, R.; Chikhe, J.M.; Javaheri, R.; , I1Soft error injection using advanced switch-level models for combinational logic in nanometer technologies,"
Microelectronics (ICM), 2009 International Conference on , vol., no., pp.332-335, 19-22

Dec. 2009

98

BIBLIOGRAPHY
[1]

R. C. Baumann, "Single event effects in advanced CMOS Technology," in Proc. IEEE
Nuclear and Space Radiation Effects Conf. Short Course Text, 2005.

[2]

M. P. Baze, S. P. Buchner, "Attenuation of single event induced pulses in CMOS combinational logic," IEEE Transactions on Nuclear Science, vol. 44, pp. 2217-2223, December 1997.

[3]

Premkishore Shivakumar, Michael Kistler, Stephen W. Keckler, Doug Burger, Lorenzo Alvisi, "Modeling the Effect of Technology Trends on the Soft Error Rate of Combinational Logic", Proceedings of the 2002 International Conference on Dependable Systems and Networks, p.389-398, June 2002.

[4]

P. Civera, L. Macchiarulo, M. Rebaudengo, M. Sonza Reorda, M. Violante," Exploiting Circuit Emulation for Fast Hardness Evaluation", IEEE Transactions on Nuclear Science, Volume 48, Issue 6, pp. 2210-2216, December 2001.

[5]

S. Kundu, M.D.T. Lewis, 1. Polian, B. Becker." A soft error emulation system for logic circuits," Conference on Design of Circuits and Integrated Systems, page 137,2005.

[6]

Kim, S., Iyer, R. K., "Impact of Device Level Faults in a Digital Avionic Processor", Proc. AIAAlIEEE 8th Digital Avionics Systems Conference (DASC), Oct 17-20, 1988, pp. 428-436.

[7]

V. Degalahal et aI., "SESEE: soft error simulation and estimation engine," Proceedings

of MAPLD International Conference, 2004.

99

[8]

J.P. Hayes, "Pseudo-Boolean Logic Circuits," IEEE Transactions on Computers, vol. 35, no. 7, pp. 602-612, July 1986.

[9]

Dahlgren P, Liden P, "Efficient Modeling of Switch-Level Networks Containing Undetennined Logic Node States", Proeedings of IEEEIACM Int. Conf. on CAD, pp. 746-752, November 1993.

[10] Veri log Hardware Descriptor Language Reference Manual (LRM) DRAFT, IEEE-STD 1364, 1995. [11] Ejlali A, Miremadi SG, "FPGA-based fault injection into switch-level models", Journal of microprocessors and microsystem, Elsevier Science, 28(5-6): pp.317-27, April 2004. [12] I.A. Delong, B.W. Johnson, lA. Profeta Iii, A fault injection technique for VHDL behavioral-level models, IEEE Design and Test of Computers 13 (4) (1996) 24-33. [13] E. lenn, J. ArIat, M. Rimen, 1 Ohlsson, 1. Karlsson, "Fault injection into VHDL models: the MEFISIO tool," Proceedings of 24th International Symposium on FaultTolerant Computing, 1994, pp. 336-344. [14] Reza Javaheri, Reza Sedaghat," Dynamic Strength Scaling for Delay Fault Propagation in Nanometer Technologies", 14th International CSI conference, 2009. [15] Kalkat, P.K.; Sedaghat, R.; Chikhe, I.M.; lavaheri, R.; , "Soft error injection using advanced switch-level models for combinational logic in nanometer technologies," Microelectronics (ICM), 2009 International Conference on, vol., no., pp.332-335, 1922 Dec. 2009

100

[16] http://www.asicnorth.com/images/asicNorth automated analog verification. pdf Relationship between strength levels and voltage levels for 1.8 supply voltage. [17]
http://www.eecs.umich.edu/~jhayes/iscas/

{SeAS' 85 benchmark circuits. [18] Hamzaoglu I, Patel J.H, "Test set compaction algorithms for combinational circuits",

IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems,
Volume 19, Issue 8, Page(s):957 - 963, August 2000.

101

