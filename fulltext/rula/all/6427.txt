DESIGNING OF AN ALGEBRAIC SIGNATURE ANALYZER FOR MIXED-SIGNAL SYSTEMS AND TESTING

By

Muhammad Mohsin Babar Bachelor of Science in Electrical and Electrical Engineering, Ahsanullah University of Science and Technology, Dhaka, Bangladesh, 2005

A project presented to Ryerson University

in partial fulfillment of the requirements for the degree of Master of Engineering in the Program of Electrical and Computer Engineering

Toronto, Ontario, Canada, 2017 © Muhammad Mohsin Babar, 2017

AUTHOR'S DECLARATION

I hereby declare that I am the sole author of this project. This is a true copy of the project, including any required final revisions.

I authorize Ryerson University to lend this project to other institutions or individuals for the purpose of scholarly research

I further authorize Ryerson University to reproduce this project by photocopying or by other means, in total or in part, at the request of other institutions or individuals for the purpose of scholarly research.

I understand that my project may be made electronically available to the public.

ii

Designing of an Algebraic Signature Analyzer for Mixed-Signal Systems and Testing
Muhammad Mohsin Babar Master of Engineering Electrical and Computer Engineering Ryerson University, Toronto, 2017

ABSTRACT
While the design of signature analyzers for digital circuits has been well researched in the past, the common design technique of a signature analyzer for mixed-signal systems is based on the rules of an arithmetic finite field. The analyzer does not contain carry propagating circuitry, which improves its performance as well as fault tolerance. The signatures possess the interesting property that if the input analog signal is imprecise within certain bounds (an inherent property of analog signals), then the generated signature is also imprecise within certain bounds. We offer a method to designing an algebraic signature analyzer that can be used for mixed-signal systems testing. The application of this technique to the systems with an arbitrary radix is a challenging task and the devices designed possess high hardware complexity. The proposed technique is simple and applicable to systems of any size and radix. The hardware complexity is low. The technique can also be used in algebraic coding and cryptography.
iii

CONTENTS

AUTHOR'S DECLARATION...................................................................................................................... ii ABSTRACT................................................................................................................................................. iii FIGURES ...................................................................................................................................................... v TABLES ...................................................................................................................................................... vi CHAPTER 1: INTRODUCTION ................................................................................................................. 1 CHAPTER 2: SCOPE OF THIS PROJECT ................................................................................................. 3 CHAPTER 3: A NOVEL METHOD .......................................................................................................... 11 CHAPTER 4: APPLICATION ................................................................................................................... 19 4.1: HARDWARE OVERHEAD ........................................................................................................... 20 4.2: TIME OVERHEAD ......................................................................................................................... 22 CHAPTER 5: EXPERIMENTAL SETUP ................................................................................................. 27 CHAPTER 6: FUTURE WORK AND CONCLUSION ............................................................................ 35 APPENDICES ............................................................................................................................................ 36 A. VHDL CODE ..................................................................................................................................... 36 B. BLOCK DIAGRAM .......................................................................................................................... 38 C. PIN PLAN .......................................................................................................................................... 39 D. WAVE FORMS ................................................................................................................................. 40 REFERENCES ........................................................................................................................................... 43

iv

FIGURES
Figure 1 Figure 2 Figure 3 Figure 4 Figure 5 Figure 6 Figure 7 Figure 8 Figure 9 Figure 10 Figure 11 Figure 12 Figure 13 Figure 14 Figure 15 Figure 16 Figure 17 Figure 18 Figure 19 Figure 20 Figure 21 Figure 22 Figure 23 Figure 24 Figure 25 Figure 26 Figure 27 Figure 28 Figure 29 Figure 30 Figure 31 Figure 32 Built-in signature analysis of a circuit under test ...................................................................... 5 A t-stage polynomial division circuit ........................................................................................ 5 A symbolic presentation of a one-stage algebraic signature analyzer....................................... 5 A logic level presentation of the algebraic 3-input signature analyzer ..................................... 6 A symbolic presentation of a one-stage arithmetic signature analyzer ..................................... 7 A 3-input arithmetic compactor .............................................................................................. 10 A symbolic form of an algebraic SA for a mixed-signal CUT ............................................... 12 A more detailed symbolic form of the SA .............................................................................. 13 A register transfer level implementation of the SA ................................................................ 15 An -bit comparator................................................................................................................ 20 A binary-weighted version of the SA...................................................................................... 21 A register transfer level implementation of the 3-bit SA ........................................................ 24 A 3-bit signature analyzer data flow ....................................................................................... 24 The experimental setup ........................................................................................................... 25 Altera DE2-115 ....................................................................................................................... 25 Altera DE2-115 Descriptions .................................................................................................. 26 9S12 ADC Transer Function................................................................................................... 28 The combination "1" is detected: ADC is operating properly on Seed 233............................ 31 The combination "1" is detected: ADC is operating properly on Seed 250............................ 31 The combination "1" is detected: ADC is operating properly on Seed 251............................ 32 The combination "1" is not detected: ADC is faulty on Seed 201.......................................... 32 The combination "1" is not detected: ADC is faulty on Seed 234 .......................................... 33 The combination "1" is not detected: ADC is faulty on Seed 252 .......................................... 33 An 8-input signature analyzer ................................................................................................. 34 Block Diagram ........................................................................................................................ 38 PIN Planner ............................................................................................................................. 39 PIN Identifications .................................................................................................................. 40 All output code deviations are within the tolerance bounds ................................................... 40 Some of the output code deviations exceed the tolerance bounds .......................................... 41 Some of the output code deviations in MAX .......................................................................... 41 Some of the output code deviations in MIN ........................................................................... 42 Some of the output code deviations in NOMINAL ................................................................ 42

v

TABLES
THREE REPRESENTATIONS FOR THE ELEMENTS OF (23 ) GENERATED BY () =  +  + . HERE () = . ......................................................................................... 7 Table 2 RELATIONSHIP BETWEEN INPUT TEST STIMULI AND OUTPUT RESPONSES ...... 30 Table 1

vi

CHAPTER 1: INTRODUCTION
A number of mixed-signal testing approaches have been proposed to detect faults in digital circuitry [1]-[2]. Early approaches were primarily aimed at defect oriented testing of the digital circuitry for manufacturing and system-level testing [2]-[3]. More recent approaches are target digital functional test and measurement, or specification oriented testing [4]-[6]. Signature analysis has been widely used for digital and mixed-signal systems testing [1]­[12]. Mixed-signal systems consist of both digital and analog circuits; however, the signature analysis method is only applicable to the subset of these systems that have digital outputs (such as analog-to digital converters, measurement instruments etc.). Signature analysis can be employed as an external test solution or can be embedded into the system under test. In the built-in implementation, a circuit under test (CUT) of digital or mixed signal nature is fed by test stimuli, while the output responses are compacted by a signature analyzer (SA), as illustrated in Figure 1. The actual signature is compared against the fault free circuit's signature and a / decision is made. A signature of a fault free circuit is referred to as a reference signature. If the CUT is of a digital nature, the SA essentially constitutes a circuit that computes an algebraic remainder. The reference signature has only one, punctual value, and the decision-making circuit consists of a simple digital comparator. If the CUT is of a mixed-signal

1

nature, the SA computes an arithmetic residue. In this case, the reference signature becomes an interval value and the decision-making circuit uses a window comparator. Design methods for an algebraic signature analyzer have been well developed in error-control coding [13]. A remainder calculating circuit for an arbitrary base (binary or non-binary) can be readily designed for a digital CUT of any size. In contrast, it is much harder to design a residue calculating circuit, specifically for a non-binary base [14]. Furthermore, due to the presence of carry propagating circuitry, the implementation complexity and error vulnerability of the residue calculating circuit is higher compared to the remainder calculating circuit. We propose an approach to designing an algebraic signature analyzer that can be used for mixed-signal systems testing. Due to an algebraic nature, the analyzer does not contain carry propagating circuitry. This helps to improve its error immunity, as well as performance.

2

CHAPTER 2: SCOPE OF THIS PROJECT
Designed of an algebraic signature analyzer on the basis of a polynomial division circuit, as shown in Figure 2 [3], [13], [15]. This circuit divides the incoming sequence of non-binary symbols (digits), - , . . . ,  ,  , treated as a polynomial: () = - - + ... +   + 
Eq. 1

by the polynomial: () =   +  +   +  ,   
Eq. 2

The remainder: () = - - + ... +   + 
Eq. 3

constitutes a CUT signature. Each digit,  ,      -  consists of  bits and is considered to be an element of the field ( ). The degree of the polynomial (2), or the number of stages, , in Figure 2, depends on the desired probability of undetected error in the sequence of incoming digits. For long sequences with independent errors, this probability is estimated as   - . In practice,    and even for the onestage circuit,   -(×) = . , which is quite low. Therefore, a
3

multiple-input signature analyzer normally contains only one stage. Such an analyzer is presented in Figure 3 [14], where  is a primitive element of the field ( ), i.e. a root of a primitive polynomial () = - - + ... +   + 
Eq. 4

The field of each element can be represented by a power of . Let   be the incoming digit and   be the content of the analyzer. Then, each operational cycle of the analyzer is described by the expression:     = 
Eq. 5

Without a loss of generality, we will consider a -bit signature register ( = ), with  being a primitive element of ( ), in particular, a root of a primitive polynomial () =  +  + . Then, a symbolic scheme of Figure 3 will transfer to the logic level circuit of Figure 4, where  =   +   +  ,   {, },     ,     
Eq. 6

()

()

()

()

4



k j

i

Figure 1

Built-in signature analysis of a circuit under test

Test Stimuli

Circuit Under Test

Output Responses

Signature Analyzer

Actual Signature Reference Signature

Decision Making Circuit

Pass Fail

Figure 2

A t-stage polynomial division circuit

1 pt

p t-1

p1

p0

s t-1

···

s1

s0

a m1 ···1 0

Figure 3

A symbolic presentation of a one-stage algebraic signature analyzer

5

a2 d2

a1 d1

a0 d0

Figure 4

A logic level presentation of the algebraic 3-input signature analyzer

This expression indicates the relationship between the power and vector representations of a field element, as reflected in Table I (  = ). If the preliminary "cleared" analyzer receives, for example, the following sequence of 3-bit output responses from a digital CUT,  ,  ,  ,  ,  ,  ,then after the  -  shift its content will become: ((((( ·  +  ) +  ) +  ) +  ) +  ) +  = 
Eq. 7

The power representation of the field element, , corresponds to the vector representation, 010, which is the actual signature of the CUT. In contrast to a digital CUT, the output responses of a mixed-signal CUT are distorted even in a fault-free case. Small permissible variations in the responses cause a significant deviation of the final signature. For example, if in the above
6

Table 1

THREE REPRESENTATIONS FOR THE ELEMENTS OF (23 ) GENERATED BY () =  +  + . HERE () = . Polynomial Representation () 2 () () 2  + 1  + 0  0  0  1  2  1 +  0  2 +  1  2 +  1 +  0  2 +  0 Vector Representation () () () 2 1 0 0 0 0 0 0 1 0 1 0 1 0 0 0 1 1 0 1 1 1 1 1 1 0 1

Power Representation   0  0  1  2  3  4  5  6

b a+ j aj

ai

Figure 5

A symbolic presentation of a one-stage arithmetic signature analyzer

sequence of output responses the least significant bit in the first response changes from    (i.e. the vector  changes to , or power  changes to  ), then the actual signature will change from    (or from  to  in power form).

7

Apparently, the conventional SA represented in Figures 3 and 4 cannot be employed for mixed-signal circuits testing. The known methods, output responses of mixed-signal circuits are compacted by a circuit referred to as a modulo adder (or accumulator, or digital integrator) [4]­ [8]. It should be noted that a modulo adder is a special case of a    [14]. A residue computing circuit is represented in Figure 5. Here  is the current content of the register,  is the incoming (arithmetic) symbol and  is the base of the system. This circuit divides the incoming data sequence of symbols, - , . . . ,  ,  , treated as a number:  = - - + ... +   + 
Eq. 8

by the modulus  = - - +  +   +  ,   
Eq. 9

As in the case with the algebraic SA, we consider a singlestage device, i.e.  = ,  =  <  = 
Eq. 10

where  is the number of bits occupied by the symbol. The residue,  , constitutes a signature.

8

An operational cycle of the circuit in Figure 5 can be described by the expression:   +  = +  ()
Eq. 11

Although the circuits of Figures 3 and 5 look similar, their implementation is quite different. In general case, the designing procedure for the arithmetic circuits is more complicated and their hardware complexity is greater. As an example, Figure 6 represents the circuit that computes a modulo 5 residue of the incoming sequence of 3-bit symbols treated as an octal number [14]. Here  is the incoming octal digit and  is a combinational circuit which generates the following next state signals:
       =       +  (   +    )
Eq. 12











         =    ( +  ) +   (  +   ) +  ( +  ) +  (  )
Eq. 13















         =    (  ) +   ( +   ) +  +   (  +   +















   )
Eq. 14



9

Each shift of this circuit implements the operation  ×  +  (). In addition to high hardware complexity, the arithmetic compactor contains carry propagating circuitry (shown in red color in Figure 6) that delays the operation and aggravates the effect of a single fault.
S

S

c

2 aj 2 S S

i a2

c C

1 a j 1 S S

i a1

c

0 a j 0 S S

a i 0

Figure 6 A 3-input arithmetic compactor Below, we design an algebraic circuit that can be employed for mixed-signal data compaction. It does not contain carry propagating circuitry.

10

CHAPTER 3: A NOVEL METHOD
The polynomial (1) in conjunction with the reference signature can be considered as a code word of the code whose minimal distance is defined by the (). The distance here is the Hamming distance. This distance characterizes algebraic error-detecting properties of the code and is not convenient for arithmetic errors that occur in mixed-signal systems. Indeed, a small permissible deviation of the data to be compacted causes the reference signature to span the entire space. Under these conditions, the decision-making circuit in Figure 1 must be able to compare the actual signature with the entire set of possible reference signatures. This increases the analyzer complexity. To decrease the complexity, an arithmetic SA treats the sequence of output responses from a mixed-signal circuit as a number (4). In conjunction with the reference residue, this is considered as a code word of an arithmetic error-control code. The properties of this code depend on the arithmetic minimal distance which in turn depends on the modulus . The arithmetic residue calculating analyzer does not search the entire space, since the space of arithmetic reference signatures is now contiguous. To make a decision, it employs a window comparator. This simplifies the circuitry. However, the hardware complexity of the arithmetic SA can still be quite high, as it was illustrated above.

11

In the rest of this paper, we will show how to design an algebraic SA, which generates a contiguous space of algebraic reference signatures. In order to be contiguous, the space of signatures must be ordered. A signature can be represented in the vector or power forms. We will use the power exponent as the criterion for ordering the signature set. The distance between two vectors (signatures) will be evaluated as the arithmetic difference between the corresponding exponents. For example, the distance between the signatures  and  will be 5, because the exponents of powers  and  differ by . We can interpret these

j

 j+i

i

Figure 7

A symbolic form of an algebraic SA for a mixed-signal CUT

12

i 2n-1 2n-2 . . . . . . i 1 0  j+2 -2 ···  
n

MUX

 j+i ···

 j+1

 j+0 j

 j+i



Figure 8

A more detailed symbolic form of the SA

exponents as output responses of a mixed-signal CUT, since they possess arithmetic properties. At the same time, the corresponding vectors (signatures) possess algebraic properties. Therefore, an arithmetic data is mapped into an algebraic data. Figure 7 represents the circuit which performs the mapping and computes an algebraic signature. The circuit of Figure 7 can be obtained from the circuit of Figure 3 by the following transform:

13

-

( +  )   = ( )- = ( )  =   + ++ =   + 
Eq. 15

Since the finite field ( ) is closed and errors are independent, this mapping will not change the probability of undetected error. The logic level implementation of the circuit of Figure 7 is more complex compared to the circuit of Figure 3, but it is less complex than that of the circuit of Figure 5. Prior to designing the circuit, we have to make a few observations. The  observation is that
   = (...  ( )) ...  
Eq. 16

Let us denote an output response from a mixed-signal CUT as . The second observation is that the response  can be considered as an exponent of the power, i.e.

14

 . Essentially, this means that the arithmetic values  are mapped into algebraic values  . Based on these observations, we can design a signature analyzer in the way shown in Figure 8. Here  is a primitive element of a finite field ( );  coincides with the bitlength of the output responses. The lower and upper inputs of the multiplexer in Figure 8 are connected together, since 
 -

=   ( ).

Figure 9

A register transfer level implementation of the SA

15

Considering the case when the analyzer is fed by -bit data, its more detailed implementation will have the form of Figure 9. Here the buses consist of 3 lines, as indicated by the appropriate number. The initial content of the SA before the shift is  , or   +   +  in the polynomial form (we have omitted the superscripts for the sake of simplicity). The notations  and +  , where   can be one of the , , , indicate the present and next states, respectively. A multiplier by  in ( ) is realized bearing in mind that () =  +  + ,  corresponds to , and (  +   +  )  () = (  +   +  ) () =  ( + ) +   +   =   + ( +  ) + 
Eq. 17

This operation is shown by cross-lines in Figure 9. The multiplexer inputs "0" and "7" are tied together, because  =  in the field ( ).

16

In order to demonstrate how to use this analyzer, we will assume that it receives only two values from a CUT, in particular   . Since the CUT is of a mixedsignal nature, there is an unavoidable (and thereby permitted) deviation of these values by ± (the greater tolerances can also be considered). The analyzer will map the received data into ± and ± , respectively. If we assume that the initial content of the SA is 001 (versus 000 for a conventional SA), then after the first shift the content becomes  ± = ± . After the second shift, it changes to ± ± = +± . This expression is derived using the interval arithmetic rules. It states that for the fault-free CUT the actual result must match one of the values from the interval [+- , ++ ], that is one of the following: +- , +- , + , ++ , ++
Eq. 18

To further simplify the SA operation, we will assume that instead of  (. . ) the initial SA content is -(+) . We will refer to this value as the  value. Then, by the same reasoning, the SA content after two shifts will match one of the following powers: - , - ,  ,  , 
Eq. 19

17

Due to the closure property of the field ( ), this power set is equivalent to:  ,  ,  ,  , 
Eq. 20

Consequently, the decision-making circuit in Figure 3 will work as follows. If the actual signature does not match any value from the set (20), the CUT is considered to be faulty. Since these values are ordered (and surround the power  ), the decision-making circuit can employ a comparator, thereby reducing the hardware complexity of the SA. As in any signature analyzer, some errors in the CUT output responses may escape detection. The aliasing rate can be estimated as described in [16] and will coincide with the aliasing rate of the conventional analyzer.

18

CHAPTER 4: APPLICATION
Let us assume a -bit CUT, which is fed by two input stimuli. Under the faultfree operation, the CUT produces the output responses  =  ±  and  =  ± .Therefore, the seed value will be -(+) = -(+) = - =  ,   in the vector form. If the CUT is fault-free, then after  shifts the SA content must match one of the elements in the set (20). For example, if the actual responses are  +  =  (  )   +  =  (  ) (i.e. the variations are within the tolerance bounds), the signature will be    =  which belongs to the set (20). And the decision-making circuit will generate a pass signal. The validity of such a decision is determined by the aliasing rate. Let us assume that a fault in the CUT has made the following changes in the output responses:   (   )    (   ). Then the actual signature will become    =  . This element does not belong to the set (20), so the fault is detected. There are two distinct ways of designing the decision-making circuit depending on the optimization criteria (time or hardware overhead).

19

4.1: HARDWARE OVERHEAD
If performance is paramount and time overhead is not desirable, the following approach can be employed. Let  be the number of output responses. All of the  +  -multiplier outputs (see Figure 8) that belong to the set (20), are connected to the first inputs of the  +  comparators of a similar type. The second inputs of these comparators are shared and fed by the vector . . . . If the CUT is fault-free, one of the comparators will produce a logic "" signal. The logic OR of the comparator outputs will constitute a / signal. The above procedure is based on the fact that the fault-free CUT produces one of the signatures from the set (20). If the actual signature is  , the comparator connected directly to the signature register produces a logic "", thus indicating that the CUT is fault free. If the actual signature is  , then the product  , generated at the output of the first -multiplier equals to , which is detected by the next comparator. The same

{

· · ·

Figure 10

An -bit comparator
20

. . .

i

0 1 2n-1

···

0 1 2

0 1 

j

Figure 11

A binary-weighted version of the SA

reasoning applies to the rest of signatures from the set (20). The logic diagram of the -bit comparator is shown in Figure 10.

21

4.2: TIME OVERHEAD
If time overhead is allowed, the hardware complexity can be further reduced. In terms of implementation, it is more convenient to use the following seed value: -(+++) where  is the number of output responses. For the above example, -(+) =  , and the set (20) will transform to:  ,  ,  ,  , 
Eq. 21

After the last output response, has been shifted in, the SA continues to shift its content  +  more times, while the input  is forced to . This ensures that the SA content is multiplied by  with each shift. For the above example,  +  = . If within this time, the match with an element of the set (21) has been determined, the CUT is considered to be fault-free. Otherwise, it is faulty. If the CUT is fault free and its output responses have not exceeded their tolerances, then while cycling through the states during the extra  +  shifts, the output of the multiplexer in Figure 8 will go through the power  or vector . . . . The match with the vector . . .  is detected by the comparator of Figure 10 connected to the multiplexor's output. The comparator output is actually producing a / signal.

22

The implementation complexity of the circuit of Figure 8 increases significantly with the growth of the data width, . Therefore, this circuit can only be implemented for the output responses with relatively low values of . For greater values of , we will modify the circuit of Figure 8 to the one shown in Figure 11. The modified circuit contains binary-weighted stages and is more economical in terms of hardware. The complexity of the multiplier ×  is comparable with that of the multiplier × , whereas the number of multipliers drops from   . The economy increases with the growth of . For the case of -bit data, the circuit of Figure 11 transfers to the one shown in Figure 12. This circuit operates much in the same way. The  -multipliers structure is determined from the following expressions: (   +   +  )  () =    + ( +  ) +    (   +   +  )  () = ( +  )  + ( +  ) +    (   +   +  )  () = ( +  +  ) + ( +  ) + ( +  )
Eq. 22

23

Figure 12

A register transfer level implementation of the 3-bit SA

Figure 13

A 3-bit signature analyzer data flow

24

VC C R S Sw Freescale 9S12DG128 VC C R V

A7 A6 A5 A4 A3 A2 A1 A0

D Altera DE2 Cyclone II 2C35

Vi
Str

Figure 14

The experimental setup

Figure 15

Altera DE2-115

25

Figure 16

Altera DE2-115 Descriptions

26

CHAPTER 5: EXPERIMENTAL SETUP
The proposed method of signature analysis has set up for experimental setup to test the proposed method of signature analysis is shown in Figure 14. The setup includes the microcontroller system board Adapt9S12D (Technological Arts Inc.) based on the Freescale's 9S12DG128 microcontroller, and the Alt era DE2 Development board based on the Cyclone II EP2C35F672C6 field-programmable gate-array (FPGA) device. We have selected 16 input test stimuli (voltages equally distributed over the range
(  . ) ,)

and applied them to the analog-to-

digital converter (ADC) of the 9S12 microcontroller (which served as a mixed-signal system). Each input voltage,
,

was measured by a high-precision voltmeter and

regarded as a nominal test input value. The circuit in Figure 14 operates as follows. Every time the switch  is closed, the system performs 8 measurements of the same test signal and averages the result by accumulating the sum of the eight -bit measurements and shifting it right three times, which eliminates noise. The ADC transfer characteristic is presented in Figure 16 [17]. According to this characteristic, each conversion result for a properly operating device can deviate from the nominal value by ±, which is an implication of the fact that the permissible differential nonlinearity can range from -.   + .  LSB (see shadowed boxes in Figure 16). For example, if conversion result can be $, $  $ (in the worst case,
27  =

 , the

Figure 17

9S12 ADC Transer Function

the points  and  coincide). Therefore, each of the thirty-two -bit average results contain an error of at most ± count. The test stimuli have been selected equal to the midpoints of the quantization bins, thereby increasing the uncertainty and worsening the probability of undetected error. If the test stimuli would have been selected at the transition points of the characteristic, the probability of undetected error (aliasing rate) would improve. This follows from the observation that each conversion would result in  possible values as opposed to  possible values in the previous case.
28

As soon as average values of the conversion results are computed by the microcontroller, they are transferred to the DE2 board. The transfer of each data is accompanied by a high-to-low transition of the strobe signal . The  signal serves as a  for the state machine that implements the signature analyzer (in its -bit configuration). The signature, , is displayed on a two-digit -segment display in hexadecimal form. The first experiment was performed on the properly operating device. In the second experiment, the average results were corrupted digitally in the microcontroller (thereby simulating random faults in the ADC) and sent to the analyzer. The analyzer has correctly identified the faulty device. The relationship between input voltages and output codes is presented in Table II. Based on this Table and taking into consideration that () =  +  +  +  + 
Eq. 23

the seed value is calculated as follows.  + + . . . + =  =   ( - ) =  - =  =    =  - =  =  =  In addition to test experiments, the operation of the analyzer (the DE2 part of the test setup) was simulated using Altera Quartus II software. Based on the two
29

experiments represented in Table II, the signatures that correspond to fault-free and faulty ADCs are respectively , ,  and , ,  (in decimal form). Table 2 RELATIONSHIP BETWEEN INPUT TEST STIMULI AND OUTPUT RESPONSES

Input Voltage mV 80 400 720 1040 1360 1680 2000 2320 2640 2960 3280 3600 3920 4240 4560 4880

Output Code Min 3 19 35 51 67 83 99 115 131 147 163 179 195 211 227 243 Nom 4 20 36 52 68 84 100 116 132 148 164 180 196 212 228 244 Max 5 21 37 53 69 85 101 117 133 149 165 181 197 213 229 245 No Fault 3 21 37 53 68 85 99 117 133 148 165 179 197 212 229 244 Fault 3 21 37 53 70 85 99 117 133 150 165 179 197 240 230 244

30

Figure 18

The combination "1" is detected: ADC is operating properly on Seed 233

Figure 19

The combination "1" is detected: ADC is operating properly on Seed 250

31

Figure 20

The combination "1" is detected: ADC is operating properly on Seed 251

Figure 21

The combination "1" is not detected: ADC is faulty on Seed 201

32

Figure 22

The combination "1" is not detected: ADC is faulty on Seed 234

Figure 23

The combination "1" is not detected: ADC is faulty on Seed 252

33

Figure 24

An 8-input signature analyzer

The process of calculation of these signatures is demonstrated in Figures 28 and 29. Figures 18, 19, 20 and 21, 22, 23 represent the fault detection process. The actual final signatures are shifted additionally  times. If the value  appears in the analyzer during these shifts, the system is fault free. Otherwise it is faulty. The simulation results matched the experimental results.

34

CHAPTER 6: FUTURE WORK AND CONCLUSION
Mixed signal systems test and measurement using Signal Analyzer is complex and can require considerable knowledge and effort by designer for successful implementation. We examined an algebraic signature analysis method that can be employed for mixed-signal circuits testing. We demonstrated how to design the appropriate device. To simplify the hardware description model, hardware elements can be conditionally generated using simulation software. This device does not produce arithmetic carries and is therefore less prone to errors. The absence of carry propagating circuitry also contributes to the higher performance of the device. Stimuli output for respective Seed for the fault-free or faulty system's signature were evaluated analytically. The proposed scheme can also be used in arithmetic and algebraic error-control coding, as well as cryptography. Future work to complement this work would be to implement the signature analyzer circuits in arithmetic error-control coding to verify a more accurate evaluation of time delay, overhead, and fault secure property of the circuit.

35

APPENDICES
A. VHDL CODE
library ieee; use ieee.std_logic_1164.all; ENTITY SigAnalyzer IS PORT (sin res, clk seed sout END SigAnalyzer;

: IN : IN : IN : BUFFER

STD_LOGIC_VECTOR(7 DOWNTO 0); STD_LOGIC ; STD_LOGIC_VECTOR(7 DOWNTO 0); STD_LOGIC_VECTOR(7 DOWNTO 0));

ARCHITECTURE Behavior OF SigAnalyzer IS SIGNAL w128, w64, w32, w16, w8, w4, w2, w1: STD_LOGIC_VECTOR(7 DOWNTO 0); SIGNAL f128, f64, f32, f16, f8, f4, f2, f1 : STD_LOGIC_VECTOR(7 DOWNTO 0); COMPONENT mux2to1 PORT (w0,w1 : IN STD_LOGIC_VECTOR(7 DOWNTO 0); s : IN STD_LOGIC; f : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)); END COMPONENT; BEGIN PROCESS (res, clk) BEGIN IF res = '0' THEN sout <= seed; ELSIF Clk'EVENT AND Clk = '0' THEN sout <= f128; END IF; END PROCESS; stage128: mux2to1 PORT MAP (f64, w128, sin(7), f128); stage64: mux2to1 PORT MAP (f32, w64, sin(6), f64); stage32: mux2to1 PORT MAP (f16, w32, sin(5), f32); stage16: mux2to1 PORT MAP (f8, w16, sin(4), f16); stage8: mux2to1 PORT MAP (f4, w8, sin(3), f8); stage4: mux2to1 PORT MAP (f2, w4, sin(2), f4); stage2: mux2to1 PORT MAP (f1, w2, sin(1), f2); stage1: mux2to1 PORT MAP (sout, w1, sin(0), f1); -w128(7) <= f64(7) XOR f64(6) XOR f64(4) XOR f64(0); w128(6) <= f64(6) XOR f64(5) XOR f64(3); w128(5) <= f64(7) XOR f64(5) XOR f64(4) XOR f64(2); w128(4) <= f64(6) XOR f64(4) XOR f64(3) XOR f64(1); w128(3) <= f64(7) XOR f64(6) XOR f64(5) XOR f64(4) XOR f64(3) XOR f64(2); w128(2) <= f64(5) XOR f64(3) XOR f64(2) XOR f64(1) XOR f64(0); w128(1) <= f64(6) XOR f64(2) XOR f64(1); w128(0) <= f64(7) XOR f64(5) XOR f64(1) XOR f64(0); -w64(7) <= f32(7) XOR f32(4) XOR f32(3) XOR f32(1); w64(6) <= f32(6) XOR f32(3) XOR f32(2) XOR f32(0); 36

w64(5) w64(4) w64(3) w64(2) w64(1) w64(0) -w32(7) w32(6) w32(5) w32(4) w32(3) w32(2) w32(1) w32(0) -w16(7) w16(6) w16(5) w16(4) w16(3) w16(2) w16(1) w16(0) -w8(7) w8(6) w8(5) w8(4) w8(3) w8(2) w8(1) w8(0) -w4(7) w4(6) w4(5) w4(4) w4(3) w4(2) w4(1) w4(0) -w2(7) w2(6) w2(5) w2(4) w2(3) w2(2) w2(1) w2(0)

<= f32(7) XOR f32(5) XOR f32(2) XOR f32(1); <= f32(7) XOR f32(6) XOR f32(4) XOR f32(1) XOR f32(0); <= f32(7) XOR f32(6) XOR f32(5) XOR f32(4) XOR f32(1) XOR f32(0); <= f32(7) XOR f32(6) XOR f32(5) XOR f32(1) XOR f32(0); <= f32(6) XOR f32(5) XOR f32(3) XOR f32(1) XOR f32(0); <= f32(5) XOR f32(4) XOR f32(2) XOR f32(0); <= f16(6) XOR f16(3) XOR f16(0); <= f16(5) XOR f16(2); <= f16(7) XOR f16(4) XOR f16(1); <= f16(7) XOR f16(6) XOR f16(3) XOR f16(0); <= f16(5) XOR f16(3) XOR f16(2) XOR f16(0); <= f16(7) XOR f16(6) XOR f16(4) XOR f16(3) XOR f16(2) XOR f16(1) XOR f16(0); <= f16(5) XOR f16(2) XOR f16(1); <= f16(7) XOR f16(4) XOR f16(1) XOR f16(0); <= f8(7) <= f8(7) <= f8(6) <= f8(5) <= f8(7) <= f8(5) <= f8(6) <= f8(7) <= f4(5) <= f4(4) <= f4(7) <= f4(6) <= f4(4) <= f4(7) <= f4(7) <= f4(6) XOR f8(6) XOR f8(4) XOR f8(1); XOR f8(6) XOR f8(5) XOR f8(3) XOR f8(0); XOR f8(5) XOR f8(4) XOR f8(2); XOR f8(4) XOR f8(3) XOR f8(1); XOR f8(6) XOR f8(3) XOR f8(2) XOR f8(1) XOR f8(0); XOR f8(4) XOR f8(2) XOR f8(0); XOR f8(3); XOR f8(5) XOR f8(2); XOR f4(4) XOR f4(3) XOR f4(3) XOR f4(2) XOR f4(3) XOR f4(5) XOR f4(6) XOR f4(5) XOR f4(3); XOR f4(2); XOR f4(2) XOR f4(1); XOR f4(1) XOR f4(0); XOR f4(1) XOR f4(0); XOR f4(4) XOR f4(2) XOR f4(0); XOR f4(5) XOR f4(1); XOR f4(4) XOR f4(0);

<= f2(7) XOR f2(3); <= f2(7) XOR f2(6) XOR f2(2); <= f2(7) XOR f2(6) XOR f2(5) XOR f2(1); <= f2(6) XOR f2(5) XOR f2(4) XOR f2(0); <= f2(7) XOR f2(5) XOR f2(4); <= f2(6) XOR f2(4); <= f2(5); <= f2(4); <= f1(5); <= f1(4); <= f1(7) XOR f1(3); <= f1(7) XOR f1(6) XOR f1(2); <= f1(7) XOR f1(6) XOR f1(1); <= f1(6) XOR f1(0); <= f1(7); <= f1(6); 37

-w1(7) <= sout(6); w1(6) <= sout(5); w1(5) <= sout(4); w1(4) <= sout(7) XOR sout(3); w1(3) <= sout(7) XOR sout(2); w1(2) <= sout(7) XOR sout(1); w1(1) <= sout(0); w1(0) <= sout(7); END Behavior; -- 8-bit mux2to1 component library ieee; use ieee.std_logic_1164.all; ENTITY mux2to1 IS PORT (w0,w1 : IN STD_LOGIC_VECTOR(7 DOWNTO 0); s : IN STD_LOGIC; f : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)); END mux2to1; ARCHITECTURE Behavior OF mux2to1 IS BEGIN f <= w0 WHEN s='0' ELSE w1; END Behavior;

B. BLOCK DIAGRAM

Figure 25

Block Diagram
38

C. PIN PLAN

Figure 26

PIN Planner

39

Figure 27

PIN Identifications

D. WAVE FORMS

Figure 28

All output code deviations are within the tolerance bounds

40

Figure 29

Some of the output code deviations exceed the tolerance bounds

Figure 30

Some of the output code deviations in MAX

41

Figure 31

Some of the output code deviations in MIN

Figure 32

Some of the output code deviations in NOMINAL

42

REFERENCES
[1] R. Frohwerk, "Signature Analysis: A New Digital Field Service Method," Hewlett Packard J., vol. 28, no. 9, pp. 2­8, 1977. [2] G. Starr, Q. Jie, B. Dutton, C. Stroud, F. Dai, and Vector P. Nelson, "Automated Generation of Built-in Self-Test and Measurement Circuitry for Mixed-Signal Circuits and Systems," in Proc. 24th IEEE International Symposium on Defect and Fault Tolerance in VLSI Systems , pp. 11­19, 2009. [3] D. K. Pradhan and S. K. Gupta, "A New Framework for Designing and Analyzing BIST Techniques and Zero Aliasing Compression," IEEE Transactions on Computers, vol. 40, no. 6, pp. 743­763, 1991. [4] C. Stroud, J. Morton, T. Islam, and H. Alassaly, "A Mixed-Signal Builtin Self-Test Approach for Analog Circuits," in Proc. Southwest Symposium on Mixed-Signal Design, 2003, pp. 196­201, 2003. [5] N. Nagi, A. Chatterjee, Y. Heebyung, and J. Abraham, "Signature Analysis for Analog and Mixed-Signal Circuit Test Response Compaction," IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, vol. 17, no. 6, pp. 540­546, 1998.

43

[6] N. Nagi, A. Chatterjee, and J. Abraham, "A Signature Analyzer for Analog and Mixed-Signal Circuits," in Proc. IEEE International Conference on Computer Design: VLSI in Computers and Processors , pp. 284­287, 1994. [7] S. Mir, M. Lubaszewski, V. Liberali, and B. Courtois, "Built-in Self-Test Approaches for Analogue and Mixed-Signal Integrated Circuits," in Proc. 38th Midwest Symposium on Circuits and Systems. Proceedings, vol. 2, pp. 1145­1150, 1995. [8] J. Rajski and J. Tyszer, "The Analysis of Digital Integrators for Test Response Compaction," IEEE Transactions on Circuits and Systems II: Analog and Digital Signal Processing, vol. 39, no. 5, pp. 293­301, 1992. [9] W. Liu and J. Lei, "An Approach to Analog and Mixed-Signal BIST based on Pseudo Random Testing," in Proc. IEEE International Conference on Communications, Circuits and Systems," pp. 1192­1195, 2008. [10] F. Corsi, C. Marzocca, and G. Matarrese, "Defining a BIST-Oriented Signature for Mixed-Signal Devices," in Proc. IEEE Southwest Symposium on Mixed-Signal Design, pp. 202­207, 2003.

44

[11] S. Demidenko, V. Piuri, V. Yarmolik, and A. Shmidman, "BIST Module for Mixed-Signal Circuits," in Proc. IEEE International Symposium on Defect and Fault Tolerance in VLSI Systems (Cat. No.98EX223), pp. 349­352, 1998. [12] T. Damarla, "Implementation of Signature Analysis for Analog and Mixed Signal Circuits," U.S. Patent US6367043 B1, Apr. 2, 2002. [13] W. Peterson and E. Weldon, Error Correcting Codes. Cambridge, MA: The MIT Press, 1972. [14] V. Geurkov, "Optimal Choice of Arithmetic Compactors for MixedSignal Systems," in Proc. IEEE International Symposium on Defect and Fault Tolerance in VLSI and Nanotechnology Systems (DFT), pp. 182­ 186, 2012. [15] S. Lin and D. Costello, Error Control Coding. Upper Saddle River, NJ: Pearson Education, Inc., 2004. [16] V. Geurkov, V. Kirischian, L. Kirischian, and R. Sedaghat, "Concurrent Testing of Analog-to-Digital Converters," I-manager's Journal on Electronics Engineering, vol. 1, no. 1, pp. 8­14, 2010.

45

[17] MC9S12DT128 Device User Guide, Motorola Inc, V02.11. Rev. May 2004, [Online]. Available: (http://www.cse.chalmers.se/~svenk/mikrodatorsystem/HC12/reference_ manuals/9S12DT128/9S12DT128DGV2.pdf)

46

