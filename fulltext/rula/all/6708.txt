Implementation of Space Vector Pulse Width Modulation on System on Programmable Chip

by

Vincent Luong

A project presented to Ryerson University in a requirement for the degree of Master of Engineering in the Electrical and Computer Engineering program

Toronto, Ontario, Canada, 2010

I

RYER~O;~ UNWil1SlTY LfBRAlrl

PROPfiflr.Y Of

Declaration

I hereby declare that I am the sole author ofthis thesis report.

I authorize Ryerson University to make copies ofthis thesis by any means, in whole or in part, for the purpose of scholarly research.

Signature:

II

Acknowledgements

I would like to express my sincere gratitude to my supervisor Professor Richard Cheung for his guidance. His tremendous patient and constant encouragement has helped me accomplishing what I thought to be beyond my ability. I am grateful to my wife and sons for their love and support. Because of my study, many weekend activities were cancelled. I give thanks to my Lord Jesus for everything I have. To Him all glory belongs!

III

Abstract

For years, DSP has been the dominant tool in implementing gate switching for power inverter. It is a powerful and reliable technology in carrying out complex switching schemes. DSP is still expensive due to its intensive use of resource in chip fabrication. There is no flexibility in making change on hardware once a DSP chip is selected. It is also time consuming in a design development because the learning curve of the DSP is stiff. Recently, a new approach to the problem has emerged. It is called embedded system design. Basically, it is a FPGA system combined with a RISC type microprocessor. This is a robust combination that allows users to pick and choose any functional peripheral devices only as needed. Once the complete hardware platform is decided upon, the circuit is configured and down loaded to a chip. Software codes are then written to run the application. The hardware system is reconfigurable. Designers can always go back to change the hardware with ease in order to improve the performance and to meet the target cost. This is an attempt to utilize the embedded system design also called System on Programmable Chip (SOPC) to perform Space Vector Modulation (SVM) gate switching strategy. The Altera Nios II IDE tool is selected for this task.

IV

Table of Content
Chapter I Introduction .......................................................................... 1 1.1 Objective .............................................................................. .1 1.2 Background ............................................................................. 1 1.3 Methodologies ......................................................................... 4 1.4 ProposaL ................................................................................ 6

Chapter II
2.1 2.2 2.3 2.4 2.5

Principal of Space Vector Modulation ........................................ 8
Switching State ........................................................................ 9 Space Vector ........................................................................... 10 Dwell Time Calculation ............................................................. 13 Modulation Index ..................................................................... 15 Switching Sequence .................................................................. .16
SVP~

Chapter III 3.1 3.2 3.3 3.4

Matlab Simulation ................................................... 20

Specification .......................................................................... 20 Simulating Scheme .................................................................. 21 Result ................................................................................... 21 Observation ........................................................................... 27

Chapter IV SVPWM Realization by SO PC иииии.ииииииииии.ииииииииииииииииииииииииииии.ии 28 4.1 Target Board .......................................................................... 28 4.2 Embedded Processor .................................................................. 29 4.3 System Development Flow .......................................................... 30 4}.1 Hardware Development Tasks ..........................................32 4.3.2 Software Development Tasks ........................................... 34 4.3.3 Refining Hardware and Software ..................................... 35 4.4 Creating The Design ................................................................. 35 4.5 Design Result ......................................................................... 52 4.6 Future Work: Multiple Processors System ............................................. 54 Chapter V Conclusion ........................................................................... 57

Appendix A Matlab Simulink Block Diagram ............................................59 Appendix B Software Codes in C Programming Language.............................62
References .......................................................................................... 71

V

Lists of Figures

Figure 2-1 Simplified Schematic of an Inverter .......................................... 8 Figure 2.1-1 Switching State Definition ................................................... 9 Figure 2.1-2 All Switching State Combination ............................................ 10 Figure 2.2-1 Space Vector Diagram ........................................................ 11 Figure 2.3-1 Dwell Time and Voltage Vectors ........................................... 14 Figure 2.5-1 Switching Sequence in Sector I ............................................. 17 Figure 2.5-2 Switching Sequence in All Six Sectors .................................... 18 Figure 3.2-1 Simulation Logic Flow ....................................................... 20 Figure 3.3-1 Simulation output at f=60Hz, fsw=900Hz, tIla=0.7 ....................... 21 Figure 3.3-2 Simulation output at f=60Hz, fsw=900Hz, tIla=O.5 ....................... 22 Figure 3.3-3 Simulation output at f=60Hz, fsw=900Hz, tIla=O.2 ....................... 23 Figure 3.3-4 Simulation output at f=30Hz, fsw=900Hz, tIla=0.9 ....................... 24 Figure 3.3-5 Simulation output at f=10Hz, fsw=900Hz, tIla=0.9 ....................... 25 Figure 3.3-1 Table of Simulation output and Its Load Current THD .................. 26 Figure 4.1-1 Target Board ................................................................... 28 Figure 4.3-1 Embedded System Design Flow ........................................... .30 Figure 4.3.1-1 Preliminary Design Block ................................................. 32 Figure 4.3.2-1 Software Algorithm ....................................................... .33 Figure 4.4-1 SOPC Builder GUI ........................................................... 35 Figure 4.4-2 On-chip Memory MegaWizard ............................................ .36 Figure 4.4-3 NIOS II Processor Core GUI ............................................... 37 Figure 4.4-4 Floating Point GUI .............................................. ;............. .38 Figure 4.4-5 Serial Communication GUI ................................................ 38 Figure 4.4-7 Interval Timer MegaWizard ............................................... 39 Figure 4.4-8 PIO MegaWizard ............................................................ 40 Figure 4.4-9 System ID Peripheral Interface Box ..................................... .41 Figure 4.4-10 Content of Complete System ............................................ .42 Figure 4.4.5-1 System Module .............................................................43 Figure 4.4.5-2 FPGA Pin Assignment MegaWizard .................................. .43 Figure 4.4.7-1 Software Main Flow Chart .............................................. .44 Figure 4.4.7-2 Flow Chart of Some Subroutines ....................................... .45 Figure 4.4.7-3 Overview of Switching Pattern, Timing Sequence and Interrupt Timers ...................................................................................................................... 48 Figure 4.5-1 Waveforms of Software Simulation and Hardware Output ............ 52 Figure 4.5-2 Matlab Simulation Waveforms ............................................ 53 Figure 4.6-1 Multiple Processors in Open Loop Control System .................... 55

VI

VII

VIII

Chapter I Introduction
1.1 Objective
The focus ofthis report is on the implementation of space vector modulation for induction load or motor using System on Programmable Chip (SOPC) method. The advantages of the induction motor over the DC motor will mentioned, two main pulse width modulation schemes will be discussed, different ways to apply the scheme will be examined before heading to the proposal.

1.2 Back Ground
The fIrst induction motor was invented by Nicola Tesla in 1888. To this day, it still remains the most rugged, reliable, less expensive to build and the least maintenance required machine. In comparison with a DC motor, the DC one relies on built in permanent magnets for flux generation in order for the machine to run. The induction motor produces its flux through the supply voltages. Hence, the induction machine is lighter in term ofweigh and output power ratio. In addition, the rotor ofthe DC machine brings about a turning force as the current carrying conductor is placed inside the magnetic fIeld. This conductor is connected to the power source through some kind brushing mechanism. Over times, this connector gets corroded due to wear and tear that affects the performance of the motor. Therefore, periodic maintenance must be carried out to ensure its effIciency [1]. For induction motor, the supply voltages in the stator give

1

offa rotating field. This moving field induces voltage in the rotor. In the case of squirrel cage induction motor where the rotor windings are short circuited, the flowing current creates a rotor flux. Consequently, the rotor flux reacts with the stator flux to yield torque to the rotor. The whole process requires no external connection to the rotor. Therefore, the motor is rugged and needs no maintenance [2]. The advantages of the induction motor out weigh that of the DC motor. It was, however, not commonly used in the early days because the motor has a fixed speed which depends on the frequency of the voltage source. Recent advancement in power electronic has given the induction motor a face lift in its applications which can be found in robotics, machine tools and hybrid vehicles [3]. The general scheme for controlling the speed of the induction motor involves an AC to DC rectifying process and a DC to AC transformation procedure. A typical unit takes AC power source, rectifies it into a steady DC voltage, and then converts it back to a desired frequency AC waveform. This DC to AC sub unit is called an inverter, which is how the motor control inverter has its name. There are two main methodologies to convert DC to AC for induction motors. One method is called Sine Pulse Width Modulation (SPWM) or Voltage Frequency (VF) control. The other is Space Vector Modulation (SVM). The principal of the sinusoidal PWM scheme is that a control sine wave at the desired frequency is compared with the triangular wave at constant amplitude. The frequency ofthe triangular wave set the inverter switching frequency [4]. Traditionally, VF control was popular mainly due to its uncomplicated implementation and the least on chip computation requirement. This algorithm has some major drawbacks. First of all, it

2

is not able to fully utilize the supply DC voltage. Less than 90% of DC supply voltage is used. Secondly, it has substantial high Total Harmonic Distortion (THD) which results in heat generated in switching devices and larger heat sink is needed. The THD is worsening when the frequency modulation index defmed by the ratio of carrier and modulating frequency is not an integer. It brings about a so called non characteristic harmonics whose frequency is not a multiplication ofthe fundamental frequency. This poses a challenge in designing a proper filter to eliminate the unwanted frequency [5]. This method also imply an inefficient way to use the memory since three 120 degree phase shifted sine tables have to be stored in the chip memory in order to generate the necessary sine waves [6]. The SVM algorithm is based on the fact that for a balanced three phase system, the sum of vectors representing 3-phase line to neutral AC power supply sine waves is zero. Hence, these vectors can be expressed as a single space reference vector in a and ~ plane [7]. By controlling the amplitude and the rotating speed ofthis vector, the motor's torque and speed can be regulated. The SVM is an advanced and computation intensive technique which gives 15% more voltage output compared to the SPWM method [8]. It generates less THD. Nowaday, this technique is widely adopted in motor speed regulation. The main challenge ofthe SVM approach lays in the calculation of the angle between two vectors. The trigonometric function such as sine and cosine to defme angle can be solved conventionally by interpolating from a detailed table ofthe known values. The end result may lack ofthe resolution needed for some applications. Modem day computers resolve that problem mainly by Taylor series with very high precision. That

3

requires large amount of hardware resources and long computing time on the computers part [9]. How fast the angles are worked out determines how well the performance of SVM. In fact, estimating the angles becomes the bottle neck ofthe entire process.

1.3 Methodologies
Over the years, with the progress of microelectronics and its cost reduction have made the SVM feasible in real time. There are many ways to carry out the scheme of which in general can be categorized into two three main streams: software, hardware and the combination of both. With many choices available, today designers have to juggle between the performance, cost effective and the ease of implementation in adopting the best method for their application. Until recently, software stream has been realized by high speed microprocessor such as RISC machines and DSP. This approach is very flexible and able to accomplish complex algorithms, but the disadvantages are long development time, poor portability of programming codes and more CPU resources. DSP still is comparatively expensive. RISC stands for Reduced Instruction Set Computer. The idea behind the creation ofRISC processor is based on the observation that only a small percentage ofa processor's basic instructions are used in majority of cases. Therefore, it is better to build processors where those instructions are handled efficiently on simplified and faster hardware [10]. The instructions ofRISC engine are simple and fixed in size so that the implementation for this faster hardware called pipe lined machines can be made easy. The concept the pipeline is borrowed from assembly line in manufacturing process. Instead of putting all the time and resource into processing one computer code, the entire operation

4

can be divided into smaller different stages where codes are managed continuously. The end result is that, after the initial delay, commands are completed in every cycle. DSP are designed for extensive enumeration purposes. It is also a RISC machine with Harvard architecture. This architecture utilizes segregated, independent program and data memories with different buses so that the two memories can be accessed at the same time. It allows an instruction and an operand to be fetched from memory in one clock cycle [11]. In order to make quick calculation, all DSP processors equip with at least one fast hardware multiplier. This fast multiplier is able to bear result in a single clock cycle. Some advance DSP employ parallel execution technique called parallelism where second or more multipliers are needed. Floating point data formats are generally used in DSP algorithms and hence complex hardware are developed for this format. Since much hardware circuits are used in its construction, DSP remains the most expensive computation machine. Also, dedicated hardware requires specialized instruction set, programmers can only optimize codes in assembly level instead of high level languages as C and C++. This may prolong system development time [12]. Recent arising of the field programmable gate array or FPGA technology, has given designers a new arsenal in tackling comprehensive enumerating challenge. This is the hardware approach for SVPWM. FPGA is an array of many logic blocks that are linked by horizontal and vertical wiring channels. A logic block consists of many logic elements which embodies look up tables (LUT), a programmable flip-flop with a synchronous enable, a carry chain, and a cascade chain. The FPGA chip is configured by a specific programming code called hardware description language (HDL). A HDL programmer can ''write'' a hardware and down load it onto a FPGA chip which performs

5

as a complex combinational function or even like an application specific integrated circuit (ASIC). The hardware is reconfigurable and therefore complicated circuits can be realized and tested in very short time. In addition, instead of executing instructions sequentially as in software approach, FPGA is able to carry out different tasks simultaneously [13]. There is no need for external wiring; the system is reliable. As a result, sine and cosine function modules, PWM output waveform module [14] and even an entire SVPWM core [15] are developed. This has greatly enhanced the SVPWM performance where the sampling rate can reach as high as 40 KHz [16]. There are a few disadvantages; a new programmable language is to be learned; proficiency in fmite state machine (FSM) design and handshaking protocol is a must in order to have all these hardware modules working together in correct timely manner.

1.4 Proposal
The quest for faster sampling time is propelled by Field Oriented Control (FOC) in servo motors. This is because in the heart ofFOC, sit the SVPWM. To achieve dynamic performance, FOC demands high sampling rate. However, not all SVPWM applications have to be high speed. In the case of high power medium voltage (MY) drive, the switching frequency of the inverter is usually below 1 KHz [17]. The reason is that the switching devices can't handle over that frequency range. This gives rise to the proposal ofthis report as high sampling rate is not required. A hardware and software combined method called embedded system design is introduced. An embedded system is a digital system with at least one processor that implements a hardware function which is part of an over all system. The Embedded

6

processors are typically rusc machines which are used the same way as microcontrollers. The main difference is that embedded system allows more flexibility and design customization due to its reconfigurable capability [18]. Designers are able to choose the hardware functions and merge together with microprocessors then down load the system into a FPGA chip. Assembler or high level language such as C and C++ is written to program the processor. The entire process necessitates a software tool called System on a Programmable chip or SOPC. This tool provides graphic user interface (GUI) for system components selection and generates interconnect logic automatically. SOPC outputs HDL files that defme all modules of the system and HDL design file that connects all modules together for the purpose of FPGA configuration. Besides that, it offers features to write software codes and to do simulation for the prototype. The SOPC used to realize SVPWM in this report belongs to Altera's Quatus software package. The sampling rate of this SVPWM method depends on how sophisticate the hardware components are selected or created. A process will be shown later that this method is easy to implement. This paper is organized as the following. The next chapter demonstrates the principle of vector modulation technique. Chapter III simulates SVPWM using Mathlab and its results are served as benchmark in comparing with the real implementing results. Chapter IV executes SVPWM by SOPC mean. Chapter V concludes the report.

7

Chapter II Principle of Space Vector Pulse Width Modulation

The theory presented here is base on the text book; High power converter and A C
drive by Professor Bin Wu [19].

Voltage source inverter (VSI) is the unit that converts a DC voltage to a threephase AC voltage with varying amplitude and frequency. The inverter is made up of six group of active switches, S 1 - S6 . Each switch has a free-wheeling diode coupled in parallel. A simplified schematic for a voltage source converter for a typical high power medium voltage is shown in Fig.2-1. Base on the DC operating voltage ofthe inverter, each switching group may composes two or more IGBT or GCT connected in series.

o--~------~------~~------~

Figure 2-1 Simplified schematic of an inverter

8

2.1 Switching state
Before introducing the SVPWM theory, some of the terminologies are familiarized in order to have a better understanding. The operating status of the switches in each inverter branch is represented by switching states. P is denoted as upper switch being turned on and its inverter terminal carrying positive voltage (Vd). 0 stands for the lower switch being turned off and its inverter terminal having zero voltage. Figure 2.1-1 provides the defmition of the switching state.

Switching State

LEG A
SI ON OFF S4 OFF ON
UAN

S3 ON OFF

LEGB S6

UBN

S5 ON OFF

LEGe S2

U eN

P
0

Vd
0

OFF ON

Vd

OFF ON

Vd

0

0

Figure 2.1-1 Switching State Definition

There are eight combinations of the switching states for the inverter. For instants, combination [P 0 0] corresponds to the conduction of SI, S6, and S2 in legs A, B, C accordingly. Within the eight switching states, [P P P] and [0 0 0] are the zero states, the rest are active states. Figure 2.1-2 lists the definition of all combinations.

9

Space Vector

Switching State

On-state Switch

Vector Definition

Zero Vector

VO

[PPP1 rOOOI

Sh S3, S5 S4, S6, S2 Sh S6, S2

V.0-0 2 '0 V; =-Vde}

~
Active Vector Vl

[POO]

3

[PPO]

S., S3, S2

Vz

=-Vd e
3

2

j~
3

V3

[OPO]

S4, S), S2

2 V3 =-Vde

,211'

3

V4

[OPP]

S4, S3, S5

2 V =-Vde
4

,311' }-

3

3

Vs

lOOP]

S4, S6, S5

_ 2 /tr Vs =-Vde 3

3

V6

[POP1

Sh S6, S5

2 ,5tr ]V6 =-Vde 3

-

3

Figure 2.1-2 All Switching State Combination

2.2 Space Vector PWM This theory is better demonstrated in graphical way. The active and zero switching states can be represented as active and zero state vectors. A space vector diagram is shown in figure 2.2-1.

10

The six vectors V 1 to

V6 form a regular hexagon with six equal sectors (I to VI).

The zero state vector, V o.lies in the centre of the hexagon. The reference vo ltage vector

V ref rotates within the hexagon at a certain speed.

jP.
-,:~;;-.m~7'""~"-"

!oI[CiORU I

I

....,.--------1~-....;.;.---

V ..poo

I..... ..и

a

St:(:U'RIV

St:C-'1'OR VI

P.
SECTOR V

Figure 2.2-1 Space Vector Diagram

The relationship between the space vector and the switching states can be derived as the following. From the inverter shown in figure 2-1, with the assumption that the inverter having three-phase balanced load, this expression is valid,

V,w (t) + VBO (t) + VCO (t)

:=

0

(2.2-1)

The state of Vco (t) is redundant, since it can be defmed by V,w (t) and Vso (t) . Also, it is convenient to transform the three-phase variable to two-phase variable.

11

(2.2-2)

Therefore, the space vector can be expressed in a - ~ plane two-phase voltages.
Vet)

= Va (t) + jVp (t)

(2.2-3)

Substituting (2.2-1) to (2.2-3),

(2.2-4)

where e

jx

= cos(x) + j sine x) and x = 0, 2It!3 and 41t13.

Considering the Active switching state [P 0 0] for example, the generated inverter phase vo ltages are
V,w(t)

= 2- ,

Vo 3

Vao(t) =

3

-V , Vco(t) = _ _ 0 3

(2.2-5)

The corresponding space vector, V; can be found by placing (2.2-5) to (2.2-4) 2 '0 Vi =-V e 1 (2.2-6)

---

3

d

In general, all six space vectors can be represented as

2 j(k-I)~ Vt=-Vde 3 wherek=1,2,3 ... 6
3

The zero-space vector Vo has two switching states. These two states are redundant to each other. The redundant state is used to minimize the switching frequency and eliminate the even harmonics. The zero and active space vectors are stationary in space and hence they are called stationary vectors.

12

The reference vector V ref, in figure circulates in space with an angular velocity at
0)

--

= 2ift

(2.2-8)

It
....

is the fundamental frequency of the inverter output voltage. The angle between

V ref and a- axis in the a-p plane is obtained by
B(t) = OJ(t)dt + B(O)
o

f

t

(2.2-9)

V

ref

can be approximated by the three stationary vectors for any given length and

position. These stationary vectors in turn determine the switching states ofthe inverter. As V ref rotates one revolution in space, the inverter completes one cycle over time. The generated output voltage frequency is proportional to the angular velocity of V ref and the output voltage magnitude is corresponding to the magnitude ofV ref.

-

-

2.3 Dwell Time Calculation

Since the spinning V ref can be composed by three stationary vectors, the length of these stationary vectors depends on the length of time assigned to them during the sampling period Ts . It is called the dwell time and is used to defme a moving vector position at that time instant. The dwell time calculation applies the 'voltage second balancing' principle. The principle states that the product ofthe reference voltage

-

.

V

ref

and the sampling period

r: equal to the sum of the voltage multiplied by time
....

interval ofthe selected space vectors. The sampling period Ts is always set small enough such that the reference vector is almost constant during Ts interval. Taking V ref inside the sector I for example, the voltage balancing equation is

13

(2.3-1)

Ta, Tb and To are the dwell times for iT I.

iT 2

and

iT 0 correspondingly.

The space vector in 2.3-1 can be shown as (2.3-2) Substituting 2.3-2 to 2.3-1 and then separate the resulting equation into real and imaginary components in the a-~ plane, Re:

1m:

(2.3-3)

\
/ . . . .". . .". . . . . . . . + . . . . . . . -

_

\

\

\

Sectorl

Vr<:r

~--~~~~--------~v.

\\

T,'V T.. I
Figure 2.3-1 Dwell Time and Voltage Vectors

Solving 2.3-3 with Ts

= Ta + Tb + To

yields

14

T
a

r:; Vref 7r =",3T -sin(--B) Vd 3
If

(2.3-4)

for Figure 2.3-1 illustrates the relation between dwell time and voltage vectors. The equations in 2.3-4 are derived when
Vref

falls in sector I. For other sectors,

-

V ref can be located by this general angle expression
B
и 7r = B-(k-l)-

3

for

7r O~B<-

3

where k=l, 2, 3, ... ,6 corresponding to sectors I, n, ... ,VI

2.4 Modulation Index
Modulation index dictates the magnitude of the inverter's output. Equation 2.3-4 can be used to express the modulation indexma.
r:; Vref и (7r B) =",3T -sm - V 3
8

Ta

d

T=T-T-T. o 1I a b

for

where

(2.4-1)

15

The maximum amplitude of the reference vector Vref иmax lies on the vertices of the hexagon outside the circle as shown in figure 2.2-1.

V
ref.max

=2V. J3 _Vd
3
d

2 -

J3

(2.4-2)

Substituting

Vref,max

into ma in 2.4-1 gives

ma =1
Therefore, the modulation is within the range of
O:5:m:5:1

(2.4-3)

and the peak fundamental voltage produced by SMV is

A

V max,SMV = Vref,max =

J3

Vd

(2.4-4)

2.5 Switching Sequence
The switching sequence for any to minimize the switching frequency. 1- Only one branch of the inverter switches change states, one being switched on and other being switched off, when one switching segment alters from one to the next. 2- As

-

V'ef

should follow these two guide lines in order

Vref travels from one sector to the next, none or minimum number of switches

change states. The figure 2.5-1 is an example of the switching sequence utilizing the above guide lines. The figure shows a seven segment sequence and inverter output voltage for
Vref

in sector I. It is observed that

16

- Sum of the different dwell times equals to the sampling time. - The transition from [0 0 0] to [P 0 0] involves only two switches which are SI (ON) and Sz (OFF). The requirement 1 is satisfied. - The redundant switching states of switching. - Each switch in the inverter is turned on and off once in one sampling period Ts Hence, the switching frequency

Vo are used to minimize the number of

law

is the same as the sampling frequency

Isp

и

Figure 2.5-1 graphs the essence ofthe switching sequence rule above in sector L
Jl-' il
i

VI
POO

j;
2

r~

I

000

pro

POO

V.iN

U ~~,_'" . . _.~~"~ . . . ~I~~.
,
i Vd . ,-:
......

. . . . .~ ..~I_ _

I
T, 2

,
:2

..,......

I vJ ... ...
,

1;1
2

, Ts

Figure 2.5-1 Switching Sequence in Sector I

17

Figure 2.5-2 summarizes the seven segment switching sequences of V ref in all six. sectors.

-

Sector
I II

uence

Yo
000

~
00

Y2
PPO

Yo
PPP

Y2
PPO

~
POO

Yo
000

Yo
000

Y3
OPO

Y2
PPO OPP

Yo
PPP

Y2
PO

Y3
OPO

Yo
000

III
IV

Yo
000

Y3
OPO

Yo
PPP

Y 4
OPP

Y]
OPO

Yo
000

Yo
000

Y4
OPP

Yo
000

V
VI

Yo
000

Ys
OOP

V;;
POP
P

Yo
000

Yo
000

~
POO

Y 6
POP

Yo
PPP

Y6
POP

~
POO

Yo
000

Figure 2.5-2 Switching Sequence in All Six Sectors

18

Chapter III SVPWM Matlab Simulation

It is always a good practice to simulate a design before actually carrying it out.
This allows designers to see the feasibilities and the performances of their would-be products preventing costly later alternation and time delay. The software package used for this project is Matlab Simmulink. The design specification is coming from an actual project.

3.1 Specifications
и и Inverter configuration: Three phase two-level inverter Rated inverter output voltage: 4160V (rms fundamentalline-to-line voltage) и и и Rated inverter output power: IMVA (three phase) DC link vol~age: constant, ripple free Inverter load: Three-phase balanced RL load with a lagging power factor of 0.9 The inverter base parameters

и и и

VB

=:;

VR13 = 41601 J3;;;; 2401.8V

IB =SRI3VB =(1*10 6 )/(3*2401.8) = 138.8A ZB =VBII B =2401.8/138.8=17.3.0

19

и
и

(j)B = 2trJ;. = 377.0rad I s
Load: R =17.3cos(8) =15.60 :. L

.: o:L =17.3sin( 8) = 7.54

= 20mH

Vd can be defined by modulation index when ma = 1 .
VABI =0.612 Vd :. V = VABI d 0.012

= 4160 =6797.4V
0.612

3.2 Simulating scheme
According to the theory of SVPWM, the position of the moving space vector at a time instant is determined by an angle fonned between the vector itself and horizontal axis. The dwell time is calculated based on the angle found at the moment. The switching pattern is decided upon by the sector where the V ref is located. For strategy wise, it is easier to fmd the sector right after the angle becomes known. The flow of the simulation logic is outlined in the figure 3.2-1.

/'

/
i',

Angle Locating

t===:::;-"'~ v

Sector Locating
/

f==-:::::::::::':v)1

Dwell Time Calculation
/

v

Switching Pattern

Figure 3.2-1 Simulation Logic Flow

3.3 Result
The result of the simulation is categorized by two types of graphs: one is the graphs of voltages and current waveforms; the other is the graph of harmonic spectrum

20

0.01
4

~O15

o.C'2

MZS

0.03

O.C'~5

0.04

O.C045

0.05

0.055

Ct.CtS

2

, ..

~I~~~~~ [I . .].:
~'
.... : .

\~'

"

.. ,

':"

%

'

.~"

..

>., ~ , .

0.015

0.02

o.!J2:5

0.03

0.035

0.04

Q.045

0.05

0055

O.OS

0.01

0.015

0.02

0.025

0.03

O.ms

0.04

0045

0.05

O.Ct55

O.CtS

-"!

\:.01

o.O~5

0.02

0.025

am

O.ms 0.04 hle(se:)

O.C45

O.OS

0."$5

0.00

{II.} Waveforms
F"nd .. m .."t..1 (!SOH,,) - 0.6956 и THD- 8.2. 16%

00
450

.to
3S

. "';;,;:

.".-

30

:;;..'4

25ID 1!O 10
~

0

0

&0

2000 .2500 I"r"'lи......"7 (Mq

!.II LlII,

illllllJL
3000 3500

40X1

Figure3.3-1:f=60Hz, fsw = 900Hz, ma =0.7, and T, =1.11ms

21

0.01

o.oi5

0.02

0.025

O.'J)

O.wS

O.'j4

0.045

0.e'5

0.055

0.00

0.01

0.0:5

0.02

0.025

0.03

0.035
t'Tle (set)

0.04

0.045

0.05

0.055

0.05

Fund;amfJnU,1 (SOHz) ... 0.4972 и THD'" 109 61 %

70
GO
'i::::;.'"O

>~

50 40

Xl
.20
10

o

0

fOO Frequency (Hz.)

(h) Ih.rmouLc

llp~tni:m

Figure 3.3-2:

f =60Hz, f sw =900Hz,

ma

=0.5, and r: = 1.1lms

22

0.0'

0.0'5

0.02

0.025

O.oJ

0.035

0.04

u.045

0.05

0.055

(l.C6

00';5

0.02

Cr.02S

0.03

0.035

0.04

0.045

0.05

M55

O.CtS

0.01

nO:5

0.02

oms

0.03

0.;)35

0.04

0.045

0.05

0.055

0.00

UD1

il015

0.02

0.025

om

0.035

O.D4

0.045

0.05

0.055

0.00

t"e :sec)
Fundamental (GOHz)

= 01989

и THO= 176.95%

100

80
60

40

o

o

.1 I.
&lO

til
.500
.2CO)

III
3000

I

I

10J0

2500

3500

4000

Fr~u~ey

(Hz)

(b) Uarmolllc

t;~mm

Figure 3.3-3: f

=60Hz, flfW =900Hz,

rna

=0.2,

and 1'., = 1.11rns

23

2

O.Ol

0.04

0.05

O.J5 (a) Wa,\-efortlu;

0.09

0.1

Fundamental (3OHz)

= 08:985

, THD= 5402%

Hi

~

"""~

10
5
oL-~

u

__~~~~U-~~~~~~~~~~UU~~~
500 1000 1500 2000 2500

Frequency (Hz) (h) Harmonic spectrum

Figure 3.3-4: f

= 30Hz, fsw = 900Hz,

ma

= 0.9,

and Ts

= l.11ms

24

he-~' 0.1;1.,;1 't; ~Neb"'1'~ ~:r.:LCeQ!71 s!'.'e"-1eo--re'"1

SVM

6~
4
,' .. ""
- ......
,

I I I
..-,.
~

r-

SilNors I

2

I

!.
0.1
O.~2

...... ,

., .

..,
0.2

:

r
0.24

(l00
4

0.'4

o.~&

0.i3

0.22

2
0

-2
-4

a.oa

0.1

O.~.2

o.~4

o.~s

0.13

ii2

02'.2

0..24

2
Cи

-2

o.ce
.2

,11

Cu2

0.14

o.~s

0.13

C.2

0.22

Q.24

{me (seo:)

(a) \\'aveforms
Fund<llment.d (10Hz) .. 0.0099 и THO- 53610/",

20

15

~ >~

10
6

a

.j

!~ .
1000 1500
::xn:J

o

2500

till

J II
3000 3500 4000

Frequency (Hz)

(n) Harmonie spectrum

Figure 3.3-5:

f =10Hz, f =900Hz, ma =0.9,
$IV

and Ts

=l.llms

25

Figure 3.3-1, -2, -3, -4 and -5 show simulations for the following cases A, B, C, D and E respectively. The THD result of the load current i A at 1000Hz range is included in Figure 3.3-1. Simulation
A B C D E
~

(Hz) 60 60 60 30 10

fsw (Hz)
900 900 900 900 900

ma
0.7 0.5 0.2 0.9 0.9

Ta (ms)
1.11 1.11 1.11 1.11 1.11

Load Current, iA , THD% 7.1 8.7 11.8 5.5 5.4

Figure 3.3-1 Table of Simulation output and Its Load Current THD

3.4 Observation The simulation result does prove that the theory works. With sampling rate remains the same through out, lower the rotating frequency yields better THD. The same is true for higher the modulation index. Higher sampling rate reduces the effect ofTHD. Most of the distortions occur at and over 900Hz range and are far away from the fundamental frequency. They can be easily filtered out.

26 PRW.:lf'( Cfi~ RYEFlWii liir.lm&IY lIDRAR'r

Chapter IV SVPWM Realization by SOPC

The best way to get familiar with Altera SOPC builder is to follow its tutorial on Nios II hardware development [20]. This tutorial serves as a guideline on designing a Nios II hardware system and then composing a software program to run on the system. Since the objective of this exercise is different from the thesis project, changes will be made as needed to fit the project's goal. .

4.1 Target Board .. The circuit board used here is the Altera DE2 Development and Education Board with Altera Cyclone II
(2C~5)

FPGA chip on it. It has a number of switches, LEDs, LCD,

and 7-segment displays either for input to the processor or visual indicator of processor activities for small project. It includes RS232 and PS2 for communication. For video and sound experiment, it provides connectors for microphone,. line-in, 24-bit audio CODEC line out, video in and VGA out. It also equips USB 2.0 connectivity for host and device. For more challenging experiments, there are SRAM, SDRAM, and Flash memory chip. The board runs at frequency of 50 MHz. Figure 4.1-1 is the picture of the target board

27

Figure 4.1 -1 Target Board

4.2 Embedded Processor
The Nios II processor is a general-purpose RISe machine . It comprises of a full 32-bit instruction set, data path, and address space; 32 general purpose registers , 32 external intemlpt sources; smgle
ins~ruction

32x32 multiplier and divider resulting in 32-

"it data ; floating point instruction for single preclsion floating point manipulation.

28

4.3 System Development flow

The embedded system development flow consists of three forms of development: hardware design, software design and system design which includes both hardware and software. For a simpler system, all ofthe above procedures can be performed by one person. For a more complex system, it may request several teams of engineers to cover all those steps. Figure 4.3-1 suggests the designing flow.
System Requirements analysis

~
Defining and Generating System in SOPC Environment: Nios Processor Cores and Standard Peripherals

~~
Integrating SO PC Builder System into Quartus Project Developing Software with the Nios II IDE: CI C++ programming. Custom Libraries, Peripheral Drivers

Pins Assignment

Compiling Software

Compiling Hardware for Target Chip

Downloading Software to Target Board

Downloading Design to the Target Board

Running and Debugging Software on Target Board

~~
Refining Software and Hardware

Figure 4.3-1 Embedded System Design Flow

29

Following the figure 4.3-1 suggestion, the requirement ofthe project has to be clearly defined. For SVM control scheme, calculation ofthe switching time and switching patterns are the predominant issues. The switching time calculation is determined by the sine trigonometry function of

an angle. This is done by mean of power series and hence a hardware multiplier is
incorporated inside the processor core.

. X 3 X 5 X7 Sm(X)=X+ - - - + ... 3! 5! 7!

(Equation 4.3.1)

The easiest way to achieve the switching pattern is to utilize interrupt timers. This is because the switching sequences change after a certain time interval according to the figure 2.5 .1.

4.3.1 Hardware Development tasks Based on these observations, a concrete system design is fmalized. This project requires a fast Nios II processor with a hardware multiplier for the power series calculation; seven interrupt timers for seven changes in switching sequences. The next step will be using

sope builder tool to specify the processor core, memory, and other

peripheral devices such as timers. The builder tool will automatically generate the interconnected logic to integrate the component in the system. In general, there are two classes of peripherals. One is the standard type such as timers, SDRAM, general purpose

va, even a secondary processor etc provided by Nios II Embedded Design Suite. The
other is the custom type like custom-made logics or the ready-made intellectual property (IP). There are two advantages; hardware implementation is faster than software; the

30

processor is free to execute other task in parallel while the peripheral operates on data. Ideally, a hardware sine function for SVM should be created to handle this kind of computation as hardware approach is always faster than software approach. This incurs higher development cost and longer development time. For the pilot run, the fastest and cheapest technique is used. Figure 4.3.1-1 shows the preliminary design for the SVM. Continuing the process, pins assignment for the IIO signals can be arranged with design constraints using the Altera SOPC builder. Finally, the entire project is compiled to produce an SRAM Object File to configure the FPGA. This file is then downloaded to the FPGA on the target board through the cable called Altera USB-Blaster.
Target Board
AII"era FPGA

VDD

-ии

]
G C 0,
T R

N ios II System Debug Control Instr
i

LEDO

'i' ./]
I"'J

~

,...

'V'--

r-ии I-ии Nf- l ии -ии a
L
L

N,osili.
Core Data

8

I
I
i

r----

IIC Ports

I 'L
,

LED1

)../1
1'-1

~

vI/'

!

JTAG UART

lED2~1./]
I"'J System Interconnect Fabric

~

10- pin JTAG Header

E

Character 110

-

R

r----

On-Chip Ram

I

T,merO и

и и и
TimerS SystemlD

-

I
I
System Clock

Other logic

I

I
Figure 4.3.1-1 Preliminary design Block

31

In this layout, JTAG UART is used for downloading both for hardware and software and for debugging. General VO ports PIO are used for switches with LEDs for visual effect. Several timer interrupts are required for setting up the switching patterns. Other logic is anticipated when the goal is not reached and custom made logic might be needed. 4.3.2 Software Development Tasks With the help ofNios II IDE, software development tasks for Nios II processor system are performed. Designers are able to write high level computer languages like C or C++ codes for the system. To interact with low level hardware components like turning on or off switches, Altera provides components drivers and a hardware abstraction layer (HAL) to facilitate such a task. Once the application program is compiled, it can be downloaded to the target board using the same USB-Blaster cable. The IDE debugger allows users to start and stop the program, step through codes, create break points, and examine variables. This debugger also provides a way to debug the software without the present ofthe target hardware. Figure 4.3.2-1 displays the software algorithm for the SVM. T to T7 represents the timer interrupt interval. In one sampling period, values ofT 0, T a, and T b are determined for the switching sequences.

32

One Sampling Period

I
To 4

I
+ Ta or ~ + Tb or Ta +
2 2 2 2
To 2

+ Tb or To + To or Tb +
2 2 2 2

To
4

Figure 4.3.2-1 Software Algorithm

4.3.3 Refining Hardware and Software
After running the software on the hardware, it might be that the performance does not meet the requirement. Designers can either go back to the software to make changes in algorithm or go to hardware to reconfigure the peripheral. Reconfigurable peripherals is one of the most distinguish difference between an embedded system and a fixed microcontroller. In this context, reconfigurable means that hardware features can be added or removed on a system-by-system basis to meet performance and price goal.

4.4 Creating the Design
Following are the step by step to implement the design using Nios II Development tool. This procedure is carried out closely adhering to the tutorial.

33

1. Install the design files for the Nios II Hardware Development Tutorial. Aft er hav ing the files unzipped, they are stored in a d irector. 2. Start the Quartus II software and open the tutorial proj ect. 3. Create a new SOPC builder system by clicking SOPC builder on the tool menu in the Quartus II software . On the Create New System dialog box, type system name. This project uses the same name as suggested in the tutorial which is

flrst_nios2_system. Figure 4.4-1 shows the SOPC builder GUl in the early state.
I .! AIt.r. SOP( OUIlM'

',nt nlol] 'Y1tMl.sopc tC;\aU.,.\h.rdw.,. 1uton.' 1c 70\first rrios1 1Y""T1 . ~PCJ

~~

", II

lJrte r".'

..

"

,[J
ea..

L''''J

I""

~_ ,

.('I'i t'f"'. , и. ",t.,.

t.)<;I'!W "'IOht

-

-

- - - - - - - - - - - - - - - - - - - - - - -1

I ... ии иJ 1и:- и1
Figure 4.4-1 SOPC Builder GUl 4 . Building the system in the

sope builder. SOPC builder is used to define the

hardware characteristics of the of the Nios II system, i.e. which Nios II core is selected, what peripherals to include in the system. Since this step is the most crucial of the whole process, detail contents ofGUI are shown and explained. On the SOPC builder, FPG A cyclone chip is chosen, and the clock is set at 50MHz. и Processor requires minImum one memory to store data and instructions; the on chip memory selection is first performed. To add 34

the memory, on the left hand side of system co ntents tab, under the category Memories and Memory Contro)Jers/On-Chip, user high lights the On-Chip Memory (RAM or ROM) then clicks Add. The On-Chip Memory MegaWizard interface appears . M4K block memory is select. Figure 4 .4-2 is the On-Chip Memory interface box.

On-Chip Memory (RAM or ROM)

r~OUl

и

RAM rMIT()ble)

(.; ROM (Reed-only )

l.J Duel -p ort ~cees.
Read DUI ing \l\trte Mode: [ tiloe" type'

1:::.4 "
Iv ] Inrtlslioe memory
COllt ~nt

Dnt

''<'VldtI1.

Total memol Y SlU: 135500
-...I

r::1fu--'i '
~es

' '''' j

Minimize mt!lTlor y I;lock usu ye (may impact fmox

Read latenc y
5 1;)"e ,,1

r,

- - T.... l

SlaVeS2:

l

-

Me m ory'ln lt lal i zati on
~

En.Jble non-de fault inrti;Jfi::otion !lle
.hex

U!::er -created inrtinll::stion file

r

Enable I,,-System M<!ffiory Content Editor f.mure

Instan ce ID

---Figure 4.4-2 On-Chip Memory MegaWizard

..., ~

The total memory size is 35Kbytes. This is because the actual software size is bigger than the default 20Kbytes. Floating point computation needs more memory space as welL

35

The Nios II core selection and its configuration is done next. There are three classes of Nios II core processor; they are economics, standard and full features . Standard core is picked in this project for the reason that it has built in hardware multiplier and divider. This hardware will accelerate the float ing point manipUlation. User selects Nios II Processor and then clicks on ADD. The Nios II processor Mega Wizard appears. Figure 4.4-3 displays the Nios II core page.

Nios II Processor

Custom Instrucbons
Cor IIIOS 11

Select a mos II cor ,, :

Nios II
Selector GU Ide

~sc ~~~-------╗~sc
32-brt

o Nios IVe

'@Nios Ills
32-bt

ONios IIIf
RISC 32-Oit
Ins1rucrion Cache BI anch Prediction

Farlll1, Cyclone"
f'S1~tetn 50.0 MH:I
l:PUld 0

Il1stJuctlol1 Cache Bronch Prediction Hardwar e Multiply

Hardware Multiply
Hordwore DiVide Barrel Shiner Oat╗ Cach e DyrIamic Branch Pr ediction

Har dware Divide

Per formance 8150.0 MHz Up to 5 DI'ItIPS Logic U,age
600-700 LEs

Up 10 25 DMPS 1200-1400 LEs

Up to 51 D~"PS 1400-1800 LEs Tl1ree M41\s + cache

Memory Usage

Two I.I4Ks (or eqliv)

Two M41'.s + cache

liordwOl e MultIply' 'EmDedded fUlpiers

.hJ 0

Hardware Di/ide

(.!emoIY ,onchiP'_I1le!l1

j ...l Offset 'Ox\)
;''' ' ' Oft~et'

0,00010000

E.... ceptlon

'Je~or "~Inory. ~crn--==:""::=-=-==---'

rlo-,c) - - - - - - 0:...00010020

n
Only IncUde t~ rll~,oIj when uSo;;Isn opelatJflg system thid t>phcltly suPports an MMU
Fast TLB IAi.. Exception Vector I.l.!ncry -

-------

-

-

-----,
...

---'-

,

orfsol

r.1

T

Figure 4.4-3 Nios II Processor Core GUT

36

Hardware divide is not adopted here since it takes up huge FPGA chip reso urce. The division w ill be do ne by software. Nios II processor provides custom instruction in order to use its hardware multip liers for floating point operation. To activate this feature, user clicks on Custom

Instructions on the Nios II core GUI. Figure 4.4-4 shows the configuration
wizard.

-'

tt

Nios II Processor

CicteS
fpolf'rt

N Port
и... il 01

:....'N~bIe

f
иi

Figure 4.4-4 Floating point GUI

37

.lTAG UART

I ~out

Q.ocum~ntatl0 n

Wnl" F IFO (Data f'-a m

Ava l

I- I
I

IRQ till esl " , ol"t, '8

"'on struct usin9 I"e'Cll s t e r __ in ste- d of rnelllOI y b lock s
TO

Rp ; H1 FIFO (Data from JTAG
Buffe, d .. ""., (bytes) [6 4

Avalo n)

I- I

IRQ thr eshold

,~ -

I C"'o n stl wet

u Sin g re gister .. Inste d o f rnernory blocks

Lc a n ce l l

'I Elnlsh J

Figure 4.4-5 Serial Communication GUI и Addmg JTAG UART allows for convenient way to communicate with Nios II processor through the USB-Blaster download cable. This is very useful for software debugging purpose. On Interface

protocols/Serial, user elects JT AG U ART the clicks Add. Figure
4.4-5 indicates the setting. и To make the progranuning part straight forward, seven timer interrupts are required here for seven switching pattern changes. Under PeripheralfMicrocontroller Peripheral!, user clicks ADD then the Timer MegaWizard interface appears. Figure 4.4-6 displays the timer interface.

38

Interval Timer
. 6!Jou t Qocumentat l on

Timeo ut per iod
Penod:

11

I U3

T imer counter size
C a unte . Si::e' @ 2

---1....J brts

H ardwar e op ti ons
P, esetll' IFUII- f eatu red

1-- 1
и

Reg i st.;>rs
[;;:] I. '"

j

1-'11..

J l..

I

"

Ii:) tиt

1

rltr

I It.

Ou t p ut Sig n a ls

U

Til

l

f

I

I

I

I (~

l"

n

,'I

[can"CetJ 1Einish i
Figure 4.4-7 Interval TImer MegaWizard Since our SVP sampling period is set at _1_ second or

900

1.11 rnilisecond, the interrupt timing for each switching sequence is in the order of microsecond. With 32 bits counter size, it is more than enough to cover one sampling cycle. The timer hardware option is set at full featured, so that the timer period can be written to, read from, and started/stopped by control bits. и General purpose VO port or PIO is used to drive LEOs for visual effect as to confirm the program working properly. They are
39

actually the switch drivers in SVM scheme. Eight bits are selected. Under Perip heralslMicrocontroUer Peripherals/PIO (Parallel 110), user clicks on ADD and the PIO Mega Wizard appears. Figure 4.4-8 exhibits the PIO interface menu.
PIO (Parallel 1/0)
j ebo ut

.Q.oc un H::n t at i o n

WILlH .
/\1dt h ( 1-:3:2 bits) .0

DII'" et l o n

. I put pori .

only

eol'"'
-

111 J.)ut Ollel

'Output POt t s

O u tP .... tt por1Q o n l y
Pf:!~~ 1

O u tPlJ' P U rl
Reset Vc\lu e.

V

t u~

10>( . . .'

r

Can cel

1

t

11

I

[ UI!:!:)(t

~

]

Ll ni s h

1

Figure 4.4-8 PIO MegaWizard и The system 10 peripheral helps accidentally downloading other software for different Nios II system. Under PeripheralsfDebug and Perfonnance, user clicks on System ID Peripheral and then clicks on ADD. The 10 Peripheral Mega Wizard interface appears. There is no need to configure the 10 option. Figure 4.4-9 shows the pop up interface box.

40

System I D Peripheral
Qocurnentation

System ID 701835872 Time stamp: 1 268667 41 8 A unique ID is assigned eery time the sy'stem is generated.

- - - -- - - - - - - -

-

----------,

I
Figure 4.4-9 System ID Peripheral Ii1terface Box

Cancel

IrEn i ~

At this point, all the necessary hardware components are in place They need to be specified as to how they interact within the system. The issues can be the base addresses assigned to each component, and designating priorities for timer interrupt requests (IRQ) and the JT AG U ART.

sope builder provides

Auto-Assign Base Address and Auto-Assign IRQs commands to facilitate these assIgnments. Since the project's timer interrupts do not happen at the same time, they can be allocated in any priority sequences as long as the JT AG U ART get the lowest one. Figure 4.4-10 displays the interconnection of the system.

41

'1 Altera SOPC Builder - first_nios2_system.sopC" (/home/facultytvluong/DE_tut2/niosltcydonell_2c35/first_nios2_'":iи~+< 1f'
<)yitem (ontents

.J'i5:ern Gel1:efJlIYl

-r"yet
elk

.J.t ~rJ '~tP,' E!jl.i~1

: ho~ I PI ,r.t-.. ~ cr
0-- BIFI9"~
j)oo .l~1

и,wJ

---

~Jlfl"I(t

t.t1:: _

If"~ I J!~

t.l1plet5 IJr otocclc;

Ellt etnal

50.0

~

tthe'nM

... lilqn

:,<<<1
U" t;.~
'.и)dlilfrl~

Des~r'l'llO!'

C-od

.~J~e

End

IRO

00 LC'S3Cy ~OmpIJlIi:-r II)
0- 'J~:,nes 3')(1 t ~~rT!(W~

01

(c-ntij
01 01

....
.....

El

onclliprnem
sl

OnиChop "tOOl; (~A1~ Of POI.I)
I

9 P.r,rerals
Del.,u'Jlnd ;)ell~ rnan:e "" DФP3y "" FPCA PEl 1"<1 als , f IlCrocontr C~1 Poenphtral!
t:J.

(!] ' pu

AV:ion tieml!! i I":.tpptc Sla.r~ Jos NPr O.... f'!SSOJ

,Ik elk t lk ' Ik , Ik elk elk elk elk

0,00010000 ),(j()()18aab 0. 00020800 ~,llfCФJ= =rff 0\00 2IOfO OllilOO:lO f' O,OOO21 0f8 ,J.C(X)-Wff
O ,OO 0 210~O

f--,

v:
~
tI

.....
~

13 jtaO_ual1 J"aJon J"Iu,la;e 13 Iys id
'~0r:t

ol _slJ oJe

PO (Por.lllell>;)',
0- f 11I1lOfocc .. o;or C:Jurdnl!tl~

13 leu"pio
.1

... PLL

13 timer
H

JTAGUAPT ~v"on I, 'tmcry !.lapped laye ~y.lem [) P. 'Pt'" .. Ava 00 Il~lKI y I.lapped 'S PIO ,POI ""'I 10) Av.on 11em.;ry I ppec Sla,,~ 1"it000ai Tmer
h'i ),on '.l{>ITЦ.Jf 1,lappeC Sla~e

~>OOO : lOef

... use
01
,;

$1

0, 00021000 ) '(")O?1('1 f
0.00021010 OxOOO;:103f

13 bmer_l
--t --t
.1

lrtervoll Trner

Ave.on Ilemcry I.lappea Slave
r1~r"ll

13 tl mer_7
<1

Timer

,.,

~ v,.on

I telller.1 ~JPped

~Io"le

0. 00021040

:,. ,X~: 1v:."

....

13 timer_3
.1

-'--

iht1val Trmer 'A."on I,"'mcry t

pp~a sat'~

0, 00021060 ) .. f00210; f

Re!!l<lve

!;cit

lIove~

I

.", Meve Ilown

J

Addtes$ ~3jl

--=- ~

F*er

Ncr!

I

Gen<r8te

Figure 4.4-10 Contents of Complete System The hardware can be now generated by clicking on System Generation tab and then clicking on Generate box. 5 Integrate the

sope builder system into Quartus II project. This step involves

instantiating the SOPC system module, assigning physical FPGA pins, compiling the project and verifying the timing, Figure 4.5-1 and Figure 4.5-2 each display system module and FPGA pins assignment.

42

CdJ
~ A

D-1ClI
- 1 I "il l ..v
'I'
~

Nios II Q UCirtu S
Tt lls

II 'Project -&nd

Nio~II ,. Cy'ctot"e It

t ho- t o p level U~ 'S4 yrlиto r ttиl,=, N lw s IIl'"i& d\lv r e Deveh..~)menl T ut o r-Ial

u n th e N I UfS Or::veluiXf le Hl & _tud. l.: V C I OIIt:; ~ eUltlol 1 .

rh l$ dEts jg:n ' vvOrks. fO': bot h :he Б:P:iC3~

6PjC3SE';;' devlce."s :

HI

:.o . .

t

For Help . pre $' F I

55 1. 41 4

Figure 4.5-1 System Module

EaJ
~

Oto up.$
Ndllleu

II
Node Nam e

и x

Tc:p Vll lU -tnJlr. l O la
Cy:I~u:

JI- EP ~~~ 51:i.1::6

«...
~ ;:~

~

GIl :1l:I:
~

-i;u:..f~..:::. ~

< <new node ;. >

I .:~k

[!JI

.%~~

"

Named:

II
Node
LEDG[ l ] LEDG[2 ] LEDG[3 J LEDG[ 4] LEDG[S] LEDG[6 ] LEDG[ ?]
N~me
Ilnlи~(l,."n

F~t"r:

~ II

Location
P IN_ A - 22

I 06<onk

LEDG[ O]

VREF GYc B7_NO
B7JJ O B7JJO 87_ NO . S7JJO
B7_ N O

Unkr"o\'.m IJnkr r.:h" l1
Un~rown
un~ro.w_ n

P 1N_ AF 22 P IN_W L9 P IN_ VI S P IN_ U lS PIN_ U l7 7 PI N _ AA ZO PI N _ V I S
0' .... Vl

7 7

_ __

Unkr'IQ\,.,n

l

7 7

S7 NO

87~'lO

Figure 4 .5-2 FPGA pin assignment W izard 6. Download hardware design to target FPGA. This process requires USB-Blaster and following the Programmer GUI procedure.

43

7. Develop software using Nios II IDE. Figure 4.7-1 depicts the logic flow ofthe main software. Figure 4.7-2 shows some of the subroutines and interrupt subroutines.

(---.sta~rt )
Initialization: count-D, lastent-O. nJ'attern=o inc_degree (1/60)/(11900); deg = (inc_degree' count) + offset; rad_deg = deg и (llp,e); Sec,num (degl60) + 1; adLdeg (rad_deg) - (sec,num 1)' (pieI3); Ta sin( p,el3 - adLdeg) и Ts Tb = sine ad_deg) и Ts To Ts - Ta - Tb Set switching patterns Write and enable 7 timer interrupts

=

=

=

=

=

Lastcnt = last count n_pattern = pattern number deg = degree Inc_degree = degree increment rad_deg = degree in radian sec.num = section number adLdeg adjusted degree Ts = sampling time

=

L..-

--I
I J
No

~
lYes
Last_cnt = 0 Count =0

No

I
'deg = (inc_degree' cQunt) + offset; rad_deg = deg и (l/pie); sec,num (deg/60) + 1; adLdeg (rad_deg) - (sec,num - 1) и (pieI3); Ta sine piel3 - adLdeg)' Ts Tb sine ad_deg) и Ts To Ts-Ta - Tb

=

=

=

Goto: switching subroutine
loading timer interrupts subroutine

Figure 4.7-1 Software main flow chart

44

Loading subroutine

Switching subroutine

Writing interrupt timers Timer Ts Timer1= To/4 Timer2=ToI4+Ta12 Timer3= To/4+TaI2+Tb/2 Timer4 =To/4+Ta/2+Tbl2+ To/2 TimerS =To/4+Ta/2+Tbl2+ To/2+Tbl2 TimerS =To/4+Ta/2+Tbl2+ ToI2+Tb/2+Ta/2 Enable timer interrupts

=

A set of switching sequence depending on section number. Section 1 '" pattern set 1 Section 2 = pattern set 2 Section 3 = pattern set 3 Section 4 ;:; pattern set 4 Section 5 '" pattern set 5 Section 6 = pattern set 6

i

(

!
return

)

(

i:
return

)

Interrupt Timer

Interrupt Timer1

~
Increment count Reset switching pattern

...
Set switching pattern 1

и ии
)

Set switching pattern 6

.,I

y

(

return

)

.,

(

return

(

return

)

Figure 4.7-2 Flow charts of some subroutines

45

The detail of software implementation is described as the following. There are three parameters that the program needs to know in order to set the inverter frequency and amplitude. They are sampling frequency, modulating frequency and the modulation index. In this project the sampling frequency is set at 900Hz, the modulating frequency is at 60Hz, and the modulation index is 1. The sampling period is
Sampling period -

=

1 Sampling _frequency

=

1 = 1.11mS (4.4.7-1) 900Hz

The number of sampling time per cycle is
Sampling _ time 900Hz =15 60Hz

(4.4.7-2)

The sampling angle increment in one circle is
Sampling _ increment

= 31~0 = 24 deg ree

(4.4.7-3)

An interrupt timer at every sampling period is established. At each interrupt, a counter ranging from zero to 14 is increased by one and it will reset itself when the number reaches 15. The sampling angle at any given time is just the product of the number in the counter and the angle of the sampling increment.
Sampling _ angle = 24 *counter's _ number

(4.4.7-4)

When the angle is became known, the switching time constant T a, T band To can be found but the angle has to be fIrst converted to radian degree.
radzan deg ree( 8) = deg ree *180 T = sin( 7r - 8) a 3
. 7r

(4.4.7-5)

with

ma = 1

(4.4.7-6)

46

Tb = sin(B)

(4.4.7-7) (4.4.7-8)

These time constant T a, T b and To are just the relative time as compared to the sampling period. In order to become real time, they have to be multiplied by a system clock time Ts related to the sampling time. These real times can now be used in setting the interrupt timers.

Ts = sampling period * system clock = 1 * 50MHz 900Hz Ts

(4.4.7-9)

=55555.55

The angle is also used to figure out the sector number that the angle belongs to. The sector number decides the switching patterns. As indicated in the chapter II, Figure 2.5_2 of this report, each sector has its unique switching patterns.

Sector number = int( sampling angle) + 1
60

(4.4.7-11)

Not only does the sector number affect the switching sequence, it also has effect on the order of the timing sequence. The odd sector number has this timing

T0 -!!.. T sequence: _

4' 2' 2

и

_0 ,

T 2

- , _Q

Tb 2

T Th T and -!!.. .. и e arrangement 0 fh t e tImmg 2 4

. . l'k hi To Tb Ta T T . d'ffi order for the even sector number IS 1 ere nt, It IS 1 e t s: - , - , - . -!!.., -!!.., 4 2 2 2 2
and To . All these procedures are observed closely according to the switching

2

4

rules laid out in the chapter II to ensure minimum switching loss.

47

Vo 000
----VAN

~
POO

V2 PPO

Vo PPP

V2 PPO

~
POO

Vo 000
-------------

;

----------------- --- -----

------- ----- --

V BN

-- ----------T4 To 2 Ts Tb 2 T6 Ta 2 T7 To 4

V eN
,

1'..
;

To 4

T2 Ta 2

T3 Tb 2
,

One Sampling Period

PPO

PPO

Poo

000

I

To 4

T To To T + _a or~ + ~or_a + 2 2 2 2

To 2

T T To + _b or---E.... + ---E.... or ~ + и2 2 2 2
To

To 4

I

Figure 4.4.7-3 Overview of Switching Pattern, Timing Sequence and Interrupt Timers

Within one sampling period, T, there are seven interrupts are set to correspond to seven changes in switching sequence as shown in figure 4.4.7-3 where sector I is taken as an example. The length of time of each interrupt is the sum of current time and all ofthe previous timing. The timer 1 is the only exception when it starts from fresh. In this example, timer interrupt T is responsible for [000] switching, timer interrupt Tl is responsible for [POO] and

48

so on. The interrupt timer seven is not used here since it is redundant with the sampling time T. The contents of each timer are listed below. . Interrupt timer T = 1 *T 900Hz s

(4.4.7-12)

Interrupt timer T 1 = Tr> 4

* Ts

(4.4.7-13)

Interrupt timer T 2 = (To + To ) * T 4 2 s Interrupt timer T 3 = (To + To + Tb) * T

(4.4.7-14)

4

2

2

(4.4.7-15)

s

- (To + To + 7;; + To ) * T ' er T 4Interrupt ttm

4

2

2

2

(4.4.7-16)

s

. T 5 = (To+To+Tb+TO+Tb)*T Interruptttmer

4

2

2

2

2

(4.4.7-17)

s

. T 6= (To Interruptttmer -+

Tb To Tb TO)*T +-+-+-+422222 s

(4.4.7-18)

Once the interrupt timer ofthe sampling period occurs, the software program will select the switching patterns and the timing order then set off other six interrupt Hmers. The program then calculates the angle related t~g> selects the switching pattern and timing sequence to prepare for the next sampling period. The switching sequences are handled by interrupt timers. Usually, the number oftimers available is fixed in microprocessor systems. With FPGA, users are able to instantiate as many as needed as long as the resource permits. Hardware choices ease software writing.

49

Anned with a hardware multiplier within the processor core, there was an attempt to avoid floating point computation. Integer arithmetic was implemented in order to speed up the calculation of the sine function.
. X3 XS Szn(8) = X - - + -

3!

5!

(4.47-19)

Only three terms were used in those trials and some scaling factors are employed for the integer arithmetic method. The scale factor has to be chosen carefully so that at the fifth power term it does not exceed the capacity of the data register ofthe processor. The practice does not yield much higher computing speed as compared to the Nios II floating-point custom instructions. It makes calculation complicated and software codes not easy to read. As it turns out, the Nios II floating-point custom instructions help writing the software an easy task. In this project, floating point manipulation is the major part. Instead of creating custom codes for sine or cosine functions, Nios II custom instructions have done the hard work and allow users to use simple ANSI C math functions. The Nios II processor performs single precision floating.:point arithmetic operations. The time spent on code writing is much shorter, but much on chip resource is also occupied. The debugging method here utilized the printffunction of the C codes. This function transmits data from FPGA chip through UART and displayed them on the host computer screen. Timing constants such as Ta, Tb and To' sector number, sampling angle and switching pattern were able to be shown on the computer screen at a desired interval.

50

C code:
Printf("%d %d %d %d %u %u %uln", sec.num, deg, pattern,ToI4, Ta12, T,/2);
Sampling time was fIrst changed to1.11Sec as to allow enough time for the data to be transferred and displayed. A complete cycle, 360 degree, of data were collected and compared to hand calculations. When the numbers were correctly matched, the sampling rate was put back to 1.11 mSec and the switching action was captured by an oscilloscope. The switching waveform was then weighed against the switching waveform ofthe Mathlab.

51

4.5 Design Result

. ..

~--

.

I
Tek.

I
.,

.....

u

_

:rViatl ab :::tmu!ati(.n

. . S 1;O P

...... tV!

Po -: - 3 .

O O rn s

Jlru III I I ruLUllJUlJ 11 II
C H 2 , OO rnи...

иa..... ""..,

2 .5 0 rns

SOPC Hardware output

Figure 4.5-1 Wave forms of software simulation and hardware output

The design result is right on its target. The pulse width modulation output of the hardware is identical to that of the Mathlab simulation. Since the SVM inverter design is intended for high power system (-3800V), it would be impractical to build a complete system just to show the validity of SOPC method. Hence, the switching waveform of Mathlab is used as a benchmark to verify the switching outcome of SOPC design. Figure

52

4.5- 1 illustrates both result of the theory and practicality. The inverter sampling rate is set at 1/900 second, rotating at 60 Hz frequ ency and the amplitude modulation index is one. Figure 4.5-2 shows current, voltage, sector number, switching wavefonns of the Matlab simulat ion at above setting.

Figure 4.5-2 Matlab simulation waveforms

53

4.6 Future Work: Multiple Processors System

In this paper, all hardware resources and software effort are concentrated on realization of Space Vector Modulation (SVM). The processor spends most of its time computing power series of the two trigonometry sine functions and outputting switching patterns. At each sampling period, calculation ofthe timing vectors has to be carried out. That means no pre-calculated values or table is stored in the memory as to boost up the sampling speed. The highest true sampling rate obtained is close to 1000Hz with 50MHz system clock. Since sampling rate of the SVM is the dominant issue, there is little attention paid for controlling and safely running ofthe motor. The subjects such as over current, over voltage, over temperature protection, blanking time and user input interface are left out. To amend these shorting comings, a multiprocessor system within a SOPC is suggested. Basically, it is a system which incorporates two or more microprocessors working together to perform one or more related tasks. Altera SOPC builder package allows users to add as many processors to a system as desired effortlessly. The arranging and connecting of hardware components are no longer an issue in building mUltiprocessor system. The challenge now lies in writing the software for the processors so that they do not conflict with one another. To prevent multiple processors from interfering with each other, hardware peripherals to coordinate effective operating of the processors are included in the Embedded Design Suite. The hardware allows different processors to claim ownership of a share resource for a period oftime and to coordinate data exchange in a single resource such as memory. They are named hardware mutex core and hardware mailbox core accordingly. A preliminary design for the open loop motor control system is shown below in figure 4.6-1. The first processor takes care of SVMand switching functions. The second processor looks after the safety operating of the machine and interfaces with users for input speed; this information is passed through the shared memory to the processor 1 which will decides either to stop, run or change speed of the motor. There is an added feature for this configuration. When the first processor detects no change in motor speed,

54

higher sampling rate can be obtained by pre-calculating all the timing vectors in one cycle and their values are stored in the memory. The next time around, the processor 1 just reads from memory and generates switching sequences without going through the long computing process. Higher sampling rate yields cleaner waveform and reduces THD.

~----~~~I
P rocessor 1 SVM & Switching Patterns
I
i i

Memo~
Interrupt Timer 0

J
!

I

i

и и и
Interrupt Timer 6 Shared
Memo~

I

I

I

I
I
!

\ Output to Switches

Ji
Processor 2 Speed Input & Safety Features

I

I

i

I
I
I

Memo~

I
I

Sensors
.

~

I

UART (Speed Input) I

Figure 4.6-1 Multiple Processors in Open Loop Control System

A closed loop servo motor control like the FOC can also be carried out in the same fashion. The field oriented control unit can be comprised of more than one processors

55

operating together. Each processor acts as a functional unit, thereby, data are processed concurrently. The perfonnance of the overall system is faster as a result. The Altera Nios II development software is capable of debugging simultaneously a multiple processors design. Debug for all processors can run at the same time and is able to pause and restart each processor independently. Break points can be placed individually anywhere in a processor. Once a breakpoint is hit, it does not halt the debug procedures of other processors. This debugging capability facilitates the development of a multiple processors system

56

Chapter 5 Conclusion

Space Vector Modulation is a superior method in converting DC voltage to AC voltage. It is a known fact that SVM has a lower THD, less switching loss, and more efficient usage of DC power supply as comparing to all other modulation schemes. The major disadvantage of this method is that it requires intensive computation. For this reason, DSP and high end microprocessor are often chosen to implement SVM. They are expensive because of complicated computer architecture is employed and hence huge resources are used to fabricate these chips. There is lack of flexibility in DSP or microprocessor technique. Once a DSP chip is elected, there is no easy turning back to make the hardware change without replacing with other DSPs. This may result in longer development period or an under utilization design. The recent emerging FPGA technology has given rise to a new approach to carry out SVM. It is called embedded system design or System On Programmable Chip SOPC. The system is consisted ofa fast RISC microprocessor in a FPGA chip. Since FPGA can be configured into any logics or functions, coupling this with a processor makes it a robust combination. The processor is acting like a tasks distributor that it out sources the works to the hardware peripherals formed by FPGA. The work done by hardware is always faster than the software for

57

hardware works concurrently and software works sequentially. That also frees up the processor to operate on other task and the system becomes truly multitasking. Software coding gets easier as well as in the case of floating-point arithmetic. The hardware added is not limited only to peripherals; a multiple processors can be put together as well. This feature makes the hardware peripherals more intelligent. The over all system performance is increased as a consequence. Unlike DSP or microprocessor structure which has fixed peripherals, the hardware in the embedded system is reconfIgurable. Designers can easily reiterate the hardware by adding or deleting functions in order to meet performance or price goal. The tools for this project are Altera DE2 development board and Altera Quatus II design suite. It is a successful implementation ofSVM in SOPC. The output switching waveform is the same as the Mathlab simulation. There is two-fold in the purpose of the Mathlab exercise. One is to observe how the theory works. The other is served as a benchmark to verifY the practical outcome. It is a long journey to go from proving the theory of the Space Vector Modulation to practically working hardware design. In reality, it is the same procedure that any serious engineering design has to go through. This practice not only detects any design flaws at early stage. It also helps foreseeing problems may emerge later on: An idea is stemmed from the same reasons; SOPC can be served as hardware simulation for the design.

58

Appendix A Mathlab Simulink Block Diagrams

Pul<es

G.I1o "gnals

~

T

DCV.ijag So fee

)

g~
A
C "enl Mu,u,"m
B

SVM in 2 level Inverter

иEFJ ntr

A

A

.J~.
c
sedors
G.in3

I C~ru~ !

C
MeM 10
Univorul Bridge

Ir" c

Th.e.иPhase Seri ии RLC Btanoh

~ v

I(-

",.Ilag" M..... remenl
K-

'L-LJ

Gain

Volligl Musuromlnll

D
~
Fo=60Hz

b-

.1

и
и
YSIgr\aI THO

~
2nd-Ord.,

Fillии

~

I

I

I

0
Soop.l

SVM overview in Matlab Simulink

59

isector

I
sectolif

D.ata Store

Memory

-eCltor

-T3 theta hetl! secte>r/I

T.

..
~

Th
sectolif To

...
p

.. Th
To

Signal

1
Pulses

Angle and seCltolS

Dwellиtime caloulat,on

Signals generation

Pulses-Gate signal block overview

Angle and sectors block diagram

60

Til Ta

Ts
theta
sin
lb

2
Tb

+
To

Dell time calculation diagram

Signal generation block diagram

61

Appendix B Software Codes in C Programming Language
iinclude iinclude iinclude 'include 'include 'include 'include "count_binary.h" "sys/alt_irq.h" "system.h" "unistd.h" "math.h" "float.h" "altera_avalon_timer_regs.h"

Iitypedef unsigned int REGISTER: Iitypedef unsigned int BITS; II union TIMER STATUS REG { II REGISTER data; II struct { II BITS TO 1; II BITS RUN I: II BITS unused 30; II bits:

I/}:

Ilunion TIMER_CONTROL_REG II REGISTER data:
II

{ :1; :1; :1: :1: :28:

II II II

II

II II I/};

struct { BITS BITS BITS BITS BITS bits;

ITO CONT START STOP unused

Iistruct TIMER REGS { II union TIMER_STATUS_REG status; II union TIMER_CONTROL_REG control; II REGISTER periodl; II REGISTER periodh: II REGISTER snapl: II REGISTER snaph;

In;

Iistruct TIMER_REGS *TIMER = (struct TIMER REGS *) (TIMER_BASE IOx00021020);

static char lastcnt;

62

1* A "loop counter" variable. *1 static alt u8 count: float rad ~ 0.0174532f: float pi = 3.141592f; float Ts 55555.55f: 11416666666.66f: float pi_by_3 = 1.04719f; float rad deg: float adf~deg; float adj_angl: unsigned long int Ta: unsigned long int Tb: unsigned long int To; unsigned long int adj To 1: unsigned long int adj-To-2: unsigned long int adj-Ta; unsigned long int adj=Tb; unsigned short int c_deg; char pattern 0; char pattern=1_5; char pattern_2_4; char pattern_3; char pattern: char nyattern: char section: char flag; Ilchar red flag; static char int cnt: char cnt; unsigned short int deg; struct b_type { unsigned last:l: int: 7;
};

1155555.5555:11555555555.5:

union sec { char num: struct b_type bits: sec: union duration_type { unsigned short int d[2]; unsigned long int 1 durtn: duration: void handle_timer_interrupts () ( count++: IOWR ALTERA AVALON TIMER STATUS (TIMER BASE, 0): 1111 IOWR_ALTERA_AVALON_TIMER_CONTROL(TlMER_BASE, 8):
}

void handle timerl interrupts () { IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_1_BASEI 0): IOWR ALTERA AVALON TIMER CONTROL(TIMER 1 BASE, 8): IOWR=ALTERA=AVALON=PIO_DATA(LED_PIO_BASE~ pattern_1_5);

63

void handle_timer2_interrupts () { IOWR_ALTERA_AVALON TIMER STATUS (TIMER 2 BASE, 0); IOWR ALTERA AVALON-TIMER-CONTROL(TIMER 2 BASE, 8): IOWR=ALTERA=AVALON=PIO_DATA(LED_PIO_BASE; pattern_2_4); n_pattern pattern_2_4; void handle_timer3_interrupts () { IOWR ALTERA AVALON TIMER STATUS (TIMER 3 BASE, 0); IOWR-ALTERA-AVALON-TIMER-CONTROL(TIMER 3 BASE, 8); IOWR-ALTERA-AVALON-PIO DATA(LED PIO BASE; pattern 3); n_pattern =-pattern_3:void handle timer4 interrupts () { IOWR ALTERA AVALON TIMER STATUS(TIMER 4 BASE, 0): IOWR-ALTERA-AVALON-TIMER-CONTROL(TIMER 4 BASE, 8); IOWR-ALTERA-AVALON-PIO DATA(LED PIO BASE; pattern 2 4): n_pattern =-pattern_2_4; - void handle timerS interrupts () { IOWR ALTERA AVALON TIMER STATUS(TlMER 5 BASE, 0): IOWR-ALTERA-AVALON-TIMER-CONTROL(TIMER 5 BASE, 8): IOWR-ALTERA-AVALON-PIO DATA(LED PIO BASE; pattern 1 5): n-pattern -pattern 1 5; - - void handle timer6 interrupts () { IOWR ALTERA AVALON TIMER STATUS(TlMER 6 BASE, 0); IOWR-ALTERA-AVALON-TlMER-CONTROL(TlMER 6 BASE, 8): IOWR-ALTERA-AVALON-PIO DATA(LED PIO BASE; pattern_Oj: n-pattern =-pattern_O:--

static void initial_message() ( printf("\n\n**************************\n"); printf("* Hello from Nios II! *\n"); printf("* Counting from 00 to ff *\n"): printf("**************************\n");

static void switching{) { switch (section) {

case OxI: pattern_O == OxO: pattern 1 5 == Ox4: pattern 2 4 = Ox6: pattern-3- Ox7; break: case Ox2: pattern_O Oxo; pattern 1 5 Ox2: pattern-2-4 Ox6; pattern-3- Ox7: break; case Ox3: pattern 0 ... OxO; pattern-IS = Ox2: pattern=2=4 Ox3: pattern 3 Ox7: break: case Ox4: pattern_O == pattern 1 5 pattern-2-4 pattern-3break: OxO:
=- OxI: =- Ox3;

Ox7;

case Ox5: pattern_O == OxO; pattern 1 5 == OxI: pattern-2-4 Ox5; pattern-3- Ox?; break; case Ox6: pattern 0 = pattern=1_5 pattern 2 4 pattern-3break: OxO; Ox4: == Ox5: Ox7:

=

static void load_I()
{

IOWR_ALTERA AVALON_TIMER_PERIODL(TIMER_I_BASE, duration.d[O]): IOWR_ALTERA_AVALON_TIMER_PERIODH(TIMER_I_BASE, duration.d[ll): static void load_2()
{

IOWR ALTERA AVALON TIMER PERIODL(TIMER 2 BASE, duration.d[O]); IOWR=ALTERA=AVALON=TIMER=PERIODH(TIMER=2=BASE, duration.d[ll):

65

static void load_3()
{

IOWR_ALTERA_AVALON_TIMER_PERIODL(TIMER 3 BASE, duration.d[Ol); IOWR_ALTERA_AVALON_TIMER_PERIODH(TIMER=3=BASE, duration.d[ll); static void load_4()
{

IOWR ALTERA AVALON TIMER PERIODL(TIMER 4 BASE, duration.d[O]); I OWR=ALTERA=AVALON=T IMER=PERIODH (TIMER=4=BASE, duration.d[l]); static void load_5()
{

IOWR ALTERA AVALON TIMER PERIODL(TIMER 5 BASE, duration.d[O]); IOWR=ALTERA=AVALON_TIMER=PERIODH(TIMER=5=BASE, duration.d[ll); static void load_6()
{

IOWR_ALTERA_AVALON_TIMER_PERIODL(TIMER_6_BASE, duration.d[O]): IOWR_ALTERA_AVALON_TIMER_PERIODH(TIMER_6_BASE, duration.d[ll):

Iistatic void II{ II IOWR ALTERA AVALON_TIMER_PERIODL(TlMER_BASE, IOWR_ALTERA_AVALON_TIMER_PERIODH(TlMER_BASE, II
II}
static void fire()
{

duration.d[O]); duration.d[ll);

IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_I_BASE, 5); I OWR_ALTERA_AVALON_T IMER_CONTROL (TIMER_2_BASE, 5): IOWR ALTERA_AVALON_TIMER_CONTROL(TIMER_3_BASE, 5); I OWR_ALTERA_AVALON_T IMER_CONTROL (TIMER_4_BASE, 5); I OWR_ALTERA_AVALON_T IMER_CONTROL (TIMER_5_BASE, 5); IOWR- ALTERA- AVALON- TIMER- CONTROL(TIMER-6 -BASE, 5):

static void loading()
{

duration.l durtn II Segment-l II duration.l_durtn load_l ();
i f (flag ! = 0)

0;

adj_To_l;

II

It is odd section

II

66

II II II II II

Segment 2 II duration.l_durtn load_2(); Segment 3 II duration.l durtn load_3(); Segment 4 II duration.l durtn load_40 ; Segment 5 II duration.l durtn load_5 () i Segment 6 II duration.l durtn load_60;

duration.l durtn + adj_Ta; duration.l durtn + adj_Tb; duration. 1 durtn + adj_To_2; duration.l durtn + adj_Tb; duration.l durtn + adj_Ta;

else
(

II II II II II II
Segment 2 II duration.l durtn load 2 (); Segment 3 II duration.l durtn load_3 () i Segment 4 II duration.l durtn load 4 () i Segment 5 II duration.l durtn load_50; Segment 6 II duration.l durtn load_6 ();

I t is even section

II

duration.l durtn + adj_Tb; duration.l durtn + adj_Tai duration.l durtn + adj_To_2; dura tion.1 durtn + adj_Ta; duration.l durtn + adJ,..Tb;

fire () ;

int main(void)
{

II FILE * led; Ilunsigned long int sine_fcn(); count = 0; lastcnt = 1; sec.num = 0; deg = 0; int cnt 1;
67

II

int cnt

0;

1* Initial message to output. *1
initial_message(); IOWR_ALTERA_AVALON_PIO_DATA(LED_PIO_BASE, OxOc);
alt_ir~register(TIMER_IRQ,

NULL, (void*)handle_timer_interrupts);

Iiduration.l durtn= Ox2faf080; duration.l_durtn= (unsigned long int)Ts; IOWR_ALTERA_AVALON_TIMER_PERIODL(TIMER_BASE, duration.d[O]); IOWR_ALTERA_AVALON_TIMER_PERIODH(TIMER_BASE, duration.d[1]); IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_BASE, 7); alt_irq_register(TIMER_IRQ, NULL, (void*)handle_timer_interrupts);

1* initialization *1
alt irq register(TIMER 1 IRQ, alt-irq-register(TIMER-2-IRQ, alt-irq-register(TIMER-3-IRQ, alt=irq:register(TIMER=4=IRQ, alt_irq_register(TIMER_S_IRQ, alt_irq_register(TIMER_6_IRQ, NULL, NULL, NULL, NULL, NULL, NULL, (void*)handle_timer1_interrupts); (void*)handle timer2 interrupts); (void*)handle-timer3-interrupts); (void*)handle-timer4-interrupts); (void*)handle-timerS-interrupts); (void*)handle=timer6=interrupts);

II

IOWR_ALTERA_AVALON_PIO_DATA(LED_PIO_BASE, pattern_Oj; n_pattern = 0; cnt = 0; Ilred flag = 0; deg =-(24 *count) + 4; rad_deg = deg * rad; sec.num (deg/60) + 1;

adj deg rad_deg - (sec.num -1)*pi_by_3; adj=angl = pi_by_3 - adj_deg; Ta Tb To (unsigned long int) (sin(adj angl)*Ts); (unsigned long int) (sin(adj=deg)*Ts); (unsigned long int)Ts - Ta - Tb ;

adj_To_2 = To ╗ 1; adj_To_1 = To ╗ 2; Ta ╗ 1; adj_Ta adj_Tb = Tb ╗ 1; section = sec.num; flag = (char) (sec.bits.last): switching(); loading();

68

printf("%d %d %d %d %u %u %u\n",sec.num,flag, deg,pattern,adj_To_2, adj_Ta, adj_Tb);

II

IOWR ALTERA AVALON PIO DATA(LED PIO BASE, pattern_Oj; n_pattern 0; --

IITIMER -> periodl = dur 6.d[0]; IITIMER -> periodh : dur=0=6.d[1]: IITIMER -> status.bits.TO = 0: IITIMER -> control.bits.ITO 1; IITIMER->control.bits.START = 1;
1* Continue O-ff counting loop. *1
while ( 1 )
{

░

if (lastcnt != count)
{

lastcnt count; if (count >= 15)
{

count = 0; lastcnt =0; I OWR_ALTERA_AVALON_P I O_DATA (LED_PIO_BASE, pattern 0); nyattern = 0: switching(): loading(); deg (24 *count) + 4; rad_deg (float)deg * rad: sec.num
(deg/60) + 1:

adj_deg rad_deg -(float) (sec.num -1)*pi_by_3; adj_angl = pi_by_3 - adj_deg; Ta Tb To (unsigned long int) (sin(adj_angl)*Ts): (unsigned long int) (sin (adj deg)*Ts); (unsigned long int)Ts - Ta Tb ;

=

adj To 2 To ╗ 1: To ╗ 2; adj=To=l Ta ╗ 1; adj Ta Tb ╗ 1; adj=Tb c deg = deg: section = sec.num; flag = (char) (sec.bits.last); Iiswitching();

69

//loading();

/I

count_all( lcd );

//printf("%d %d %d %d %u %u %u\n",sec.num,flag, deg,pattern, adj_To_2, adj_Ta, adj_Tb);

return 0;

70

References

[l]Ned Mohan, "Electric Drives, An Integrative Approach", MNPERE Minneapolis, 2001, pp7-1. [2]Harold W.Gingrich, "Electrical Machinery, Transformers, and Controls", PrenticeHall, Inc., 1979, pp231. [3]Ned Mohan, "Electric Drives, An Integrative Approach", MNPERE Minneapolis, 2001, ppll-l. [4]Mohan, Undeland, Robbins, "Power Electronics-Converters, Applications and Design", John Wiley & Sons, INC., 2003, pp203. . , [5]Bin Wu, "High-Power Converters and AC Drives", John Wiley and Sons, INC., 2006, pp6.3. [6]Microchip, ''VF Control of3-Phase Induction Motor Using Space Vector Modulation", AN955, 2005, ppl. [7]Hein Willi Van Der Broeck, Hans-Christoph Skudelny and Georg Viktor Stanke, "Analysis and Realization of a Pulsewidth Modulator Based on Voltage Space Vector", IEEE Transaction on Industry Applications, Vol 24, No.1, January/February 1988, pp143. [8]D.Rathnakumar, 1.Lakshmana Perumal and T.Srinivasan, "A new Software Implementation of Space Vector PWM", Proceedings IEEE SoutheastCon, 2005, pp131.

71

[9]Clive "Max" Maxfield, "The Design Warrior's Guide to FPGAs" Newnes " 2004 pp95, pp229. [IO]Michel Cosnard, Denis Trystram, "Parallel Algorithms and Architectures", International Thomson Computer Press, 1995, pp22. [11] Douglas Gard, "Digital Signal Processor Architecture", US patent 5954811, 1999, pp20. [12]Theerayod Wiangtong and Prasoot Dechsuwan, "Unified Motor Controller Based on Space Vector Modulation Technique", IEEE International Symposium on Circuit and System, 2006, pp5635. [13]Rui Wu, Donghua Chen and Shaojun Xie, "A Three-Dimentional Space Vector Modulation Algorithm in A-B-C Coordinate Implemented By a FPGA", IEEE 32nd Annual conference ofIndustrial Electronics Society, 2005, ppI071. [14]Su Chen and Gera Joos, "Symmetrical SVPWM Pattern Generator Using Field Programmable Gate Array Implementation", 17th Annual IEEE Applied Power Electronics Conference and Exposition, 2002, pp 1004. [15]Guijie Yang. Pinzhi Zhao and Zhaoyong Zhou, "The Design of SVPWM IP Core Based on FPGA", The 2008 IEEE Conference on Embedded Software ans System Symposia, 2008, pp191. [16] Zhaoyong Zhou and Tiecai Li, "Design ofa Universal Space Vector PWM Controller Based on FPGA", IEEE 19th Annual IEEE Applied Power Electronics Conference and Exposition, 2004, pp1968. [17]Bin Wu, "High-Power Converters and AC Drives", John Wiley and Sons, INC., 2006, pp 6.1.

.

72

[18]Zainalabedin Navabi, PH.D., "Embedded Core Design with FPGAs", McGraw-Hill, 2007,pp217,pp391. [19]Bin Wu, "High-Power Converters and AC Drives", John Wiley and Sons, INC., 2006, pp6.1-pp6.13. [20]Altera Corporation, "Nios II Hardware Development Tutorial", Nios II Applications, 2007, pp 1-1 -pp 1-41.

73

