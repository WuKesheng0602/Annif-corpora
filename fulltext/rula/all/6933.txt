CIRCUIT COMPLEXITY OF CONSTRAINT SATISFACTION PROBLEMS WITH FEW SUBPOWERS

by Amir El-Aooiti Bachelor of Science, Ryerson University, 2015

A thesis presented to Ryerson University

in partial fulfillment of the requirements for the Degree of Master of Science in the program of Applied Mathematics

Toronto, Ontario, Canada, 2017
©Amir El-Aooiti 2017

AUTHOR'S DECLARATION FOR ELECTRONIC SUBMISSION OF A THESIS

I hereby declare that I am the sole author of this thesis. This is a true copy of the thesis, including any required final revisions, as accepted by my examiners.

I authorize Ryerson University to lend this thesis to other institutions or individuals for the purpose of scholarly research.

I further authorize Ryerson University to reproduce this thesis by photocopying or by other means, in total or in part, at the request of other institutions or individuals for the purpose of scholarly research.

I understand that my thesis may be made electronically available to the public.

ii

CIRCUIT COMPLEXITY OF CONSTRAINT SATISFACTION PROBLEMS WITH FEW SUBPOWERS

Amir El-Aooiti Master of Science, 2017 Applied Mathematics Ryerson University

Although Constraint Satisfaction Problems (CSPs) are generally known to be NP-complete, placing restrictions on the constraint template can yield tractable subclasses. By studying the operations in the polymorphism of the constraint language, we can construct algorithms which solve our CSP in polynomial time. Previous results for CSPs with Mal'tsev [7] and generalized majority-minority operations [10] were improved to include CSPs with k -edge operations [15]. We present an alternative method to solve k -edge CSPs by utilizing Boolean trees placing the problem in the class NC2 . We do this by arranging the logical formulas describing the CSP into a Boolean tree where each leaf represents a constraint in the CSP. We take the conjunction of the constraint formulas yielding partial solutions at every step until we are left with a solution set at the root of the tree which satisfies all of the constraints. iii

ACKNOWLEDGMENTS

To begin, I would like to thank Allah for giving me the opportunity to succeed. It is only by his will that I am able to accomplish my goals now and for the years to come.

No one has stood by me like my family. They have provided me with nothing short of total love and support during my life, and I have no doubt they will continue to support me long after. For that, they have my lifelong gratitude.

I am deeply appreciative of the faculty and staff who were part of this program. I would like to thank Dr. Bonato, Dr. Escobar, Dr. Ferrando, Dr. Ilie, Dr. Pralat, and Dr. Rohlf for the hours they spent lecturing; Dr Georgiou for conducting the seminars; and Luisa Chan, Steve Kanellis, Teresa Lee, and Kathy Peter, for their administrative and technical work.

I would like to acknowledge and thank the members of the thesis defense committee Dr. Bonato, Dr. Deli´ c, Dr. Georgiou, and Dr. Pascal.

Most of all, I want to express my deep appreciation for my supervisor Dr. Dejan Deli´ c for giving me the opportunity to write a fulfilling thesis and for guiding me the entire way. iv

TABLE OF CONTENTS

Declaration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Abstract . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

ii iii iv 1 2 4 6 8 10 10 13 15 16 21 22 25 26 29 32

Acknowledgments

1 Introduction to Complexity Theory 1.1 1.2 1.3 1.4

Polynomial Time Classes . . . . . . . . . . . . . . . . . . . . . Completeness . . . . . . . . . . . . . . . . . . . . . . . . . . . Circuit Complexity Classes . . . . . . . . . . . . . . . . . . . . Logspace Classes . . . . . . . . . . . . . . . . . . . . . . . . .

2 Constraint Satisfaction Problems . . . . . . . . . . . . . . . . . . . 2.1 2.2 2.3 2.4 2.5 2.6 A Proper Definition of a CSP . . . . . . . . . . . . . . . . . . CSP as a Homomorphism Problem . . . . . . . . . . . . . . . Restricted CSPs . . . . . . . . . . . . . . . . . . . . . . . . . . Algebras . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Polymorphisms . . . . . . . . . . . . . . . . . . . . . . . . . . The Mal'tsev Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3 Constraint Languages with Few Subpowers 3.1 3.2 3.3

Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . Signatures and Representations . . . . . . . . . . . . . . . . . A Tractability Algorithm . . . . . . . . . . . . . . . . . . . . .

v

4 Reduction and Analysis of our Relational Structure . . . . . . . . . 4.1 4.2 4.3 Reduction to a Binary Relational Structure . . . . . . . . . . . Bounded Width . . . . . . . . . . . . . . . . . . . . . . . . . . Subalgebras of the Binary Constraint Language . . . . . . . .

39 39 42 47 54 54 58 62 62 63 66

5 A Boolean Circuit Algorithm for CSPs with Few Subpowers . . . . 5.1 5.2 Subdirect Products of two Strictly Simple Subalgebras . . . . Constructing a Logical Formula Capturing the CSP . . . . . . . . . . . . . . . . . . . .

6 Concluding Remarks and Open Problems 6.1 6.2

A Brief Summary . . . . . . . . . . . . . . . . . . . . . . . . . Open Problems . . . . . . . . . . . . . . . . . . . . . . . . . .

Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

vi

Chapter 1

INTRODUCTION TO COMPLEXITY THEORY

An algorithm is generally defined as a series of steps taken to solve or verify a solution to a problem. Algorithms which solve mathematical problems require both space and time to produce and verify solutions and can be classified based on their efficiency. Complexity theory is the field of mathematics which classifies problems based on their characteristics and the requirements of an algorithm to produce or verify given solutions; problems are called "hard" if they cannot be solved "efficiently". In this chapter, we will define and study the complexity classes P, NP, NC, L, and NL. Problems in these classes (among others) can be solved using what is called a Turing machine. Originally a real computer invented by British mathematician Alan Turing in 1936, a Turing machine is a mathematical model used to simulate the process an algorithm takes to solve or verify a solution to a problem. A Turing machine traverses a one-dimensional strip with symbols containing the input and manipulates the symbols in accordance with the algorithm being implemented. A modern computer today simulates the logical steps taken by a Turing machine, albeit much faster.

1

1.1

Polynomial Time Classes

In this section, we will study the polynomial time classes P and NP. These classes classify problems based on the amount of time, not space, taken by a Turing machine to solve or verify a solution to a problem. Definition 1.1. Given an input string of size n, problems in P can be solved by a Turing machine in O(np )-many steps for some positive integer p. Problems in P are said to be solvable in polynomial time and are called tractable. Consider the following example of a tractable problem: Example 1.1. The product of two n × n matrices can be computed in polynomially many steps in n. Suppose we are taking the product of n × n matrices A and B with entries ai,j and bi,j respectively, and let AB = C . The formula corresponding to each entry in C ,
n

ci,j =
k=1

ai,k bk,j ,

can be computed in n steps and the matrix C itself will have n2 entries. The products themselves can be computed in polynomial time given that the matrix entries are not large. Hence, it takes a total of O(n3 )-many steps to compute all of the entries in C using this formula. Example 1.2. Other examples of problems in P include: (1) basic arithmetic functions, (2) Euclid's algorithm for finding the greatest common divisor, 2

(3) (s, t)-connectivity problem for graphs, and (4) linear programming.

Next, we will consider the class NP, a class whose problems are said to be "harder" than those in P. Definition 1.2. Given an input string of size n, nondeterministic solutions to problems in NP can be verified (but not necessarily solved) by a nondeterministic Turing machine in O(np )-many steps for some positive integer p. Problems in NP are said to be verifiable in polynomial time. If a problem in NP cannot be solved in polynomial time by any known algorithm, it is called intractable. Consider the following example of an intractable problem: Example 1.3. Consider a graph G = (V, E ) for which we want to verify the existence of a Hamiltonian path. If we nondeterministically choose a permutation of vertices v1 , v2 , ..., vn  V (G), then we can verify that it forms a Hamiltonian path by checking that vi vi+1 is an edge in E (G) for all 1  i  n - 1. Since there are n - 1 consecutive vertex pairs in our permutation, it takes a total of n - 1 = O(n) steps to verify that our permutation is a Hamiltonian path in G. Example 1.4. Other examples of problems in NP include: (1) finding the smallest dominating set on a graph, (2) Boolean satisfiability, 3

(3) graph isomorphism, and (4) all problems in P. It is known that P  NP because any problem which can be solved in polynomial time can also be verified in polynomial time. Note that P is not a proper subset of NP because it remains an open problem as to whether P = NP; it is conjectured and generally accepted that in fact P = NP. With this assumption, we can introduce two more complexity classes.

1.2

Completeness

Reductions are a central tool in complexity theory allowing us to further classify problems into subsets of P and NP. Given a Turing machine, a single valid input for which the Turing machine returns an affirmative result is called a string. A language L is the set of all strings accepted by a specific Turing machine. Referring to Example 1.3, suppose we are given a Turing machine which verifies that a graph has a Hamiltonian path. An acceptable input for this Turing machine is a graph G with a Hamiltonian path. The language accepted by this Turing machine is written as the language

Hampath = {G : G has a Hamiltonian path}.

Definition 1.3. Given two languages L1 and L2 , a reduction from L1 to L2 is a function f : L1 - L2 such that x  L1 if and only if f (x)  L2 . Furthermore, 4

if f itself can be computed in polynomially many steps in the size of the input string from L1 , then f is referred to as a polynomial-time reduction. If there exists a polynomial-time reduction from language L1 to L2 , we write L1 P L2 .

Reductions are useful when it comes to classifying problems into complexity classes. We can show that a problem belongs to a complexity class by reducing another problem from the same complexity class to it using a function with the appropriate complexity. With reductions, we can define two more subsets contained in P and NP. Definition 1.4. A problem in P is called P-complete if all other problems in P can be reduced to it using a reduction from the class NC (see next section). Analogously, a problem in NP is called NP-complete if all other problems in NP can be reduced to it using a reduction from the class P. Example 1.5. The Boolean satisfiability problem is the problem of deciding whether there exists an assignment of literals which satisfies a Boolean formula. A Boolean formula is said to be written in n-disjunctive normal form (n-DNF) if it is written as a disjunction of conjunctions which each contain n literals. The problem of finding an assignment of literals for a formula in 3-DNF is written as the language

3-Sat = { :  is a satisfiable Boolean formula in 3-DNF}.

An independent set in a graph G is a set of vertices S  V (G) for which no two vertices in S are adjacent. For some positive integer n, the problem of 5

finding an independent set of size n in a graph is written as the language,

Ind = {G : G has an independent set of size n}.

An instance of 3-Sat can be reduced to an instance of Ind in polynomial time. First we convert the Boolean formula  to conjunctive normal form with n clauses in order to create a new graph G. For each clause in , we create a triangle graph where each vertex represents a literal for a total of 3n vertices. Then, we place edges between the triangles between vertices whose literals are negations of each other. This reduction can be done in polynomial time. It can be shown that finding an assignment of literals satisfying  is equivalent to finding the largest independent set on G by assigning "TRUE" to each vertex in the independent set. Hence, 3-Sat P Ind. Both the set of P-complete and NP-complete problems are contained in P and NP respectively. If we assume that P = NP, then it follows that P  (NP-complete) = . As a result, NP-complete problems are harder than those in NP and the analogous statement is true regarding P-complete problems and problems in P.

1.3

Circuit Complexity Classes

The study of the circuit complexity of problems provides us with a new complexity class called NC (Nick's Class) named after computer scientist Dr. Nicholas Pippenger. While problems in P and NP are classified by the ef6

ficiency in which they are solved by a Turing machine, problems in NC are classified by the efficiency in which they are solved by a Boolean circuit ; a wholly different model. A Boolean circuit (or Boolean tree) is a directed tree with a maximum vertex degree of 3. Vertices of degree 3 are labeled with either the binary  ("and") or  ("or") operations, vertices of degree 2 are labeled with the unary ¬ ("not") operation, vertices of degree 1 are labeled as input gates, and a single vertex of degree 1 is labeled as an output gate. The size of a Boolean circuit is the number of input gates it contains and the depth of a Boolean circuit is the maximal length of a path from some input gate to the output gate. The circuit complexity of a problem depends not on the number of steps taken, but on the number of input gates in the Boolean circuit and its depth. Definition 1.5. Given an input string of size n, problems in NCi can be solved using a Boolean circuit which contains O(np )-many input gates and has a depth of O(logi n) for some positive integers i and p. We define the class NC as


NC =
i=1

NCi .

Example 1.6. A single entry of the product C of two n × n Boolean matrices A and B can be computed in NC1 . The formula corresponding to each entry in C is
n

ci,j =

(ai,k  bk,j )
k=1

for binary entries ai,j and bi,j in A and B respectively. We can compute the conjunction ai,k  bk,j in depth 1 for each k  [n] and we can compute the 7

disjunction of the n conjunction terms in depth O(logn). In total, the formula for each entry can be calculated in depth O(logn +1) = O(logn). Furthermore, since the computation of each entry involves taking a row from A and a column from B , the number of inputs in our Boolean circuit is equal to 2n = O(n), a polynomial.

It is known that Boolean circuit algorithms can be simulated by a Turing machine, but the converse of that statement is still an open problem; hence, we have NC  P. It is conjectured and generally accepted that NC = P. It follows that NC  (P-complete) = . By the definition of NC, we have NC1  NC2  ...  NCi  NC for any positive integer i. Although it is an open problem as to whether NCi = NCi+1 for all i, it is conjectured that this is the case.

1.4

Logspace Classes

Finally, we will study, but not delve into, the logspace classes L and NL. Logspace classes classify problems based on the space, not time, used by a Turing machine to solve or verify a solution to a problem. L and NL have an important fit into our complexity hierarchy discussed so far. Definition 1.6. Given an input string of size n, problems in L can be solved by a Turing machine in O(logp n) amount of rewritable memory space and nondeterministic solutions to problems in NL can be verified by a nondeter8

ministic Turing machine in the same space for some positive integer p. It is known that L  NL and it is conjectured, and generally accepted, that L = NL. Having defined these classes, we are ready to illustrate a hierarchy of space and time complexity. For any positive integer i, we can order our classes as follows:

NC1  L  NL  NC2  NC3  ...  NCi  NC  P  NP.

This ordering can also be seen as an order of hardness with the class NC1 being the easiest and NP being the hardest of the classes mentioned thus far. Many more classes have also been studied and can be added to our ordering on both ends and in between classes, but they go beyond the scope of this paper.

9

Chapter 2

CONSTRAINT SATISFACTION PROBLEMS

A constraint satisfaction problem (CSP) is a mathematical model used to express combinatorial problems for which a set of variables must be made to satisfy a set of constraints by assigning to them elements from a given domain. Many problems can be expressed in the language of CSPs and, thus, can all be solved using algorithms designed to solve CSPs. For the purposes of this paper, we will assume that all CSPs contain a finite domain and finitely many variables (unless mentioned otherwise) so as to produce finitely sized solutions. An algorithm which solves a CSP will either return a set of possible solutions in the form of functions, or return an empty set indicating that no assignment of variables satisfies the given constraints. While algorithms can be designed to output an optimal solution to a CSP, for our purposes, we will focus on finding all solutions satisfying the constraints including those which are suboptimal.

2.1

A Proper Definition of a CSP

A CSP can be interpreted as a mapping from a domain to a set of variables which satisfies the constraints imposed on each variable. Constraints may either be imposed artificially in order to find desirable or optimal solutions, or 10

they may be naturally assumed so as to conform to physical boundaries and avoid logical fallacies. A CSP can be expressed as a mathematical object. Definition 2.1. An instance of a CSP is a triple (V, A, C ) such that:
 V is a finite set of variables  A is a finite set known as the domain  C is a set of constraints {C1 , C2 , ..., Cq }, where each constraint is a pair

(si , Ri ) such that for all i  [q ]: ­ si  V mi is a tuple of size mi (the scope of Ci ). ­ Ri  Ami is a mi -ary relation (the template of Ci ). The solution set of the CSP is the set of functions f : V - A such that for all i  [q ], we have f (si )  Ri . Example 2.1. The k -Colourability problem for a graph G can be interpreted as the triple (V, D, {C1 , C2 , ..., C|E (G)| }), where:
 V = {v1 , v2 , ..., vn } is the set of vertices,  D = {1, 2, ..., k } the domain of colours, and  Ci = (ei  V 2 , D2 \ {(j, j ) | j  [k ]}) is the constraint corresponding to

ith edge e for all i  [|E (G)|]. The constraint states that any vertex pair connected by an edge must not have the same colour. The solution set to this CSP will be the set of colourings of G for which no edge has vertex endpoints of the same colour. 11

Example 2.2. 3-Sat of a Boolean formula  with n clauses, can be interpreted as the triple (X, T, {C1 , C2 , ..., Cn }), where:
 X = {x1 , x2 , x3 } is the set of literals,  T = {TRUE, FALSE} is the set of truth assignments, and  Ci = ((x1 , x2 , x3 )i , T 3 \ (FALSE, FALSE, FALSE)) is the constraint cor-

responding to the ith clause in . The constraint states that, for all i  [n], the clause (x1 , x2 , x3 )i , must have at least one true literal. A solution to this CSP will be the set of truth assignments for  such that at least one literal is true in every clause. Example 2.3. A system of linear equations over the set Zk = {0, 1, ..., k } can be interpreted as the triple (X, Zk , {C1 , C2 , ..., Cm }). Let Am×n be the matrix, bm×1 be the column vector, and xm×1 be the variable vector defining our linear system Ax = b, where:
 X = {x1 , x2 , ..., xn } are the entries of column vector x = [x1 x2 ... xn ]T ,  Zk = {0, 1, ..., k } with addition modulo k , and  Ci = ((x1 , x2 , ..., xn ), {(z1 , z2 , ..., zn )  Zn k |ai,1 z1 + ai,2 z2 + ... + ai,n zn = bi })

is the constraint corresponding to the equation in the ith row for all i  [m]. The constraint states that the left-hand side of the equation must equal the right-hand side of the equation for every row.

12

The input size of a CSP instance P = (V, A, C ) is n = |V |. By definition, there are |A|n possible mappings from V to A which puts some algorithms which solve CSPs into an exponential time complexity class much harder than the polynomial time classes P and NP [13]. In order to find the complexity of verifying a CSP, it is helpful to interpret CSPs using an alternative definition.

2.2

CSP as a Homomorphism Problem

CSPs can be interpreted as the problem of finding homomorphisms for relational structures. A relation R on a set A is a subset R  An for some fixed positive integer n called the arity of R. Definition 2.2. A relational structure is a pair A = (A, RA ), where A is a set and RA is a relation on A. In more obvious cases, we will write R instead of RA for relations which pertain to a relational structure A. Let R be a finite set of relation symbols with their associated arities; we will call R a similarity type. A relational structure A = (A, R) is of type R if R  R. For example, a graph or digraph is a relational structure G = (V, E ), where E  V 2 . A pair of relational structures A and B are called similar if they have the same similarity type. Like with graphs, a homomorphism from one relation to another can be defined. Definition 2.3. Let A = (A, RA ) and B = (B, RB ) be similar relational structures. A homomorphism from A to B is a function h : A - B such that if r  RA , then h(r)  RB . We write A - B if there exists at least one 13

homomorphism from A to B.

For a relational structure B = (B, R), if we take B to be a set of variables (a scope) and R to be a set of constraints (a template), we can take the CSP of B. By definition, the solution set of the CSP of B is the set

CSP(B) = {A | A - B}.

Example 2.4. The k -Colourability problem can be expressed as CSP(T), where T = ({1, 2, ..., k }, {1, 2, ..., k }2 \ {(i, i) | i  [k ]}) is the complete graph Kk . Graphs which are homomorphic to T are k -colourable by colouring all of the vertices which are mapped to each element in {1, 2, ..., k } the same colour. A homomorphism h from A = (A, RA ) to B = (B, RB ) is a mapping of size n, where n = |A|. Verifying that h is a homomorphism can be done in polynomial time with respect to n since we must check that for all r  RA , we have h(r)  RB given that the size of RA is not large. Since the size of RA is polynomial in n, we can see that the problem of verifying a CSP solution belongs in NP; more specifically, CSPs are known to be NP-complete [7]. But, it is possible to find tractable cases of CSP once we apply restrictions on the constraint templates.

14

2.3

Restricted CSPs

In this section, we will introduce a subclass of CSPs which have restrictions on their constraint templates. Definition 2.4. Let P = (V, A, {C1 , C2 , ..., Cq }) be a CSP instance with constraints Ci = (si , Ri ) and let  be a set of relations on A. We denote the subclass CSP() as being the class of CSPs such that Ri   for all i  [q ]. Every constraint template is restricted to the relations in . We call  the constraint language of P . Example 2.5. In reference to Example 2.1, we consider the constraint template R = D2 \ {(i, i) | i  [k ]} from the constraints for k -Colourability. The subclass CSP(R) includes the CSP for k -Colourability.

By conforming to specific conditions, it is possible to create a constraint language  which yields a tractable subclass CSP(). A constraint language  (not necessarily finite) is called locally tractable if for every finite subset   , the class CSP( ) is tractable, and  is called globally tractable if CSP() itself is tractable. Since we are dealing with finite constraint languages in this paper, we will refer to both locally and globally tractable constraint languages as simply being tractable. Otherwise,  is called NP-complete if CSP() is. The Dichotomy Conjecture introduced in [11] states that CSP() is either tractable or NP-complete for all constraint languages . The conjecture was proven for constraint languages of size 2 [17], and for those of size 3 [6] among others; 15

however, it remains open for all constraint languages of size greater than 3. In order to determine which constraint languages are tractable, it is useful to study their algebraic properties.

2.4

Algebras

While the study of universal algebra is a distinct field of mathematics on its own, mounting evidence has shown that the algebraic properties of CSPs have a significant impact on their complexity [1]. Before we proceed, we must define an algebraic structure (or just algebra) as a mathematical object. Definition 2.5 ([9]). An algebra A = (A, F ) is a pair where A is a set of elements called the universe of A, and F is a set of operations (or functions) which can be applied to the elements in A, and are closed under A. The arity of an operation f  F is the number of elements the operation accepts as its argument. An operation is called k -ary if it has an arity of k . A term operation in A is an operation which can be obtained by repeated compositions of the operations in F . Example 2.6. The pair A = (Z, {+, ×}) is the algebra on which integer arithmetic is done. Our universe is the set of integers Z, and our operations are both the binary sum and product operations. This particular algebra is called the ring of integers. Definition 2.6. An algebra B = (B, F ) is a subalgebra of A = (A, F ) if B  A and B is closed under the operations in F . We denote this as B  A. If A is 16

the universe of an algebra A = (A, F ) and the subset B  A is closed under the operations in F , we call B a subuniverse of A (or a subuniverse of A itself). Example 2.7. The algebra B = (2Z, {+, ×}) is a subalgebra of the ring of integers A = (Z, {+, ×}) presented in Example 2.6. Taking 2Z to be the set of even integers, it is clear that 2Z  Z and that 2Z is closed under {+, ×} since taking the sum or product of two even integers always yields an even integer. Definition 2.7. The direct product of a pair of algebras A and B which share the same set of operations F is the algebra C = (A × B, F ), where A × B denotes the Cartesian product {(a, b) | a  A, b  B }. The direct product of algebras A and B is denoted A × B. The elements in A × B are still closed under the operations in F which are applied element-wise to each component a and b in a tuple (a, b)  A × B . We will use the notation An to denote the direct product of n copies of an algebra A.

Algebras can be classified based on properties corresponding to their universes and operations. Here, we will define some of the properties associated with algebras. Definition 2.8. Let A = (A, F ) be an algebra and  be a binary operation which accepts, as arguments, all elements from the universe A. The following are referred to as algebraic axioms:
 Associativity : For all x, y, z  A, we have (x  y )  z = x  (y  z ).  Commutativity : For all x, y  A, we have x  y = y  x.

17

 Closure : For all x, y  A, we have (x  y )  A.  Identity element : For all x  A, there exists some i  A such x  i = x.  Inverse element : For all x  A and some identity element i  A, there

exists some x-1  A such that x  x-1 = i. Different classes of algebras exist depending on which axioms are obeyed and by which operations. Here, we present some of the different classes of algebras which will be relevant to our paper. Definition 2.9. A field F = (F, {+, ×}) is an algebra which consists of a set of elements and the addition and product operations. The operations + and × must satisfy the following field axioms for all x, y, z  F :
 Associativity: We have (x+y )+z = x+(y +z ) and (x×y )×z = x×(y ×z ).  Commutativity: We have x + y = y + x and x × y = y × x.  Distributivity: We have x × (y + z ) = (x × y ) + (x × z ).  Identity elements: There exists an element i  F such that x + i = x

and there an element i  F such that x × i = x.
 Inverse elements: For an additive identity element i, there exists some

-x  F such that x + (-x) = i. For a multiplicative identity element i , there exists some x-1  F such that x × x-1 = i Definition 2.10. A group G = (G, ) is an algebra which consists of a set of elements and a single operation . The operation must satisfy the following group axioms for all x, y, z  G: 18

 Associativity: We have (x  y )  z = x  (y  z ).  Closure: We have x  y  G.  Identity elements: There exists an element i  G such that x  i = x.  Inverse elements: For some identity element i, there exists some x-1  G

such that x  x-1 = i.
 Commutativity (for Abelian groups only): We have x  y = y  x.

Definition 2.11. A partially ordered set (or poset ) P = (X, ) is a set X and an ordering , which is transitive, antisymmetric, and reflexive. The supre-

mum (or join ) of X is an element sup(X ) = s  X such that for all x  X , we have x s, and the infimum (or meet ) of X is an element inf(X ) = i  X x. These properties essentially arrange

such that for all x  X , we have i

the elements in X from "smallest" to "greatest". Definition 2.12. A lattice L = (L, {, }) is an algebra which consists of a poset L, the meet operation , and the join operation . The operations  and  must satisfy the following lattice axioms for all x, y, z  L:
 Associativity: We have (x  y )  z = x  (y  z ) and (x  y )  z = x  (y  z ).  Commutativity: We have x  y = y  x and x  y = y  x.  Absorption: If x

y , we have x  (x  y ) = x  (x  y ) = x.

 Idempotency: We have x  x = x  x = x.

19

Now that we have studied the different algebraic classes we will see, we will study the notion of algebraic homomorphisms. Definition 2.13. Let A = (A, FA ) and B = (B, FB ) be algebras. A function h : A - B is a called homomorphism from A to B if

h(fA (a1 , a2 , ..., an )) = fB (h(b1 ), h(b2 ), ..., h(bn ))

for all n-ary operations fA  FA and fB  FB . A homomorphism h from A to B is called (1) an isomorphism if the inverse h-1 is a homomorphism from B to A, (2) an endomorphism if A = B, or (3) an automorphism if it is both an isomorphism and an endomorphism. Example 2.8. Let G = (R, +) be the group under addition with the universe of real numbers and let H = (R+ , ×) be the group under multiplication with the universe of positive real numbers. Let h : R - R+ be the function h(x) = ex , where e is the exponential constant. We can see that h is a homomorphism from G to H since for all x, y  R, we have h(x + y ) = ex+y = ex × ey = h(x) × h(y ).

The relations in a constraint language alone do not meet the definition of an algebra. But, by taking the domain of a CSP along with the relations in the constraint language, it is possible to create operations accepted by the domain 20

which preserve the relations.

2.5

Polymorphisms

In order to study the algebraic properties of , we must create a set of operations using the relations in . Definition 2.14. Let R  Ak be a k -ary relation on A and let  : An - A be an n-ary operation on A.  is called a polymorphism of R (or R is invariant
i i i under ) if for all n-tuples (r1 , r2 , ..., rn ), where ri = (r1 , r2 , ..., rk )  R, we

have

1 2 n 1 2 n 1 2 n (r1 , r2 , ..., rn ) = ((r1 , r1 , ..., r1 ), (r2 , r2 , ..., r2 ), ..., (rk , rk , ..., rk ))  R.

If  is a set of relations on A, then

Pol() = { |  is a polymorphism of all R  }.

If  is a set of operations on A, then

Inv() = {R | R is invariant under all   }.

Example 2.9. Let R be a relation denoting the solution set of a system of linear equations on a finite field. More specifically, for some matrix A and column vector b defining our linear system, R = {r | Ar = b}. Let

21

 : R3 - R be the operation (x, y, z) = x - y + z. We can see that  is a polymorphism of R. Indeed,  preserves the relation since for all x, y, z  R, we have,

A(x, y, z) = A(x - y + z) = Ax - Ay + Az = b - b + b = b.

Given a CSP instance P = (V, A, C ) with constraint language , we can create an algebra A = (A, Pol()). Conversely, given an Algebra B = (B, F ), we can create a constraint language B = Inv(F ). Just as with constraint languages, we call an algebra B tractable or NP-complete if the constraint language B is. Through past research, it has been shown that the operations in Pol() play a significant role in the complexity of the subclass CSP() [1].

2.6

The Mal'tsev Operation

In [7], it was shown by Bulatov and Dalmau that a subclass CSP() is tractable if Pol() contained a Mal'tsev operation. Definition 2.15. A Mal'tsev operation on a set A is a function m : A3 - A such that for all x, y  A, we have m(x, y, y ) = m(y, y, x) = x. Given a Mal'tsev operation m, we can take the relations invariant to m to create a tractable subclass CSP(Inv(m)), where Inv(m) is the set of constraint languages which have the operation m in their polymorphisms. Example 2.10. In Example 2.9, we mentioned that the operation (x, y, z ) 22

was a polymorphism of the solution set, R, of a system of linear equations over a finite field.  also happens to be a Mal'tsev operation on the solution set since for all x, y  R, we have

(x, y, y ) = x - y + y = x

and

(y, y, x) = y - y + x = x.

Since R is an invariant under , the problem of solving a system of linear equations on a finite field is tractable.

Since the set of Mal'tsev operations only includes those with arity 3, the related CSP subclass does not fully encapsulate the entire subclass of tractable CSPs. Over the years, efforts have been made to expand on the known

tractable subclasses and many results have been obtained. Dalmau himself was able to improve on his result involving Mal'tsev operations by showing that constraint languages with generalized majority-minority (GMM) operations also yield a tractable subclass [10]. Definition 2.16. A generalized majority-minority operation on a set A is a function g : Ak - A with k  3 such that for all a, b  A, we have g (x, y, y, ..., y ) = g (y, x, y, y, ..., y ) = g (y, y, ..., y, x) = y, or g (x, y, y, ..., y ) = g (y, y, ..., y, x) = x, x, y  {a, b}. x, y  {a, b},

A 3-ary GMM operation includes those which are Mal'tsev (see next chapter). Dalmau's GMM result is a generalization of his older result involving 23

Mal'tsev operations, but it still does not encapsulate the entire subclass of tractable CSPs. In the coming chapters, we will study CSP subclasses whose polymorphisms contain what are called k -edge operations.

24

Chapter 3

CONSTRAINT LANGUAGES WITH FEW SUBPOWERS

As discussed in the previous chapter, tractable CSP subclasses have been found over the years, but we have yet to fully encapsulate the entire subclass of tractable CSPs. Constraint languages with Mal'tsev operations were shown to be tractable by Bulatov and Dalmau who created an algorithm which can solve any Mal'tsev CSPs in polynomial time [7]. This result was later improved by Dalmau himself by showing that CSPs with constraint languages which have GMM operations were also tractable [10]; this was done by generalizing his previous algorithm to include operations with higher arity.

In this chapter, we will describe an algorithm which will further improve Dalmau's results by including constraint languages which have what are called k -edge operations. Constraint languages  whose polymorphisms contain k edge operations are tractable [15]. This result was presented by Idziak et al and uses a variation of Dalmau's algorithm essentially unchanged. The algorithm presented in this chapter can be seen as a generalization of the algorithm which performs Gaussian elimination on a system of linear equations. The solution sets of CSP() are known to have generating sets when considered as universes of particular algebras analogous to the basis of a vector space. Furthermore, it is also argued by Idziak et al that constraint languages which do not contain k -edge operations cannot be solved by any variation of their 25

"robust Gaussian-like" algorithm. However, this still leaves open the possibility that constraint languages without k -edge operations can be solved by a different algorithm in polynomial time.

3.1

Preliminaries

Just as GMM operations were a generalization of Mal'tsev operations, k edge operations are a generalization of both GMM and Mal'tsev operations along with other operations not mentioned. Definition 3.1. For k  2, a k -edge operation on a set A is a (k + 1)-ary operation e which, for all x, y  A, satisfies:

e(x, x, y, y, y, ..., y, y ) = y e(x, y, x, y, y, ..., y, y ) = y e(y, y, y, x, y, ..., y, y ) = y e(y, y, y, y, x, ..., y, y ) = y . . . e(y, y, y, y, y, ..., x, y ) = y e(y, y, y, y, y, ..., y, x) = y.

We note the "shepherd's crook" [15] shape formed by the occurrence of the variable x in the previous definition. It is clear that an operation is a 2-edge operation if and only if it is a Mal'tsev operation. It was also established in 26

[5] that if an algebra contains a k -ary GMM operation, then it also contains a k -edge operation. As a result, we can see that a k -edge operation is indeed a generalization of both Mal'tsev and GMM operations. To establish the existence of k -edge operations in the polymorphisms of a constraint language , we must define a type of subalgebra called a subpower. Definition 3.2. An algebra B is a subpower of A if B is a subalgebra of An for some positive integer n. We denote this as B  An . Now that we have properly introduced subpowers, we are ready to explain the notion of an algebra having "few" subpowers. In order to do this, we must first define what is called the relational clone of a constraint language. Definition 3.3. Given a class of relation symbols , a primitive positive formula is a formula in the form
n

1 , 2 , ..., n
i=1

i ( , ..., ),

where

represents either a free variable or one of variables 1 , 2 , ..., n , and

all formulas i use relation symbols from  for all i  [n]. Definition 3.4. Let  be a set of relations over a set A. We define a new set of relations  = Inv(Pol()). The set  is precisely the set of relations over A definable from  using primitive positive formulas where  = {=}. If  =  , then  is called the relational clone of .

Let  be a set of relations over a set A and let P = (V, A, C ) be an instance of CSP(). The solution set of P can be identified by any n-ary member 27

of  (where n = |V |) which themselves are the universes of the subpowers of A . As mentioned earlier in this chapter, the solution sets of CSP() are known to have generating sets when considered as universes of the subpowers of A . Dalmau's algorithm requires that the size of these generating sets be "small", meaning that they are of order O(np ) for some positive integer p. We introduce some equivalent conditions which ensures that all subpowers of A have small generating sets. Definition 3.5. Let A be an algebra and let S = {B | B  An } be the set of all subpowers of A for some positive integer n. Let sA (n) = log2 |S| and let gA (n) be the smallest integer t such that every subpower of A has a generating set of size at most t. For some positive integer p, (1) if sA (n) = O(np ), then A has few subpowers, and (2) if gA (n) = O(np ), then A has polynomially generated subpowers. Theorem 3.1 ([5]). Let P = (V, A, C ) be an instance of CSP() and let n = |V |. The following statements are all equivalent for the algebra A : (1) A contains a k -edge operation for some k  2. (2) A has few subpowers and sA (n) = O(nk ). (3) A has polynomially generated subpowers and gA (n) = O(nk-1 ). The proof for this theorem utilizes three term operations in A derived from the k -edge operation. The presence of these term operations allows us to present the following lemma. 28

Lemma 3.1 ([5]). Let A be a finite algebra with universe A which contains a k edge term operation e. Then the algebra (A, e) contains three term operations d(x, y ), p(x, y, z ), and s(x1 , x2 , ..., xk ) (which are also term operations of A) such that:

p(x, y, y ) = x p(x, x, y ) = d(x, y ) d(x, d(x, y )) = d(x, y ) s(y, x, x, x, x, ..., x, x) = d(x, y ) s(x, y, x, x, x, ..., x, x) = x s(x, x, y, x, x, ..., x, x) = x . . . s(x, x, x, x, x, ..., x, y ) = x.

3.2

Signatures and Representations

In this section, we will focus on the elements in the universe A of an algebra A. For positive integers n and j , let t = (t1 , t2 , ..., tn ) be an n-ary tuple and let i = (i1 , i2 , ..., ij ) be a j -ary tuple such that ik  [n] for all k  [j ]; the elements in i need not be distinct. In the proceeding definition, we will use these tuples to create a new relation from A. Definition 3.6. Let R  An be an n-ary relation on A. If t  R, we define the

29

projection of t on i as the j -ary tuple proji t = proji1 ,i2 ,...,ij t = (ti1 , ti2 , ..., tij ). Similarly, we can take the projection of R itself on i which creates the j -ary relation proji R = {proji t | t  R}. Referring to the previous section, consider an algebra A which contains a k edge operation e and the term operations d, p, and s as defined in Lemma 3.1. The pair (a, b)  A2 is called a minority pair if d(a, b) = b. We call the triple I = (i, a, b)  [n] × A2 an index of rank n if i  [n] and a, b  A and we call I a minority index if (a, b) is a minority pair. Definition 3.7. Let A be a finite set, t1 and t2 be n-ary tuples, and let the tuple (i, a, b)  [n] × A2 be a minority index. We say that the pair (t1 , t2 ) witnesses (i, a, b) if proj1,2,...,i-1 t1 = proj1,2,...,i-1 t2 , proji t1 = a, and proji t2 = b; to be clear, the first i - 1 elements in t1 and t2 match while their ith elements are equal to a and b respectively. Let R  An be a relation. We define the signature of R to be the set of tuples

SigR = {(i, a, b)  [n] × A2 | t1 , t2  R witnesses (i, a, b)}.

The size of the signature of a relation R depends on how closely pair of tuples in R match each other. Let S  R be a relation. We call S a representation of R if SigS = SigR . Furthermore, we call S a compact representation of R if |S |  2|SigR |. In fact, it was proven by Dalmau [10] that it is possible to construct a compact representation of any relation on a finite set.

30

Example 3.1. Let A = {1, 2, 3, 4} and let

R = {(1, 4, 1, 3), (1, 4, 1, 2), (2, 2, 1, 3), (2, 2, 4, 4), (3, 4, 3, 3)}  A4 .

We can see that SigR = {(3, 3, 2), (2, 1, 4)}. A representation of R is

S = {(1, 4, 1, 3), (1, 4, 1, 2), (2, 2, 1, 3), (2, 2, 4, 4)} = R \ (3, 4, 3, 3)

since S  R and SigS = SigR . We can also see that S is a compact representation of R since 4 = |S |  2|SigR | = 2(2) = 4.

Let R be an n-ary relation on A and let  be an operation. We define the new relation R


to be the smallest n-ary relation which contains R and is


invariant under ; we call R definition that R  R  .

the closure of R under . It is clear from the

Theorem 3.2 ([5]). Let A be a finite algebra with a k -edge operation e for some k  2 and term operations d, p, and s as defined in Lemma 3.1, let B be a subpower of A with universe B , and let R be representation of B . Suppose I = (i, a, b) is a minority index witnessed in B . For all t  R e , where proji = a, there exists u  R
e

such that (t, u) witness I.

Going back to compact representations, if A is an algebra with universe A with a k -edge operation and B is a subpower with universe B , then every subset B  An will have a representation with size bounded above by a polynomial 31

in n of degree k - 1. More specifically, if we set m = min{k - 1, n}, every subset B  An will have a representation of size at most

2|SigB | +

|projT B | = O(nk-1 ).

T [n] |T |m

This fact stems from the claim in Theorem 3.1 that the function gA (n) is of order O(nk-1 ) when an algebra A contains a k -edge operation.

3.3

A Tractability Algorithm

With some slight modifications to the algorithm presented in [10] which solves CSPs with GMM operations, the following theorem was proven. Theorem 3.3 ([15]). Let A be a finite algebra with universe A with few subpowers, and let  be the constraint language consisting of all subuniverses of An for some positive integer n. Then the class CSP() is tractable. To prove that CSPs with few subpowers were tractable, it sufficed to prove that CSPs with k -edge operations were tractable since both were equivalent. For the duration of this chapter, we will set A = (A, (x1 , x2 , ..., xk )) to be an algebra with a k -edge operation . Let P = (V, A, C ) be an instance of CSP(A ), where V = {v1 , v2 , ..., vn } is the set of variables, A is the universe of A, and C = {C1 , C2 , ..., Cm } is the set of constraints. For the purposes of the upcoming algorithm, we will use Pl = (V, A, Cl ) to denote the CSP where Cl contains the first l constraints of C for some l  m. We will set R and Rl to 32

denote the solution set of P and Pl respectively.

The algorithm presented by Idziak et al begins with the compact representation of R0 (equal to An ). It will then recursively add in each constraint Cl producing a solution set Rl for 0  l  m until we are left with Rm = R, a compact representation of the solution set of P . It is clear that Rm  Rm-1  ...  R0 since the addition of each constraint Cl will eliminate possible solutions which had only satisfied the constraints before it. If Rm is empty, then there is no solution to the CSP. The following is a pseudocode describing Dalmau's algorithm. Algorithm Dalmau(({v1 , v2 , ..., vn }, A, {C1 , C2 , ..., Cm })) Step 1 Step 2 set R0 some compact representation of An for each l  {0, 1, ..., m - 1} do (let Cl+1 be ((vi1 , vi2 , ..., vikl+1 ), Sl+1 )) Step 2.1 set Rl+1 := Next(Rl , i1 , i2 , ..., ikl+1 , Sl+1 ) end for each Step 3 Step 4 if Rm =  return "yes" return "no"

The subroutine Next uses the subroutine Next-Beta which itself uses subroutines Nonempty and Fix-Values all of which are fully described and analyzed in [15]. Here, we provide a brief description of each subroutine.

Nonempty(R , i1 , i2 , ..., ij , S ) receives, as input, a compact representation R of a subuniverse R  An , a sequence of elements i1 , i2 , ..., ij from [n], and a sub33

universe S  An . If there exists some tuple t  R such that proji1 ,i2 ,...,ij t  S , then Nonempty outputs t; otherwise, it will output "no". The running time of Nonempty is bounded above by O(((n|A|)k + |proji1 ,i2 ,...,ij R|)k+2 n|S |) [15]. Although the size of proji1 ,i2 ,...,ij R may be exponential with regards to the size of the input n, Dalmau was able to deal with this issue by invoking Nonempty in such a way as to bound |proji1 ,i2 ,...,ij R| above polynomially [10]. This version of Nonempty is unchanged from the one used in [10]. Algorithm Nonempty(R , i1 , i2 , ..., ij , S ) 1 2 set U := R while t1 , t2 , ..., tk  U such that / proji1 ,i2 ,...,ij U do proji1 ,i2 ,...,ij (t1 , t2 , ..., tk )  2.1 set U := U  {(t1 , t2 , ..., tk )} endwhile 3 4 if t in U such that proji1 ,i2 ,...,ij t  S then return t else return "no"

Fix-Values(R , a1 , a2 , ..., am ) receives, as input, a compact representation R of a subuniverse R  An , and a sequence of elements a1 , a2 , ..., am from A. It outputs a compact representation

{t  R : proj[m] t = (a1 , a2 , ..., am )}  A. The running time of Fix-Values is bounded above by O((n|A|)(k+1)(k+2) ) [15]. This version of Fix-Values differed slightly from that in [10]; Step 2.2.1.2 34

was deleted and Step 2.2.1.1 was changed to "set t5 := p(t1 , t2 , t3 )", where p(x, y, z ) is the 3-ary term operation as defined in Lemma 3.1. Algorithm Fix-Values(R , a1 , a2 , ..., am ) 1 2 2.1 2.2 2.2.1 set j := 0; Uj := R while j < m do set Uj +1 :=  for each (i, a, b)  [n] × A2 , with (a, b) a minority pair, do if Nonempty(Uj , j + 1, i, {(aj +1 , a)}) = "no" and t2 , t3  Uj witnessing (i, a, b) and i > j + 1 then (let t1 be the tuple returned by Nonempty(Uj , j + 1, i, {(aj +1 , a)})) 2.2.1.1 2.2.1.2 set t5 := p(t1 , t2 , t3 ) set Uj +1 := Uj +1  {t1 , t5 } end for each 2.3 for each k  [k - 1] for each l1 , l2 , ..., lk  [n] with l1 < l2 < ... < lk for each d1 , d2 , ..., dk  A do 2.3.1 if Nonempty(Uj , l1 , l2 , ..., lk , j + 1, {(d1 , d2 , ..., dk , aj +1 )}) = "no" then (let t6 be the tuple returned by Nonempty(Uj , l1 , l2 , ..., lk , j + 1, {(d1 , d2 , ..., dk , aj +1 )})) set Uj +1 := Uj +1  {t6 } end for each 35

2.4

set j := j + 1 end while

3

return Um

Next(R , i1 , i2 , ..., ij , S ) receives, as input, a compact representation R of a subuniverse R  An , a sequence of elements i1 , i2 , ..., ij from [n], and a subuniverse S  Aj . It outputs a compact representation of the subuniverse

R = {t  R : proji1 ,i2 ,...,ij t  S }  A.

Next uses a subroutine Next-Beta similar to itself, but has a potentially worse running time. The running time of Next was shown to be bounded above by O((n|A||S |)(k+2) ) [15]. This version of Next is unchanged from the one used in [10]. Algorithm Next-Beta(R , i1 , i2 , ..., ij , S ) 1 2 2.1 set U :=  for each (i, a, b)  [n] × A2 , {a, b} is a minority pair do if Nonempty(R , i1 , i2 , ..., ij , i, S × {a}) = "no" then (let t1 be Nonempty(R , i1 , i2 , ..., ij , i, S × {a})) 2.2 if Nonempty( Fix-Values(R , proj1 t, proj2 t, ..., proji-1 ), t, i1 , i2 , ..., ij , i, S × {b})) = "no" (let t2 be Nonempty( 36
2

Fix-Values(R , proj1 t, proj2 t, ..., proji-1 ), t, i1 , i2 , ..., ij , i, S × {b})) set U := U  {t1 , t2 } end for each 3 for each k  [k - 1] for each l1 , l2 , ..., lk  [n] with l1 < l2 < ... < lk for each d1 , d2 , ..., dk  A do 3.1 if Nonempty(R, i1 , i2 , ..., ij , l1 , l2 , ..., lk , S × {(d1 , d2 , ..., dk )}) = "no" then (let t3 = Nonempty(R, i1 , i2 , ..., ij , l1 , l2 , ..., lk , S × {(d1 , d2 , ..., dk )})) set U := U  {t3 } 4 return U

Theorem 3.4 ([15]). The algorithm Dalmau determines whether an instance P of CSP(A ) has a solution in O(m(n|A||S  |)k+2 )-many steps where n is the number of variables, m is the number of constraints, and S  is the largest constraint relation to appear in P . The algorithm presented in [15] is the most general tractable "robust Gaussianlike" algorithm there is for solving CSPs. Both Gaussian elimination on a system of linear equations over a finite field and Dalmau's algorithm in [10] are systems of constrains with n variables and the solution sets each have 37
2

generating sets of size polynomial in n with respect to an appropriate algebraic structure. Furthermore, Dalmau's algorithm applies globally to the class CSP(  ) where  = Inv(Pol()).

38

Chapter 4

REDUCTION AND ANALYSIS OF OUR RELATIONAL STRUCTURE

In this chapter, we will design and describe an algorithm which can solve a CSP with few subpowers using a Boolean circuit. Before we can start solving a given CSP, we must reduce our instance to one which fits our algorithm. In this case, we desire to reduce the relational structure associated with the CSP to one which contains only binary relations. Afterwards, we will alter our CSP by implementing a consistency checking algorithm designed to use existing constraints to create new ones of arity 2 and 3 helping us narrow down our solution set. Once we have a fully reduced CSP, we will study the algebraic properties of its relational structure. More specifically, we will study the different types of subalgebras of the algebra created using its relational structure.

4.1

Reduction to a Binary Relational Structure

By interpreting CSPs as homomorphism problems between relational structures, Hell and N eset ril proved the Dichotomy conjecture for simple graphs [14] and Barto et al improved the result by including finite digraphs with no sources or sinks [2]. Feder and Vardi were able to reduce, in polynomial time, the problem of proving the Dichotomy Conjecture to the homomorphism 39

problem for digraphs whose vertices can be partitioned into levels (balanced digraphs) [11]. More specifically, it was shown that any relational structure A can be reduced to a balanced digraph D(A) such that CSP(A) is polynomialtime equivalent to CSP(D(A)).

Just as with constraint languages in the form of relations, we can create an algebra using the polymorphisms of the relations in a relational structure. Let A = (A, R) be a relational structure. We define the algebra of polymorphisms AA to be the algebra Pol(A) = (A, Pol(R)). Just as with constraint languages, we call a relational structure A tractable or NP-complete if CSP(A) is. For relational structures whose algebra of polymorphisms has few subpowers, the complexity of the reduction itself from A to D(A) was improved in [8] who showed that it was possible to perform the reduction in logspace. Before we describe this reduction, we must first define a new type of relational structure (or constraint language) which is equivalent to one which has few subpowers. Definition 4.1. An algebra is called congruence modular if there exist operations m0 (x, y, z, u), m1 (x, y, z, u), ..., mn (x, y, z, u) satisfying

m0 (x, y, z, u) = x mi (x, y, y, x) = x, mi (x, x, y, y ) = mi+1 (x, x, y, y ) mi (x, y, y, z ) = mi+1 (x, y, y, z ) mn (x, y, z, u) = u for all i  n for all even i  n for all odd i  n

40

The reduction we will describe reduces congruence modular relational structures (among others) to a balanced digraph in logspace. It was also proven in [19] that congruence modular relational structures are equivalent to those which have few subpowers. The following theorem was established. Theorem 4.1 ([8]). Let A be a finite relational structure and let D(A) be the associated digraph. On the algebra of polymorphisms of A and D(A), there exist congruence modular operations if and only if there exists a k -edge operation for some k  4 (equivalent to having few subpowers).

For the construction of D(A) in [8], vertices were connected by what were called oriented paths. An oriented path is a sequence of vertices v1 , v2 , ..., vk such that for every i  [k ], only one of the pairs, (vi , vi+1 ) and (vi+1 , vi ), contains a directed edge between them. These oriented paths were made up of two kinds of components made up of vertices · and directed edges · - ·. A single edge between two vertices was simply the directed edge · - · and a zigzag between four vertices was the oriented path · - · - · - ·. Each of these components were partitioned in a manner such that each would add one level to the balanced digraph (hence the name "zigzag"). The oriented path connecting each vertex in D(A) was made up of a concatenation of single edges and zigzags (denoted P1 P2 , where P1 and P2 are components of an

oriented path). For an oriented path P with a sequence of vertices v1 , v2 , ..., vk , we refer to first vertex v1 as P and the last vertex vk as  P.

Let A = (A, R) be a relational structure and let k be the arity of R. For 41

each subset L  [k ] and element l  [k ], the oriented path component QL,l was defined as a single edge if l  L and a zigzag if l  [k ] \ L. The oriented path QI was defined as

QL = · - ·

QL,1

QL,2

...

QL,k

· - ·

which has level k + 2; one for each QL,l and two more to account for the single edges at each end. Having established these components, the digraph D(A) was defined. Definition 4.2 ([8]). For every e = (a, r)  A × R, define the oriented path Pe = Q{i:a=ri } . The digraph D(A) is the relational structure (A  R, A × R) for which each edge relation e  A × R is replaced with the oriented path Pe (with a = Pe and r =  Pe ) and the vertex set A  R does not include the · vertices used the make up each oriented path.

4.2

Bounded Width

For our particular CSP, and CSPs in general, we can use what are called consistency checking algorithms to identify and refute unsolvable instances without attempting to solve them using straightforward algorithms. Using the constraints already presented in the CSP and the variables in their scope, we can formulate "obvious" unary constraints (an assignment for a single variable) and use them to arrive at a contradiction. CSP subclasses whose instances with no solutions can all be refuted using consistency checking algorithms are said 42

to have bounded width. More specific cases of bounded width can be classified based on the size of the constraints and number of variables used to create the new constraints. Example 4.1. Consistency checking can be used to refute unsolvable cases of 2-Colourability. Suppose we are given a graph G which is a 5-cycle with vertices v1 , v2 , ..., v5 . The CSP instance can be expressed as P = (V, A, C ) where: V = {v1 , v2 , ..., v5 }, A = {0, 1}, and Ci = {(vi , vi+1 ), {(0, 1), (1, 0)}}  C for all i  [5] with addition modulo 5. By assigning a value to each vertex based on its colour, we are essentially presented with the following inequalities:

v1 = v2 , v2 = v3 , v3 = v4 , v4 = v5 , v5 = v1 .

If take the first two inequalities v1 = v2 and v2 = v3 , then we have v1 = v3 which introduces a new constraint X = {(v1 , v3 ), {(0, 0), (1, 1)}}. If we take v1 = v3 and the third inequality v3 = v4 , then we have v1 = v4 which introduces another new constraint Y = {(v1 , v4 ), {(0, 1), (1, 0)}}. If we take v1 = v4 and the fourth inequality v4 = v5 , then we have v1 = v5 which introduces another new constraint Z = {(v1 , v5 ), {(0, 0), (1, 1)}}. Our new equality v1 = v5 contradicts the fifth inequality v5 = v1 and the constraint set C + {X, Y, Z } contains two contradicting constraints, C5 and Z , which cannot both be satisfied. Hence, by using consistency checking, we are able to refute the CSP instance P = (V, A, C + {X, Y, Z }) and declare it unsolvable.

Every unsolvable instance of 2-Colourability can be refuted with a 43

consistency checking algorithm like the one presented in Example 4.1 because graphs with odd cycles are not bipartite (see next paragraph). Hence, 2Colourability has bounded width. More specifically, since the consistency checking algorithm creates 2-ary constrains using other constraints which, together, consist of at most 3 distinct variables, we say that 2-Colourability has (2, 3)-width. In order to provide a more mathematical definition of bounded width, we must first introduce the notion of minimality. Definition 4.3 ([4]). A CSP instance P = (V, A, C ) with binary constraints is (2, 3)-minimal if it contains a unique unary constraint Cx for all x  V and a unique binary constraint Cx,y for all distinct x, y  V such that: (1) For every pairwise distinct variables x, y, z  V and every binary relation (a, b)  Cx,y , there exists a unary relation (c)  Cz such that (a, c)  Cx,z and (b, c)  Cy,z for all a, b, c  A.
-1 and (2) For any pairwise distinct variables x, y  V , we have Cx,y = Cy,x

the projection of Cx,y onto the first and second coordinates are equal to Cx and Cy respectively.

To understand this definition, it is helpful to visualize a (2, 3)-minimal instance of a CSP as an "n-partite" graph. In this context, we will define a n-partite graph as a graph G = (V, E ) such that the vertex set V (G) can be partitioned into disjoint sets V1 , V2 , ..., Vn and edges can only exist between vertices in distinct sets. Our n-partite graph for a (2, 3)-minimal instance P = (V, A, C ) will have n = |V | partitions (one for each variable). In the 44

partition corresponding to a variable x  V , we will place a vertex for each relation (a)  Cx . We will place an edge between vertices a and b if they are in separate partitions and (a, b)  Cx,y . The first condition of Definition 4.3 guarantees that each edge in our graph belongs to a triangle. It is easy to see that a solution to our CSP instance corresponds to an n-clique in our n-partite graph for which each vertex is contained in a separate partition.

It is known that any binary CSP instance P = (V, A, C ) can be converted to a (2, 3)-minimal instance in polynomial time as long as the unary constraint Cx is not empty for all x  V [4]; we will refer to the algorithm which performs this conversion as the (2, 3)-minimality algorithm. We are now ready to provide a proper definition of bounded width [4]. Definition 4.4 ([4]). A constraint language  is said to have (2, 3)-width if the (2, 3)-minimality algorithm refutes all unsolvable instances of CSP(). There are many other ways to define bounded width using equivalent characteristics. Like the tractability of a CSP, bounded width can be assessed using algebraic properties of the algebra of polymorphisms of the associated relational structure. Definition 4.5. Let A be an algebra with universe A. An n-ary operation  is called a weak near-unanimity (WNU) operation if for all x, y  A, (1)  (x, x, ..., x) = x ( is idempotent ), and (2)  (y, x, x, ..., x) =  (x, y, x, x, ...x) =  (x, x, ..., x, y ).

45

The presence of WNU operations in the algebra associated with a constraint language has a direct link to the solvability of a CSP. It was shown through a combination of results [1] that if the algebra associated with a constraint language  does not contain a WNU operation, then the subclass CSP() is NP-complete. The presence of WNU operations is also linked to whether a CSP has bounded width. Theorem 4.2 ([1]). Let A be the algebra associated a constraint language . The subclass CSP() has bounded width if and only if A contains two WNU operations with consecutive arities. Example 4.2. Let B = (B, R) be a binary relational structure such that B = {0, 1} and has the relation 0 1. The algebra of polymorphisms

Pol(B) will contain (among others) the 2-ary operation  ("or") such that (x, y ) = (y, x) = 1 if and only if x = 1 or y = 1, and the 3-ary operation  (majority) such that  (x, y, z ) = 1 if and only if at least two of the numbers x, y, z are equal to 1 for all x, y, z  B . We can see that  is a WNU operation since: (1) (0, 0) = 0, (1, 1) = 1, and (2) (1, 0) = (0, 1) = 1. Also, we can see that  is a WNU operation since: (1)  (0, 0, 0) = 0,  (1, 1, 1) = 1, and 46

(2)  (1, 0, 0) =  (0, 1, 0) =  (0, 0, 1) = 0,  (0, 1, 1) =  (1, 0, 1) =  (1, 1, 0) = 1. Since both  and  are WNU operations with consecutive arities, we can conclude that the subclass CSP(B) has bounded width.

4.3

Subalgebras of the Binary Constraint Language

The balanced digraph A created as a result of reducing a relational structure whose algebra of polymorphisms contains few subpowers has binary edge relations. As a result, the subclass CSP(A) will have binary constraint relations. In this section, we will study the subalgebras of the algebra of polymorphisms AA . The subalgebras of AA can be interpreted as compatible unary relations thus making them definable primitive positive formulas over basic relations and constants. In fact, the primitive positive formulas can be defined using relations only because we can omit the constants since every constant corresponds to basic unary relations. Since AA contains a k -edge operation, its minimal subalgebras can only be of Type 2, 3, or 4 in the sense of Tame Congruence Theory [16] (not to be confused for similarity type for relational structures). Of these algebra types, only Type 3 and Type 4 have what we call an absorbing element for each binary operation. Definition 4.6. Let A = (A, F ) be an algebra and let   F be a binary operation. An element x  A is called an absorbing element if for all a  A, we have x  a = a  x = x. 47

Example 4.3. Let A = (Z, {gcd, ×}) be an algebra whose universe is the set of integers and whose binary operations include the Greatest Common Divisor and product operations. We can see that the element 1  Z is an absorbing element for gcd since gcd(1, x) = gcd(x, 1) = 1 for all x  Z. Similarly, we can see that the element 0  Z is an absorbing element for × since 0 × x = x × 0 = 0 for all x  Z.

Type 2 (affine type): Suppose M is a strictly simple subalgebra of AA of Type 2; it is a strictly simple affine module [18]. An algebraic structure is said to be strictly simple if it is simple, its domain has at least 2 elements, and it has no proper, non-trivial subalgebra. An algebra M is said to be affine with respect to an Abelian group M = (M, {+, -, 0}) if M and M have the same universe, m(x, y, z ) = x - y + z is a term operation of M, and the 4-ary relation QM = {(a, b, c, d)  M 4 | a - b + c = d} is a subuniverse of M 4 . For a vector space KM , let T (KM ) denote the group, {x + m | m  M }, of translations of KM , and let C (KM ) denote the set of all binary operations rx + (1 - r)y , where r  End(KM ), the set of all endomorphisms of M (also known as the endomorphism ring of M). A finite algebra, M with universe M is said to be affine if and only if there exists a finite field K, a vector space KM = (M, +, K), and an endomorphism e of KM with e2 = e such that M is term-equivalent to one of the algebras

(M, {x - y + z, C (KM ), e})

or

(M, {x - y + z, C (KM ), e, T (KM )})[18].

48

Every finite simple affine algebra has, as it underlying universe, a finitedimensional vector space over a finite field F with universe F , where |F | = pk for some prime number p and positive integer k . Definition 4.7. A cyclic group C = (C, ) is an Abelian group with an invertible associative operation  whose universe contains an element which can generate the entire set. Example 4.4. The group Zn = ({0, 2, ..., n - 1}, +) under addition modulo n is a cyclic group. The universe of Zn can be generated by the element 1 since for all k  {0, 2, ..., n - 1}, we have k = 1k , where the notation 1k represents the addition of 1 to itself k times. Here, we have 0 = 1n since 0 = n (mod n). We consider the following theorem known as the Fundamental Theorem of Finite Abelian Groups, Theorem 4.3. Suppose G is an Abelian group. Then G can be expressed uniquely as a direct product of finite cyclic groups of order pk for some prime number p and some positive integer k . If we fix an element 0  M in the universe of M such that x + y = x - 0 + y , our theorem implies that under the binary operation +, the subuniverse M is a direct sum of a finite number of cyclic groups Zpr for some r  [k ].

Type 3 (Boolean Type): Suppose M is a strictly simple subalgebra of AA of Type 3. We consider three kinds: quasiprimal, Boolean, and "cross-type" [18]. The quasiprimal algebras are algebras whose operations are all induced

49

by a polymorphism on some relation on the elements of its universe. Hence, every element of a quasiprimal universe is an absorbing element [18]. A Boolean algebra M = (M, F ) is one for which the universe M = {TRUE, FALSE} contains the Boolean truth values and the set F = {, , ¬} contains the binary  ("and") and  ("or") operations and the unary ¬ ("not") operation. It is also true that every element in a Boolean algebra is an absorbing element since TRUE is the absorbing element for , and FALSE is the absorbing element for .

To define a "cross-type" subalgebra M of AA , we must define a new type of group. Definition 4.8. A permutation group is a group G = (G, ) such that the elements of G are permutations p : P - P of some finite set P and the operation  is the composition of permutations such that for f (P ), g (P )  G, we have f  g = f (g (P )). We introduce the following notations regarding M = (M, F ). For m  M and integer k  2, we define the following k-ary relation [18]

m Xk = {(m1 , m2 , ..., mk )  M k : mi = m for at least one i  [k ]}.

m Also, we define Fk to be the set of operations f on universe M for which m Xk is a subuniverse of the algebra (M, f )k . Let G be a permutation group

acting on M . We define RM (G) to be the set of operations f on M which are idempotent and admit each member of G as an automorphism. A "cross-type" 50

m subuniverse is a strictly simple algebra M = (M ; Fk  RM (G)) [18].

Theorem 4.4. If M is a "cross-type" algebra, then it cannot contain a Mal'tsev operation. Proof: We argue by contradiction. Suppose M = (M, F ) is a "cross-type" algebra and m(x, y, z )  F is a Mal'tsev operation on M . Let 0 be a distinct element used to define the "cross" and let x = 0. If the cross for M is k dimensional with k  3, we consider the following k -tuples,

a = (0, x, x, x, ..., x), b = (0, 0, x, x, ..., x), c = (x, 0, x, x, ..., x).

Clearly, a, b, and c are in the k -cross and m(a, b, c) = (x, x, x, ..., x) since m(0, 0, x) = m(x, 0, 0) = m(x, x, x) = x. This k -tuple is also in the k -cross which implies that x = 0, a contradiction. Hence, a "cross-type" algebra cannot contain a Mal'tsev operation.

Before we continue, we must expand of the algebraic concepts discussed so far. Let A = (A, F ) and B = (B, F ) be algebras of the same type. We call B an absorbing subalgebra of A if there exists an idempotent term operation t in A such that t(B, B, ..., B, A, B, B, ..., B )  B . To be clear, if all but one of the arguments in t are elements in B , then t outputs an element in B . An algebra A is called hereditarily absorption-free (HAF) if each subalgebra B  A has no absorbing subalgebra. Before stating our next theorem, we must define a new type of operation. Definition 4.9. Let t be an n-ary operation. We call t a Taylor term if it is 51

idempotent and, for each coordinate i  n, satisfies

t(x1 , x2 , ..., xn ) = t(y1 , y2 , ..., yn ),

where x1 , x2 , ..., xn , y1 , y2 , ..., yn  {x, y } and xi = x, yi = y . Theorem 4.5 ([3]). Let A be a finite idempotent algebra with a Taylor term. If A is HAF, then it has a Mal'tsev term. We will use the contrapositive statement to Theorem 4.5 to show that a "crosstype" algebra contains an absorbing element. Theorem 4.6. Let M be a Type 3 algebra with universe M . If M is a "crosstype" algebra, then it must contain an absorbing element. Proof: We argue by contradiction. Suppose M is a strictly simple "crosstype" algebra with no absorbing element. Since M cannot have a Mal'tsev operation, it is not HAF. So there exists some subalgebra of M which has an absorbing subalgebra. But, since M is an algebra on a binary set, the only proper subuniverse of M is single element. An algebra with a single element in its universe cannot have an absorbing subalgebra. Therefore, M must be HAF and, as a result, must have a Mal'tsev term; a contradiction. Hence, M must have an absorbing element.

Type 4 (lattice type): The only strictly simple subalgebra of AA of Type 4 is the 2-element lattice,

M = ({0, 1}, {, }). 52

Assuming that the elements are ordered 0

1, the element 0 is the absorbing

element of the  ("meet") operation and the element 1 is the absorbing element of the  ("join") operation.

53

Chapter 5

A BOOLEAN CIRCUIT ALGORITHM FOR CSPS WITH FEW SUBPOWERS

Having reduced our constraint template to one which is binary, the subalgebras of the algebra of polymorphisms of our relational structure allow us to define a solution set to a CSP with few subpowers as an algebra itself using the context of these subalgebras. We are then able to define the CSP as a logical formula which we can interpret as a Boolean tree. Using our Boolean tree interpretation, we are able combine pairs of constraints and eliminate inconsistent solutions until we reach a solution set which satisfies all of the constraints. In order to interpret our CSP solution as an algebra, we must introduce an algebraic structure similar to that of a subpower.

5.1

Subdirect Products of two Strictly Simple Subalgebras

In this section, we will construct and analyze an algebraic structure made up of the solution set of a CSP. Let P = (V, A, C ) be a CSP instance and let F be the set of functions f : V - A which make up the solution set of P (in the form of functions which map V to A). We can define a "solution algebra" S = (A, F ) to be the algebra associated with solution set of P . Before we continue, we must define a new type of subalgebra which is similar to a 54

subpower. Definition 5.1 ([9]). Let A1 , A2 , ..., An be a set of finite algebras with universes A1 , A2 , ..., An respectively. An algebra B with universe B is a subdirect product of A1 , A2 , ..., An if it is a subalgebra of A1 × A2 × ... × An and proji B = Ai for all i  [n]. We denote this as B sp A1 × A2 × ... × An . As per its definition, a subdirect product is a generalization of a subpower. Whereas a subpower is a subalgebra of the product of n copies of an algebra A, a subdirect product is a subalgebra of the product of n different algebras Ai . We will now prove a well-known property of subdirect products. Theorem 5.1. Suppose A1 and A2 are subalgebras of A = (A, F ). If x  A, then the set [x]+ = {y  A2 | (x, y )  A1 × A2 } is a subuniverse of A1 . Proof: Let y1 , y2 , ..., yk  [x]+ . Suppose we take some k -ary operation f  F . Since f is idempotent, we have x = f (x, x, ..., x)  A1 , and since A2 is a subalgebra of A, we have y = f (y1 , y2 , ..., yk )  A2 . Therefore, we have (f (x, x, ..., x), f (y1 , y2 , ..., yk ))  A1 × A2 and f (y1 , y2 , ..., yk )  [x]+ .

The previous theorem leads to the following corollary presented by Burris and Sankappanavar. Corollary 5.1 ([9]). Let A1 and A2 be strictly simple subalgebras of A with universes A1 and A2 respectively. A subdirect product of A1 and A2 must be either, (1) be isomorphic to A1 × A2 , 55

(2) be equivalent to A1 × A2 (a direct product), or (3) have the following property: for every x  A1 , either the set [x]+ is a trivial subuniverse of A2 or [x]+ = A2 .

We are almost ready to present the main result of this paper. Before we design an algorithm which solves a CSP with few subpowers using a Boolean circuit, we must prove our theorem which establishes algebraic properties of the solution algebra crucial to the formulation of the Boolean circuit. Theorem 5.2. Let P = (V, A, C ) be an instance of CSP(A), where A is relational structure reduced to one which is binary as in Chapter 4.1 and altered using consistency checking as in Chapter 4.2 whose algebra of polymorphisms A has few subpowers. Let S = (A, F ) be the solution algebra associated with the set of functions F which make up the solution set of P . The following statements hold true: (1) S is a subalgebra of An , where n = |V | (S is a subpower of A). (2) There exists a subalgebra B of S such that

B sp B1 × B2 × ... × Bn ,

where Bi  A for all i  [n] are either trivial or strictly simple affine modules. Proof: (1) follows directly from the definition of a solution set for a CSP and the definition of a polymorphism from Chapter 2; we will prove (2). It is clear 56

from (1) that the solution algebra S can be written as a subdirect product

S sp S1 × S2 × ... × Sn  Ax1 × Ax2 × ... × Axn  An ,

such that every Si is a subalgebra of Axi , which we will define as the subalgebra of A whose universe consists solely of the element xi for all i  [n]. Suppose, without a loss of generality, that S1 is neither trivial nor a strictly simple affine module. Then S1 must itself contain a strictly simple subalgebra M1 . If S1 is in fact trivial or a strictly simple affine module, then set S1 = M1 . Let the algebra S1 = proj1 S be the restriction of S to those solution n-tuples whose first projection coordinate lies in the universe of M1 . Proceeding iteratively on all Si up to i = n, we have

projn S = Sn sp M1 × M2 × ... × Mn ,

where Mi are all trivial or strictly simple and Sn is a subalgebra of S. However, strictly simple subalgebras of Type 3 and Type 4 have absorbing elements as explained in Chapter 4. Applying absorption in each coordinate i such that Mi is neither trivial nor a strictly simple affine module gives us the desired result. Hence, by setting Sn = B and Mi = Bi , we have proven our claim.

57

5.2

Constructing a Logical Formula Capturing the CSP

Let  be a constraint language with few subpowers and let A be the associated algebra. Suppose P = (V, A, C ) is an instance of CSP() with binary constraints as defined in Theorem 5.2. We will construct a logical formula which can solve our CSP. We may also assume that P is a simplified CSP such that every pair of variables in V appears as the scope of, at most, one constraint. If we set n = |V |, then there are n2 possible constraints in C . For some integer l, where 1  l  n2 , the constraints of P can be written as Ci (xi1 , xi2 ) for all 1  i  l and distinct xi1 , xi2  V . We can now interpret the solvability of P as being equivalent to the satisfiability of the primitive positive formula
l

x1 , x2 , ..., xn
i=1

Ci (xi1 , xi2 ).

This formula can be arranged as a Boolean tree B with leaves labeled "Ci " and internal vertices labeled "". It is clear that the total number of leaves (input gates) in B is of order O(n2 ) and the depth of B is of order O(logn) since logl  log(n2 ) = 2logn.

Next, we will analyze the complexity of the Boolean formulas corresponding to the leaves in B . Every constraint Ci (xi1 , xi2 ) can be written as the disjunction M1 (xi1 )  M2 (xi2 )  M1 ,M2 (xi1 , xi2 ) ,
M1 ,M2 A

where the disjunction ranges over all pairs, M1 and M2 , of trivial and strictly

58

simple subalgebras of A. The formulas M1 and M2 are primitive positive formulas which define the subuniverses M1 and M2 of M1 and M2 respectively while the formula M1 ,M2 states that there exists a subdirect product of M1 ×M2 which is contained in the solution set of P . The number of pairs, M1 and M2 , of trivial strictly simple subalgebras of A is a constant dependent only on its universe and operations and not on the number of variables n = |V |; it will not affect the complexity of solving P .

We will closely study the formula M1 ,M2 . It will vary based on whether at least one of the subalgebras M1 or M2 does not has a Mal'tsev operation. If both M1 and M2 have Mal'tsev operations, their subdirect product must either be an isomorphism of M1 × M2 or a direct product according to Corollary 5.1. In the case of an isomorphism, M1 ,M2 may be written as xi2 = xi1 + a, where a is some constant in the Abelian group which is the isomorphism type of both M1 and M2 . In fact, as discussed earlier in this chapter, this equation for M1 ,M2 is equivalent to the conjunction of cyclic equations over Zpr for some prime number p and a suitable positive integer r. In the case of a direct product, the formula for M1 ,M2 can be omitted from the constraint. If at least one of M1 and M2 has no Mal'tsev operation, then the subalgebra must contain an absorbing element as explained in Chapter 4.3. We have a direct product of two subalgebras where at least one is trivial. Like in the previous case, the formula for M1 ,M2 can be omitted from the constraint while the formulas for M1 and M2 can be changed to one for a trivial subalgebra corresponding to the absorbing element.

59

We are ready to state and prove our main result and show that the subclass of CSPs with few subpowers belongs to the class NC2 . As mentioned earlier, the constraints of P can be arranged as a Boolean tree with each leaf being labeled as a constraint and each internal vertex being labeled "". We will show that the formulas corresponding to each  vertex can be computed in logspace. Theorem 5.3. Let P = (V, A, C ) be an instance of CSP(A), where A is relational structure reduced to one which is binary as in Chapter 4.1 and altered using consistency checking as in Chapter 4.2 whose algebra of polymorphisms A has few subpowers, and let V = {x1 , x2 , ..., xn }. Suppose P is formulated as a Boolean tree B as described so far in this section. Given the formulas corresponding to its children vertices, the formula corresponding to a  vertex can be computed in logspace. Proof: Inductively, we may assume that the formulas for the children vertices of each  vertex can be expressed as
n

1 (x1 )  2 (x2 )  ...  n (xn )  sys(x1 , x2 , ..., xn ) ,
Ci C

where each i (xi ) is a primitive positive formula defining a trivial or strictly simple subalgebra of A whose universe consists solely of the element xi for all i  [n], and sys(x1 , x2 , ..., xn ) is the formula which describes a conjunction of linear systems of cyclic equations. The conjunction of two such disjunction terms which appear in the children vertices of the  vertex can be computed 60

in logspace. If the vertices are inconsistent, the conjunction of the two terms will be deleted from the disjunction. Therefore, the formula corresponding to the root vertex of the binary tree can be computed in logspace. It is known that any system of linear equations over a finite field can be computed in NC2 [20]. If we add the depth of the tree to our overall algorithm, it will be of order O(log2 n + 2logn) = O(log2 n).

Having shown that the formulas in the Boolean circuit B can be solved in logspace, and that the circuit itself has logarithmic depth and polynomially many input gates, we can conclude that the subclass of CSPs with few subpowers belongs to the class NC2 .

61

Chapter 6

CONCLUDING REMARKS AND OPEN PROBLEMS

We conclude by providing a brief overview of the material covered in this paper. We began by summarizing the full scope of the constraint languages whose CSP subclasses can be solved using the "robust Gaussian-like" algorithm described by Idziak et al [15]. The algorithm they described represents a full generalization of the algorithms presented by Bulatov and Dalmau in [7] and [10] among other contributions. Although we eventually go on to explore alternative methods to solve CSPs with few subpowers, we still consider [15] to be the primary source on such CSPs. Along with the conjectures we will present, there are many more open problems pertaining to the study of CSPs. Our result in this paper does not solve any of them, but it does tighten the result presented in [15] by placing the subclass of CSP with few subpowers in the class NC2 , a subset of P.

6.1

A Brief Summary

There exists an alternative algorithm more efficient than the one presented in [15] which solves CSPs with few subpowers. The algorithm we describe solves these CSPs using a Boolean circuit placing the subclass of CSPs with few subpowers in the class NC2 . First, our method requires that the CSP 62

be reduced to one which has only binary constraints so that the algebra of polymorphisms of the associated binary relational structure yields favorable subalgebras which will be used to define the CSP as a logical formula. Afterwards, we must run a consistency checking algorithm to use the constraints already provided to create new ones to narrow down our set of possible solutions.

Once our CSP has been properly reduced and modified, we set the stage for our main result by presenting and proving Theorem 5.2, which interprets our solution set as an algebra itself. Using this interpretation, we are able to define our CSP as a primitive positive formula which can be arranged as a Boolean tree where each leaf is a constraint. The process of solving the CSP is akin to traveling up our binary tree by combining pairs of constraints and eliminating inconsistent functions from the solution set until we have reached the root of the tree. The remaining functions in the solution set will be those which satisfy all of the constraints. Since there are polynomially many constraints and the depth of the tree is logarithmic, we can place the subclass of CSPs with few subpowers in the class NC2 .

6.2

Open Problems

We conclude our exposition on the subject of tractable CSP subclasses by examining some of the open problems related to the subject of this paper. Like

63

the Dichotomy Conjecture, which remains open decades after its conception, the following conjectures remain open as of this writing.

Conjecture 6.1. Every CSP over a finite template with few subpowers can be reduced in polynomial time (or logspace) to one which has bounded width. Furthermore, the reduced CSP has only binary constraints. In [1] a polynomial time reduction to a so-called syntactically simple binary instance is presented; the reduction can be carried out in such a way that the obtained binary instance is (2,3)-minimal. This reduction can be viewed as a counterpart to our reduction of a CSP to a digraph since our reduction is to instances of affine domains which lack the properties associated with domains of bounded width. For a brief introduction to Polynomial Interpretation Logic and its role in the problem of solving CSPs based on finite relational structures in polynomial time, we refer the reader to [12].

Conjecture 6.2. Every CSP over a finite template with few subpowers is definable in Polynomial Interpretation Logic with Cardinality Quantifiers (or, equivalently, in the Choiceless Polynomial Time with Counting). If this conjecture were to be confirmed, it would provide evidence that the two logics, which are equal in their expressive power, can fully encapsulate the subclass of tractable CSPs based on finite relational structures. This would also provide evidence that the Dichotomy for Finite Template CSPs can be logically formulated. The problem of expressibility of finite template CSPs in 64

Choiceless Polynomial Time with Counting is also closely related to expressibility of certain known tractable cases of the graph isomorphism problem in the same logic.

Conjecture 6.3. (High Parallelizability Dichotomy) A CSP subclass is in the complexity class NC if and only if the variety generated by its algebra of polymorphisms omits Type 5 (semi-lattice type) algebras in the sense of Tame Congruence Theory [16].

65

BIBLIOGRAPHY

[1] Barto, L. and Kozik, M. Constraint Satisfaction Problems of Bounded Width. Proceedings of the 50th Annual IEEE Symposium on Foundations of Computer Science, FOCS'09, 2009, 595-603. [2] Barto, L.; Kozik, M.; and Niven, T. The CSP Dichotomy Holds for Digraphs with no Source and no Sinks (A Positive Answer to a Conjecture of Bang-Jensen and Hell). SIAM Journal on Computing, 2009, 38, 1782-1802. [3] Barto, L.; Kozik, M.; and Stanovsk´ y, D. Mal'tsev Conditions, Lack of Absorption, and Solvability. Algebra Universalis, 2015, 74, 185-206. [4] Barto, L.; Krokhin, A.; and Willard, R. Polymorphisms, and How to Use Them The Constraint Satisfaction Problem: Complexity and Approximability. [Result of a Dagstuhl Seminar], 2017, 1-44. [5] Berman, J.; Idziak, P.; Markovi´ c, P.; McKenzie, R.; Valeriote, M.; and Willard, R. Varieties with Few Subalgebras of Powers, Transactions of the American Mathematical Society, 2010, 362, 1445-1473 [6] Bulatov, A. A Dichotomy Theorem for Constraint Satisfaction Problems on a 3-Element Set. Journal of the ACM, 2006, 53, 66-120. [7] Bulatov, A. and Dalmau, V. A Simple Algorithm for Mal'tsev Constraints. SIAM Journal on Computing, 2006, 36, 16-27.

66

[8] Bul´ in, J.; Deli´ c;, D.; Jackson, M.; and Niven, T. A Finer Reduction of Constraint Problems to Digraphs. Logical Methods in Computer Science, 2015, 11, 1-33. [9] Burris, S. and Sankappanavar, H. A Course in Universal Algebra. SpringerVerlag, 1981. [10] Dalmau, V. Generalized Majority-Minority Operations are Tractable. Logical Methods in Computer Science, 2006, 2, 1-15. [11] Feder, T. and Vardi, M. The Computational Structure of Monotone Monadic SNP and Constraint Satisfaction: A Study through Datalog and Group Theory. SIAM Journal on Computing, 1999, 28, 57-104. [12] Gr¨ adel, E.; Kaiser, ; Pakusa, W.; and Schalth¨ ofer, S. Characterising Choiceless Polynomial Time with First-Order Interpretations. Proceedings of 30th Annual ACM/IEEE Symposium on Logic in Computer Science, 2015. [13] Habte, A. Constraint Satisfaction Problems in the Logic LFP+Rank. Ryerson University, 2015. [14] Hell, P. and N eset ril, J. On the Complexity of H-Coloring. Journal of Combinatorial Theory, 1990, Ser. B 48, 92-110. [15] Idziak, P.; Markovi´ c, P.; Mckenzie, R.; Valeriote, M.; and Willard, R. Tractability and Learnability Arasing from Algebras with Few Subpowers. SIAM Journal on Computing, 2010, 39, 3023-3037.

67

[16] Larose, B. and Tesson, P. Universal Algebra and Hardness Results for Constraint Satisfaction Problems. Theoretical Computer Science, 2009, 410, 1629-1647. [17] Schaefer, T. The Complexity of Satisfiability Problems. Conference Record of the Tenth Annual ACM Symposium on Theory of Computing, 1978, 216-226. ´ A Survey of Strictly Simple Algebras and Minimal Varieties. [18] Szendrei, A. Universal Algebra and Quasigroup Theory, 1992, 19, 209-239. [19] Valeriote, M. A Subalgebra Intersection Property for Congruence Distributive Varieties. Canadian Journal of Mathematics, 2009, 61, 451-464. [20] Vollmer, H. Introduction to Circuit Complexity, Springer-Verlag, 1999.

68


