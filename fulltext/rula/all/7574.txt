AUTHENTICATION PROTOCOLS FOR SMART HOMES

by Maninder Singh Raniyal B.Tech in Computer Science, Punjab Technical University, India, 2010

A Thesis presented to Ryerson University in partial fulfillment of the requirements for the degree of Master of Science in the Program of Computer Science

Toronto, Ontario, Canada, 2018 c Maninder Singh Raniyal 2018

Author's Declaration
I hereby declare that I am the sole author of this thesis. This is a true copy of the thesis, including any required final revisions, as accepted by my examiners. I authorize Ryerson University to lend this thesis to other institutions or individuals for the purpose of scholarly research. I further authorize Ryerson University to reproduce this thesis by photocopying or by other means, in total or in part, at the request of other institutions or individuals for the purpose of scholarly research. I understand that my thesis may be made electronically available to the public.

ii

AUTHENTICATION PROTOCOLS FOR SMART HOMES
c Maninder Singh Raniyal, 2018 Master of Science in Computer Science Ryerson University

Abstract
One of the IoT's greatest opportunity and application still lies ahead in the form of smart home. In this ubiquitous/automated environment, due to the most likely heterogeneity of objects, communication, topology, security protocols, and the computationally limited nature of IoT objects, conventional authentication schemes may not comply with IoT security requirements since they are considered impractical, weak, or outdated. This thesis proposes: (1) The design of a two-factor device-to-device (D2D) Mutual Authentication Scheme for Smart Homes using OTP over Infrared Channel (referred to as D2DA-OTP-IC scheme); (2) The design of two proxy-password protected OTP-based schemes for smart homes, namely, the Password Protected Inter-device OTP-based Authentication scheme over Infrared Channel and the Password Protected Inter-device OTP-based Authentication scheme using public key infrastructure; and (3) The design of a RSA-based two-factor user Authentication scheme for Smart Home using Smart Card.

iii

Acknowledgment

Foremost, I would like to thank Dr. Isaac Woungang for his incomparable guidance and continuous support. It is a wonderful and extraordinary experience to work with Dr. Isaac Woungang. His guidance was very helpful throughout my research. I am also thankful to the Department of Computer Science at Ryerson University for their support toward the accomplishment of my degree, special thanks to our program administrator, Norm Pinder, for his instantaneous support throughout my degree. Wholeheartedly, I thank my family members: father, mother, my both sisters and brothersin-law, and my brother and sister-in-law. Their support was very helpful and motivating, I feel without their support it was difficult to achieve my goal. I am also thankful to my friends for their support at the Ryerson University, they keep me motivated to succeed in my goal.

iv

Contents

Contents List of Figures List of Tables List of Abbreviations 1 Introduction 1.1 1.2 1.3 1.4 Motivation and Research Problems . . . . . . . . . . . . . . . . . . . . . . . Approaches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Thesis Contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

v viii ix x 1 1 3 4 4 6 6 6 7 11 12 13

Thesis Outline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2 Background and Related Work 2.1 Background . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2.1.1 2.1.2 2.1.3 2.1.4 2.2 Need for Multi-Factor Authentication in Smart Home Environment . Smart Home Network Architecture in IoT . . . . . . . . . . . . . . . Types of Authentication Schemes for Smart Home Environments . . . Considered Security Attacks . . . . . . . . . . . . . . . . . . . . . . .

Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

v

2.2.1

Related Work on Authentication Schemes for Smart Home/IoT Environments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

2.2.2

Related Work on Remote User Authentication Schemes Using Smart Card . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 22 22 22 27 27 29 32 36 38 38 43 47 51 53 53 54 59 59 59 60 62 66

3 Proposed Authentication Protocols for Smart Homes Network 3.1 Design and Modelling of the D2DA-OTP-IC Scheme 3.1.1 3.1.2 . . . . . . . . . . . . .

High-Level Architecture of the D2DA-OTP-IC Scheme . . . . . . . . 3.1.2 Modelling of the D2DA-OTP-IC Scheme . . . . . . . . . . . . . 3.1.2.1 3.1.2.2 3.1.2.3 Modelling Tool . . . . . . . . . . . . . . . . . . . . . . . . . HSPSL Syntax . . . . . . . . . . . . . . . . . . . . . . . . . Modelling of the D2DA-OTP-IC Scheme Using HSPSL . . .

3.2

Enhancements of the D2DA-OTP-IC Scheme . . . . . . . . . . . . . . . . . . 3.2.1 3.2.2 3.2.3 3.2.4 3.2.5 Assumptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Design of the PPIDA-IC Scheme . . . . . . . . . . . . . . . . . . . . Design of the PPIDA-PKI Scheme . . . . . . . . . . . . . . . . . . . . Modelling of the PPIDA-IC Scheme Using HLPSL . . . . . . . . . . . Modelling of the PPIDA-PKI Scheme Using HLPSL . . . . . . . . .

3.3

Design of the RSA-ASH-SC Scheme 3.3.1 3.3.2

. . . . . . . . . . . . . . . . . . . . . .

RSA Public Key Cryptosystem . . . . . . . . . . . . . . . . . . . . . RSA-ASH-SC Scheme . . . . . . . . . . . . . . . . . . . . . . . . . .

4 Simulations and Security Analysis of the Proposed Schemes 4.1 Security and Performance Analysis of the D2DA-OTP-IC Scheme . . . . . . 4.1.1 4.1.2 4.1.3 4.1.4 SPAN/AVISPA Tool . . . . . . . . . . . . . . . . . . . . . . . . . . . Simulation of the D2DA-OTP-IC Scheme Using AVISPA . . . . . . . Informal Security Analysis of the D2DA-OTP-IC Scheme . . . . . . . Proof of Concept of the D2DA-OTP-IC Scheme . . . . . . . . . . . .

vi

4.2

Security and Performance Analysis of the PPIDA-IC and PPDA-PKI Schemes 72 4.2.1 4.2.2 4.2.3 Simulation Results of the PPIDA-IC Scheme Using AVISPA . . . . . Simulation Results of the PPIDA-PKI Scheme Using AVISPA . . . . 73 75

Informal Security Analysis of the PPIDA-IC and PPIDA-PKI Schemes 76 . . . . . . . . . . . 78

4.3 4.4

Informal Security Analysis of the RSA-ASH-SC Scheme

Comparison of Selected RSA Variants w.r.t. to Security Attacks and Selected Security Metrics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79 79 81 86 86 87 87 89 90 92 108 115 123 125

4.5 4.6

Comparison of Selected RSA Variants w.r.t Computational Performance

. .

Convergence Speed of the Proposed RSA-ASH-SC Scheme . . . . . . . . . .

5 Conclusion 5.1 5.2 Contributions of the Thesis . . . . . . . . . . . . . . . . . . . . . . . . . . . Future Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5.2.1 5.2.2 5.2.3 With respect to the proposed D2DA-OTP- IC protocol . . . . . . . . With respect to the proposed PPIDA-IC and PPIDA-PKI protocols . With respect to the proposed RSA-ASH-SC scheme protocol . . . . .

Appendix A HLPSL code for D2DA-OTP- IC Appendix B HLPSL code for PPIDA-IC Appendix C HLPSL code for PPIDA-PKI Appendix D Servo controller Code Bibliography

vii

List of Figures
2.1 2.2 3.1 3.2 3.3 3.4 4.1 4.2 4.3 4.4 4.5 4.6 4.7 4.8 4.9 Example of a smart home. . . . . . . . . . . . . . . . . . . . . . . . . . . . . Typical Smart Home Network Architecture in IoT. . . . . . . . . . . . . . . High-level architecture of the proposed authentication scheme. . . . . . . . . High Level Design of AVISPA Tool [25]. . . . . . . . . . . . . . . . . . . . . PPIDA-IC scheme authentication phase. . . . . . . . . . . . . . . . . . . . . PPIDA-PKI scheme authentication phase. . . . . . . . . . . . . . . . . . . . Simulation of the D2DA-OTP-IC protocol in AVISPA. . . . . . . . . . . . . D2DA-OTP-IC protocol verification using the OFMC back-end. . . . . . . . D2DA-OTP-IC protocol verification using the CL-AtSE back-end. . . . . . . Raspberry Pi Infrared trancever circuit for LIRC [64]. 3D rotating servo placement. 3D rotating servo circuit. . . . . . . . . . . . . 8 9 23 28 40 45 61 62 63 67 68 69 71 73 74 75 76

. . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . .

OTP based mutual authentication using infrared channel. . . . . . . . . . . . PPIDA-IC protocol verification with the OFMC backend. . . . . . . . . . . . PPIDA-IC protocol verification with the CL-AtSe backend. . . . . . . . . . .

4.10 PPIDA-PKI protocol verification with the OFMC backend. . . . . . . . . . . 4.11 PPIDA-PKI protocol verification with the CL-AtSe backend. . . . . . . . . . 4.12 Convergence speed of selected RSA variants for key length 1024 bits vs. 2048 bits when k=3. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

85

viii

List of Tables
3.1 3.2 3.3 4.1 4.2 A-B Style Notations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . HLPSL Notations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Notations used in the proposed RSA-ASH-SC scheme . . . . . . . . . . . . 24 30 55 65

Comparison of Selected Authentication Schemes based on Security Attacks . Comparison of Selected Authentication Schemes based on some Authentication Characteristics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

66 66

4.3 4.4

Comparison of Selected Authentication Schemes based on evaluation models Comparison of selected RSA variants w.r.t. to security attacks and selected security metrics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

80 81 83

4.5 4.6

Comparison of selected RSA variants w.r.t. to computation performance . . Decryption performance of selected RSA variants [69] . . . . . . . . . . . . .

ix

List of Abbreviations
IR IC OTP D2D DH RSA PKI D2DA-OTP-IC PPIDA-IC PPIDA-PKI RSA-ASH-SC HLPSL AVISPA SPAN FIPS HG BLE LED VLC DoS NFC MIMA BAN SSH CA NIST Infra-red IR channel One Time Password Device to Device Diffie-Hellman Rivest-Shamir-Adleman public-key cryptosystems Public Key Infrastructure D2D authentication schemes for smart homes using OTP over IC Password Protected Inter-device Authentication scheme over IC Password Protected Inter-device Authentication scheme using PKI RSA-based Authentication scheme for Smart Home using Smart Card High Level Protocol Specification Language Automated Validation of Internet Security Protocols and Applications Security Protocol ANimator for AVISPA Federal Information Processing Standard Home Gateway Bluetooth LE Light-Emitting-Diodes Visible Light Communication Denial-of-Service Near Field Communications man-in-the-middle attack Burrows-Abadi-Needham logic Secure shell Certificate Authority National Institute of Standards and Technology x

OFMC CLAtSe TA4SP DY DAC ACL LIRC AES SATMC PAM OS

Onthefly ModelChecker Constraint Logicbased Attack Searcher Tree Automata for the Analysis of Security Protocols Dolev Yao attacker model Discretionary Access Control Access Control Lists Linux Infrared Remote Control Advanced Encryption Standard SAT-based Model Checker Pluggable Authentication Module Operating System

xi

Chapter 1 Introduction
This Chapter introduces the motivation and context of the research carried out in this thesis. The research problems and our solution approaches are highlighted, along with our contributions.

1.1

Motivation and Research Problems

Internet of Things (IoT) [1] has emerged as a driver for many applications in the area of smart homes, smart cities, to name a few. In IoT, devices (also referred to as objects) are often grouped into clusters, therefore, in order to enable secure communications across them, it is required that these objects be able to first authenticate with each other using cloud platforms or IoT-based communication protocols such as the constrained application protocol or the message queue telemetry transport [2], to name a few. However, most of these protocols do not possess inbuilt security mechanisms or rely on limited inbuilt singlefactor authentication security mechanisms [2]. In addition, focusing on a particular class of authentication methods for IoT devices in the cloud, namely one-time password (OTP), it has been reported [3] that most existing OTP schemes are not applicable in the smart home context because their designs would have to be substantially adjusted to fulfill the IoT requirements, in particular smart home requirements. In such an environment, there are 1

essentially two types of authentication schemes: user authentication and device-to-device (D2D) authentication. In user-authentication schemes, some type of secrecy (known only by the user) or a unique biometric information of the user, is utilized for authentication purpose [4]. On the other hand, the design of D2D authentication schemes is challenging since devices are usually heterogeneous, and thus, they are expected to operate under various different protocols as well as being subject to various different resource constraints such as energy restriction and security constraints. In addition, most smart home systems make use of wireless technologies (such as ZigBee, Wi-Fi, to name a few) for communication purpose; and if an attacker can hold the related network packages, various types of attacks such as replay attack, man-in-the-middle, eavesdropping, masquerading, message modification, denial-of-service, reflection, impersonation, to name a few, can be launched [5] to compromise the security of the system. These facts have motivated the need for designing D2D multi-factor authentication schemes for IoT devices, in particular, smart home devices. This thesis proposes the design of two-level device-to-device authentication schemes for smart homes using OTP over an infrared channel (our so-called D2DA-OTP-IC protocol), along with a proof-of-concept in the form of a hardware solution [7]); and two password-proxybased protocols (so-called PPIDA-IC and PPIDA-PKI schemes), which are enhancements to the D2DA-OTP-IC protocol [7]. Although smart homes filled with connected objects will make our lives more convenient by enabling the users to remotely control these objects in communication using, for instance, a voice command or simple push buttons, it is expected that this benefit will also entail serious security concerns from a remote user authentication perspective [6]. Focusing on password-based remote user authentication using smart card, which has been widely used as method (due its user friendliness and easy implementation) to verify the legitimacy of remote users over an insecure network, ensuring a proper access rights to system resources by users and validating the user's identity are major challenges, which justify a clear demand for

2

new layered security approaches for remote user authentication using smart card that can be resistant to various types of attacks including stolen verifier password, forgery attack, server spoofing attack, replay attack, password guessing attack, to name a few. In this respect, this thesis proposes a RSA-based two-factor user Authentication scheme for Smart Home using Smart Card (so-called RSA-ASH-SC) protocol.

1.2

Approaches

The design of our proposed D2DA-OTP-IC protocol [7] comprises two level. In the first level, the key exchange is performed using the DH key exchange protocol and a public key cryptography in order to validate the identity of devices. The second level relies on the use of infrared communication to distribute the OTPs among devices for authentication purpose. In the D2DA-OTP-IC protocol [7], storing the secret information may not be considered safe [8]. Therefore, to fulfill this requirement while complying with the Federal Information Processing Standard (FIPS) 4.7.5 standard [8], the design of the D2DA-OTP-IC scheme is modified to protect the secret and public keys, yielding the PPIDA-IC and PPIDA-PKI schemes, where these keys are protected using passwords and a centralized server is used to provide proxy-password services to the smart home devices. The design of our proposed RSA-ASH-SC relies on the use of a variant of RSA [10], where the message is encrypted and the anonymity about the device/user is achieved and maintained using a one-time-token. The High-Level Protocol Specification Language (HLPSL) is used to model the proposed D2DA-OTP-IC, PPIDA-IC, and PPIDA-PKI schemes, and the Security Protocol Animator for (SPAN)/AVISPA (Automated Validation of Internet Security Protocol and Applications) tool is used for the formal analysis and verification of the efficiency of D2DA-OTP-IC, PPIDA-IC, and PPIDA-PKI schemes, in terms of achieving the goals of secrecy of secret keys and D2D mutual authentication, and integrity. A security analysis of the proposed

3

RSA-ASH-SC scheme is also conducted, showing that it is about 50% faster than the Om and Kumari scheme [10] and 15 times faster than few other RSA-based schemes [10] in terms of RSA decryption speed when the RSA key length is 2048. The RSA-ASH-SC scheme is also shown to maintain the anonymity of the user using a one-time token.

1.3

Thesis Contributions

The contributions of this thesis are as follows: · Design of a two-factor device-to-device (D2D) mutual Authentication scheme for Smart Homes using OTP over Infrared Channel (D2DA-OTP-IC scheme), along with a proofof-concept in the form of a hardware solution. · Design of two proxy-password protected OTP-based schemes (PPIDA-IC and PPIDAPKI) for smart homes, which are enhancements of the D2DA-OTP-IC scheme. · Design of a RSA-based two-factor user Authentication scheme for Smart Home using Smart Card (RSA-ASH-SC). · Formal analysis and verification of the security properties of the above D2DA-OTP-IC, PPIDA-IC and PPIDA-PKI protocols using the SPAN/AVISPA tool. · Security analysis of the RSA-ASH-SC protocol.

1.4

Thesis Outline

The thesis is organized as follows: · Chapter 1 introduces the subject, motivation, and contributions of our research. · Chapter 2 presents some background information and related work pertaining to the scope of this thesis. 4

· Chapter 3 describes the designs and modelling of the proposed D2DA-OTP-IC, PPIDA-IC and PPIDA-PKI protocols, as well as the design of the RSA-ASH-SC protocol. · Chapter 4 is devoted to the simulations and security analysis of the proposed schemes. · Chapter 5 concludes the thesis and highlights some of the future work that can be carried out further.

5

Chapter 2 Background and Related Work
This Chapter introduces the concept of authentication in IoT, in particular, smart homes. The security requirements for smart homes are highlighted, along with the types of authentication schemes for smart home networks. Some security metrics and tools for evaluating and analyzing authentication schemes are discussed, and the ones used in this thesis are highlighted. In addition, the class of security attacks on authentication protocols, which prevail in the context of our study is presented. Finally, some of the recent related work on authentication protocols for smart home environments and remote user authentication schemes for smart home using smart card are discussed.

2.1
2.1.1

Background
Need for Multi-Factor Authentication in Smart Home Environment

Authentication can be defined as a secure process or cryptographic mechanism to correctly identify the communicating parties over an insecure channel in order to prevent any illegal access to the system resources [2]. In conventional authentication schemes, a password is often associated with the user's identity in such process or cryptographic mechanism. The 6

client and the server have no limitations regarding the resources. All devices are able to run complex algorithms such as encryption, and they have no memory limitations. Putting this in the context of IoT or smart home environment, authentication refers to the process of validating a device's identity in communication while ensuring the reliability of the origin of the communication, keeping in mind the constraints associated with the device (such as limited processing power, battery, bandwidth, CPU, memory, network capabilities, to name a few). Nowadays, with the rise of emerging trends of the Internet of Things (IoT) paradigm [11], which are considered as drivers for many applications in the area of smart homes, smart cities, to name a few, IoT devices (referred to as things' or objects' [11]) are typically grouped into clusters. Therefore, in order to design an efficient authentication scheme, it is necessary that a secured and integrated communications be primarily established between objects, in such a way that these objects can be able to authenticate each other afterwards, for instance, via a cloud platform using IoT communication protocols such as the Constrained Application Protocol, the Message Queue Telemetry Transport, to name a few [12]. However, most of these protocols do not have inbuilt security mechanisms, or they rely on limited inbuilt single-factor authentication security mechanisms [13]. In addition, our literature survey has revealed that most existing conventional OTP-based authentication schemes [3] have not been designed specifically for IoT [4]. This has motivated the need for multi-factor authentication schemes for IoT, in particular, smart home environments, which involve combining multiple factors such as smart card, biometrics, one-time-password (OTP), to name a few.

2.1.2

Smart Home Network Architecture in IoT

In a smart home environment (such as the one as depicted in Fig. 2.1), physical objects such as doors, temperature, alarms, alerts, appliances, fridge, to name a few, are equipped with the ability to operate over the Internet, for monitoring, collecting and sharing their 7

resources (in particular their data) [14].

Figure 2.1: Example of a smart home.

As shown in Fig. 2.1, devices in a smart home are usually connected to each other through a Home Gateway (HG), an interface between the home network and the Internet. In order to control the smart home system, the HG has a routing functionality and is usually connected to the user interface using a mobile software, a well-mounted solution, to name a few. Some smart home implementations also include the use of a home server, which is responsible for authenticating the devices. A typical smart home network architecture in IoT is depicted in Fig. 2.2 8

Considering the architecture in Fig. 2.2, communication technologies in a smart home

Figure 2.2: Typical Smart Home Network Architecture in IoT.

environment include radio waves which are electromagnetic waves with frequencies between 3 kHz to 300 GHz - and light waves communication where light is used as communication medium. The former is widely accepted and has the ability to penetrate through the wall or objects, making them suitable for smart homes while the latter is rarely utilized and usually cannot penetrate through walls or objects, limiting the communication space. Common radio wave technologies include X10, Ethernet, RS-485, 6LoWPAN, Bluetooth LE (BLE), ZigBee, Li-Wi, and Z-Wave. On the other hand, Li-Wi is a well-known example of light waves communication [15] where communication is achieved by turning the light ON or OFF. Indeed, 9

the light-emitting diodes (LEDs), in particular Visible Light Communication (VLC) can be used as a mean to achieve light communication because of their high performance to turn the light ON or OFF. However, one of the problems encountered with the use of VLC is that it requires the light to be constantly ON for the communication to happen. In a smart home environment, this requirement might not be achieved since in the night, the lights are likely to be turned OFF. Other types of light communication include dark visible light communication - which uses VLC for communication purpose - and infrared communication which uses Infrared light spectrum for the same purpose [16]. In the proof-of-concept of our proposed D2DA-OTP-IC protocol [7] in the form of hardware solution, we have used the infrared-light for inter-device communication purpose. However, any other light communication medium could have been used as well. Finally, considering the architecture in Fig. 2.2 in the prospect of designing an authentication protocol for a smart home network, some minimal security requirements should be met, which include: confidentiality, availability, integrity, and mutual authentication.

·

Confidentiality : The smart home devices should maintain privacy of the data exchanged between devices/user. Only authorized user/device should have access to sensitive data and the data should be protected from unintended users. Typically, cryptography is used to address the confidentiality issue when dealing with an insecure network.

·

Availability : In a smart home, it is desirable that a service be available to the authorized users all the time. Typically, Denial-of-Service (DoS) attacks are used to make a service unavailable/unusable. In this type of attack, the attacker sends many false requests, with the goal to overload the server; in such a way that it can no longer serve the requests from legitimate users normally, or in such a way that the service is completely turned down.

· Integrity : Data integrity is an important aspect of security. It is meant to ensure that 10

the is not manipulated by an unauthorized user. If an adversary is able to manipulate the data/message, the results of doing so could be devastating to the network. · Mutual authentication (also referred to as two-way authentication) : It occurs when both parties involved in the authentication validates each other's identity. During this process, an attacker can attempt to spoof the server by sending a false information in many ways, via the use of several types of attacks. Therefore, a mutual authentication mechanism usually comes with its set of attacks that its design can enable to prevent, and for which a security analysis has to be conducted to verify the effectiveness of the said protection.

2.1.3

Types of Authentication Schemes for Smart Home Environments

Considering the above-mentioned smart home network architecture in IoT, there are essentially two types of authentication schemes: user authentication and D2D authentication. In user-authentication schemes, some type of secrecy (known only by the user) or a unique biometric information of the user, or a combination of these metrics, is utilized for authentication purpose [4]. On the other hand, the design of D2D authentication schemes is challenging since devices are usually heterogeneous. Thus, they are expected to operate under various different protocols as well as being subject to various different resource constraints such as energy restriction and security constraints. In addition, most smart home networks make use of wireless technologies (such as ZigBee, Wi-Fi) for communication purpose; and if an attacker can hold the related network packages, various types of attacks such as replay attack, man-in-the-middle, eavesdropping, masquerading, message modification, denial-of-service, impersonation, can be launched [5], [17] to compromise the security of the system. As far as user remote authentication for smart home environments is concerned, our liter-

11

ature survey has revealed that techniques based on passwords [18] are typically weak and are not considered very secure. To improve this weakness, other techniques have been proposed such as those relying on the user's personal memory (or digital memory) [19], those relying on the use of Kerberos authentication to implement a single-sign-on [20], those relying on mobile OTP or OAuth [21], an open standard authentication and authorization protocol, in which the user receives a password that should be used within short time period after its generation, otherwise the OTP expires; those relying on smart cards [22], those relying on biometrics [23], those involving transactions based on Near Field Communications (NFC) [24], and those relying on RSA [9], [10], to name a few. The novel RSA-ASH-SC scheme proposed in this thesis belongs to this later class of protocols since its design relies on the use of a variant of RSA (so-called Om and Kumari scheme [10]), in which the anonymity of the user/device is achieved by using a one-time-token.

2.1.4

Considered Security Attacks

Considering the aforementioned smart home network architecture in IoT, any adopted type of authentication scheme should be designed by taking into account the security attacks that could be prevented using its design features, as well as common security requirements for the smart home automation network. In this thesis, for the later, we have considered: (1) user anonymity or privacy protection - this property should be maintained in such a way that an intruder cannot trace the user's identity. For instance, some cryptographic techniques can be applied on the user's identity before sending it over a public channel; (2) secrecy an intruder should not be able to compute a valid session key from previously eavesdropped messages. A potential solution for this is to ensure the freshness of the session key at each computation time; and (3) No verification table should be necessary - this refers to storing secret values in a table. For instance, this can be avoided by ensuring that none of these values are stored in any format at the server side. For the former, following the above re12

quirements, the security attacks that have been considered in the authentication schemes proposed in this thesis include: man-in-the-middle attack (MIMA), eavesdropping attack, masquerading/impersonation attack, replay attack, message modification attack, dictionary attack, stolen card attack, password-guessing attack, forgery attack, Denial of Service attack, forward secrecy attack, brute force attack, reflection attack, and multi-protocol attack [5]. To evaluate and/or perform a security analysis of any authentication schemes with respect these attacks (and others), some security metrics can be considered, along with existing tools for analyzing or validating the security features of such schemes. In this thesis, we have used the Security Protocol Animator (SPAN) for Automated Validation of Internet Security Protocol and Applications (AVISPA) tool (referred to a SPAN/AVISPA) [25]. Other tools (not used here) include the Burrows-Abadi-Needham (BAN) logic [26]. Examples of security metrics used in this context include: secrecy of the secret keys, mutual authentication, integrity, types of security attacks (case of the D2DA-OTP-IC, PPIDA-IC and PPIDA-PKI schemes) and computation time, type of security attacks, computational performance, and RSA decryption speedup (case of the proposed RSA-ASH-SC remote user authentication scheme).

2.2

Related Work

Several authentication schemes for smart home and IoT as well as remote authentication schemes for smart home network in IoT are discussed.

2.2.1

Related Work on Authentication Schemes for Smart Home/IoT Environments

Authentication schemes for IoT environments have been intensively investigated in the recent years. Representative ones are described as follows. In [4], Madsen reports on new mechanisms and standards that can be used to authenti13

cate IoT actors in a health care devices architecture. Related challenges and opportunities are also described. In [13], Shivraj et al. proposed an end-to-end authentication scheme for IoT based on Lamport's OTP. In their scheme, the OTP generation is modelled as a 4 steps process, namely: (1) the Setup phase - where some cryptographic parameters are involved in the PKI generation to optimize some computations over elliptic curve; (2) the Extract phase - where public and private keys are assigned to registered IoT applications and devices; (3) the Generate phase - where both the requests and data are transferred between IoT devices and a IoT cloud center using the aforementioned keys, and the required information are extracted; and (4) the Validate phase - where the OTP received at the cloud center is checked against that originally sent by the device. It is proved that the hardness of the OTP generation scheme is equivalent to solving the computational Diffie-Hellman problem [51]. In [27], Wilson proposed a D2D mutual authentication protocol for IoT based on asymmetric cryptography providing that a shared secret session key be given. The public key cryptography is meant for data exchange purpose between devices. The scheme is composed of three phases, namely: a pre-deployment phase where the manufacturer prepares and equip the devices with the necessary firmware; a deployment phase where the authentication information and a device virtual identity are collected; and an authentication phase where a public key cryptography scheme is designed based on the aforementioned parameters and is invoked to establish a secure data exchange between two devices after these devices have mutually authenticated themselves to each other. In [28], Yao et al. proposed a lightweight multicast authentication scheme for small scale IoT applications based on the absorbency property of the original Nyberg's fast one-way accumulator [30]. In their scheme, the MAC is exploited to achieve such design; and in terms of security analysis, seven cardinal properties that are required by multicast authentication for resource-constraint applications are assessed and validated. In [29], Hernandez-Ramos et al. proposed a set of lightweight authentication and autho-

14

rization mechanisms which can be used to assure authentication and authorization functionalities on constrained smart objects. These mechanisms are combined with some standard technologies to address different security planes of the life cycle of an IoT device within an introduced Architectural Reference Model-compliant security framework [30]. The suitability of the proposed framework for IoT scenarios is demonstrated through experiments, showing promising results. In [31], Sharaf-Dabbagh and Saad proposed an authentication framework for IoT objects, which uses the unique fingerprints of these objects to differentiate between normal changes in fingerprints and security attacks. In their scheme, the IoT objet set is divided into multiple hierarchies based on the types and geographic locations of the fingerprinting features. Each partition is then modelled as a set of distributions on which a learning approach is performed to extract the knowledge from the different fingerprints, thereby identifying the IoT objects. From simulations, it is found that their scheme outperforms the conventional authentication schemes by up to 8% in terms of authentication performance. In [32], Shin et al. proposed an authentication scheme for smart home networks, which uses a group key shared among the devices to encrypt and decrypt all messages from all devices. A digital DNA is also used to differentiate the devices against those pertaining to other smart home networks. The DNA (in the form of a magical number) generated by the authentication server or home server is used to distinguish the devices that belong to the different smart homes. However, if the group key is compromised, so will be the entire system. This scheme has been shown to be vulnerable to replay attacks since they do not use any timestamps or other mechanisms to prevent these types of attacks. In their scheme, the initial registration phase assumes that the communication channel is secure while registering a new device. In [33], Kumar et. al. here proposed a short token-based authentication scheme which can be used for secure key establishment in smart home environments. In their scheme, the device registration is performed offline, which is a quite cumbersome process. This scheme

15

is not fully protected against DoS attacks and the communication using it cannot be kept anonymous. Moreover, devices cannot communicate with each other. In [34], Santoso et al. proposed an elliptic curve cryptography-based authentication scheme for smart homes, where the authentication mechanism involves the use of a mobile device. First, the user gets the identity information (such as device ID), and a secret key for the device, then passes them to the IoT device, which is connected automatically to the mobile device, which in turn shares this information with the gateway. Using this mechanism, the device attempts a connection to the gateway, and if the gateway has the secret key, a second level authentication process starts and a secure connection is established. However, the secret information is stored on the device itself, which is an issue. Their scheme does not keep the network anonymous, and the communication is handled via a Wi-Fi channel, which makes it vulnerable to DoS and replay attacks. In [35], various different forms of secure shell (SSH)-based authentication schemes are analyzed and an SSH agent forwarding scheme is proposed, where a user can log in to a second hop system without storing the keys into the first hop system, and the private keys never leaves the user's system at any time. In such scheme, it is assumed that the public keys are pre-shared by the remote system in advance. However, this approach does not allow the application in the remote device to authenticate itself to another remote service as there is no private keys for each system/application. The application has no way to forward the challenge to the user's system so that the ssh agent can create and respond to it. In [36], Park and Kang proposed an inter-device authentication scheme along with a session-key distribution protocol for IoT devices which are only equipped with encryption modules. The proposed approach relies on the assumption that the secret key and encryption function are securely share among devices and saved at the device setting step. Based on this, an authentication requestor and a responder can authenticate each other using an authentication and session-key agreement procedure that enables them to share a different session key for each authentication session without having to exchange new parameters or

16

without the need to invoke an additional method. The proposed authentication scheme has been shown to protect against man-in-the-middle attacks, replay attacks, and wiretapped secret-key attacks. In [37], Kang et al. proposed a secure mutual D2D authentication scheme in smart homes, which is based on the use of zero-knowledge proof instead of a secret value between the sensor node and the home gateway. In their scheme, a master key exchange produced in the registering phase is utilized for securing the channel between two devices before a message gets send from one device to another. In [38], Vaidya et al. proposed a device authentication mechanism for smart home area network jointly with a key establishment method, based on elliptic curve cryptography and a self-certified public key following the smart energy profile standard for home area networks [21]. Their proposed scheme is composed of (i) pre-deployment phase - where every device must securely obtain an implicit certificate from a Certificate Authority (CA) prior to enter an initialization phase, in which long-term private/public keys are computed. Based on this computation, (ii) a two-pass authenticated key agreement protocol between two entities is established to achieve the goal of device authentication. The D2DA-OTP-IC [7], PPIDA-IC and PPIDA-PKI schemes proposed in this thesis are fundamentally different from the above-discussed schemes by their design features. In addition, unlike the above-discussed schemes, a proof-of-concept of the proposed D2DA-OTP-IC scheme in the form of a hardware solution is provided, which uses Raspberry-Pi, Infrared circuit and the OpenSSH protocol.

2.2.2

Related Work on Remote User Authentication Schemes Using Smart Card

Some of the notations used in this subsection are as follows: Ui : ith user 17

P Wi : ith user's password IDi : ith user ID CIDi : Smart Cards identifier hi : secret information create by the card issuer at the registration time Si : user's secret information (e, n): Public key components of RSA d: Private key components of RSA g : An integer and primitive element for prime factors of the private key of RSA f : Hash function T : Current time stamp Ri : Random number generated by smart card In the literature, several remote user authentication schemes for smart home based on the use of smart card have been investigated. Representative ones are described as follows.

In [39], Yang and Shieh proposed two smart card based password authentication methods, namely, time-stamp based and nonce-based. In their schemes, the host does not need to keep the password table as well as the verification table. For their timestamp-based protocol, in the registration phase, the following information (IDi , CIDi , hi , Si , e, g, n) is written into the card. Next, whenever the user wants to login, he calculates Xi  g ri .pwi (mod n) and Yi  Si .hi i
r .f (CIDi .T )

(mod n), and sends (IDi , CIDi , Xi , Yi , e, g, n, T ) to the host, which

in turn verifies the following information: IDi , CIDi and timestamp, then calculates Yie = IDi .Xi
f (CIDi .T )

. If the equation holds true, the user gets authenticated. Chan and Cheng [40]

and Sun and Yeh [41] performed a cryptanalysis of this scheme and reported that it is vulnerable to forgery attack. In [42], Fan et al. also performed a cryptanalysis of the Yang and Shieh scheme [39] and showed that it is vulnerable to impersonation attack. Based on their findings, they proposed an enhanced scheme which can be forged only with a valid CIDi , by imposing a restriction

18

on IDi so that an attacker cannot freely generate the IDi . In [43], Yang et al. also proposed an improvement of the timestamp-based authentication scheme proposed in [39]. In that scheme, the registration phase is not modified, but in the
i .T login phase, the user calculates Xi = g pwi .ri (mod n) and Yi = Si .hr (mod n) , and sends i

(IDi , CIDi , Xi , Yi , e, g, n, T ) to the host. In the authentication phase, the host verifies the
CIDi following information: IDi , CIDi and timestamp, and calculates Yie = IDi .XiT mod n . If

the equation holds true, the user gets authenticated. They also performed a security analysis of this scheme, and verified that it is protected against forgery attack, password-guessing attack, smart-card loss attack and replay attack. In [44], Shen et al. proposed a modified version of the Yang and Shieh scheme [39] scheme, transforming it to a mutual authentication scheme. They performed an analysis of the scheme in [39] and discovered that no relationship has been established between IDi and CIDi ,and without this, an intruder could bypass the remote server verification. In the modified scheme, a relationship between IDi and CIDi at the registration phase is established a as follows: CIDi = f (IDi  d),so that when the server receives the login request, it checks the validity of IDi Then, it calculates CIDi = f (IDi  d) ,and if CIDi is equal to CIDi , the user gets authenticated. In [45], Liu et al. proposed a remote user mutual authentication scheme for smart home as a result of a cryptanalysis of the Shen et al. scheme [44]. In their analysis, it was reported that if IDi is chosen by a legitimate user, an attacker may be able to impersonate that user. In the modified Shen et al. scheme [44], to address this deficiency, instead of sending the CIDi , the user sends f (CIDi ) to the server, and a random nonce is used to challenge the user for mutual authentication purpose. In [46], Chien et al. also proposed a remote user mutual authentication scheme for smart home, for which the security is based on the use of one-way hash functions. In their scheme, the server maintains a secret value x, and a timestamp is generated and attached to all messages that are exchanged between the user and the server, in order to protect against replay

19

attack. However, a cryptanalysis of this scheme by Hsu [47] showed that it is vulnerable to parallel session attacks. In [22], Om and Reddy proposed a RSA-based remote user authentication scheme using smart card. In their scheme, to achieve authentication, no verification table, nor password table is needed. Their scheme uses the standard RSA algorithm for cryptography as follows. In the registration phase, the user Ui submits its IDi to the system, which in turn calculates
d P Wi = IDi mod (n). It should be noted that a password generated in this way is difficult

to remember for a user. Next, the smart card is issued with (f, IDi , e, n). To login, the user
x calculates x = P Wi  T , y = IDi (mod n) and C = y e (mod n). Then, sends the following

message S = (x, IDi , C, T ) to the server. Upon receipt, the server validates IDi and the timestamp, then checks if C d (mod n) = y . If that equation holds, the user gets authenticated. A cryptanalysis of this scheme by Om and Kumari [10] reveal that it is does not work properly for any given password. In [10], Om and Kumara proposed a modified version of the Om and Reddy scheme [22] as follows. The registration phase is similar to that of the Om and Reddy scheme [22], except that additionally, the user calculates Si = f (P Wi ||IDi ) and stores it in the smart
x card. To login, the user calculates x = f (f (P Wi ||IDi )  T )mod n, y = IDi (mod n) and

C = y e (mod n), then sends (IDi , C, T ) to the server. Upon receipt, the server checks for IDi
x and the timestamp, then calculates x = f (Si  T )mod n, y = IDi mod n and M = C d mod n.

If M = y , the server authenticates the user. It should be noted that Si is a sensitive information which is related to the password Si = f (P Wi ||IDi ); and Si is also calculated when the user enters the password. If the smart card is lost, this information may lead to a compromised security [48]. Om and Kumari [10] also proposed a user remote authentication scheme based on the RPrime algorithm, a variant of RSA which is considered fast than the standard RSA [49]. In this scheme, at the registration time, the user chooses IDi , P Wi and a random number Ni , then sends IDi , f (P Wi  Ni ) to the server. Next, the server calculates, CIDi = f (IDi  d)mod (n), Si = (CIDi  f (P Wi  Ni ))e mod n and Ri = f (Si ||Ni ), where

20

Si is the sensitive information referred to in the Om and Reddy scheme [22], then stores the data (CIDi , Ri , n) in the smart card. This scheme was shown to be vulnerable to smart-card loss attack. Unlike the above-described remote user authentication schemes, our proposed scheme is based on a lightweight version of a RSA variant [10]. the messages are kept encrypted and only one-time-token is used in clear-text. In addition, the anonymity of the device or user is achieved using a one-time-token, and a session key is established for any new session. Finally, our scheme is designed to protect against replay attacks by using a timestamp in each message exchange between the user and the server.

21

Chapter 3 Proposed Authentication Protocols for Smart Homes Network
In this Chapter, the designs and modelling (using the HPSL language [25]) of the two-factor D2D Mutual Authentication Scheme for Smart Homes using OTP over Infrared Channel (socalled D2DA-OTP-IC scheme), the Password Protected Inter-device OTP-based Authentication scheme over Infrared Channel (so-called PPIDA-IC) and the Password Protected Inter-device OTP-based Authentication scheme using Public Key Infrastructure (so-called PPIDA-PKI scheme) are presented, along with the design of the RSA-based two-factor user Authentication scheme for Smart Home using Smart Card (so-called RSA-ASH-SC scheme).

3.1
3.1.1

Design and Modelling of the D2DA-OTP-IC Scheme
High-Level Architecture of the D2DA-OTP-IC Scheme

The high-level architecture of the proposed scheme is depicted in Fig. 3.1, where three devices are considered: OTP-server, Device 1 (denoted D1), and Device 2 (denoted D2) (of course, more devices can be considered). Without loss of generality, the number of devices

22

has been restricted to three only for the hardware proof-of-concept purpose. In Fig. 3.1, D2 is initiating the authentication request with D1. After being authenticated using a publickey infrastructure, D1 sends a request for OTPs to the OTP-server. Upon receipt of this request, the OTP-server replies by sending the OTPs to both D1 and D2. It should be noted that the same high-level architecture prevails for the PPIDA-IC and PPIDA-PKI schemes since these have been proposed as enhancements of the D2DA-OTP-IC scheme.

Figure 3.1: High-level architecture of the proposed authentication scheme.

In order to represent the data exchanged in the proposed protocols and the cryptographic processes that are involved, the abstract A-B notations style given in Table 3.1, which is 23

inherited from [25], will be used (here, A-B is meant for Alice-Bob').

Table 3.1: A-B Style Notations Notation D1 D2 OTP-server T1, T2, T3, T4, T5 KD1 , KD2 , KO , KKP Ho , KKP Ha KD1 , KD2 , KO , KKP Ho , KKP Ha P, P1, P2 G, G1, G2 N1, N2, N3, N4 SK, SK1, SK2 Hash() A- > B : M En{}K EXP REQ MOD OTP1, OTP2 Token Password Timestamp Description Client device Server device OTP server that generates and sends the OTPs Current timestamp Public keys of devices D1, D2 and O Private keys of devices D1, D2 and O Prime number primitive root modulo of P Random secret numbers Secret key generated using the Diffie-Hellman key exchange protocol [53] Hash function A send message M to B Encryption is performed using key K Exponent function OTP request number Modulus operation One-Time-Password Random number to uniquely identify a service Password of a service Time stamp

As per the notations on Table 3.1, the working of the proposed D2DA-OTP-IC scheme (Fig. 3.1) consists of three phases: manufacturing (or pre-deployment) phase, deployment and registration phase, and authentication (or functioning) phase, described as follows. Manufacturing Phase: In this phase, the manufacturer presets the device for father coming phases. First, the manufacturer builds the device along with the infrared light transceivers which will be used for infrared communication. In this process, each device gets a unique ID. Using those IDs, devices will communicate with each other. The manufacturer then uploads the software (i.e. operating system such as Linux or other hardening 24

tools such as Lynis, CIS-CAT and Tiger) to a device, including the drivers for infrared light communication. The software is then configured in such a way that it is compliant with the NIST/FIPS regulations and standards [8]. Even though our focus is not on the hardening of devices, it is usually a good practice to harden the system in advance in order to protect against zero-day attacks [50]. It is also assumed that the software is capable of updating itself frequently in a secure manner. Deployment and Registration Phase: In this phase, all devices are registered with the OTP-server, as well as with peer devices with whom they need to authenticate in future. To register with the OTP-server, the public key of the device is stored with the OTP-server in a secure manner, along with the device ID. The location of the device with respect to the OTP-server is also stored in the form of degree of angle. It should be emphasized that the device has to face towards the OTP-server in order for the infrared light communication to happen. In addition, the device will save its IP address information and device ID of the OTP-server. For a device, say D1, to communicate with another device, say D2, device D1 will need to pre-register with device D2 the same way that it has registered with the OTP-server. Authentication Phase: When a device, say D1 wants to communicate with another device, say D2, device D1 initiates the request for authentication. The goal is to generate a secret key which will be used for future communication. Here, the DH key exchange protocol [51] is used to generate the secret keys that will be kept secret between D1 and D2. For every new session, a different secret key will be generated for the communication. The authentication steps are then performed as follows. Step 1: First, D1 generates a random number N1 and calculates EXP(G1, N1), where G is a chosen positive integer and EXP denotes the exponentfunction. The output of this operation is used to find the modulus over P using the MOD (modulus) function, where G and P are publically known. D1 then sends the following message to D2, signed with its private key:

25

D1- > D2 : D1.{D1.T 1.G.P.M OD(EXP (G, N 1), P ).Hash(D1.T 1.G.P.M OD(EXP (G, N 1), P ))}KD1 Step 2: D2 first checks if the message is originated from D1using D1's public key, then it checks whether the timestamp is recent or not. If both checks are successful, D2 continues with the request and saves MOD(EXP(G, N1), P) into a variable (say AA); otherwise the request is dropped. Next, D2 calculates EXP(G,N2) and the output of this is used to calculate the modulus over P. Finally, D2 sends the following message to D1, signed with its private key. D2- > D1 : D2.{D2.T 2.M OD(EXP (G, N 2), P ).Hash(D2.T 2.M OD(EXP (G, N 2), P ))}KD2 Then, it derives the secret key SK by calculating MOD(EXP(AA, N2),P). When D1 receives the message, it first checks the authenticity of the message using D2's public key. Then, it checks whether the timestamp is recent or not. If both checks are successful, D1 continues further with that request and saves MOD(EXP(G, N2), P) into a variable (say BB); otherwise it understands that something has gone wrong or it drops the message. Next, it gets the secret key SK by calculating MOD(EXP(BB, N1), P). At this point, both devices D1 and D2 have successfully shared the secret key SK using the DH key exchange algorithm [51]. Step 3: Next, D2 requests the OTP-server to provide the OTPs for both devices D1 and D2. To issue such request, D2 generates a timestamp T3 and sends the following message to OTP-server, signed with its private key. D2- > OT P - server : D2.{D1.D2.T 3.REQ.Hash(D1.D2.T 3)}KD2 Step 4: Upon receipt of the request, the OTP-server checks if the message is really originated from D2 and it also checks if the timestamp is recent. If both checks are successful, the OTP-server continues with the request and generates two OTPs: OTP1 and OTP2, along with a timestamp T4; otherwise, it drops the request. Next, it sends the following message to D1, encrypted with D1's public key: OTP-server - > D1 : {T 4.OT P 2.OT P 1}KD1

26

Step 5: In a similar manner than in Step 4, the OTP-server sends the following message to D2, encrypted with D2's public key: OTP-server - > D2 : {T 4.OT P 1.OT P 2}KD2 It should be noted that the OTPs are sent over the infrared communication channel within the home (which is considered as a secure channel); therefore, the encryption of the above message can be optional. At this point, both devices D1 and D2 have received their OTPs. Step 6: D1 sends the hash of OTP2 to D2, encrypted with the secret key SK, i.e. D1- > D2 : {Hash(OT P 2)}SK Step 7: Similarly, D2 sends the hash of OTP1 to D1, i.e. D2- > D1 : {Hash(OT P 1)}SK Finally, D1 (resp. D2) checks the received hash Hash(OTP1) (resp. Hash(OTP2)) using M=Hash(OTP1) (resp. M=Hash(OTP2)), where M is the received message after decryption; and if there is a match, D1 and D2 have mutually authenticated each other; otherwise the authentication has failed.

3.1.2
3.1.2.1

3.1.2 Modelling of the D2DA-OTP-IC Scheme
Modelling Tool

The SPAN/AVISPA tool [25] is used for the formal evaluation and simulation of the D2DAOTP-IC protocol. Its high-level design [25] is illustrated in Fig. 3.2. The use of the SPAN/AVISPA tool requires that the protocols be modelled using HLPSL [25]. This tool considers the protocol written in HLPSL format, then uses its integrated HLPSL2IF translator to convert it into an Intermediate format (IF), which is then passed to a specific backend tool composed of four modules, namely the On the fly Model Checker OFMC), the Constraint Logic based Attack Searcher (CLAtSe), the SAT based Model Checker (SATMC), and the Tree Automata based on Automatic Approximations for the Analysis of Security Protocols (TA4SP), which are responsible for the analysis of the 27

Figure 3.2: High Level Design of AVISPA Tool [25].

protocol as well as the verification of its effectiveness in terms of various different predefined attack types. This backend tool also checks whether the sessions are bounded or unbounded, then present the results in an output format (OF). The OFMC module is meant for protocol falsification and bounded session verification considering both typed and untyped protocol models as well as integrated symbolic constraint-based techniques which can be used to ensure that no attacks are lost. OFMC also supports the intruder's implementation aiming at guessing weak passwords; in addition, it provides the specification of the algebraic properties of cryptographic operators. When the OFMC model specifies that the protocol is safe, it 28

means that all the specified goals have been met. On the other hand, the CL-AtSe module also performs the protocol falsification and verification by translating the protocol specification into a set of constraints used to identify the attacks. These back-end modules can be used for analyzing the security threats in a protocol using the implemented Dolev Yao (DY) network attack model itself considered as the default attack model in which an attacker has a full control over the network, thus can perform various different types of hacking tricks to compromise the protocol. When the SPAN/AVISPA tool [25] is run, its generated output is interpreted as safe or unsafe against the DY attacker model.

3.1.2.2

HSPSL Syntax

The abstract notations used to convert the proposed protocols into the HSPL code to be considered as input (as per Fig. 3.2) to the AVISPA tool [25], are given in Table 3.2.

In HLPSL, variables start with capital letters and constants are represented with lower case letters. HLPSL is a role-based language, where all entities involved in a communication such as client, environment, server, session, etc., have roles associated with their message exchange. As an example, security-related properties of a protocol can be defined using HLPSL [25]. In doing so, there are two types of roles: basic roles and composed ones, depending on whether they are defined to represent the actions of one or more agents. To achieve message exchanging between two entities, a session is created between the roles and the environment for all sessions. Basic Role: Considering the Alice-Bob (A-B) notation (given in Table 3.1). A sends an

encrypted message M to B, using key K to encrypt the message is represented as: A ->B: {M} K An example of the syntax of a basic role declared using HLPSL is: role alice(A,B,S: agent,

29

Table 3.2: HLPSL Notations Notation . := , /\ =|> {} {} agent channel (dy) def= hash func exp init inv Intruder knowledge played by request witness secret Description associative concatenation (of messages) initialization (of local variable) in init-section OR assignment to a local variable prime, used for referring to the next (new) value of a variable in a transition conjunction (logical AND) immediate transition set delimiter, e.g. in knowledge declaration encryption or signature data-type for agents data-type for channels. Currently only the Dolev-Yao channel is implemented. indicates the beginning of the body of a role data-type for one-way functions exponentiation operator (prefix) indicates the initialization of local variables inverse of a key: given a public key returns the private key defines knowledge of the intruder for basic roles: specifies which agent is playing this role used to check strong authentication (together with a witness) used to check authentication (together with the request) used to check secrecy

Kas: symmetric key, SND, RCV : channel (dy)) played by A def= local State: nat, Kab: symmetric key init State:= 0 Transition ... end role 30

where Alice is a role called with agents A, B, S, symmetric key Kas (resp. Kab) shared between A and S (resp. A and B) and SND, RCV as Dolev-Yao (dy) channels [10]. Transition: The behavior of a system in HLPSL is modelled as a state. Each state has

variables that are responsible for state transitions. A transition is defined by a trigger event or precondition, along with the associated action that should be performed when the trigger event occurs [10]. An example is as follows: State = 0 /\RCV({Kab'} Kas) =|>State':= 2 /\SND({Kab'} Kbs) Where step1 is the transition's name. The above HLPSL statements specify that if the value of the state is equal to 0 and a message, which contains some value Kab' encrypted with Kas is received on the RVC channel, then a transition will occur, yielding a new state value (here 2) and that same value of Kab' encrypted (this time) using Kbs will be sent on a SND channel. Composed role: This is a composition of several basic roles in sessions where the knowledge shared between these roles are explicitly known. An example of such role made of three different basic roles [10], where the symbol / indicates that the constituent roles are executed in parallel, is given as: role session(A,B,S : agent, Kas, Kbs: symmetric key) def= local SA, RA, SB, RB SS, RS: channel (dy) Composition alice (A, B, S, Kas, SA, RA) /\bob (B, A, S, Kbs, SB, RB) /\server(S, A, B, Kas, Kbs, SS, RS) end role

31

Environment: The environment used for protocol execution is defined, where i denotes the intruder and 'kis' denotes the intruder's private key. In the environment role, top level global constants are defined. In this top-level role, the intruder's knowledge parameter defining the intruder's initial knowledge is specified. An example of environment role [10] is as follows: role environment() def= const a, b, s : agent, kas, kbs, kis : symmetric key intruder knowledge = {a, b, s, kis} Composition session(a,b,s,kas,kbs) /\session(a,i,s,kas,kis) /\session(i,b,s,kis,kbs) end role

3.1.2.3

Modelling of the D2DA-OTP-IC Scheme Using HSPSL

Following the above HLPSL syntax specifications [25], our proposed D2DA-OTP-IC scheme can be modelled as follows: First, initially, when a device (client) wants to start communication with another device (server), it sends the request along with all parameters required for DH key exchange. This request is modelled in HLPSL as follows: State=0 /\RCV(start) =|> State':=1 /\Na':= new() /\Timestamp':= new()

32

/\AA' := MOD(EXP(G,Na'),P) /\SND(A.{A.Timestamp'.AA'.G.P.Hash(AA'.G.P.Timestamp'.A)} inv(KPa))

where the state variable `State' is initialized to 0 in the init section. Second, the client receives a start message via the RCV channel to start the protocol. It first updates the state variable's new value to 1, then it generates a random number, which in turn is used to generate the DH key exchange. It also generates the current timestamp (assuming that all the system's time is in sync). Then, it calculates MOD(EXP(G,Na')), where P and G are known variables, and then it stores the output in a variable, say AA', which is known to the intruder. It then calculates the hash of the message. Next, it sends the message by signing it with its private key. Upon receipt of this message, the server checks whether the timestamp is valid or not, and if that is validated, the server sends back its calculated value for the DH key exchange. This is modelled in HLPSL as follows: State=0 /\RCV(A.{A.Timestamp'.AA'.G.P.Hash(AA'.G.P.Timestamp'.A)} inv(KPa)) =|> State':=1 /\Nb':= new() /\BB' := mod(exp(G,Nb'),P) /\SND(B.{B.Timestamp'.BB'.Hash(BB'.Timestamp'.B)} inv(KPb)) /\Key' := mod(exp(AA',Nb'),P) /\secret(Key',secret key, A,B) /\Req':=new() /\SND(B. {A.B.Timestamp'.Req'.Hash(A.B.Timestamp')} inv(KPb))

It should be noted that in this specification, the state variables are local to both the client and the server. Third, the server generates its own private random number Nb' for the DH key exchange, then in a similar way as above, it calculates BB' and sends the message to the client by sign-

33

ing it with its private key. At this point, the server can form the secret session key Key'. Here, the secret() function is used to check the secrecy of the session key. The server then requests the OTP-server to provide the OTPs to both the client and itself. At the same time, the client receives the message from the server. It then attempts to validate the timestamp and authenticity of the message. If the validation is successful, the client will acquire the BB' value from the server, and form a session as shown below: State=1 /\RCV(B.{B.Timestamp.BB'.Hash(BB'.Timestamp'.B)} inv(KPb)) =|> State':=2 /\Key' := mod(exp(BB',Na'),P) /\secret(Key',secret key, {A,B})

Fourth, the OTP server attempts to validate the timestamp and the authenticity of the request. If that is successful, it sends the OTPs to both the client and the server by encrypting them with their respective public keys as shown below: State=0 /\RCV(B.{A.B.Timestamp'.Req'.Hash(A.B.Timestamp')} inv(KPb)) =|> State':=1 /\Timestamp' := new() /\SND({Timestamp'.OTP1.OTP2} KPb) /\SND({Timestamp'.OTP2.OTP1} KPa) /\secret(OTP1, server otp1, {A,B,O}) /\secret(OTP2, server otp2, {A,B,O})

It should be noted that the OTPs are sent on the infrared light communication channel within the house, which is considered secure since the light cannot pass through objects such as walls. In real situations, the OTPs can be sent unencrypted because it is assumed that the intruder cannot get hold on the light communication channel. However, the OTPs have been kept encrypted. Also, it should be noted that the secrecy of the OTPs is ensured by using the secret() function. Fifth, when both the client and the server have received their OTPs from the OTP-

34

server, they decrypt the message and validate the timestamp. Next, the client sends OTP2, encrypted with the session key and the server sends OTP1, encrypted with the session key as well. Both the client and the server mutually authenticate each other if the encrypted hash of the received OTP matches with the hash of the OTP which was not sent by both entities. In the client side, to check for strong authentication, which is achieved by means of the request() and witness() functions, the following HLPSL code is used: State= 3 /\RCV( {Hash(OTP1')} Key) =|> State':= 4 /\witness(A,B,server client bb , {B.Timestamp'.BB'} inv(KPb) .Hash(OTP1')) /\request(A,B,client server aa ,{A.Timestamp'.AA'} inv(KPa).Hash(OTP2'))

Now, at the server side, the server witnesses the message and the OTP hash it has received from the client and request for its message and hashed OTP using the following HLPSL code.

State= 2 /\RCV({Hash(OTP2)} Key') =|> State':=3 /\SND({Hash(OTP1)} Key') /\witness(B,A,client server aa,{A.Timestamp'.AA'} inv(KPa).Hash(OTP2')) /\request(B,A,server client bb,{B.Timestamp'.BB'} inv(KPb).Hash(OTP1'))

Finally, the goals of keeping OTP1 and OTP2 secret; ensuring the secrecy of the session key; and achieving mutual authentication between the client and server, is coded as follows using HLPSL: goal secrecy of server otp1 secrecy of server otp2 secrecy of secret key authentication on client server key

35

authentication on server client key end goal

3.2

Enhancements of the D2DA-OTP-IC Scheme

In the above proposed D2DA-OTP-IC Scheme [7], storing the secret information may not be considered safe as per the recommendations from [8]. Thus, it is essential that the proposed D2DA-OTP-IC design be adjusted to protect the secret and public keys. One way to achieve this goal is to store the password (or passphrase) used to protect the encrypted key in the system itself in order to comply with the Federal Information Processing Standard (FIPS) 4.7.5 [8], which states that "Plaintext secret and private keys shall not be accessible from outside the cryptographic module to unauthorized operators. A cryptographic module shall associate a cryptographic key (secret, private, or public) stored within the module with the correct entity (e.g. person, group, or process) to which the key is assigned ". Therefore, in a D2D scenario, a solution to encrypt the secret information and provide the password on demand to the registered applications is required. In this regard, two proxy-password protected OTP-based schemes for smart homes, designed to achieve this requirement, are proposed as enhancements to the D2DA-OTP-IC scheme (so-called PPIDA-IC and PPIDAPKI schemes). In both schemes, the keys are protected using passwords and a centralized server provides proxy-password services to the smart home devices. In addition, this server maintains the database of passwords as well as the servers' password-proxy services. A Linux security module (so-called Secure-Enhanced Linux (SELinux [52]) is also utilized, which provides a mandatory access control (MAC) mechanism implemented at the kernel level. Without this feature, a Linux system can only enforce the Discretionary Access

36

Control (DAC) and the Access Control Lists (ACLs) methods, and the user and programs can gain access to the files and other resources which are not required for their normal operations. SELinux works on the least-privilege model and it has three modes of operations: Enforcing, Permissive and Disabled [53]. In the enforcing mode, it enforces the policies and only enables the use of operations that are allowed in the policy while blocking the remaining operations. Using SELinux, the process and resources are confined by means of labels [53]; the superuser (root user) privileges can be restricted or disabled [54], [55], [56]. As reported in [57] [58], the sudoers should not have access to change the password for the root and to shutdown, reboot, mount, unmount or install any new software. The only access given to sudo users is to execute our developed infrared program, which reads the password over the infrared channel and load the private key. The above-mentioned proof-of-concept of D2D-OTP-IC scheme [7] has been implemented in such a way that the infrared channel can be read using the Linux Infrared Remote Control (LIRC) program [65], but there was no provision of a mechanism to check which user is calling or whether an operation is valid or not. In our proposed PPIDA-IC scheme, the developed infrared program is meant to achieve these operations. Typically, this program is used for accessing the infrared devices in the smart home. It should be noted that usually a non-super user program does not have access to the infrared device, unless a sudo command is utilized. Finally, it should be noted that the HLPSL language [25] is also used to model the proposed PPIDA-IC and PPIDA-PKI schemes; and a security analysis is conducted using the SPAN/AVISPA tool [25] to demonstrate that these schemes can also achieve the goals of secrecy of the secret keys and mutual authentication (please refer to Chapter 4 for the details of the evaluation).

37

3.2.1

Assumptions

For the design of both the PPIDA-IC and PPIDA-PKI schemes, the following assumptions prevail: · The applications which need authentication runs on a non-root (non-administrative) account so that even if a non-root application is compromised (for instance, due to a vulnerability), the impact of this attack would be less severe than that of an attack in a root account. · The OTP-server encrypts its database (which contains all the information on the proxy services) with a secret key (for instance, using the Advanced Encryption Standard (AES)), and this secret key is protected using the database's private key. · This private key is further protected by the SELinux [52] in such a way that only the OTP-server process can access it. Alternatively, this private key can also be protected by a passphrase. In that case, the user will have to provide the passphrase until the OTP-server reboots. · The infrared channel is considered secure and the infrared light cannot spread outside a home.

3.2.2

Design of the PPIDA-IC Scheme

In the PPIDA-IC scheme, the infrared communication channel is used to send the password to the requesting device. The high-level architecture depicted in Fig. 3.1 also supports this scheme. Here, device D2 wants to get authenticated to device D1 with the help of the OTPserver. In addition, two kinds of services are involved, namely password-proxy service for D2's private key and distribution of the OTPs to both D1 and D2 for mutual authentication purpose. The working of the PPIDA-IC scheme consists of three phases as follows: (1) Manufacturing phase: In this phase, the manufacturer presets the device and equips 38

it with the infrared light transceivers and drivers for infrared light communication. This software package is configured in compliance with the FIPS NIST standards [8] and the system is hardened for protection against zero-day attacks [50] using tools such as Tiger, Lynis, etc. (2) Deployment and registration phase: All the devices need to be registered in ad-

vance with OTP-server. There are two types of registration: OTP-server registration and peer-device registration. If a device, say D1, needs to authenticate to its peer device, say D2, D1 should also register with D2. To register a device D1 with OTP-server, the public key of the device is stored in the OTP-server in a secure manner, along with the device ID. The location of the device with respect to the OTP-server is also stored in the form of degree of angle (it is assumed that it is pre-registered). It should be emphasized that the devices should face towards the OTP-server in order for the infrared light communication to occur. In addition, home devices must save the OTP-server s public-key. Each home-device can run more than one services. All the services should be registered in advance. For each passwordproxy service, an associated random token is generated by the OTP-server, which in turn is saved in the OTP-server's database and the home-device. This token is also linked with the password of that password-proxy service (as a way to recognize the requested service in future). For peer-peer home-device registration, the public keys are assumed to be shared among these devices in a secure manner. (3) Authentication phase: 3.3). Step 1: When a device, say D1, needs to get authenticated, it first requires the use of a password for its private-key. It sends a message to the OTP-server, encrypted with the OTP-server s public key. This message includes a unique token, which is to be used for service identification. To protect against replay attack, a timestamp is appended to the token; and for integrity check, the message is hashed. These operations translate into the following statement: D1 - >O : D1.{T oken.T imestamp.Hash(T oken, T imestamp)}Ko This phase comprises the following steps (as shown in Fig.

39

Figure 3.3: PPIDA-IC scheme authentication phase.

Step 2: Once the OTP-server has received a request, it validates the timestamp and token. If this validation is successful, it sends the password over the infrared channel to the requesting device. O - >D1 : O.{T imestamp.P assword.Hash(T imestamp.P assword)}KO where O denotes the OTP-server. Once the password is received, it is used to fetch the encrypted private key. Step 3: D1 generates a random number N1 and calculates EXP(G,N1), where G is a chosen positive integer and EXP is the exponent function. The output of this operation is used to find the modulus over P using the MOD (modulus) function, where P is publicly known. D1 then sends the following message to D2, signed by its private key. D1 - >D2 : 40

D1.{D1.T 1.G.P.M OD(EXP (G, N 1), P ).Hash(D1.T 1.G.P.M OD(EXP (G, N 1), P ))}KD1 Step 4: D2 checks if the message is originated from D1 using D1's public key, then it checks whether the timestamp is recent or not. If these checks are successful, D2 continues with the request and saves MOD (EXP(G, N1),P) into a variable (say AA); otherwise the request is dropped. Next, D2 calculates EXP(G, N2) and the output of this is used to calculate the modulus over P. Finally, D2 sends the following message to D1, signed with its private key. D2- > D1 : D2{D2.T 2.M OD(EXP (G, N 2), P ).Hash(D2.T 2.M OD(EXP (G, N 2), P ))}KD2 Then, it derives the secret key SK by calculating MOD(EXP(AA, N2), P). When D1 receives the message, it first check the authenticity of the message using D2's public key. Then, it checks whether the timestamp is recent or not. If both checks are successful, D1 continues further with that request and saves MOD(EXP(G,N2), P) into a variable (say BB); otherwise it understands that something has gone wrong or it drops the message. Next, it gets the secret key SK by calculating MOD(EXP(BB, N1), P). At this point, both devices have successfully shared the secret key SK using the DH key exchange algorithm [51]. Step 5: Next, D2 requests the OTP-server to provide the OTPs for devices D1 and D2. To issue such request, D2 generates a timestamp T3 and sends the following message to OTP-server, signed with its private key. D2- >OTP-server: D2.{D1.D2.T 3.REQ.Hash(D1.D2.T 3)}KD2 Step 6: Upon receipt of the request, the OTP-server checks if the message is really originated from D2 and whether the timestamp appended to it is recent or not. If both checks are successful, the OTP-server continues with the request and generates two OTPs: OTP1 and OTP2, along with a timestamp T4; otherwise, it drops the request. Next, it sends the following message to D1, encrypted with D1's public key. OTP-server->D1 : {T 4.OT P 2.OT P 1}KD1 Step 7: In a similar manner as in Step 6, the OTP-server sends the following message to D2, encrypted with D2's public key.

41

OTP-server->D2 : {T 4.OT P 1.OT P 2}KD2 It should be noted that the OTPs are sent over the infrared communication channel within the home (which is considered as a secure channel); therefore, the encryption of the above message can be optional. At this point, both devices D1 and D2 have received their OTPs. For the OTP-based mutual authentication of D1 and D2 (i.e. second authentication level), the above secret key SK is modified as follows, producing SK' SK := XOR(SK, Hash(XOR(OT P 1, OT P 2))) where XOR and Hash denote the XOR operation and a one-way hash function respectively. Step 8: D1 sends the hash of OTP2 to D2, encrypted with the secret key SK', i.e. D1 - >D2 : {Hash(OT P 2)}SK Step 9: Similarly, D2 sends the hash of OTP1 to D1, i.e. D2 - >D1 : {Hash(OT P 1)}SK Finally, D1 (resp. D2) checks the received hash Hash(OTP1) (resp. Hash(OTP2)) using M=Hash(OTP1) (resp. M=Hash(OTP2)), where M is the received message after decryption; and if there is a match, D1 and D2 have mutually authenticated each other; otherwise the authentication has failed. It should be emphasized that in the above process, the infrared channel program utilized to fetch the password using the infrared channel requires the sudo/root access. Thus, an access control program such as the one proposed in [28] can be used to enable the infrared device to read the infrared channel and to allow any user to execute it in order to receive the password. It is the task of the infrared program to check if the requesting user is the owner of the service. This program is meant to read the password and load the private key into a SSH-agent [29], which in turn can enable that user to access it. This way, the private key is kept secure and a non-root user cannot get hold of the password. It should be noted that once the private key is loaded, it can be used by the same user multiple times, until it is revoked.

42

3.2.3

Design of the PPIDA-PKI Scheme

In the PPIDA-PKI scheme, a PKI is used to send the password proxy services to the requesting device. Its high-level architecture is similar to that of PPIDA-IC scheme depicted in Fig. 3.1, but with some differences in its functional requirements (as will be described in the following). In this scheme, two levels of PKI key-pairs are used, namely, host level authentication and user level authentication (where the application runs), each using a private-public key pair. At the host level authentication phase, the private key is protected by the root user. Afterwards, the root user is disabled if attempted to login (as per the SELinux requirements [52]). In our scheme, SELinux is used to enforce the access policy in such a way that no one can access the private keys of the host, except the cryptographic module. It should be emphasized that all sudoers accounts should only have access to the infrared program which in turn reads the infrared channel for OTP exchange purpose. In the user level authentication, the user's private key is encrypted with the password or passphrase, then it is used for authentication purpose. The working of the PPIDA-PKI scheme consist of three phases as follows: (1) Manufacturing phase: This is similar to the manufacturing phase of the PPIDA-IC scheme. (2) Deployment and registration phase: All the devices need to be registered in ad-

vance with the OTP-server. There are two types of registration: home-device registration with OTP-server and peer-to-peer home-device registration. If a device, say D1, needs to authenticate to its peer device, say D2, D1 should also register with D2. To register a device D1 with the OTP-server, a host level public key-pair (kpha) is created, then the associated public key is stored in the OTP-server in a secured manner. It should be noted that Kpha is owned by the root (superuser) on D1. Similarly, the OTP-server creates a host level public key-pair (kpho) in a one-time operation, and the associated public key is also stored with D1 securely. 43

A user level public key pair (KD1/ka) of D1 is also created and its associated public key is shared with the OTP-server. Next, the OTP-server's public key (ko) is stored with D1; this key is used to receive the password-proxy requests. In addition, the location of the device with respect to the OTP-server is also stored in the form of degree of angle. It is worth pointing out that the devices should be facing towards the OTP-server in order for the infrared light communication to occur. In addition, the home devices must save the OTP-server s public-key. For each passwordproxy service, a random token is generated by the OTP-server, then saved in the OTP-server and the device. This token is also linked with the password of that password-proxy service (as a way to recognize the requested service in future). For peer-device registration, if a device, say D1, wants to communicate with another device, say D2, then D1 has to pre-register with D2. In peer-to-peer home device registration, the public keys KD1/ka and KD2/kb are shared in advance in (a secure manner) among the devices. (3) Authentication phase: This phase comprises the following steps (shown in Fig. 3.4).

Step 1: When a device, say D1 wants to communicate with another device, say D2, it initiates the request for authentication. In the PKI-based host authentication level, the DH key exchange algorithm [27] is used to generate the secret session key that will be kept secret between D1 and D2. For every new session, a different secret key will be generated and used for encrypting all communication between both hosts. Next, D1 sends the following message to initiate the authentication by encrypting the service token, the current timestamps, and their hash using with OTP-server's public key, i.e. D1 - >O : D1.{T oken.T imestamp.Hash(T oken.T imestamp)}KO where O denotes the OTP-server. Step 2: Once the OTP-server has received that request, it generates a random number

44

Figure 3.4: PPIDA-PKI scheme authentication phase.

N1 and calculates EXP(G2, N1), where G2 is a chosen positive integer. The output of this operation is used to find the modulus over P2 using the MOD (modulus) function, where P1 is publicly known. O then sends the following message to device D1, signed by its private key PKHo: O - >D1 : O.{O.T 1.G2.P 2.M OD(EXP (G2, N 1), P 2).Hash(O.T 1.G2.P 2 .M OD(EXP (G2, N 1), P 2))}KP Ko Step 3: D1 checks if the message is originated from O using O's public key, then it checks whether the timestamp is recent or not. If both checks are successful, D1 continues with 45

that request; otherwise the request is dropped. If these checks are successful, D1 continues with the request and saves MOD(EXP(G2, N2),P2) into a variable (say AA); otherwise the request is dropped. Next, D1 calculates EXP(G2, N2); and the output of this is used to calculate the modulus over P2. Finally, D1 sends the following message to O signed by its private key PKHa: D1 - >O : D1{D1.T 2.M OD(EXP (G2, N 2), P 2).Hash(D1.T 2 .M OD(EXP (G2, N 2), P 2))}KP Ka After sending the message to O, D1 obtains the secret key SK1 by calculating MOD(EXP(AA, N2), P2). Once O receives the message, it first checks the authenticity of the message using D1's public key. Then, it checks whether the timestamp is recent or not. If these checks are successful, O continues with the request and saves MOD(EXP(G2, N2),P2) into a variable (say BB); otherwise it understands that something has gone wrong or it drops the message. Next, it gets the secret key SK1 by calculating MOD(EXP(BB, N1), P2). At this point, both devices have successfully shared the secret key SK1 using the DH key exchange algorithm [51]. Step 4: Now, the OTP-server looks into database entries for the token and retrieve the password. This password is encrypted with O's private key, then further encrypted with SK1, i.e. O - >D1 : {O.T 3.P assword.KO .Hash(O.T 3.P assword.KO )}SK 1 Next, D1 validates the message and retrieves the password used to decrypt the private key file KD1 Step 5 to Step 9: These steps are similar Step 3 to Step 7 of the PPIDA-IC scheme authentication phase. Step 10: For the OTP-based mutual authentication of D1 and D2 (i.e. second authentication level), the generated secret key SK (different from the above private key SK1) is modified as follows, producing SK'

46

SK := XOR(SK, Hash(XOR(OT P 1, OT P 2))) Step 11: Next, D1 sends the hash of OTP2 to D2, encrypted with the secret key SK', i.e. D1 - >D2 : {Hash(OT P 2)}SK Similarly, D2 sends the hash of OTP1 to D1, i.e. D2 - >D1 : {Hash(OT P 1)}SK Finally, D1 (resp. D2) checks the received hash, i.e. Hash(OTP1) (resp. Hash(OTP2)) using M=Hash(OTP1) (resp. M=Hash(OTP2)), where M is the received decrypted message; and if there is a match, D1 and D2 have mutually authenticated each other; otherwise, the authentication has failed.

3.2.4

Modelling of the PPIDA-IC Scheme Using HLPSL

As per the above HLPSL syntax specifications [25], our proposed PPIDA-IC scheme can be modelled as follows. It should be noted that the numbering of the steps in this subsection is similar to that of the PPIDA-IC design steps described earlier in Subsection 3.2.2. The steps are as follows. Step 1: Initially, when a device D1 wants to start communication with another device D2, it does not have a password for securing its private key. It then sends the following message to the OTP-server to request one, encrypted with the OTP-server's public key: State=0 /\RCV(start) =|>State':=1 /\Timestamp':=new() /\SND(A.{Token.Timestamp'.Hash(Token.Timestamp')} KPo) where State is a local variable of every agent, which is initialized to 0 at the beginning. D1 receives a start message over the RCV channel to begin the protocol. Then, it updates its state to 1, and then it generates a timestamp, which will be used to protect against replay attacks. Here, Token is a unique number used to identify a service, and this number is assigned at the registration phase. D1 sends the message to the OTP-server over the SND 47

channel, which includes the token, timestamp and their hash, all encrypted using the OTPserver's public key. This message is transmitted over a radio channel (e.g. using Wi-Fi). Step 2: The OTP-Server receives the message over its RCV channel and updates its state to 1. First, it validates the request by checking the timestamp, D1 identify, hash of the message and the service token. It then creates a current timestamp and fetch the password from its database. Next, it fetches the location of the device relative to its position from the database and points the Infrared trans-receiver toward D1. Then, it sends the following message, encrypted with its private key over the infrared channel to D1. State=0 /\RCV(A.{Token.Timestamp'.Hash(Token.Timestamp')} KPo) =|>State':=1 /\Timestamp' := new() /\SND(O.{Timestamp'.Password.Hash(Timestamp'.Password)} inv(KPo)) /\secret(Password,sec 1,{A,O}) Where the secret() function is used to check for the password secrecy between D1 and the OTP-server. It should be noticed that the infrared channel is considered secure, therefore, the password can also be sent to D1 even in its plaintext form over the infrared channel. Step 3: D1 receives the message by decrypting it. Then, it validates the message by checking the hash and timestamp, and it uses the password to retrieve its private key, which in turn is used to generate the DH session key between D1 and D2 in a similar as in [7]: State=1 /\RCV(O.{Timestamp'.Password'.Hash(Timestamp'.Password')} inv(KPo)) =|> State':=2 /\secret(Password', sec 1,{A,O}) /\Na':=new() /\Timestamp':=new() /\AA' := MOD (EXP(G,Na'),P) /\SND(A.{A.Timestamp'.AA'.G.P.Hash(AA'.G.P.Timestamp'.A)} inv(KPa)) Step 4 and Step 5: D2 validates the message by checking the hash and timestamp. To complete the DH key exchange protocol [51], D2 also sends a message (encrypted with D2's

48

private key) to the OTP-server to request the OTPs that will be used for second level authentication purpose. Here, the hash is used to ensure the message integrity. The OTP-server replies as follows: State=0 /\RCV(A.{A.Timestamp'.AA'.G.P.Hash(AA'.G.P.Timestamp'.A)} inv(KPa)) =|> State':= 1 /\Nb':=new() /\BB' := MOD(EXP(G,Nb'), P) /\SND(B.{B.Timestamp'.BB'.Hash(BB'.Timestamp'.B)} inv(KPb)) /\Key' := MOD(EXP(AA',Nb'),P) /\secret(Key', secret key, {A,B}) /\Req':=new() /\SND(B.{A.B.Timestamp'.Req'.Hash(A.B.Timestamp')} inv(KPb)) Where new() is a function used to create a random nonce, G and P are publicly known, and mod() and exp() are the modular and exponential operations respectively. Step 6 and Step 7: After the OTP server receives the OTP-request, it validates it and generates a new timestamp; then it sends the OTPs to D1 and D2 over the infrared channel. Next, the message is encrypted with public keys of D1 and D2. Here, it should be emphasized that the secrecy of the OTPs is ensured by means of the secret() function. State=1 /\RCV(B.{A.B.Timestamp'.Req'.Hash(A.B.Timestamp')} inv(KPb)) =|> State':=3 /\Timestamp' := new() /\SND({Timestamp'.OTP1.OTP2} KPb) /\SND({Timestamp'.OTP2.OTP1} KPa) /\secret(OTP1, server otp1, {A,B,O}) /\secret(OTP2, server otp2, {A,B,O}) Step 8: When D1 receives the OTPs, it updates its state to 2, then updates its session key and sends the hash of OTP2 to D2, encrypted using the newly generated session key as follows:

49

State=3 /\RCV({Timestamp2'.OTP2'.OTP1'} KPa) =|> State':=4 /\Key' := XOR(Key',Hash(XOR(OTP1',OTP2'))) /\SND({Hash(OTP2')} Key') State=4 /\RCV({Hash(OTP1')} Key') =|> State':=5 /\witness(A,B, server client bb,{B.Timestamp'.BB'} inv(KPb).Hash(OTP1')) /\request(A,B, client server aa,{A.Timestamp'.AA'} inv(KPa).Hash(OTP2')) where the functions witness() and request() are used to check for strong authentication. Step 9: D2 also computes the session key in a similar way as in Step 8 and sends the hash of OPT1 to D1, protected by the session key, as follows: State=1 /\RCV({Timestamp2'.OTP1'.OTP2'} KPb) =|> State':=2 /\Key' := XOR(Key',Hash(xor(OTP1',OTP2'))) State=2 /\RCV({Hash(OTP2)} Key') =|> State':=3 /\SND({Hash(OTP1)} Key') /\witness(B,A,client server aa,{A.Timestamp'.AA'} inv(KPa).Hash(OTP2')) /\request(B,A,server client bb,{B.Timestamp'.BB'} inv(KPb).Hash(OTP1')) Both D1 and D2 can now validate the received hash by computing {Hash(OTP1)} Key' and {Hash(OTP2)} Key' respectively. If there is a match, they have mutually authenticated each other; otherwise, the authentication has failed. Next, the goals of keeping OTP1 and OTP2 secret, ensuring the secrecy of the session key, achieving mutual authentication between D1 and D2, and ensuring the secrecy of the password between D1 and the OTP-server, is coded as follows: goal secrecy of server otp1 secrecy of server otp2 secrecy of secret key secrecy of sec 1 authentication on client server key

50

authentication on server client key end goal

3.2.5

Modelling of the PPIDA-PKI Scheme Using HLPSL

As per the above HLPSL syntax specifications [25], our proposed PPIDA-PKI scheme can be modelled as follows. It should be noted that the numbering of the steps in this subsection is similar to that of the PPIDA-PKI design steps described earlier in Subsection 3.2.3. The steps are as follows. Step 1: This step is identical to Step1 of the PPIDA-IC scheme. Step 2: The OTP-Server receives the message over its RCV channel, and updates its state to 1. Next, it validates the request by checking the timestamp, D1 identify, hash of message and service token. Then, it initiates the DH key exchange protocol [27] with D1. It should be emphasized that the SeLinux [52] is invoked here to protect the host keys. The DH key exchange is achieved using these keys. This step is modelled as follows: State=0 /\RCV(A.{Token.Timestamp'.Hash(Token.Timestamp')} KPo) =|>State':=1 /\No':=new() /\OO' := MOD(EXP(G2,No'),P2) /\SND(O.{O.Timestamp'.OO'.G2.P2.Hash(O.Timestamp'.OO'.G2.P2)} inv(KPHo)) Where G2 and P2 are publicly known and No' is the OTP-server's nonce. Step 3: When D1 receives the message, it validates it and generates its own secret Na'; then it generates a DH key and sends the message to the OTP-server. It should be noticed that the secrecy of the session key is also checked. This step is modelled as follows: State=1/\RCV(O.{O.Timestamp.OO'.G2.P2.Hash(O.Timestamp.OO'.G2.P2) } inv(KPHo))=|>State':=2 /\Na':=new() /\AA' := MOD(EXP(G2,Na'),P2) 51

/\Session key' := mod (exp(OO',Na'),P2) /\SND(A.{A.Timestamp.AA'.Hash(A.Timestamp.AA')} inv(KPHa)) /\secret(Session key',secret key1, {A,O}) Step 4: The OTP-server receives and validates the D1 message, then it generates the DH session key and sends a message containing the password encrypted with this key as follows: State=1 /\RCV(A.{A.Timestamp.AA'.Hash(A.Timestamp.AA')} inv(KPHa)) =|> State':=2 /\secret(Password,sec 1,{A,O}) /\Timestamp':=new() /\Session key' := MOD(EXP(AA',No'),P2) /\SND(O.{{O.Timestamp'.Password.KPo. Hash(O.Timestamp'.Password.KPo)} inv(KPo)} Session key') /\secret(Session key',secret key1, {A,O}) Step 5: D1 receives the message by decrypting it with the session key. Next, it validates the message, then uses the password to retrieve its private key. This key is then used to generate the DH session key with D2 in a similar way than in [7], as follows: State=2/\RCV(O.{{O.Timestamp'.Password'.KPo. Hash(O.Timestamp'.Password'.KPo)} inv(KPo)} Session key') =|>State':=3 /\secret(Password',sec 1,{A,O}) /\Na':=new() /\Timestamp':=new() /\AA' := MOD(EXP(G1,Na'),P1) /\SND(A.{A.Timestamp'.AA'.G1.P1.Hash(AA'.G1.P1.Timestamp'.A)} inv(KPa))

Step 6 and Step 7: These steps are modeled in a similar way that Steps 4 and 5 of the PPIDA-IC scheme were modelled, but with G and P are now replaced by G1 and P1. Step 8 to Step 11: These steps are modeled in a similar way that Steps 6 to 9 of the PPIDA-IC scheme were modelled.

52

The goals of keeping OTP1 and OTP2 secret, ensuring the secrecy of the session keys (secret key and secrey key1), and the password (sec 1) secret, achieving mutual authentication between D1 and D2, and ensuring the secrecy of the password between D1 and the OTP-server, is coded as follows: goal secrecy of server otp1 secrecy of server otp2 secrecy of secret key secrecy of secret key1 secrecy of sec 1 authentication on client server key authentication on server client key end goal

3.3

Design of the RSA-ASH-SC Scheme

Our proposed RSA-based two-factor User Authentication Scheme for Smart Home using Smart Card (so-called RSA-ASH-SC) relies on a variant of the RSA algorithm [59]. For a better understanding of its design and for notations purpose, it is preferable to replicate here the steps of the RSA public key cryptosystem.

3.3.1

RSA Public Key Cryptosystem

The RSA algorithm [59] is composed of three steps: key generation, encryption and decryption. Key generation : First, the input to this algorithm is a security parameter n (also referred

53

to as length of the RSA). Second, two prime numbers p and q are chosen, each with n/2 bits long. Third, N is computed as N = p.q . Fourth, the Euler's totient function (N ) is calculated as (N ) = (p - 1).(q - 1). Fifth, e the encryption component is chosen such that gcd(e, (N )) = 1<and<1<e<(N ). Typically, e = 65537. The next step is to derive a private key d such that d = e-1 mod((N )). The public key is (e, N ) and private key is (d, N ). Encryption : Either of the keys (e, N ) or (d, N ) can be used to encrypt the message (usually the public key). To decrypt the message, a second key is used. The message M should be an integer in the range {1, ..., (N - 1)}. If it is not, the message from the input bit string should be formatted such that M belongs to {1, ..., (N - 1)}. For this purpose, the PKCS#1 standard [60] is commonly used, and the message M is encrypted as C = M e mod(N ),where C is the ciphertext. Decryption : The private component d and N are used to decypher the message C. To retrieve the original message M, one calculates C d mod(N ) Since d and N are large numbers, it is very computation intensive, and to ensure a fast convergence of the decryption algorithm, the Chinese Remainder Theorem has been used as standard. It has been proven that its use can substantially boost the performance of the RSA (about four time faster compared to when it is not used) [60]. More precisely, M p and M q are calculated as follows:
dp M p = Cp (mod p) dq M q = Cq (mod q )

Where dp = d(mod p) and dq = d(mod q ), and the message M is retrieved using the Chinese Remainder Theorem [60].

3.3.2

RSA-ASH-SC Scheme

For the design of this scheme, the notations used are given in Table 3.3 In this algorithm, for the cryptography purpose, a fast variant of RSA, which is a com54

Table 3.3: Notations used in the proposed RSA-ASH-SC scheme Notation (N ) n k s p, q e d mod() gcd()  h(), f () T {}Si Ui IDi P Wi OT Ti Description Euler's totient Input security parameter for key generation algorithm Distinct prime numbers in RSA key generation Size of prime numbers in RSA key generation (Rebalanced) Prime numbers used in RSA key generation Encryption exponent Decryption exponent Modulus operation Greatest common divisor XOR operation One way Hash function Threshold time used to prevent replay attack Symmetric key encryption/decryption, here Si is symmetric key ith user ith user's ID ith user's password ith user's One-Time-Token

bination of Multi-power and Rebalance RSA algorithms [9], is considered. The proposed RSA-ASH-SC scheme is a two-factor remote authentication scheme, the first of which is password (i.e. what you know factor) and the second is smart card (i.e. what you have factor). The user is required to register (one time process) beforehand with the system. Each user Ui submits a hash of his chosen password P Wi in a secure manner and a smart card issuer generates a unique IDi and other information, which are saved in the smart-card, to be used for remote user authentication purpose. The steps of the RSA-ASH-SC scheme are as follows: Initialization phase: The RSA keys are generated as per the method described in [9]. In our scheme, the card issuer (in Smart Home, the issuer can be himself) is the same as the authentication server/system. The key generation algorithm takes two security parameters

55

as inputs: n and k . First, it generates n/k bits long two prime numbers p and q , such that gcd((p - 1), (q - 1)) = 2. Then, it calculates N = p(k-1) .q . Next, it generates two random numbers r1 and r2 in such a way that gcd(r1, (p - 1)) = 1, gcd(r2, (q - 1)) = 1 and r1 = r2<mod(2). Then, it finds the integer d such that d = r1<mod(p - 1) and d = r2<mod(q - 1). Finally, it calculates e such that e = d-1 mod((N )). Here, the public key is (e, N ) and the private key is (p, q, r1, r2), which is kept secret with the card issuer. Registration Phase: The user submits a request, in secure manner, to the issuer for the smart card by sharing the hash of his password HP Wi = h(P Wi ), where h() is a one-way hash function and P Wi is the password of the user. Upon receiving the request, the issuer-server creates a random and unique IDi for the user. The server also creates a random one-time-token OT Ti to keep the future authentication requests. Next, the server calculates HP W IDi = h(HP Wi  IDi ) and stores this value and OT Ti in its database, which is protected by its private key. Next, the server stores the following information (IDi , OT Ti , h, e, N ) on the smart card. The smart card is then physically handed over to the user. Login phase: The user requires a smart card reader before starting the login process. First, the user connects the smart card reader and writer (SCRW) to the personal digital assistant (PDA). Then, he opens the application which makes use of the proposed authentication. The user enters the password P Wi which is sent to the card, for ex-

ample, using an application protocol data unit (APDU) [61]. This application also generates and sends a random secret key Si to the smart card. It should be noted that the secret key is generated for every new session. The card then performs the following steps. First, it computes x as x = (h((h(P Wi )  IDi ))e  h(T ))mod N , where T is a newly created timestamp. Then, it computes HXOT Ti = h(x  OT Ti ), Next, it computes y = (OT Ti ||T ||Si ||h(OT Ti ||T ||Si ||HXOT Ti )||HXOT Ti ) and encrypts y as C = y e mod (N ), then sends the following message (OT Ti , C ) to the server. Authentication phase: Upon receipt, the server compares OT Ti against the entries in

56

the database. If there is a match, it decrypts the message. To achieve this, it computes M1 = C r1 mod(p) and M2 = C r2 mod(q ). Using CRT, it calculates M  ZN such that M = M1 mod (p) and M = M2 mod (q ). The received message M = (OT Ti ||T |||Si ||h(OT Ti ||T ||Si ||HXOT Ti )||HXOT Ti ). Then, it checks whether the timestamp is recent or not, i.e. (Tc - T )<T where Tc is the current time and T is the acceptable timestamp difference. It also verifies OT Ti within message M again with the unencrypted OT Ti . It also verifies the hash of the message to check if the message was tempered. Then, it computes x = ((HP W IDi )e  h(T ))mod N and Z = h(x  OT Ti ). If Z and HXOT Ti are equal, it authenticates the request. The server then creates a new random token OT Tnew and current timestamp Tnew , then computes the response as Mr = (Tnew {h(Tnew ||OT Tnew ).OT Tnew }Si ) and sends that response to the user. Here, {}Si is the encryption/decryption function and Si is the symmetric key. The server also updates the token (OT Ti ) of the corresponding IDi and OT Tnew . When the user receives the response, it decrypt the message M = (Tnew {{h(Tnew ||OT Tnew ) OT Tnew }Si }Si ). First, it checks whether the timestamp is recent or not, i.e. (Tc - Tnew )<T . If it is the case, it stores the new token OT Tnew in the card for the new time and uses Si for further communication; otherwise it drops the authentication request. Password change: To update the password, the user needs to be authenticated in advance. The user enters its password and calculates the hash of the new password as

HP Wnew = h(P Wnew ), then sends a password update command to the server as CM D = {passupdate , T, h(T, HP Wnew ), HP Wnew }Si , where passupdate is a known command to the server. After receiving the command, the server decrypts the message using Si and validates the timestamp and hash of the message as described above. If validated, the server computes HP W IDnew = h(HP Wnew  IDi ). then updates the HP W IDi in the database corresponding to the user IDi . The proposed RSA-ASH-SC Scheme can be summarized as follows: Client <----------------------------------------------------- >Server

57

x = (h((h(P Wi )  IDi ))e  h(T ))mod N HXOT Ti = h(x  OT Ti ) y = (OT Ti ||T ||Si ||h(OT Ti ||T ||Si ||HXOT Ti )||HXOT Ti ) C = y e mod (N )

(OT Ti , C )

M1 = C r1 mod(p) M2 = C r2 mod(q ) U sing CRT M  ZN M = (OT Ti ||T ||Si ||h(OT Ti ||T ||Si ||HXOT Ti )||HXOT Ti ) If (Tc - T )<T V erif y OT Ti x = ((HP W IDi )e  h(T )) mod N Z = h(x  OT Ti ) If Z == HXOT Ti Create OT Tnew and Tnew Mr = (Tnew {h(Tnew ||OT Tnew ).OT Tnew }Si )

M = (Tnew {{h(Tnew ||OT Tnew ).OT Tnew }Si }Si If (Tc - Tnew )<T U pdates OT Tnew

58

Chapter 4 Simulations and Security Analysis of the Proposed Schemes
This Chapter presents the security and performance analysis of the proposed protocols. The back-ends of the AVISPA tool [25] are used to simulate and verify the D2DA-OTP-IC, PPIDA-IC, and PPDA-PKI protocols against attacks. Through informal security analysis, the ability of the proposed schemes to resist against various common cryptographic attacks is checked.

4.1

Security and Performance Analysis of the D2DAOTP-IC Scheme

4.1.1

SPAN/AVISPA Tool

The SPAN/AVISPA tool [25] is used to determine whether the proposed D2DA-OTP-IC protocol (in HLPSL format) is secure or not in terms of ensuring the secrecy of the session key and achieving mutual authentication. The authentication is achieved when two devices D1 and D2 can validate their identities using OTPs. The secrecy refers to ensuring that the 59

information that is exchanged between devices D1 and D2 cannot be deciphered or cannot be disclosed to an unauthorized entity and only the intended receiver can decipher it; integrity refers to the fact that it is not possible for an intruder to alter or destroy the information shared by devices D1 and D2 during the communication process. This is achieved by appending a hash to the message at its source and by re-computing the hash of the message at the destination, then check for a match between the two quantities. If a protocol is found unsafe, the AVISPA tool [25] will reveal the trace of the attack found; otherwise the protocol is qualified as safe against attacks. This is a distinguishing feature of the AVISPA tool compared to other available tools such as BAN Logic [26].

4.1.2

Simulation of the D2DA-OTP-IC Scheme Using AVISPA

In the proposed D2DA-OTP-IC scheme, the session keys (symmetric keys) are utilized to encrypt the message and the DH key exchange algorithm [51] is used for key exchange purpose over an insecure channel. The simulation results of our proposed scheme are attributed to the OFMC and CL-AtSe back-end modules of the AVISPA tool [25] as the other two back-end modules: SATMC and TA4SP [25] have reported NOT SUPPORTED and have produced INCONCLUSIVE results. The SPAN gives a better understanding of the protocol and it is used to confirm whether the specification is executable or not. It also helps visualizing the operations of the protocol as shown in Fig. 4.1 Verification of the results: The two back-ends modules of AVISPA, namely OFMC and CL-ATSe reported that the proposed D2DA-OTP-IC protocol is safe as confirmed in Fig. 4.2 and Fig. 4.3 respectively. Indeed, Fig. 4.2 and Fig. 4.3 indicate that no authentication attack, nor secrecy attack has occurred on the proposed D2DA-OTP-IC protocol. In addition, no attack is found on the session key by the intruder and the secrecy of the transferred message between devices. It is also shown that the session keys are also maintained. In the proposed D2DA-OTP-IC 60

Figure 4.1: Simulation of the D2DA-OTP-IC protocol in AVISPA.

protocol, we have exchanged the session keys using the DH key exchange algorithm [51], and this was checked for secrecy purpose and the AVISPA tool validated this checking. We have also checked for the secrecy of OTP1 and OTP2, which was also validated by the AVISPA tool. In addition, our goals of keeping the OTP1 and OTP2 secret, ensuring the secrecy of the session key, and achieving mutual authentication between the client and the server, have been validated by the SPAN/AVISPA tool since the protocol is reported as safe.

61

Figure 4.2: D2DA-OTP-IC protocol verification using the OFMC back-end.

4.1.3

Informal Security Analysis of the D2DA-OTP-IC Scheme

In this subsection, we discuss about some attacks and how our proposed D2DA-OTP-IC scheme can be used to protect against them. Eavesdropping attack: In this attack, the eavesdropper silently listens to the communication of others without their knowledge. He/she may gain some sensitive information if not protected. In our scheme, the DH key exchange algorithm is used to construct the session keys, and the identity of the messages is signed using the private keys, which only the owner has access to. In addition, on top of it, the OTPs are sent over a light communication and an eavesdropper cannot get access to these entities after a successful authentication since 62

Figure 4.3: D2DA-OTP-IC protocol verification using the CL-AtSE back-end.

all the communication entities use the session key to encrypt the data and the eavesdropper cannot make anything out of it. The session keys are generated for each session in order to maintain high security. Masquerading/Impersonation attack: In this kind of attack, the intruder presents himself as a genuine entity to gain the unauthorized access. Our scheme makes use of digital signature to validate the messages in the first phase, where the session keys are exchanged. Therefore, masquerading attempts will be blocked right at the first phase. Replay attack: In this kind of attack, the intruder first captures the data packets which can be used later to gain access to the system. To protect against this type of attack, the

63

current timestamp is used in our scheme, which is included in the digital signature, and it is assumed that the systems sync on time. On top of it, OTPs are used, which are randomly generated for each session. Message modification attack: In this type of attack, the intruder tries to tamper the message. Our scheme uses a public key Infrastructure in its first phase to check if the message is legitimate or not. In its second phase, the hashed OTPs are sent by encrypting them with the session keys. If the message is tampered at any phase, the authentication will fail. Therefore, our scheme can be used to protect against message modification. Reflection attack: In this type of attacks, the attacker tries to gain access to the system by taking advantage of the protocols weakness, for instance, when encryption and decryption are performed without prior checking of the identity of the user. In the caseof our protocol, the attacker can only gain access to the radio channel (e.g. Wi-Fi). In the first two steps, the message is encrypted using the private keys KD 1andKD 2), but the secret nonce N1 and N2 are never sent to a third party. Therefore, the attacker has no way to get these nonce, which are used to establish the secret session key (using the DH key exchange [51]). The communication between device D2 and the OTP-server is also signed by D2's private key; the attacker can get hold of this message if he has the public key of D2, but there is no sensitive information at this step of the protocol operations. In the final two steps, the hash of the OTPs are protected with the secret key SK before being exchanged and the attacker cannot decrypt this information. Therefore, this attack will not work. Multi-Protocol attack: In this attack, multi-protocols are used to target one of the protocol and the attacker authenticates itself by misleading the protocol. In our scheme, the attacker cannot generate the signed messages between devices D1 and D2 since he does not have access to the private keys. Thus, even if he tries with multiple protocols, the response from D1 and D2 will be different since random nonce N1 and N2 (used to establish the session key for every new session) are generated each time. The attacker also does not have access to the OTPs and cannot authenticate itself. Hence, the attacker cannot compromise

64

the protocol. A qualitative comparison the proposed D2DA-OTP-IC scheme against few schemes in terms of security attacks is given in Table 4.1

Table 4.1: Comparison of Selected Authentication Schemes based on Security Attacks Shin Kumar Kumar MarktsRuj Santoso Preethy Proposed et al. et al. et al. cheffel et et al. et al. [27] Scheme [32] [17] [33] al. [63] [62] [34] *

MIMA Impersonation attack Replay attack Password guessing attack Forgery attack Eavesdropping attack Brute-Force attack Repudiation Forward Secrecy Denial of Service attack

*

A qualitative comparison the proposed D2DA-OTP-IC scheme against few schemes in terms of some authentication characteristics is given in Table 4.2.

A qualitative comparison the proposed D2DA-OTP-IC scheme against few schemes based on considered evaluation models is given in Table 4.3. * means subject to special consideration. In our proposed D2DA-OTP-IC scheme, a proofof-concept has been implemented.

65

Table 4.2: Comparison of Selected Authentication Schemes based on some Authentication Characteristics Shin Kumar Kumar MarktsRuj Santoso Preethy Proposed et al. et al. et al. cheffel et et al. et al. [27] Scheme [32] [17] [33] al. [63] [62] [34] MutualAuthentication AdditionalHardware MultipleCredential MultipleAuthenticationLevels Registration Offline-Phase Anonymity Table 4.3: Comparison of Selected Authentication Schemes based on evaluation models Shin Kumar Kumar MarktsRuj Santoso Preethy Proposed et al. et al. et al. cheffel et et al. et al. [27] Scheme [32] [17] [33] al. [63] [62] [34] Implementation * Simulation TheoraticalEvalution PerformanceEvaluation

4.1.4

Proof of Concept of the D2DA-OTP-IC Scheme

We have developed a proof-of-concept of the D2DA-OTP-IC scheme in the form of a hardware design, using three Raspberry-Pi (B+, Pi2, and Pi3) as home devices. For this, the OTPserver was running on Raspberry-Pi3, the server was running on Raspberry-Pi-B+, and the client was running on Raspberry-Pi2. All Raspberry devices were running with the Raspbian Operating System. Each of these devices was embedded with an infrared transceiver circuit 66

as shown in Fig. 4.4. For the infrared communication, we have used an infrared emitter (IR333c LED) to send the

Figure 4.4: Raspberry Pi Infrared trancever circuit for LIRC [64].

infrared signal and the TSOP38238 as an infrared receiver. To send and receive the infrared signals, we have used the Linux Infrared Remote Control (LIRC) [65], which is meant for infrared remote communication. The LIRC package on Linux comes with multiple programs; we have used the "irsend " and "irw " programs. To configure the LIRC, a config-file [65] was used. The OPT-server was installed with a 3D rotation device made of two SG90 Micro servo motors, which can be rotated only by 180 degrees. To build a 3D rotation, we integrated 67

the two servos together as shown in Fig. 4.5

Figure 4.5: 3D rotating servo placement.

The infrared transceiver was set on top of it to send the infrared signal in the direction that the 3D device is pointing to. The servo circuit diagram is shown in Fig. 4.6.

To control the servos, a program in Python was developed using the GPIO library [65]. For the first level of authentication, the OpenSSH was utilized. On the server side, a Pluggable Authentication Module (PAM) was developed, which ran on Python; for this purpose, the "python-pam " python module was installed. This PAM module achieved an infrared 68

Figure 4.6: 3D rotating servo circuit.

communication-based OTP authentication as second level of authentication. Setup Phase: Initially, the Raspbian OS was downloaded from [66] and installed on all the devices. Python came by default, and the "pyopenssl " and "python-pam " python modules were installed, followed by"lirc" the Linux package "lirc ". Next, the LIRC remote config file [65] was installed and the sshd PAM (/etc/pam.d/sshd) was configured in order to enable the PAM module (OTP PAM.py) for ssh. The OTP PAM.py was also configured using the OTP-servers IP as follows: auth required pam python.so OTP PAM.py . Next, the sshd config file (/etc/ssh/sshd config) was configured to enable the use of public-key based authentication using PAM as follows: 69

PasswordAuthentication no UsePAM yes AuthenticationMethods publickey,keyboard-interactive To create the public-private key pairs for public-key authentication, we have used ssh-keygen. We have used user "pi " for this proof of concept; ssh uses this information to create the identity. The public key was copied from the client machine to the server machine, and the public-private key pair was generated in the PEM format for the OTP-server using the "openssl " command. Then, the public key of the OTP-server was copied to both devices. The OTP-server ran OTP-server.py, which created and served the OTPs. As the part of the setup, the client and server devices direction were registered in the OTP-server.py file as well, relatively to the 3D rotating device. After these configurations were done, the ssh was restarted to enable a new configuration. To setup the hardware, the 3D rotating device was attached to the OTP-server and the GPIOs were connected to the device as shown in Fig. 4.5. Then, the infrared transceiver circuit was connected as shown in Fig. 4.6. For both the client and the server device, the infrared circuit were also configured as shown in Fig. 4.6. Experimental Phase: To run the proposed hardware design, LOGIN.py was executed on the client machine (i.e. the machine which was requesting the authentication). LOGIN.py uses ssh to establish the session key using the DH key exchange algorithm [51]. After the server and the client have authenticated each other, and have generated a session key, the PAM module was called on the server side for the second phase authentication. It should be noted that using the ssh public-key authentication alone was not sufficient and there was a need for a second phase to successfully achieve the device-to-device authentication. The PAM module got the information on both the client and server IPs and used it to requests for OTPs to the OTP-server. In response, the OTP-server sent back two OTPs (one for the client and one for the server). It should be noticed these OTPs could further be encrypted in order to strengthen the security of the proposed scheme. Next, both the client and the

70

server calculated the hash of their OTPs and sent these values to each other over a Wifi channel. Then, both devices checked if the hash of each other OTPs matched with the received hashed-OTP; if that was the case, mutual authentication had occurred; otherwise, it had failed. Results: For the proof of concept purpose, all the information have been recorded in log files. The experimental results are shown in Fig. 4.7. On the left-down of Fig. 4.7, the OTP-servers logs showed which OTPs have been generated

Figure 4.7: OTP based mutual authentication using infrared channel.

and which device requested the OTPs. The OTP-server sent the OTPs (OTP1, OTP2) to both devices, but in the opposite order. On the right-hand side of Fig. 4.7, the servers Syslog 71

file is shown, where the PAM module aws logging. The results were displayed by running the tail command on the Syslog file (/var/log/syslog). This shows which device requested for authentication; once it asked for the OTP-server to provide OTPs, it had wait until both OTPs were received. It is observed that both OTPs are received over the infrared channel. It then sends the hash of OTP1 to the client over a Wifi connection and waits for the hashed OTP2. On receiving the hashed OTP2, it validates it, which is shown since it is observed that the authentication has succeeded. On left-top of Fig. 4.7, the client logs are shown, where LOGIN.py was the script used for authentication purpose. First, the public-key authentication occurred, then the OTPs (OTP2, OTP1) were received by the devices. From the server side, it received the OTP1 hash, which was validated and the hash of OTP2 was sent back. During this experiment, we had encountered an issue in the infrared emission, i.e. the LED transmission could be detected in a wide range. To fix this problem, a narrow pipe was created and foiled, which was used to the infrared light on the infrared LED and the back side of the pipe was immediately closed after installation. In conducting the above experiments, two python programs have been developed, namely OTP SERVER.py and servo controller.py to generate the OTP and send it over the infrared channel.

4.2

Security and Performance Analysis of the PPIDAIC and PPDA-PKI Schemes

The AVISPA tool [25] is also used to verify if the proposed PPIDA-IC and PPDA-PKI protocols satisfy the aforementioned three security related properties, namely mutual authentication; integrity and secrecy. The simulation results of our proposed scheme are also attributed to the OFMC and CL-AtSe back-end modules of the AVISPA tool [25] as the other two back-end modules: SATMC and TA4SP [25] have reported NOT SUPPORTED 72

and have produced INCONCLUSIVE results.

4.2.1

Simulation Results of the PPIDA-IC Scheme Using AVISPA

Results for the PPIDA-IC scheme are shown in Fig. 4.8 and Fig. 4.9. In Fig. 4.8 and Fig. 4.9, it is detected that no authentication attack has occurred on the

Figure 4.8: PPIDA-IC protocol verification with the OFMC backend.

PPIDA-IC protocol, nor secrecy attack. Also, no attack is found on the session key by the intruder and the secrecy of the transferred message between devices. In addition, the session key is maintained. In the proposed PPIDA-IC scheme, we have exchanged the session keys 73

Figure 4.9: PPIDA-IC protocol verification with the CL-AtSe backend.

using the DH key exchange algorithm [51] and this was checked for secrecy purpose by the AVISPA tool [25], which validated it. We have also check for the secrecy of both OTP1 and OTP2, which this was validated by the AVISPA tool [25] as well. Finally, our goals of keeping the OTP1 and OTP2 secret, ensuring the secrecy of the session key, and achieving mutual authentication between the client and the server, have also been validated by the AVISPA tool [25] since the protocol is reported as safe.

74

4.2.2

Simulation Results of the PPIDA-PKI Scheme Using AVISPA

Similarly, for the PPIDA-PKI scheme, the SPAN tool [25] also gives a better understanding of the protocol and it is used to confirm whether the specification is executable or not. The results for the PPIDA-PKI scheme using AVISPA [25] are shown in Fig. 4.10 and Fig. 4.11. Fig. 4.10 and Fig. 4.11 exhibit the same type of behavior observed in the case of the

Figure 4.10: PPIDA-PKI protocol verification with the OFMC backend.

PPIDA-IC scheme (Fig. 4.8 and Fig. 4.9), and the AVISPA tool [25] alos reported the PPIDA-PKI protocol as safe.

75

Figure 4.11: PPIDA-PKI protocol verification with the CL-AtSe backend.

4.2.3

Informal Security Analysis of the PPIDA-IC and PPIDAPKI Schemes

In this section, we discuss about some attacks and how our proposed PPIDA-IC and PPIDAPKI schemes can be used to protect against them. Man-In-Middle attack (MIMA): In this attack, the attacker can modify/delete/generate messages, delete messages. In our proposed schemes, pre-shared public keys are used and all communication is in encrypted form, except for the infrared (IR)-based password transmission. However, the IR channel is considered secure and no new keys are accepted, i.e. the

76

attacker has no way to succeed. Dictionary attack: This kind of attack is applied to retrieve the passwords from a hashed file. In our schemes, the passwords are encrypted and a salt is used to make it even more stronger. The encryption key is protected by the private key, which in turn is protected by SELinux [11]. Thus, our scheme is secure against the dictionary attack. Eavesdropping attack: In this attack, the eavesdropper silently listens to the communication of others without their knowledge. He may gain some sensitive information if not protected. In our schemes, the DH key exchange algorithm [27] is used to construct the session keys, and the identity of the messages is signed using the private keys, which only the owner has access to. In addition, the OTPs password is sent over a light communication and an eavesdropper cannot get access to these entities after a successful authentication since all the communication entities use the session key to encrypt the data and the eavesdropper cannot make anything out of it. The session keys are generated for each session in order to maintain a high security. Masquerading/Impersonation attack: In this kind of attack, the intruder presents himself as a genuine entity to gain unauthorized access. Our scheme makes use of digital signature to validate the messages in the first phase, where the session keys are exchanged. The keys are protected with a passphrase; even if the keys are stolen, the attacker cannot use them directly. In addition, the second level authentication requires the use of OTPs, which are sent only to the device in its physical location. Therefore, impersonation attack cannot succeed. Replay attack: In this kind of attack, the intruder first captures the data packets which can be used later on to gain access to the system. In our schemes, the current timestamp is used, which is included in the digital signature assuming that the system is sync on time. In addition, the OTPs are used, which are randomly generated for each session. Message modification attack: In this type of attack, the intruder tries to tamper the message. Our scheme uses a PKI in its first phase to check whether the message is tampered or not using a hash. In its second phase, the hashed OTPs are sent by encrypting them

77

with the session keys. If the message is tampered at any phase, the authentication will fail. Therefore, our schemes can be used to protect against message modification.

4.3

Informal Security Analysis of the RSA-ASH-SC Scheme

In this subsection, we informally analyze the security of our proposed RSA-ASH-SC scheme to show that it can protect against few attacks. Forgery attack: In this scheme, the anonymity is ensured by the use of one-time tokens. The attacker cannot get any information from the one-time token and encrypted message. The encryption and decryption operations are performed by using Rebalanced-Multi-Power RSA variant [22]. The login message makes use of a password, a unique ID which is associated with a user and a timestamp. For attacker, there is no way to gain this information as the communication is encrypted. Replay attack: In this scheme, a timestamp is utilized to calculate x = (h((h(P Wi )  IDi ))e  h(T ))mod N ,which is used to construct the login message, which in turn will be different each time. Therefore, the adversary cannot launch a replay attack. Man-in-the-Middle attack (MIMA): In this scheme, since our messages are encrypted and only OT Ti is given in plaintext which is only for one time use. The attacker cannot perform this type of attack, unless he knows P Wi , IDi and OT Ti in advance. Password-Guessing attack: In this scheme, to guess the password, the adversary needs to decrypt the login message, which is infeasible it is protected by the private key. The other way that the adversary could try is to compromise the server and get its password database; but this is not an easy task since the database itself is protected by the private key, thus, this type of attack cannot be launched by an attacker. Smart-card loss attack: In case, the smart-card is lost or stolen, the adversary can try to get 78

IDi andOT Ti from the smart-card using invasive attacks [48], which is difficult. However, the adversary cannot get the password information. Therefore, he cannot compromise the security. Denial of Service (DoS) attack: The server only requires to check OT Ti to decide if a valid user is trying to authenticate. If OT Ti is not valid, the server can discard the login request without processing the encrypted message, which in turn requires very less computation compared to if it has to perform the hash of symmetric/asymmetric decryption. Even if the attacker makes use of a valid OT Ti by eavesdropping, the server will be able to identify the particular OT Ti used for DoS attack and report the incident to the administrator. The administrator can then set firewall rules to drop the login requests which make use of that OT Ti ; this operation may temporarily disable the user associated with OT Ti , but the administrator can ask the user to manually update OT Ti over the secure channel.

4.4

Comparison of Selected RSA Variants w.r.t. Security Attacks and Selected Security Metrics

to

In this subsection, we qualitatively compare the proposed RSA-ASH-SC scheme against selected RSA-based variants in terms of selected security attacks. Our findings are captured in Table 4.4.

4.5

Comparison of Selected RSA Variants w.r.t Computational Performance

In this subsection, we compare the proposed RSA-ASH-SC scheme against the same selected RSA-based variants (listed in Table 4.4) in terms of computational performance. Our findings 79

Table 4.4: Comparison of selected RSA variants w.r.t. to security attacks and selected security metrics Yang Fan Yang Om Om et al. et al. et al. et al. et al. [39] [42] [43] [22] [10] Confidentiality Availability Integrity Mutual authentication MIMA Smart card loss attack Passwordguessing attack Replay attack Forgery or Impersonation attack DoS attack Forward Secrecy Shen et al. [44] Liu Chien et al. et al. [45] [46] Proposed RSA

are captured in Table 4.5, where: · Texp is the time taken by modular exponent operation. · Tmul is the time taken by the modular multiplication operation. · Th is the time taken by hash function operation. · Txor is the time taken by the XOR operation. · Te is the time taken by the modular encryption exponent (e) operation. · Td is the time taken by the modular decryption exponent (d) operation · Ts is the time taken to encrypt and decrypt using the symmetric key.

80

Based on Table 4.5, it is found that Chien et al. [46] scheme yields the less computation time compared to other schemes.

Table 4.5: Comparison of selected RSA variants w.r.t. to computation performance Login Phase Yang et al. [39] 2Texp + 3Tmul + 1Th Fan et al. [42] 2Texp + 3Tmul + 1Th Yang et al. [43] 2Texp + 3Tmul Om et al. [22] 1Te + 1Texp + 1Th + 1Txor Om et al. [10] 1Te + 1Texp + 2Th + 1Txor Shen et al. [44] 1Te + 2Texp + 3Tmul + 2Th Liu et al. [45] 1Td + 1Te + 1Texp + 1Tmul + 2Th + 2Txor Chien et al. [46] 2Th + 2Txor Proposed RSA-ASH- 2Te + 1Ts + 6Th + 2Txor SC scheme Authentication Phase 1Te + 1Texp + 1Tmul + 1Th 1Te + 1Texp + 1Tmul + 1Th 1Te + 2Texp + 1Tmul 1Td 1Td + 1Texp + 1Th + 1Txor 1Td + 2Th + 1Txor 1Te + 2Th + 1Txor + 3Tmul + 2Texp 3Th + 3Txor 1Td +1Te +2Th +2Txor +1Ts

4.6

Convergence Speed of the Proposed RSA-ASH-SC Scheme

Our proposed RSA-ASH-SC scheme is a RSA-based protocol. As such, it performance in terms of speed of convergence is heavily dependent on that of the considered RSA underlying algorithm. In this subsection, inspired from a study carried in [67], the impact of the performance of the RSA underlying algorithm (including selected RSA variants' performance) on the performance of the proposed RSA-ASH-SC scheme is quantified in terms of speed of convergence. According to the Crypto++ benchmark [67], the RSA decryption is much slower in performance than the RSA encryption. Indeed, it was reported [24] that with a key length of 2048, the RSA encryption takes only 0.03 milliseconds/operation to complete whereas the

81

decryption algorithm takes 1.03 milliseconds/operation, on the Fedora Operating system, Release 25 (x86 64), where the host CPU is a 6th generation Skylake, with a frequency 3.14e + 9 Hz. Because of this, in the sequel, when we refer to " decryption performance ", we mean "the performance of the RSA algorithm as a whole in terms of how fast it converges ". This convention prevails for all RSA variants referred to in this Subsection, which have been proposed in the literature and validated as improvements to the decryption performance of the RSA algorithm [59], i.e. to speed up the decryption process, namely the Batch RSA scheme [68], the Multi-Prime RSA scheme [71], the Multi-Power RSA scheme [72], Rebalanced RSA scheme [73], the RPrime RSA scheme [49], and a combination of Rebalanced RSA and Multi-Power RSA scheme (here referred to as Rebalanced-Multi-Power RSA scheme [9]). According to a performance study of these RSA variants using a 1024 bits key size [69], and that considering the cost of single modular exponentiation, the Batch RSA scheme [68] can compute several modular exponentiations effectively. Indeed, it was reported that a batch size of 4 (resp. 8) increases the decryption performance of RSA by a factor of 2.6 (resp. 3.5). For the Multi-Prime RSA scheme [71], which generates k distinct prime numbers (using the same key size of 1024), it was reported that k should be less or equal to 3 and the decryption process requires k full exponentiations modulo n/k bit numbers to complete. In contrast, running the standard RSA in conjunction with the Chinese Remainder Theorem [59], it was reported [69] that to calculate xd mod p , it takes O(logd.log 2 p), and if d is at the same scale of p, the decryption performance of Multi-Prime RSA scheme [71] is (2.(n/2)3 )/k.(n/k )3 = k 2 /4 better than that of the standard RSA [59]. For the Multi-Power RSA scheme [72], where the moduli is formed as N = pk-1 .q where p and q are two distinct primes of n/k bits each, it was reported [69] that 2 full exponentiations modulo n/b bits are required for the completion of the decryption [69], yielding a decryption performance of (2.(n/2)3 )/2.(n/k )3 = k 3 /8 better than that of the standard RSA [59]. For the Rebalanced RSA scheme [73], which creates 2 prime numbers of n/2 bits size

82

each and an input parameter s  n/2 is used to generate the decryption key, it was reported [69] that the decryption performance is (n/2)/s = n/2s better than that of the standard RSA [59]. For the RPrime scheme [49], which was designed as a combination of the Rebalanced RSA scheme [73] and the Multi-Prime RSA scheme [71], which also generates k distinct prime numbers (using a key size of 1024) as in Multi-Prime RSA scheme [71], it was reported [69] the decryption performance is (k 2 /4).(n/k.s) = n.k/4.s better than that of the standard RSA [59]. For the Rebalanced-Multi-Power RSA scheme [9], which was designed as a combination of the Rebalanced RSA [73] and Multi-Power RSA scheme [72], it was reported [69] the decryption performance is (k 3 /8).(n/k.s) = n.k 2 /8.s better than that of the standard RSA [59]. Table 4.6 highlights the performance comparison of the above RSA variants [ [69] in terms of convergence speed]. It can be observed an increase in k (the number of prime factors used in the RSA algorithm) also yields an increase in the decryption performance of the above discussed RSA variants. In order to estimate the performance of our proposed RSA-ASH-SC Table 4.6: Decryption performance of selected RSA variants [69] RSA variant Standard RSA [59] Batch RSA [68] Multi-Prime RSA [71] Multi-Power RSA [72] Rebalanced RSA [73] RPrime RSA [49] Rebalanced-Multi-Power RSA [9](used in our RSA-ASH-SC scheme) Decryption performance x 2.6x(if batch size = 4); 3.5x(if batch size = 8) (k 2 /4).x (k 3 /8).x (n/2.s).x (n.k/4.s).x (n.k 2 /8.s).x

scheme in terms of convergence speed, we have considered the Rebalanced-Multi-Power RSA scheme [9] as underlying RSA algorithm, using a key length of 1024 bits (as above), but also a key length of 2048 bits (as per the NIST recommendation [70]). Using the results shown in 83

Table 4.6, the comparison of the RSA variants in term of decryption performance when k=3 are captured in Fig. 4.12. In Fig. 4.12, it can be observed that independently of the RSA key length, our proposed scheme is about 100% faster than the Om and Kumari scheme [10]. For a RSA key length of 2048 bits with k=3, our proposed scheme is about 14.4% faster than any of the other considered RSA variants. For a RSA key length of 1024 bits with k=3, our proposed scheme is about 7.2% more faster than the Om and Kumari scheme [10], which itself is 9.6 time faster than the standard RSA for a key length 2048 (resp. 4.8 times faster for a RSA key length 1028) [9]. Finally, it is observed that independently of the key length, our proposed scheme outperforms the other considered schemes when k=3. Hence, we conclude that our proposed scheme yields a better decryption performance compared to the other considered schemes.

84

Figure 4.12: Convergence speed of selected RSA variants for key length 1024 bits vs. 2048 bits when k=3.

85

Chapter 5 Conclusion
5.1 Contributions of the Thesis

In this thesis, we have proposed the design of four authentication schemes for smart home networks: · A two-factor device-to-device (D2D) Mutual Authentication Scheme for Smart Homes using OTP over Infrared Channel (so-called D2DA-OTP-IC scheme) and of proof-ofconcept of this scheme iin the form of a hardware solution. · Two enhanced versions (proxy-password of the D2DA-OTP-IC scheme (the so-called Password Protected Inter-device OTP-based Authentication scheme over Infrared Channel (PPIDA-IC) and Password Protected Inter-device OTP-based Authentication scheme using public key infrastructure (PPIDA-PKI scheme). · A RSA-based two-factor user Authentication scheme for Smart Home using Smart Card (so-called RSA-ASH-SC scheme). The proposed D2DA-OTP-IC, PPIDA-IC and PPIDA-PKI schemes have been modelled using HLPSL and these models have been validated using the SPAN/AVISPA tool. These protocols have also been verified using the SPAN/AVISPA tool for their efficiency in terms of achieving the goals of secrecy of secret keys and D2D mutual authentication. An informal 86

security analysis of the proposed RSA-ASH-SC scheme has also been conducted; as well as its performance with respect to the convergence speed. For this performance study, we have considered the Rebalanced-Multi-Power RSA scheme [9] as underlying RSA algorithm of our RSA-ASH-SC scheme, using respectively a key length of 1024 bits and 2048 bits, the results have revealed that: (1) Using a key length of 1028 (resp. 2048) with k=3, where k is the number of prime factors used in the RSA scheme, our proposed RSA-ASH-SC scheme is about 50% faster than the Om and Kumari scheme [10]; (2) Using a key length of 2048 bits with k=3, our proposed RSA-ASH-SC scheme is about 15% faster than any of the other considered RSA variants; (3) Using a key length of 1024 bits with k=3, our proposed RSAASH-SC scheme is about 7.2% faster than the Om and Kumari scheme [10]. Next, we have also compare selected RSA variants with respect to few security attacks and selected security metrics. Except for the Forward Secrecy attack, which our RSA-ASHSC scheme may not prevent, all other considered attacks could be prevented based on the design features.

5.2
5.2.1

Future Work
With respect to the proposed D2DA-OTP- IC protocol

a) Adopt light communication for smart homes: Light communication has specific properties which are undetectable for human eyes and cannot cross the obstacles. In the D2DA-OTP-IC scheme [7], the OTPS are shared over the infrared channel with the home devices, which is more secured than radio channels (e.g. Wi-Fi). However, the DH key exchange and normal communication is over a radio channel. The vulnerabilities in the software may lead to security compromise. Therefore, smart home communication should be completely based on light communication, so that there is no room for attacks from outside the home. Examples of light communication which 87

can be used include Visible light communication (VLC) [15], Dark light communication (DLC) [16] and Infrared light communication (ILC) [7]. These variations of light communication have different properties, which needs more exploration for the smart home applications. The problem with VLC is that all the time the light should be in ON state, which may be irritating for the inhabitants [15]. Similarly, DLC is not suitable when inhabitants need light in their homes [16]. Mulvey et al. [74] have discussed the potential hazards of over exposure to infrared light. Therefore, each of these communication mediums has its own weaknesses and strengths, and more research is required to be able to switch completely from radio-based communication to light-based communication.

b) Supporting dynamic movements of home devices:

In the proposed D2DA-OTP-IC

scheme [7], in the registration phase, the OTP-server saves the location of the home device and this location is fixed. However, some devices may need movement within a home, therefore, the OTP-server should support dynamic movement of these kind of devices. As of now, no such support is provided. To support dynamic movements of a device, this device should be able to localize itself and communicate its coordinates to the OTP-server. Another possible solution is that the OTP-server should be able to find the devices in the home by tracking. The localization issue in smart home needs to addressed. c) Protecting the private key within the device: In the proposed D2DA-OTP-IC scheme [7], the DH key exchange is supported by PKI and the private keys are not protected within the system. According to FIPS 4.7.5 standard [8], the secret information such as secret key and private keys needs protection. Protecting the private key and secret key in D2D communication is a challenge, as someone/something should protect the password, if the secret/private key is encrypted by a password and it this password is saved within the device, it does not solve the purpose since the password is the 88

sensitive information and according to FIPS 4.7.5 standard [8], it shouldnt be saved in the plaintext format. In our literature review, we could not find any solution to protect the keys with password. A novel solution is required where human intervention is not required. By protecting the private and secret keys, the FIPS 4.7.5 standard requirement of not storing the sensitive information can be achieved.

5.2.2

With respect to the proposed PPIDA-IC and PPIDA-PKI protocols

d) Reducing the number of keys: In the proposed password-proxy schemes (PPIDA-IC and PPIDA-PKI), the number of keys used increases as more and more devices are registered to the system. Management of these keys becomes a cumbersome process and subject to human error. Registering a new device and updating the keys is very time- consuming process. It would be helpful if the number of keys are reduced. A centralized solution is vital, for instance, using a certificate authority-based or a Kerberos-based protocol for key management. e) Automatic registration: In the proposed PPIDA-IC and PPIDA-PKI schemes, the

registration is manual and consumes some time as someone needs to configure the keys in the device and update the OTP-server manually. If the inhabitants do not have the security knowledge, they would need technical assistance, which may have some associated cost. Therefore, the automation of the registration process will save time and money to the inhabitants. Automatic registration process (compromising the security is the system) would ease the adoption of the proposed schemes. f) Supporting the dynamic movements of home devices: The proposed PPIDA-IC and PPIDA-PKI schemes does not support the movement of home devices within the smart home. As discussed earlier, dynamic movements are desirable in smart home environment. This requires that a suitable localization solution be developed in the context

89

of smart home. g) Completely light-based communication in smart homes: In the proposed PPIDA-IC and PPIDA-PKI schemes, the OTPs are sent over the infrared channel. Thus, these schemes should implement the light-based communication. PureLiFi [15] is one of the leading company, which is implementing the VLC-based solutions, but as discussed earlier, this technology is still in its infancy.

5.2.3

With respect to the proposed RSA-ASH-SC scheme protocol

h) Private Key for each smart card: In the proposed RSA-ASH-SC scheme, the authentication is based on password and smart card. The smart card only stores some secret information and public key of the server. In this scheme, the session keys are created by a client, and then encrypted and sent to the server over a network. If the RSA keys are compromised, the scheme will become vulnerable to forwards secrecy attack. To protect against this attack, the session keys should be exchanged in a secure manner, for instance, using the DH key exchange protocol [51]. In this way, even if the attacker records the packets and get access to the RSA keys, he cannot compromise the security of the past communication. To achieve the DH key exchange, the smart card also need its private key and the server should be able to recognize this key, thus, involving a certificate authority in this scenario might be useful. i) Biometric support: It is well-known that passwords can be compromised by various hacking techniques such as shoulder surfing, social engineering, key loggers, certificate frauds, etc. Therefore, biometric might be a good alternative for authentication. Moreover, some users prefer biometric-based authentication. The proposed RSA-ASH-SC approach can be re-designed to rely on biometric rather than smart card. It can also be adjusted to rely on the three factors: smart card, password, and biometric. The tight

90

coupling of these three factors will add more security layers; yielding a much stronger authentication mechanism for smart home networks.

91

Appendix A HLPSL code for D2DA-OTP- IC
(Only the roles of each entity in the model and the knowledge given to the intruder are shown)

The client (D1) implementation in HLPSL: Here role role A is created for device D1.

// ============ HLPSL code f o r D2DA -OTP - IC Scheme=============== // r o l e r o l e A (A: agent , B : agent , KPa : p u b l i c k e y , KPb : p u b l i c k e y , G: t e x t , P: text , SND,RCV: c h a n n e l ( dy ) ) played by A d e f= local S t a t e : nat , Na : t e x t ,

92

Timestamp : t e x t , Timestamp2 : t e x t , Mod : f u n c t i o n , Nb : t e x t , OTP2 : t e x t , OTP1 : t e x t , Hash : f u n c t i o n , AA,BB: message , Key : message const mod : function ,

client server aa : protocol id , server client bb : protocol id init S t a t e := 0 transition 1 . S t a t e=0 / \ RCV( s t a r t ) =|> S t a t e ' : = 1 / \ Na' : = new ( ) / \ Timestamp ' : = new ( ) / \ AA' := mod( exp (G, Na ' ) , P) / \ SND(A. { A. Timestamp ' . AA' } i n v (KPa ) )

2 . S t a t e=1 / \ RCV(B. { B . Timestamp . BB' } i n v (KPb) ) =|> S t a t e ' : = 2 / \ Key ' := mod( exp (BB' , Na ' ) , P) / \ s e c r e t ( Key ' , s e c r e t k e y , {A, B } ) 5 . S t a t e=2 / \ RCV( { Timestamp2 ' . OTP2 ' . OTP1' } KPa ) =|> S t a t e ' : = 3 / \ SND( { Hash (OTP2' ) } Key ) 7 . S t a t e=3 / \ RCV( { Hash (OTP1' ) } Key ) =|> State ':=4

93

/ \ w i t n e s s (A, B, s e r v e r c l i e n t b b , { B . Timestamp ' . BB' } i n v (KPb) . Hash (OTP1' ) ) / \ r e q u e s t (A, B, c l i e n t s e r v e r a a , { A. Timestamp ' . AA' } i n v (KPa) . Hash (OTP2' ) ) end r o l e Device D 2 s r o l e i n HLPSL :

r o l e r o l e B (A: agent , B : agent , KPa : p u b l i c k e y , KPb : p u b l i c k e y , G: t e x t , P: text , SND,RCV: c h a n n e l ( dy ) ) played by B d e f= local S t a t e : nat , Na : t e x t , Mod : f u n c t i o n , Nb : t e x t , Timestamp : t e x t , Timestamp2 : t e x t , Req : t e x t , OTP2 : t e x t , OTP1 : t e x t , Hash : f u n c t i o n , AA,BB: message , Key : message const

94

mod :

function ,

client server aa : protocol id , server client bb : protocol id init S t a t e := 0 transition 1 . S t a t e=0 / \ RCV(A. { A. Timestamp ' . AA' } i n v (KPa ) ) =|> S t a t e ' : = 1 / \ Nb' : = new ( ) / \ BB' := mod( exp (G, Nb ' ) , P) / \ SND(B. { B . Timestamp ' . BB' } i n v (KPb) ) / \ Key ' := mod( exp (AA' , Nb ' ) , P) / \ s e c r e t ( Key ' , s e c r e t k e y , {A, B } ) / \ Req ' : = new ( ) / \ SND(B. { A. B . Timestamp ' . Req ' } i n v (KPb) )

4 . S t a t e=1 / \ RCV( { Timestamp2 ' . OTP1 ' . OTP2' } KPb ) =|> State ':=2 6 . S t a t e=2 / \ RCV( { Hash (OTP2) } Key ' ) =|> S t a t e ' : = 3 / \ SND( { Hash (OTP1) } Key ' ) / \ w i t n e s s (B, A, c l i e n t s e r v e r a a , { A. Timestamp ' . AA' } i n v (KPa) . Hash (OTP2' ) ) / \ r e q u e s t (B, A, s e r v e r c l i e n t b b , { B . Timestamp ' . BB' } i n v (KPb) . Hash (OTP1' ) ) end r o l e

OTP - s e r v e r r o l e i n HLPSL : r o l e r o l e O (O: agent , A: agent , B : agent ,

95

KPa : p u b l i c k e y , KPb : p u b l i c k e y , KPo : p u b l i c k e y , OTP1 : t e x t , OTP2 : t e x t , SND,RCV: c h a n n e l ( dy ) ) played by O d e f= local S t a t e : nat , Timestamp : t e x t , Req : t e x t init S t a t e := 0 transition 3 . S t a t e=0 / \ RCV(B. { A. B . Timestamp ' . Req ' } i n v (KPb) ) =|> S t a t e ' : = 1 / \ Timestamp ' := new ( ) / \ SND( { Timestamp ' . OTP1 . OTP2} KPb ) / \ SND( { Timestamp ' . OTP2 . OTP1} KPa ) / \ s e c r e t (OTP1, s e r v e r o t p 1 , {A, B,O} ) / \ s e c r e t (OTP2, s e r v e r o t p 2 , {A, B,O} ) end r o l e

In HLPSL, t h e f o l l o w i n g knowledge was g i v e n t o t h e i n t r u d e r . i n t r u d e r k n o w l e d g e = { p , g , o t p s e r v e r , c l i e n t , s e r v e r , ka , kb , ki , i n v ( k i ) }

Goal s e t t i n g f o r t h e p r o t o c o l : goal secrecy of server otp1

96

secrecy of server otp2 secrecy of secret key authentication on client server key authentication on server client key end g o a l

OTP s e r v e r a c t i o n s

from s o c k e t import SOCK STREAM, AF INET import s o c k e t import random import o s import time REGISTERED LOCATION MAP = { " 1 0 . 4 2 . 0 . 4 5 " : [ " 1 8 0 " , " 7 5 " ] , "10.42.0.87":["90" ,"100"] } d e f de cry p t m s g ( enc msg ) : try : with open ( " msg . enc " , "w" ) a s f d : f d . w r i t e ( enc msg ) o s . system ( " / u s r / b i n / o p e n s s l r s a u t l - i n msg . enc -out msg . dec - i n k e y /home/ p i / . s s h / key . pem - d e c r y p t " ) with open ( " msg . dec " , " r " ) a s f d : return fd . read ( ) except : return False

return False

97

d e f generate OTP ( ) : OTP = "" f o r i in range ( 8 ) : OTP += s t r ( random . r a n d i n t ( 0 , 9 ) ) p r i n t "OTP" ,OTP r e t u r n OTP

d e f p o i n t s y s t e m ( system ) : o s . system ( " sudo python s e r v o c o n t r o l l e r . py " +REGISTERED LOCATION MAP [ system ] [ 0 ] + " " + REGISTERED LOCATION MAP [ system ] [ 1 ] )

d e f f i n d s y s t e m a n d s e n d O T P ( system , OTP1, OTP2 ) : i f not system i n REGISTERED LOCATION MAP : p r i n t system , " i s not r e g i s t e r e d ! " time . s l e e p ( 1 ) p o i n t s y s t e m ( system ) time . s l e e p ( 1 ) send OTP (OTP1) send OTP (OTP2) time . s l e e p ( 3 )

d e f send OTP (OTP) : key map = { " 0 " : " KEY 0" , " 1 " : " KEY 1" , " 2 " : " KEY 2" , " 3 " : " KEY 3" , " 4 " : " KEY 4" , " 5 " : " KEY 5" ,

98

" 6 " : " KEY 6" , " 7 " : " KEY 7" , " 8 " : " KEY 8" , " 9 " : " KEY 9" } f o r i i n OTP: i f i not i n key map : print "OTP s h o u l d have o n l y numeric k e y s "

return False o s . system ( " i r s e n d s e n d o n c e HP RC2234302 /01B KEY GREEN" ) f o r i i n OTP: o s . system ( " i r s e n d s e n d o n c e HP RC2234302 /01B "+key map [ i ] ) time . s l e e p ( . 1 ) o s . system ( " i r s e n d s e n d o n c e HP RC2234302 /01B KEY RED" ) r e t u r n True d e f p r o c e s s m s g ( msg , c l i e n t ) : #p r i n t " Message r e c e i v e d : " , msg i f msg . s t a r t s w i t h ( "OTP AUTH REQUEST" ) : msg = msg . s p l i t ( ) i f l e n ( msg ) != 2 : p r i n t "Wrong OTP AUTH REQUEST format ! " return False OTP1 = generate OTP ( ) OTP2 = generate OTP ( ) f i n d s y s t e m a n d s e n d O T P ( c l i e n t , OTP1, OTP2) f i n d s y s t e m a n d s e n d O T P ( msg [ 1 ] , OTP2, OTP1) r e t u r n True else : p r i n t "Don ' t know what t o do ! "

99

s=s o c k e t . s o c k e t (AF INET , SOCK STREAM) s . bind ( ( ' 1 0 . 4 2 . 0 . 1 1 ' , 5 4 5 4 5 ) ) s . l i s t e n (1) try : w h i l e True : print " listening " connection , c l i e n t a d d r e s s = s . accept () p r i n t "#"  50 p r i n t "Remote Host : " , c l i e n t a d d r e s s [ 0 ] rec = connection . recv (1024) p r o c e s s m s g ( d e c r y p t ms g ( r e c ) , c l i e n t a d d r e s s [ 0 ] ) p r i n t "#"  50 except : p r i n t " Exception " s . close ()

Login program

import sys , s y s l o g , o s from p e x p e c t import pxssh import p e x p e c t import time import random import h a s h l i b from s o c k e t import AF INET ,SOCK STREAM, SOL SOCKET,SO REUSEADDR,SO BROADCAST import s o c k e t

GATEWAY ADDR = ' 1 0 . 4 2 . 0 . 1 1 '

100

PORT = 54545 d e f e n c r y p t w i t h p u b l i c k e y ( msg ) : try : with open ( " msg . msg " , "w" ) a s f d : f d . w r i t e ( msg ) o s . system ( " / u s r / b i n / o p e n s s l r s a u t l - i n msg . msg -out msg . enc -pubin - i n k e y ~ / . s s h / key . pub - e n c r y p t " ) with open ( " msg . enc " , " r " ) a s f d : return fd . read ( ) except : return False

return False d e f s e n d m s g t o g a t e w a y ( msg ) : try : s o c = s o c k e t . s o c k e t (AF INET , SOCK STREAM) s o c . c o n n e c t ( (GATEWAY ADDR, PORT) ) msg enc = e n c r y p t w i t h p u b l i c k e y ( msg ) s o c . send ( msg enc ) except : return False r e t u r n True

d e f run cmd ( c l i e n t ) : cmd = r a w i n p u t ( " " ) c l i e n t . s e n d l i n e (cmd) c l i e n t . prompt ( ) output = c l i e n t . b e f o r e [ l e n (cmd ) : - 1 ] p r i n t ( output . r s t r i p ( ) )

101

''' d e f generate OTP ( ) : OTP = "" f o r i in range ( 8 ) : OTP += s t r ( random . r a n d i n t ( 0 , 9 ) ) r e t u r n OTP ''' def read receiver OTPs ( ) : p r i n t " r e a d i n g OTP" key map = { "KEY 0 " : " 0 " , "KEY 1 " : " 1 " , "KEY 2 " : " 2 " , "KEY 3 " : " 3 " , "KEY 4 " : " 4 " , "KEY 5 " : " 5 " , "KEY 6 " : " 6 " , "KEY 7 " : " 7 " , "KEY 8 " : " 8 " , "KEY 9 " : " 9 " } f i l e o t p = "/tmp/ c o d e s . data " f o r i in range ( 6 0 ) : time . s l e e p ( 1 ) p r i n t " t r y i n g :"+ s t r ( i ) sys . stdout . f l u s h () try : with open ( f i l e o t p ) a s f d :

data = f d . r e a d l i n e s ( )

102

i f l e n ( data ) < 1 0 : continue else : data = [ l i n . s p l i t ( ) [ 3 ] f o r l i n i n data ] i f data [ 0 ] == "KEY GREEN" and data [ 1 1 ] == "KEY GREEN" : pass else : print "Wrong s t a r t i n g s i g n a l ! "

o s . system ( " sudo p k i l l - f i r w " ) o s . system ( "rm /tmp/ c o d e s . data " ) return False i f data [ 1 0 ] == "KEY RED" and data [ 1 9 ] == "KEY RED" : pass else : print "Wrong e n d i n g s i g n a l ! "

o s . system ( " sudo p k i l l - f i r w " ) o s . system ( "rm /tmp/ c o d e s . data " ) return False OTP1 = "" f o r i in range ( 1 , 9 ) : i f data [ i ] i n key map : OTP1 += key map [ data [ i ] ] else : print "OTP s h o u l d have o n l y numeric k e y s ! "

o s . system ( " sudo p k i l l - f i r w " ) o s . system ( "rm /tmp/ c o d e s . data " ) return False OTP2 = "" f o r i in range ( 1 1 , 1 9 ) :

103

i f data [ i ] i n key map : OTP2 += key map [ data [ i ] ] else : print "OTP s h o u l d have o n l y numeric k e y s ! "

o s . system ( " sudo p k i l l - f i r w " ) o s . system ( "rm /tmp/ c o d e s . data " ) return False o s . system ( " sudo p k i l l - f i r w " ) o s . system ( "rm /tmp/ c o d e s . data " ) r e t u r n [ OTP1, OTP2 ] except : print " e r r o r occured while reading ! " o s . system ( " sudo p k i l l - f i r w " ) o s . system ( "rm /tmp/ c o d e s . data " ) return False

''' d e f send OTP (OTP) : key map = { " 0 " : " KEY 0" , " 1 " : " KEY 1" , " 2 " : " KEY 2" , " 3 " : " KEY 3" , " 4 " : " KEY 4" , " 5 " : " KEY 5" , " 6 " : " KEY 6" , " 7 " : " KEY 7" , " 8 " : " KEY 8" , " 9 " : " KEY 9" } f o r i i n OTP:

104

i f i not i n key map : p r i n t "OTP s h o u l d have o n l y numeric k e y s " return False o s . system ( " i r s e n d s e n d o n c e HP RC2234302 /01B KEY GREEN" ) f o r i i n OTP: o s . system ( " i r s e n d s e n d o n c e HP RC2234302 /01B "+key map [ i ] ) time . s l e e p ( . 1 ) o s . system ( " i r s e n d s e n d o n c e HP RC2234302 /01B KEY RED" ) p r i n t "OTP s e n t " r e t u r n True ''' d e f main ( ) : #s t a r t IR r e c e i v e r o s . system ( "rm /tmp/ c o d e s . data " ) o s . system ( " i r w > /tmp/ c o d e s . data &") #send auth i n f o r m a t i o n t o gateway #s e n d m s g t o g a t e w a y ( "CONNECTING "+s y s . argv [ 3 ] ) #c o n n e c t u s i n g s s h s s h c l i e n t = pxssh . pxssh ( ) #p r i n t " C a l l i n g l o g i n " #s y s . s t d o u t . f l u s h ( ) s s h c l i e n t .PROMPT = "^ A u t h e n t i c a t e d \W" #p r i n t ( s y s . argv ) p r i n t s s h c l i e n t . l o g i n ( s y s . argv [ 3 ] , s y s . argv [ 1 ] , a u t o p r o m p t r e s e t=F a l s e , o r i g i n a l p r o m p t=p e x p e c t .EOF) print ( ssh client . before ) #p r i n t " Returned from l o g i n " #s y s . s t d o u t . f l u s h ( ) s s h c l i e n t .PROMPT = "^ R e c e i v e d \W[ \ : ] "

105

s s h c l i e n t . prompt ( ) print ( ssh client . before ) sys . stdout . f l u s h () #check OTPs received OTPs = r e a d r e c e i v e r O T P s ( ) i f received OTPs == F a l s e : p r i n t "Didn ' t r e c e i v e d t h e OTP from S e r v e r " sys . exit () p r i n t "OTP R e c e i v e d : " , received OTPs sys . stdout . f l u s h () st = ssh client . before . s p l i t () p r i n t "Hash r e c e i v e d =>", s t [ 1 ] sys . stdout . f l u s h () i f h a s h l i b . sha256 ( received OTPs [ 0 ] ) . h e x d i g e s t ( ) != s t [ 1 ] : p r i n t " R e c e i v e d Hash doen ' t match ! " sys . exit () #s s h c l i e n t .PROMPT = "^ P l e a s e e n t e r OTP' s hash \W[ \ : ] " #s s h c l i e n t . prompt ( ) s s h c l i e n t . s e n d l i n e ( h a s h l i b . sha256 ( received OTPs [ 1 ] ) . h e x d i g e s t ( ) ) s s h c l i e n t .PROMPT = " [ \ $ \ #]" s s h c l i e n t . prompt ( ) #time . s l e e p ( 5 ) #p r i n t ( s s h c l i e n t . b e f o r e ) w h i l e True : run cmd ( s s h c l i e n t ) if name == " main ":

i f l e n ( s y s . argv ) != 3 : p r i n t " Usage : OTP LOGIN . py <username > < r e m o t e s e r v e r >" sys . exit ()

106

try : main ( ) except : o s . system ( "rm /tmp/ c o d e s . data " ) // ==================================================== //

107

Appendix B HLPSL code for PPIDA-IC
(Only the roles of each entity in the model and the knowledge given to the intruder are shown)

// ============ HLPSL code f o r PPIDA-IC ==================== // D1 r o l e i n HLPSL : r o l e r o l e A (A: agent , B : agent , O: agent , KPa : p u b l i c k e y , KPb : p u b l i c k e y , KPo : p u b l i c k e y , G: t e x t , P: text , Token : t e x t , SND,RCV: c h a n n e l ( dy ) ) played by A d e f= local S t a t e : nat ,

108

Na : t e x t , Timestamp : t e x t , Timestamp2 : t e x t , Mod : f u n c t i o n , Nb : t e x t , OTP2 : t e x t , OTP1 : t e x t , Hash : f u n c t i o n , AA, BB,OO: message , Key : message , Password : t e x t , S e s s i o n k e y : message const mod : function ,

client server aa : protocol id , server client bb : protocol id init S t a t e := 0 transition 1 . S t a t e=0 / \ RCV( s t a r t ) =|> S t a t e ' : = 1 / \ Timestamp ' : = new ( ) / \ SND(A. { Token . Timestamp ' . Hash ( Token . Timestamp ' ) } KPo ) 2 . S t a t e=1 / \ RCV(O. { Timestamp ' . Password ' . Hash ( Timestamp ' . Password ' ) } i n v (KPo ) ) =|> S t a t e ' : = 2 / \ s e c r e t ( Password ' , s e c 1 , { A,O} ) % countinue old protocol / \ Na' : = new ( )

109

/ \ Timestamp ' : = new ( ) / \ AA' := mod( exp (G, Na ' ) , P) / \ SND(A. { A. Timestamp ' . AA' . G. P . Hash (AA' . G. P . Timestamp ' . A) } i n v (KPa ) )

2 . S t a t e=2 / \ RCV(B. { B . Timestamp . BB ' . Hash (BB ' . Timestamp ' . B) } i n v (KPb) ) =|> S t a t e ' : = 3 / \ Key ' := mod( exp (BB' , Na ' ) , P) / \ s e c r e t ( Key ' , s e c r e t k e y , {A, B } ) 5 . S t a t e=3 / \ RCV( { Timestamp2 ' . OTP2 ' . OTP1' } KPa ) =|> S t a t e ' : = 4 / \ Key ' := xor ( Key ' , Hash ( xor (OTP1' , OTP2' ) ) ) / \ SND( { Hash (OTP2' ) } Key ' ) 7 . S t a t e=4 / \ RCV( { Hash (OTP1' ) } Key ' ) =|> State ':=5 / \ w i t n e s s (A, B, s e r v e r c l i e n t b b , { B . Timestamp ' . BB' } i n v (KPb) . Hash (OTP1' ) ) / \ r e q u e s t (A, B, c l i e n t s e r v e r a a , { A. Timestamp ' . AA' } i n v (KPa) . Hash (OTP2' ) ) end r o l e D2 r o l e i n HLPSL : r o l e r o l e B (A: agent , B : agent , KPa : p u b l i c k e y , KPb : p u b l i c k e y , G: t e x t , P: text , SND,RCV: c h a n n e l ( dy ) ) played by B d e f=

110

local S t a t e : nat , Na : t e x t , Mod : f u n c t i o n , Nb : t e x t , Timestamp : t e x t , Timestamp2 : t e x t , Req : t e x t , OTP2 : t e x t , OTP1 : t e x t , Hash : f u n c t i o n , AA,BB: message , Key : message const mod : function ,

client server aa : protocol id , server client bb : protocol id init S t a t e := 0 transition 1 . S t a t e=0 / \ RCV(A. { A. Timestamp ' . AA' . G. P . Hash (AA' . G. P . Timestamp ' . A) } i n v (KPa ) ) =|> S t a t e ' : = 1 / \ Nb' : = new ( ) / \ BB' := mod( exp (G, Nb ' ) , P) / \ SND(B. { B . Timestamp ' . BB ' . Hash (BB ' . Timestamp ' . B) } i n v (KPb) ) / \ Key ' := mod( exp (AA' , Nb ' ) , P) / \ s e c r e t ( Key ' , s e c r e t k e y , {A, B } )

111

/ \ Req ' : = new ( ) / \ SND(B. { A. B . Timestamp ' . Req ' . Hash (A. B . Timestamp ' ) } i n v (KPb) )

4 . S t a t e=1 / \ RCV( { Timestamp2 ' . OTP1 ' . OTP2' } KPb ) =|> S t a t e ' : = 2 / \ Key ' := xor ( Key ' , Hash ( xor (OTP1' , OTP2' ) ) ) 6 . S t a t e=2 / \ RCV( { Hash (OTP2) } Key ' ) =|> S t a t e ' : = 3 / \ SND( { Hash (OTP1) } Key ' ) / \ w i t n e s s (B, A, c l i e n t s e r v e r a a , { A. Timestamp ' . AA' } i n v (KPa) . Hash (OTP2' ) ) / \ r e q u e s t (B, A, s e r v e r c l i e n t b b , { B . Timestamp ' . BB' } i n v (KPb) . Hash (OTP1' ) ) end r o l e OTP - s e r v e r r o l e i n HLPSL : r o l e r o l e O (O: agent , A: agent , B : agent , KPa : p u b l i c k e y , KPb : p u b l i c k e y , KPo : p u b l i c k e y , OTP1 : t e x t , OTP2 : t e x t , Token : t e x t , Password : t e x t , SND,RCV: c h a n n e l ( dy ) ) played by O d e f= local S t a t e : nat ,

112

Timestamp : t e x t , Req : t e x t , No : t e x t , OO,AA: message , Hash : f u n c t i o n , S e s s i o n k e y : message init S t a t e := 0 transition 3 . S t a t e=0 / \ RCV(A. { Token . Timestamp ' . Hash ( Token . Timestamp ' ) } KPo ) =|> S t a t e ' : = 1 / \ Timestamp ' := new ( ) / \ SND(O. { Timestamp ' . Password . Hash ( Timestamp ' . Password ) } i n v (KPo ) ) / \ s e c r e t ( Password , s e c 1 , { A,O} )

3 . S t a t e=1 / \ RCV(B. { A. B . Timestamp ' . Req ' . Hash (A. B . Timestamp ' ) } i n v (KPb) ) =|> S t a t e ' : = 3 / \ Timestamp ' := new ( ) / \ SND( { Timestamp ' . OTP1 . OTP2} KPb ) / \ SND( { Timestamp ' . OTP2 . OTP1} KPa ) / \ s e c r e t (OTP1, s e r v e r o t p 1 , {A, B,O} ) / \ s e c r e t (OTP2, s e r v e r o t p 2 , {A, B,O} ) end r o l e

I n t r u d e r s knowledge : i n t r u d e r k n o w l e d g e = { p , g , o t p s e r v e r , c l i e n t , s e r v e r , ka , kb , ki , i n v ( k i ) }

113

Goal f o r t h e p r o t o c o l i n HLPSL : goal secrecy of server otp1 secrecy of server otp2 secrecy of secret key secrecy of sec 1 authentication on client server key authentication on server client key end g o a l

// ==================================================== //

114

Appendix C HLPSL code for PPIDA-PKI
(Only the roles of each entity in the model and the knowledge given to the intruder are shown)

// =================== HLPSL code f o r PPIDA-PKI================= // D1 r o l e i n HLPSL : r o l e r o l e A (A: agent , B : agent , O: agent , KPa : p u b l i c k e y , KPb : p u b l i c k e y , KPo : p u b l i c k e y , KPHa: p u b l i c k e y , KPHo: p u b l i c k e y , G1 , G2 : t e x t , P1 , P2 : t e x t , Token : t e x t , SND,RCV: c h a n n e l ( dy ) )

played by A

115

d e f= local S t a t e : nat , Na : t e x t , Timestamp : t e x t , Timestamp2 : t e x t , Mod : f u n c t i o n , Nb : t e x t , OTP2 : t e x t , OTP1 : t e x t , Hash : f u n c t i o n , AA, BB,OO: message , Key : message , Password : t e x t , S e s s i o n k e y : message const mod : function ,

client server aa : protocol id , server client bb : protocol id init S t a t e := 0 transition 1 . S t a t e=0 / \ RCV( s t a r t ) =|> S t a t e ' : = 1 / \ Timestamp ' : = new ( ) / \ SND(A. { Token . Timestamp ' . Hash ( Token . Timestamp ' ) } KPo ) 2 . S t a t e=1 / \ RCV(O. { O. Timestamp .OO' . G2 . P2 . Hash (O. Timestamp .OO' . G2 . P2 ) } i n v (KPHo) ) =|> S t a t e ' : = 2

/ \ Na' : = new ( )

116

/ \ AA' := mod ( exp (G2 , Na ' ) , P2 ) / \ S e s s i o n k e y ' := mod ( exp (OO' , Na ' ) , P2 ) / \ SND(A. { A. Timestamp .AA' . Hash (A. Timestamp .AA' ) } i n v (KPHa) ) / \ s e c r e t ( S e s s i o n k e y ' , s e c r e t k e y 1 , {A,O} )

4 . S t a t e=2 / \ RCV(O. { { O. Timestamp ' . Password ' . KPo . Hash (O. Timestamp ' . Password ' . KPo) } i n v (KPo) } S e s s i o n k e y ' ) =|> S t a t e ' : = 3 / \ s e c r e t ( Password ' , s e c 1 , { A,O} ) % countinue old protocol / \ Na' : = new ( ) / \ Timestamp ' : = new ( ) / \ AA' := mod( exp (G1 , Na ' ) , P1 ) / \ SND(A. { A. Timestamp ' . AA' . G1 . P1 . Hash (AA' . G1 . P1 . Timestamp ' . A) } i n v (KPa ) )

2 . S t a t e=3 / \ RCV(B. { B . Timestamp . BB ' . Hash (BB ' . Timestamp ' . B) } i n v (KPb) ) =|> S t a t e ' : = 4 / \ Key ' := mod( exp (BB' , Na ' ) , P1 ) / \ s e c r e t ( Key ' , s e c r e t k e y , {A, B } ) 5 . S t a t e=4 / \ RCV( { Timestamp2 ' . OTP2 ' . OTP1' } KPa ) =|> S t a t e ' : = 5 / \ Key ' := xor ( Key ' , Hash ( xor (OTP1' , OTP2' ) ) ) / \ SND( { Hash (OTP2' ) } Key ' ) 7 . S t a t e=5 / \ RCV( { Hash (OTP1' ) } Key ' ) =|> State ':=6 / \ w i t n e s s (A, B, s e r v e r c l i e n t b b , { B . Timestamp ' . BB' } i n v (KPb) . Hash (OTP1' ) ) / \ r e q u e s t (A, B, c l i e n t s e r v e r a a , { A. Timestamp ' . AA' } i n v (KPa)

117

. Hash (OTP2' ) ) end r o l e

D2 r o l e i n HLPSL : r o l e r o l e B (A: agent , B : agent , KPa : p u b l i c k e y , KPb : p u b l i c k e y , G1 : t e x t , P1 : t e x t , SND,RCV: c h a n n e l ( dy ) ) played by B d e f= local S t a t e : nat , Na : t e x t , Mod : f u n c t i o n , Nb : t e x t , Timestamp : t e x t , Timestamp2 : t e x t , Req : t e x t , OTP2 : t e x t , OTP1 : t e x t , Hash : f u n c t i o n , AA,BB: message , Key : message const mod : function ,

client server aa : protocol id ,

118

server client bb : protocol id init S t a t e := 0 transition 1 . S t a t e=0 / \ RCV(A. { A. Timestamp ' . AA' . G1 . P1 . Hash (AA' . G1 . P1 . Timestamp ' . A) } i n v (KPa ) ) =|> S t a t e ' : = 1 / \ Nb' : = new ( ) / \ BB' := mod( exp (G1 , Nb ' ) , P1 ) / \ SND(B. { B . Timestamp ' . BB ' . Hash (BB ' . Timestamp ' . B) } i n v (KPb) ) / \ Key ' := mod( exp (AA' , Nb ' ) , P1 ) / \ s e c r e t ( Key ' , s e c r e t k e y , {A, B } ) / \ Req ' : = new ( ) / \ SND(B. { A. B . Timestamp ' . Req ' . Hash (A. B . Timestamp ' ) } i n v (KPb) ) 4 . S t a t e=1 / \ RCV( { Timestamp2 ' . OTP1 ' . OTP2' } KPb ) =|> S t a t e ' : = 2 / \ Key ' := xor ( Key ' , Hash ( xor (OTP1' , OTP2' ) ) ) 6 . S t a t e=2 / \ RCV( { Hash (OTP2) } Key ' ) =|> S t a t e ' : = 3 / \ SND( { Hash (OTP1) } Key ' ) / \ w i t n e s s (B, A, c l i e n t s e r v e r a a , { A. Timestamp ' . AA' } i n v (KPa) . Hash (OTP2' ) ) / \ r e q u e s t (B, A, s e r v e r c l i e n t b b , { B . Timestamp ' . BB' } i n v (KPb) . Hash (OTP1' ) ) end r o l e

OTP - s e r v e r r o l e i n HLPSL : r o l e r o l e O (O: agent , A: agent ,

119

B : agent , KPa : p u b l i c k e y , KPb : p u b l i c k e y , KPo : p u b l i c k e y , KPHa: p u b l i c k e y , KPHo: p u b l i c k e y , OTP1 : t e x t , OTP2 : t e x t , G2 : t e x t , P2 : t e x t , Token : t e x t , Password : t e x t , SND,RCV: c h a n n e l ( dy ) ) played by O d e f= local S t a t e : nat , Timestamp : t e x t , Req : t e x t , No : t e x t , OO,AA: message , Hash : f u n c t i o n , S e s s i o n k e y : message init S t a t e := 0 transition 3 . S t a t e=0 / \ RCV(A. { Token . Timestamp ' . Hash ( Token . Timestamp ' ) } KPo ) =|> S t a t e ' : = 1 / \ No' : = new ( )

120

/ \ OO' := mod( exp (G2 , No ' ) , P2 ) / \ SND(O. { O. Timestamp ' . OO' . G2 . P2 . Hash (O. Timestamp ' . OO' . G2 . P2 ) } i n v (KPHo) ) 3 . S t a t e=1 / \ RCV(A. { A. Timestamp .AA' . Hash (A. Timestamp .AA' ) } i n v (KPHa) ) =|> S t a t e ' : = 2 / \ s e c r e t ( Password , s e c 1 , { A,O} ) / \ Timestamp ' : = new ( ) / \ S e s s i o n k e y ' := mod( exp (AA' , No ' ) , P2 ) / \ SND(O. { { O. Timestamp ' . Password . KPo . Hash (O. Timestamp ' . Password . KPo) } i n v (KPo) } S e s s i o n k e y ' ) / \ s e c r e t ( S e s s i o n k e y ' , s e c r e t k e y 1 , {A,O} ) 3 . S t a t e=2 / \ RCV(B. { A. B . Timestamp ' . Req ' . Hash (A. B . Timestamp ' ) } i n v (KPb) ) =|> S t a t e ' : = 3 / \ Timestamp ' := new ( ) / \ SND( { Timestamp ' . OTP1 . OTP2} KPb ) / \ SND( { Timestamp ' . OTP2 . OTP1} KPa ) / \ s e c r e t (OTP1, s e r v e r o t p 1 , {A, B,O} ) / \ s e c r e t (OTP2, s e r v e r o t p 2 , {A, B,O} ) end r o l e

I n t r u d e r s knowledge : i n t r u d e r k n o w l e d g e = { p1 , p2 , g1 , g2 , o t p s e r v e r , c l i e n t , s e r v e r , ka , kb , ki , i n v ( k i ) } Goal s e t f o r t h e p r o t o c o l : goal secrecy of server otp1 secrecy of server otp2 secrecy of secret key secrecy of secret key1

121

secrecy of sec 1 authentication on client server key authentication on server client key end g o a l

//======================================================== //

122

Appendix D Servo controller Code
// =================Servo c o n t r o l l e r Code================= // import RPi . GPIO a s GPIO import time import s y s

i f l e n ( s y s . argv ) != 3 : p r i n t " Usage : s e r v o c o n t r o l l e r . py < s e r v o 1 p o s i t i o n [0 - 180] > < s e r v o 2 p o s i t i o n [0 - 180] > " sys . exit () i f i n t ( s y s . argv [ 1 ] ) < 10 o r i n t ( s y s . argv [ 1 ] ) > 1 8 0 : p r i n t " Usage : s e r v o c o n t r o l l e r . py < s e r v o 1 p o s i t i o n [0 - 180] > < s e r v o 2 p o s i t i o n [0 - 180] > " sys . exit () i f i n t ( s y s . argv [ 3 ] ) < 10 o r i n t ( s y s . argv [ 3 ] ) > 1 8 0 : p r i n t " Usage : s e r v o c o n t r o l l e r . py < s e r v o 1 p o s i t i o n [0 - 180] > < s e r v o 2 p o s i t i o n [0 - 180] > " sys . exit () GPIO . setmode (GPIO .BOARD)

123

GPIO . s e t u p ( 1 2 , GPIO .OUT) GPIO . s e t u p ( 7 , GPIO .OUT) try : p 1 = GPIO .P W M( 1 2 , 5 0 ) p 2 = GPIO .P W M( 7 , 5 0 ) x 1 = 1 . 0 / 1 8 . 0  i n t ( s y s . argv [ 1 ] ) +2 print " Setting servo 1 " p 1 . start ( x 1 ) time . s l e e p ( 2 ) x 2 = 1 . 0 / 1 8 . 0  i n t ( s y s . argv [ 3 ] ) +2 print " Setting servo 2 " p 2 . start ( x 2 ) time . s l e e p ( 2 ) except : p r i n t " Exception occurred " p 1 . stop () p 2 . stop () GPIO . c l e a n u p ( ) // ======================================================= //

124

Bibliography
[1] M. H. Miraz, M. Ali, P. S. Excell, R. Picking, A review on Internet of Things (IoT), Internet of Everything (IoE) and Internet of Nano Things (IoNT), Proc. of IEEE Internet Technologies and Applications (ITA), Glyndwr University, Wrexham, North East Wales, UK, Sept. 8-11, 2015, pp. 219-224. [2] E. Stobert, Usable R. Biddle, and Authentication in the Home", (HUPS), July 24, Workshop on Home Newcastle, UK,

Privacy

Security

2013,

http://cups.cs.cmu.edu/soups/2013/HUPS/HUPS13-ElizabethStobert.pdf. Retrieved Dec. 4, 2017. [3] P. Sherin and K. G. Raju, Multi-level authentication system for smart home-security analysis and implementation, Proc. of IEEE International Conference on Incentive Computation Technologies (ICICT), Aug. 26-27, Coimbatore, India, DOI: 10.1109/INVENTIVE.2016.7824790 [4] P. Madsen, Authentication in the IoT: challenges and opportunities,

http://www.secureidnews.com/news-item/authentication-in-the-iot-challenges-andopportunities. Retrieved Dec. 4, 2017. [5] U. Saxena, J. S. Sodhi, Y. Singh, Analysis of security attacks in a smart home networks, Proc. of 7th Intl. Conference on Cloud Computing, Data Science & Engineering, Noida, India, Jan. 12-13, 2017, pp. 431-436, 2017.

125

[6] S. Peter and R. K. Gopal, Multi-level authentication system for smart home-security analysis and implementation, Proc. of Intl. Conference on Incentive Computation Technologies (ICICT), Coimbatore, India, Aug. 26-27, 2016, DOI: 10.1109/INVENTIVE.2016.7824790 [7] M. S. Raniyal, I. Woungang, S. K. Dhurandher, An Inter-Device Authentication Scheme for Smart Homes using One-Time-Password over Infrared Channel, (Accepted Aug 10, 2017) to the International Conference on Intelligent, Secure, and Dependable Systems in Distributed and Cloud Environments (ISDDC 2017), Oct. 26-28, 2017, Vancouver, BC, Canada. [8] NIST FIPS, http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.140-2.pdf. Retrieved Dec. 4, 2017. [9] D. Garg and S. Verma, Improvement over Public Key Cryptographic Algorithm, IEEE International Advance Computing Conference (IACC 2009), Patiala, India, March 2009 [10] H. Om and S. Kumari, Comment and modification of RSA based remote password authentication using smart card, Journal of Discrete Mathematical Science and Cryptography, 2017, p. 625-635. [11] K. Ashton, That 'Internet of things' thing, RFID Journal, 2009,

http://www.rfidjournal.com/articles/view?4986. Retrieved Dec. 4, 2017 [12] Z. Dawy, W. Saad, A. Ghosh, J. G. Andrews, E. Yaacoub, Towards massive machine type cellular communications, IEEE Wireless Communications, Vol. 24, Issue 1, Feb. 2017, pp. 120-128. [13] V. L., Shivraj, M. A. Rajan, Singh Meena, P. Balamuralidhar, "One time password authentication scheme based on elliptic curves for Internet of Things (IoT)". Proc. of IEEE 5th National Symposium on Information Technology: Towards New Smart World (NSITNSW 2015), Feb. 17-19, 2015, pp. 1-6. 126

[14] E. Stobert, Usable

R. Biddle, and

Authentication in the Home", (HUPS), July 24,

Workshop on Home Newcastle, UK,

Privacy

Security

2013,

http://cups.cs.cmu.edu/soups/2013/HUPS/HUPS13-ElizabethStobert.pdf. Retrieved Dec. 4, 2017. [15] PureLiFi, http://purelifi.com. Retrieved Dec. 4, 2017. [16] Z. Tian, K. Wright, X. Zhou, The DarkLight Rises: Visible Light Communication in the Dark", http://www.cs.dartmouth.edu/ xia/papers/mobicom16-darklight.pdf. Retrieved Aug. 9, 2017. [17] P. Kumar, A. Braeken, A. Gurtov, J. Iinatti, P. H. Ha, Anonymous Secure Framework in Connected Smart Home Environments, IEEE Transactions on Information Forensics and Security, Vol. 12, Issue 4, Jan. 2017, pp. 968-979. [18] C. C. Yang, R. C. Wang, and T. Y. Chang, An improvement of the Yang-Shieh password authentication schemes, Applied Mathematics and Computation, vol. 162, 2005, pp. 1391-1396. [19] N. Shone, C. Dobbins, W. Hurst, Q. Shi, Digital Memories Based Mobile User Authentication for IoT, Proc. of IEEE Intl. Conference on Computer and Information Technology, Ubiquitous Computing and Communications, Dependable, Autonomic and Secure Computing, Pervasive Intelligence and Computing, 2015, Oct. 26-28, Liverpool, UK, pp. 1796-1802 [20] P. P. Gaikwad, J. P. Gabhane, S. S. Golait, 3-Level Secure Kerberos Authentication for Smart Home Systems Using IoT, Proc. of 1st IEEE Intl. Conference on Next Generation Computing Technologies (NGCT) Dehradun, India, Sept. 4-5, 2015, pp. 262-268. [21] T. Borgohain, A. Borgohain, U. Kumar, S. Sanyal, Authentication Systems in Internet of Things, https://arxiv.org/abs/1502.00870. Retrieved Dec 4, 2017.

127

[22] H. Om and M. Reddy, RSA based remote password authentication using smart card. Journal of Discrete Mathematical Science & Cryptography, 2012, 15(2): 105-111, 2012. [23] X. Wang, W. Zhang, An efficient and secure biometric remote user authentication scheme using smart cards, Proc. of Pacific-Asia Workshop on Computational Intelligence and Industrial Application (PACIIA'08), Wuhan, China, Dec 19-20, 2008, DOI: 10.1109/PACIIA.2008.382, pp. 913-917. [24] Remote user authentication using NFC, US patent US20110212707,

https://www.google.ch/patents/US20110212707. Retrieved Dec. 4, 2017. [25] SPAN/AVISPA Tool, http://www.avispa-project.org. Retrieved Dec. 4, 2017. [26] M. Burrows, M. Abadi, R. Needham, A logic of authentication, ACM Trans. on Computer Systems, Vol.8 (1), pp.18-36,1990. [27] P. Wilson, Inter-Device Authentication Protocol for the Internet of Things, MSc Thesis, Department of Electrical and Computer Engineering, University of Victoria, B.C, Canada, July 2017. [28] X. Yao, X. Han, X. Du, X. Zhou, "A lightweight multicast authentication mechanism for small scale IoT applications", IEEE Sensors Journal, Vol. 13, Issue 10, June 2013, pp. 3693-3701. [29] J. L. Hernandez-Ramos, M. P. Pawlowski, A. J. Jara, A. F. Skarmeta, L. Ladid, Toward a lightweight authentication and authorization framework for smart objects, IEEE Journal on Selected Areas in Comm., Vol. 33, Issue 4, Apr. 2015, pp. 690-702. [30] P. Hughes, ARM and Sensor Platforms Deliver an Open Source Framework for Sensor Devices, ARM, https://www.arm.com/about/newsroom/arm-and-sensor-platformsdeliver-an-open-source-framework-for-sensor-devices.php. Retrieved Aug. 9, 2017.

128

[31] Y. Sharaf-Dabbagh, W. Saad, On the authentication of devices in the Internet of Things, Proc. the 17th IEEE Int. Symposium on World Wireless, Mobile Multimedia Networks, Coimbra, Portugal, Jun. 2016, pp. 1-3. [32] S. Shin; H. Yeh; K. Kim, An effective device and data origin authentication scheme in home networks, Proc. of 9th Intl. Conference and Expo. on Emerging Technologies for a Smarter World (CEWIT), Nov. 5-6, Incheon, South Korea, Sept. 2012, pp. 1-5. [33] P. Kumar, A. Gurtov, J. Iinatti, M. Ylianttila, M. Sain, Lightweight and Secure SessionKey Establishment Scheme in Smart Home Environments, IEEE Sensors Journal, Vol. 16, Issue 1, Jan. 2016, pp. 254-264. [34] F. K. Santoso, N. C. H. Vun, Securing IoT for smart home system, Proc. of Intl. Symposium on Consumer Electronics (ISCE), Madrid, Spain, June 24-26, 2015, pp. 1-2. [35] Steve Friedl's Unixwiz.net Tech Tips, An Illustrated Guide to SSH Agent Forwarding, http://www.unixwiz.net/techtips/ssh-agent-forwarding.html. Retrieved Dec. 4, 2017. [36] N. Park and N. Kang, Mutual Authentication Scheme in Secure Internet of Things Technology for Comfortable Lifestyle, Sensors 2016, 16(1), 20; doi:10.3390/s16010020 [37] J. Kang, G. Park, J-H. Park, Design of secure authentication scheme between devices based on zero-knowledge proofs in home automation service environments, Journal of Supercomputing, Vol. 72, DOI: 10.1007/s11227-016-1856-y, 2016, pp. 4319-4336. [38] B. Vaidya, D. Makrakis, H. T. Mouftah, Device Authentication Mechanis m for Smart Energy Home Area Networks, Proc. of IEEE Intl. Conference on Consumer Electronics (ICCE), Jan. 9-12, 2011, Las Vegas, NV, USA, pp. 787-788 [39] W. H. Yang and S. P. Shieh, Password authentication schemes with smart cards, Computers and Security, Vol. 18, no. 8, pp. 727- 733, 1999. 129

[40] C. K. Chan, L. M. Cheng, Cryptanalysis of a timestamp-based password authentication scheme, Computers and Security 21 (I), 2002, pp. 74-76. [41] H. M. Sun, H. T. Yeh, Further cryptanalysis of a password authentication scheme with smart cards, IEICE Transactions and Communications E86-B (4), 2003, pp. 1412-1415. [42] L. Fan, J. H. Li, and H. W. Zhu, An enhancement of timestamp based password authentication scheme, Computers & Security, vol. 21, pp. 665-667, 2002. [43] C. C. Yang, R. C. Wang, and T. Y. Chang, An improvement of the Yang-Shieh password authentication schemes, Applied Mathematics and Computation, vol. 162, pp. 13911396, 2005. [44] J.J. Shen, C.W. Lin, M. S. Hwang, Security enhancement for the timestamp-based password authentication scheme using smart cards, Computers and Security 22 (7) (2003) 591595. [45] Y. Liu, A. M. Zhou, M. X. Gao, A new mutual authentication scheme based on nonce and smart cards, Computer Communications 31 (10) (2008) 2205-2209. [46] H. Y. Chien, J. K. Jan, and Y. M. Tseng, An efficient and practical solution to remote authentication: smart card, Computers & Security, vol. 21, no. 4, pp. 372375, 2002. [47] C. L. Hsu, Security of Chien et al.'s remote user authentication scheme using smart cards, Computer Standards & Interfaces, 2003. [48] H. Bar-El, Known Attacks Against Smart cards, http :

//www.inf osecwriters.com/textr esources/pdf /KnownA ttacksA gainstS martcards.pdf , Retrieved Dec. 4, 2017 [49] C. A. M. Paixao and D L G Filho. An efficient variant of the RSA cryptosystem, Eprint Archive, 2003.

130

[50] Zero-Day Attacks, http://www.pctools.com/security-news/zero-day-vulnerability. Retrieved Dec. 4, 2017 [51] Diffie-Hellman Key Exchange Protocol, http : //www.math.ucla.edu/ baker/40/handouts /revD H/node1.html. Retrieved Dec. 4, 2017 [52] SELinux Project, https : //selinuxproject.org/page/M ainP age. Retrieved Nov 24, 2017 [53] SELinux, https : //wiki.centos.org/HowT os/SELinux. Retrieved Dec. 4, 2017 [54] Restricting even root access to a folder, http://blog.siphos.be/2015/07/restricting-evenroot-access-to-a-folder/. Retrieved Dec. 4, 2017 [55] User Management, https://help.ubuntu.com/14.04/serverguide/user-

management.html. Retrieved Dec. 4, 2017 [56] RedHat-Disallowing Root Access, https : //access.redhat.com/documentation/en - U S/RedH atE nterpriseL inux/4/html/SecurityG uide/s2 - wstation - privileges - noroot.html. Retrieved Dec. 4, 2017 [57] Ubuntu Sudoers, https://help.ubuntu.com/community/Sudoers. Retrieved Dec. 4, 2017 [58] Limiting root access with sudo, http://www.techrepublic.com/article/limiting-rootaccess-with-sudo-part-1/. Retrieved Dec. 4, 2017. [59] R. L. Rivest, A. Shamir, L. Adleman, "A Method for Obtaining Digital Signatures and Public-Key Cryptosystems", Communications of the ACM, Vol 21, No. 2, Feb. 1978, pp. 120-26 [60] RSA Labs. Public Key Cryptography Standards (PKCS), Number 1.,

https://tools.ietf.org/html/rfc3447. Retrieved Dec. 4, 2017

131

[61] Smart

card

application

protocol

data

unit,

https Retrieved

: Dec.

//en.wikipedia.org/wiki/Smartc arda pplicationp rotocold atau nit, 4, 2017 [62] S. Ruj, A. Nayak, S. Naik,

Securing home networks using Physically Unclonable

Functions, Proc. of 4th International Conference on Ubiquitous and Future Networks (ICUFN), July 4-6, Puket, Thailand, 2012, pp. 288-293. [63] T. Marktscheffel; W. Gottschlich; W. Popp, P. Werli, S. D. Fink, A. Bilzhause; H. de Meer, QR code based mutual authentication protocol for Internet of Things, Proc. of IEEE 17th International Symposium on A World of Wireless, Mobile and Multimedia Networks (WoWMoM), June 21-26, 2016, Coimbra, Portugal, pp. 1-6. [64] Open Source Universal Remote, https : //upverter.com/alexbain/f 24516375cf ae8b9/ Open - Source - U niversal - Remote/#/. Retrieved Dec. 4, 2017. [65] Linux Infrared Remote Control, http://www.lirc.org. Retrieved Dec. 4, 2017. [66] Raspbian Operating System, https://www.raspberrypi.org/downloads/raspbian. Retrieved Dec. 4, 2017. [67] Crypto++ Benchmark, https://www.cryptopp.com/benchmarks.html, Retrieved Nov. 28, 2017. [68] A. Fiat. Batch RSA. In G. Brassard, ed., Proceedings of Crypto 1989, vol. 435 of LNCS, pp. 175185. Springer-Verlag, Aug. 1989. [69] B. D, Shacham H. Fast variants of RSA. In RSA Laboratories' Crypto bytes, https://cseweb.ucsd.edu/ hovav/dist/survey.pdf. Retrieved Dec. 4, 2017 [70] NIST, Recommendation for key management, "http://nvlpubs.nist.gov/nistpubs /SpecialPublications/NIST.SP.800-57Pt3r1.pdf", Retrieved Nov. 28, 2017

132

[71] T. Collins, D. Hopkins, S. Langford, and M. Sabin, Public Key Cryptographic Apparatus and Method, US Patent #5848159, Jan. 1997. [72] T. Takagi. Fast RSA-type Cryptosystem Modulo pkq. In H. Krawczyk, ed., Proceedings of Crypto 1998, vol. 1462 of LNCS, pp. 318326. Springer-Verlag, Aug. 1998. 36(3):553558. May 1990. [73] M. Wiener. Cryptanalysis of Short RSA Secret Exponents, IEEE Trans. Information Theory, Vol. 36, Issue 3, May 1990, pp. 553-558 [74] F. Mulvey, A. Villanueva, D. Sliney, R. Lange, M. Donegan, "Safety issues and infrared light", Assistive Technologies: Concepts, Methodologies, Tools, and Applications, pp.1062-1083, 2013

133


