Ryerson University

Digital Commons @ Ryerson
Theses and dissertations

1-1-2013

Application Of Residue Codes For Error Detection In Mixed Signal Devices
Leila Feyzmohammadi
Ryerson University

Follow this and additional works at: http://digitalcommons.ryerson.ca/dissertations Part of the Electrical and Computer Engineering Commons Recommended Citation
Feyzmohammadi, Leila, "Application Of Residue Codes For Error Detection In Mixed Signal Devices" (2013). Theses and dissertations. Paper 1350.

This Thesis Project is brought to you for free and open access by Digital Commons @ Ryerson. It has been accepted for inclusion in Theses and dissertations by an authorized administrator of Digital Commons @ Ryerson. For more information, please contact bcameron@ryerson.ca.

APPLICATION OF RESIDUE CODES FOR ERROR DETECTION IN MIXED SIGNAL DEVICES

by Leila Feyzmohammadi MEng., Ryerson University, Toronto, Canada, 2012

A project report presented to Ryerson University

in partial fulfillment of the requirements for the degree of Master of Engineering in the Program of Electrical and Computer Engineering

Toronto, Ontario, Canada, 2013 © Leila Feyzmohammadi, 2013

Author's Declaration

I hereby declare that I am the sole author of this project report.

I authorize Ryerson University to lend this project report to other institutions or individuals for the purpose of scholarly research.

I further authorize Ryerson University to reproduce this project report by photocopying or by other means, in total or in part, at the request of other institutions or individuals for the purpose of scholarly research.

ii

Application of Residue Codes for Error Detection in Mixed Signal Devices

Leila Feyzmohammadi Master of Engineering Electrical and Computer Engineering Ryerson University, Toronto, 2013

Abstract
Testing methods based on residue codes are considered as simple, with high probability of detecting errors. Most of the literatures on arithmetic error control codes are mainly focused on applications of secure data transmission and testing digital circuits rather than testing mixedsignal systems. In both cases implementation of residue computing circuit (RCC), also known as the residue generator is an integral part of the hardware design. In this work a low-cost compactor circuit to calculate the residue for on-line testing of analog-to-digital converter has been presented. Aliasing rate and its relationship with the resolution of the ADC have been analyzed. Theory and operation of Linear Feedback Shift Registers have been applied for the implementation of the modulo adder circuit. The compaction circuits were simulated, and the result confirmed the theoretical analysis.

iii

TABLE OF CONTENTS
1. Chapter 1 Introduction......................................................................................................................... 1 1.1 1.2 1.3 1.4 2. Motivation..................................................................................................................................... 1 Scope of this Project ..................................................................................................................... 2 Report Outline............................................................................................................................... 2 Project Contribution ..................................................................................................................... 3

Chapter 2 Background.......................................................................................................................... 4 2.1 2.2 Introduction .................................................................................................................................. 4 Finite fields .................................................................................................................................... 4 Basic Definitions and Properties ........................................................................................... 4 Polynomials ........................................................................................................................... 5 Construction and Representation of Addition over Multiplication over ...................................................................... 6

2.2.1 2.2.2 2.2.3 2.2.4 2.2.5 2.3 2.4 2.5 2.6 2.7 3.

.......................................................................................................... 7 - General Bit-level Multiplications .......................................... 7

Theory and Operation of Linear Feedback Shift Registers ........................................................... 9 Fault Modeling ............................................................................................................................ 12 Detecting errors in finite field operations .................................................................................. 12 Residue Codes for Checking Arithmetic Operations ................................................................... 13 Residue Generator ...................................................................................................................... 21

Chapter 3 Application of Residue Codes for Error Detection in Mixed-Signal Systems .................... 24 3.1 3.2 3.3 3.4 3.5 3.6 3.7 Introduction ................................................................................................................................ 24 General Aspects of Compression Techniques ............................................................................. 24 Ones-Count Compression ........................................................................................................... 26 Transition-Count Compression ................................................................................................... 26 Parity-Check Compression .......................................................................................................... 27 Syndrome Testing ....................................................................................................................... 28 LFSRs Used as Signature Analyzers ............................................................................................. 29

iv

3.8 3.9 3.10 4.

Multiple-Input Signature Registers ............................................................................................. 30 Arithmetic Compaction Circuits for Testing Mixed-Signal Systems ............................................ 31 Testing Mixed Signal Device........................................................................................................ 32

Chapter 4 Residue Calculator Circuit Architecture for Mixed-Signal Systems ................................... 36 4.1 4.2 4.3 4.4 Operation of Arithmetic and Algebraic Compactor .................................................................... 36 Operation of Arithmetic and Algebraic Compactor .................................................................... 36 Low-Cost Compactor schemes .................................................................................................... 40 Compaction Process .................................................................................................................... 41

5.

Chapter 5 Simulation and analysis of the results ............................................................................... 45 5.1 Simulation ................................................................................................................................... 45

6. 7. 8.

Chapter 6 Future Work and Conclusion ............................................................................................. 51 Appendix ............................................................................................................................................. 53 References .......................................................................................................................................... 55

v

TABLE OF FIGURES

Figure  2-1 Feedback shift register................................................................................................................. 9 Figure  2-2 Type 1 LFSR ................................................................................................................................ 10 Figure  2-3 Type2 LFSR ................................................................................................................................. 10 Figure  2-4 Open Fault Model and Truth Table............................................................................................ 12 Figure  2-5 Error detection scheme ............................................................................................................. 15 Figure  2-6 Adder cell with no logic shared ................................................................................................. 18 Figure  2-7 Adder cell with some logic shared ............................................................................................. 19 Figure  2-8 8-bit number modulo 7 .............................................................................................................. 22 Figure  2-9 8-bit number modulo 9 .............................................................................................................. 22 Figure  2-10 Self-checking Multiplier ........................................................................................................... 23 Figure  3-1 Test Data Analyzer ..................................................................................................................... 25 Figure  3-2 One-Count Compression............................................................................................................ 26 Figure  3-3 Transition Detector .................................................................................................................... 27 Figure  3-4 Parity Check Compression ......................................................................................................... 28 Figure  3-5 Example of single-input signature analyzer ............................................................................... 30 Figure  3-6 Multiple input register (MISR) ................................................................................................... 31 Figure  3-7 On-line Testing of ADC Device ................................................................................................... 33 Figure  3-8 Transfer function of a 3-bit MSS ................................................................................................ 34 Figure  4-1 Operation of the 3-input signature register .............................................................................. 37 Figure  4-2 3-Input Residue Calculator in RTL Form .................................................................................... 38 Figure  4-3 3-Input Arithmetic Compactor................................................................................................... 39 Figure  4-4 3-Input Ternary Arithmetic Compactor ..................................................................................... 39 Figure  4-5 An Alternative 3-Input Arithmetic Compactor .......................................................................... 41 Figure  5-1 RCC with Modulo 5 Adder ......................................................................................................... 46 Figure  5-2 Arithmetic Compaction Circuit modulo 5 .................................................................................. 46 Figure  5-3 Arithmetic Compaction Modulo 9 ............................................................................................. 47 Figure  5-4 Testing an ADC with Offset ........................................................................................................ 48 Figure  5-5 RTL form of modulo adder with Combinational Unit ................................................................ 48 vi

Figure  5-6 Compaction Circuit calculating modulo adder of a ternary number ......................................... 49 Figure  5-7 An alternative modulo adder..................................................................................................... 49 Figure  5-8 Implementation of the Modulo adder....................................................................................... 49

vii

1. CHAPTER 1 INTRODUCTION
1.1 Motivation

As the size of electronic devices decrease the probability occurrence of errors increases. At the same time testing of the circuit becomes more difficult as the number of gates increases. To ensure the reliability of the circuits, it is important to detect errors as soon as they happen, identify the faulty circuit and ensure the correct functionality of the circuit in the presence of fault. Error detecting codes, more specifically residue codes has been applied to provide testability in a wide range of very large integrated circuit (VLSI) circuits [1]. Also the effectiveness of residue code checking for on-line error detection in multipliers with different architectures has been evaluated experimentally [2]. Many electronic systems, such as those for signal processing, video compression and biometrics are essentially of a mixed-signal type. A mixed-signal system (MSS) incorporates both analog and digital circuits. It is highly desirable to assure the reliability of these systems. Many methods developed for testing analog-to-digital converters (ADC) are based on the estimation of their static and dynamic metrics such as, gain, offset, SNR etc. [3]. Although these metrics carry important information about the functionality of an ADC and its subunits, but their calculation needs complex equipment for digital processing of test responses. This work develops a test scheme based on residue calculation to test the functionality of ADCs.

1

1.2

Scope of this Project

This work extends the application of residue codes for on-line testing of ADCs. In order to detect all possible faults in an ADC, an exhaustive set of test patterns is applied as an input to the device under test (DUT). Such a test set consists of analog input stimuli covering the full scale (FSR) of an ADC. The output responses which are also referred to as output codes should be digitally compared with the expected values. If the comparison is done after each conversion more memory, proportional to the number of input stimuli, is needed. Off-line compaction schemes can be designed based on the estimation of the arithmetic sum (signature) of the output responses of the (DUT) [4]. The actual signature is then compared against the fault-free circuit's signature. In this work, compaction schemes based on residue codes for different modulo are analyzed, simulated, and implemented on Altera FPGA board. The aliasing rate is estimated based on theoretically achievable testing accuracy for the tolerance bounds. The limitation of the method according to [5], is that the tolerance bounds are obtained from empirical data, which requires the availability of a reference device and does not guarantee the highest accuracy for the bounds.

1.3

Report Outline

The organization of the remainder of the report is as follows. A brief overview of required background of residue codes and a number of schemes for testing arithmetic circuits, and selfchecking multipliers based on residue codes is presented in Chapter 2. In Chapter 3 data compression technique for testing is explained, and testing ADCs based on analyzing the residue is presented. Several residue calculation schemes are presented. Aliasing rate is estimated and ways to improve the rate is discussed.
2

In Chapter 4 the result of the simulation of the residue calculation circuit (RCC) is presented. Finally, some conclusions are summarized in Chapter 5.

1.4

Project Contribution

Finding the best compaction scheme for testing ADC without the need for complex equipment is the major concern of this project. The contribution of this project to achieve this goal is simulation, and implementation of residue calculation circuit for testing ADC. Also an estimation of aliasing for the schemes was accomplished.

3

2. CHAPTER 2 BACKGROUND
2.1 Introduction

In this Chapter, basic definitions of finite fields, polynomials and arithmetic operations are provided. Basics of fault modeling are introduced. Residue codes and their application in testing arithmetic circuits are discussed in details in this chapter. Schemes of cost effective residue testing circuits that has been previously developed for testing arithmetic circuits are analyzed. Proofs of the theories are omitted for briefness.

2.2

Finite fields

In this section important definitions and theories of finite fields are summarized from [6]. Proofs are omitted. All of these definitions and theories can be seen in most of algebra texts. 2.2.1 Basic Definitions and Properties

Definition 2.1 A group is a set G with a binary operation `*' on G if it satisfies these conditions: The binary operation `*' is associative:

There exists an identity element e in G:

There exists an inverse element for each element:

4

A group is an Abelian or communicative if:

Definition 2.2 A set F with two operations denoted by `+' and `.' is a field if these conditions are met:     Definition 2.3 A field that contains a finite number of elements is called a finite field known as Galois field. Definition 2.4 The number of elements in a Galois field is called the order of the field and a Galois field with the order of q is denoted by GF(q). Definition 2.5 Let a be an element of GF(q). The smallest positive integer m, such that , is called the characteristic of the field. Theorem 2.1 The characteristic of any finite field is prime. Theorem 2.2 In a Galois field, the order of the field is a prime or a power of a prime. (F,+) is an Abelian group and 0 is its identity element (F*, .) is an Abelian group and 1 is its identity element then

2.2.2 Polynomials
A polynomial over GF(p) is an expression of the following form:

5

Definition 2.6 A polynomial F(x) over GF(p) is called irreducible if it cannot be written as the product of some lower degree polynomials over GF(p). Definition 2.7 F(x) is a polynomial over GF(p), F(0) 0. The order of F(x) is the least positive integer t, such that F(x)| -1 Definition 2.8 Let F(x) be a polynomial of degree m over GF(p). Polynomial F(x) is said to be a primitive polynomial if its order is Definition 2.9 A sequence of numbers called a generation function [7]. . can be associated with a polynomial,

2.2.3 Theorem 2.3 Let polynomials over

Construction and Representation of be an irreducible polynomial of degree of degree less than form a finite field . , then is called a subfield of . and over . Then all of order , if

addition and multiplication are performed modulo Definition 2.10 If and are two fields such that

is called an extension field of . For example, Definition 2.11 The binary extension field polynomial of degree m:

) is an extension field of

is constructed using an irreducible

6

Here

for

. The constructed field is an extension of the basic field elements. Assuming that x is a root of , any field element of

and contains

can be represented as a polynomial of degree m-1:

2.2.4

Addition over

The addition of the two field elements is carried out by pair-wise XOR operation [8]: 2.2.5 Suppose are the bits. Multiplication over - General Bit-level Multiplications

is the modulus that defines the polynomial of the field.

7

Algorithm 2.1, and 2.2 show the bit-level multiplication from low bit to high bit and from high bit to low bit which are obtained according to equations (2.1), and (2.2) [9].
Algorithm 2.1: Bit-level algorithm of multiplication from low bit to high bit in

}

Bit-level multiplication can be done from high to low bit-level in equation (2.2):

according to

Algorithm 2.2: Bit-level algorithm of multiplication from high-to-low bit in

}

8

2.3 Theory and Operation of Linear Feedback Shift Registers
Linear feedback shift register [LFSR] devices are used in built-in self test (BIST) designs. They can be used to carry out the response of the compression which will be explained in more details in chapter3.In this section some of the properties associated linear feedback shift registers are presented from [7].These circuits are based on cyclic redundancy checking (CRC) and have only clocks as their input. Symbolic form of a feedback shift register is shown in figure 2.1. Each cell is assumed to be a clocked D flip-flop. When these circuits are clocked repeatedly, they go through a fixed sequence of states. For example consisting of n flip-flops. is the sequence for a binary counter

Figure 2 -1 Feedback shift register

The maximum number of states for each device is

. A linear circuit is a logic network of

basic components: Flip-flops, modulo-2 adders, modulo-2 multipliers. All operations of such circuits are done modulo 2. The response to a linear combination of stimuli is the linear combination of the responses of the circuit to the individual stimuli [7]. Type 1 (external-XOR) and type 2 (internal-XOR) LFSR are shown in figure 2.2 and 2.3 respectively.

9

Figure 2 -2 Type 1 LFSR

Figure 2 -3 Type2 LFSR

Definition 2.9 Let {

where

, represent the output sequence that is

generated by an LFSR. Then the sequence can be expressed as:

Multiplication and division of the polynomials are done modulo 2 [7].

10

Structure of type 1 LFSR is such that if the current state (CS) of

is

, then is the feedback

. This means that the operation of the circuit is a recursive function. coefficient, and It can be proved that are initial state (IS) of the device.

is a function of initial states of the LFSR and the feedback .

coefficients [7]. Equation (2.3) shows this property of function

Definition 2.12 The denominator of equation (2.3) is known as the characteristic polynomial of the sequence { as is denoted as [7]: . If sequence { , and , then G(x) will be reduced to 1/ . Assuming that

is cyclic with period p as shown in equation (2.4):

Definition 2.13 If the initial state of an LFSR is the LFSR sequence

,

, then divides

is periodic; the period is the smallest integer k for which

Definition 2.14 If the period of the sequence generated by an n-stage LFSR is is called a maximum length sequence.

, then it

Definition 2.15 The characteristic polynomial associated with a maximum-length sequence is called a primitive polynomial.
11

2.4

Fault Modeling

Faults can be investigated at different levels of abstraction of circuits, such as gate level or architectural level. Gate level faults are open faults, short faults, and stuck-at faults. Figure 2.4 shows an open fault circuit with its corresponding truth table. C is the correct output and C' is the faulty one. In higher architectural-level, the error can be modeled as equation 2.5 [9]: (2.5)

Figure 2 -4 Open Fault Model and Truth Table

2.5

Detecting errors in finite field operations

In past, circuits capable of concurrent error detection were only dedicated to critical applications such as, railway control. But today with shrinking size of electronic devices and the fact that circuits are more susceptible to internal and external noises, self-checking circuits are more desirable. In order to detect errors occurred in any finite field operations, different approaches, such as, parity bits, scaling techniques has been proposed in literatures [7, 9].

12



Parity Prediction: Works based on predicting the parity of the output from the parity of the input. This method can only find odd number of erroneous bits.

 

Scaling technique: Representing the value N by the number AN, known as AN codes. Residue codes (or inverse residue codes): Computing a residue for each input and, then predicting the residue of the output based on them. It essentially means representing the value N by the pair (N,C) where C is N mod A or (N-N mod A) and is called the check part.



Time redundancy based techniques: Re-computing the result with shifted operands.

The main problems associated with the design of self-checking circuits are hardware cost and time consumption of the design. Developed Parity prediction designs allow high fault coverage with low hardware cost in self-checking data paths for blocks such as, adders, Shifters, register files, etc. However, parity prediction self-checking multipliers has much higher overhead.

Using parity codes for checking memory systems and register files provides fault secure property with low overhead, however, arithmetic operators produce output errors that are not detectable by parity code; in multipliers, fault secure design based on parity prediction requires hardware overhead in the range of 40% to 50% [10]. Therefore, in the case of multipliers, residue codes can be a good alternative to achieve fault secure property.

2.6 Residue Codes for Checking Arithmetic Operations
Modulo A (A is a positive integer) arithmetic circuits have found many applications in digital signal processing, computing convolution, elliptic encryption systems and fault tolerant digital systems [11].

13

Arithmetic codes in general, add some bits as an information part to the input before the operation, to be checked after the operation. The information part can be the original number multiplied by a constant number or, it can be a check part representing the modulo m of the information part. One of the most important classes of modulus M are Mersenne numbers that are in the form of . These circuits are known to have simple hardware implementation as

there is no need for division to calculate the residue. Residue checking circuit requires compact hardware [10]. It needs a small arithmetic operator (adder, multiplier) which can add or multiply operands of the size of the check parts of the operands, A modulo generator which can compute the residue which is independent of the size of the operator. It also requires an arithmetic code checker and a code translator with the size proportional to the size of the operands. Residue checking has been studied for error detection in arithmetic processors. Many papers have been published to evaluate residue checking in terms of delay, fault coverage and hardware overhead. So far the results show that it may not be the most efficient method for checking addition and subtraction circuits, however, it is shown that the method has a very good performance for checking multiplier circuits especially large multipliers [10]. Residue checking is a method to check the accuracy of an operation which can be done in parallel with the actual operation. This means that it can provide concurrent error detection. For example for checking an addition operation, the adder and the residue checker are implemented as an independent logic functions. Then an easy to implement modulus should be selected to check the residue of the operands and the result to see if they match. Figure 2.5 from [12] illustrates the idea of error detection using residue checking.

14

Figure 2 -5 Error detection scheme Another method to detect errors in an arithmetic operation is parity prediction and because of its low hardware implementation, it is sometime considered as more efficient than residue checking. The most important problem with this method is that it can only find odd number of errors and because of the occurrence of errors with random nature in arithmetic operations, there might be some errors that cannot be detected by parity prediction method. In a number system two numbers A and B are shown as the following [14]:

The congruence relationship of the two numbers modulus m is produced by equation (2.6):

The benefit of the residue checking is that numbers that are congruent to the same modulus can be added, subtracted and multiplied, and the result is still a valid congruence [13]. This means that the residue of the sum is equal to the sum of the residues. For example, modulo 3 residues can detect single-bit errors using only two check bits in the radix 2 number system. The
15

structure is that, in parallel with the addition operation, separate residues for A and B will be obtained in two residue generator blocks. These residues are then added in an adder unit and the resulting sum is applied to another residue calculator. Final step is to compare the residue of the sum against the residue of the sum of the residues to indicate an effort if they do not match [14]. This structure can be illustrated in the mathematical equation of (2.7) as the following form:

Table (2.1) shows the result of 4-bit binary number modulo 3. Note that the residue representation needs only 2 bits. The division operation to find the residue was implemented by a sequence of shifts and addition or subtraction depending on the previous state of the previous high order carry-out [14]. The carry out determined the quotient bit at any level and also the next operation.

16

Table 2 -1 4-Bit Binary Numbers and Their Residue Modulo-3 Binary Data 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 Modulo-3 Residue 00 01 10 00 01 10 00 01 10 00 01 10 00 01 10 00

17

The use of arithmetic codes for adders/ALUs has reduced interest because of the complexity and the large overhead of the circuit. The size of the multiplier however, is proportional to the square of the size of the operands, meaning that for large multipliers residue codes is a good solution [10]. A CAD system has been developed in [10] allows automatic generation of different schemes of self-checking multipliers based on residue codes. The experimental result of this paper confirmed that residue checking for multipliers bigger than significantly, even down to 5% or 6% for multipliers. reduces the area overhead

For simplicity it is assumed that faults affect a single gate at a time. Two different schemes for an adder cell can be defined to model fault which are shown in figures 2.6, and 2.7 from [10]. In the model shown in figure 2.6 sum and carry-out are independently computed as the result of XORing. In figure 2.7 however, A B result which is shown as P, is to calculate carry-out.

Clearly the latter model results in propagating error of P to C.

Figure 2 -6 Adder cell with no logic shared

18

Figure 2 -7 Adder cell with some logic shared The result of applying residue codes for different schemes of multipliers are summarized here [10]. Array Multipliers Array multipliers are implemented by network of full and half adders to calculate the partial products. To detect errors using residue codes in Array Multipliers or any other type of multiplier, it should be considered that if the arithmetic value of the error produced by multiplier is multiple of the base of the residue codes, then, the error would go undetected. Since we are working with binary system, any error at . So, bit of the output bits has the arithmetic value of is

for the scheme of figure 2.7 can be selected as the check base because

never a multiple of 3; it is known as the cheapest check base because it only needs 2 bits to register the residue. Check-base 3 however, cannot detect some of the faults in the scheme of 2.7. In this case, arithmetic value of the error will be the form of 7 can be used so that the base does not divide the error. which is multiple of 3. In this case base

19

Multipliers with Wallace Trees Accumulating partial products using Wallace trees improves the delay known for Array multipliers [14]. Same as the Array Multipliers, the network of ripple-carry adders that add the partial products will add the arithmetic value of the error to the final result. So here also base 3 achieves fault secure property. However, because of the delay known for the ripple-carry adder, the carry propagate adder must be implemented in a carry look-ahead manner [10]. Now the check base in this case would be different. Important fact need to be considered is that carries here are generated by a carry look-ahead function which has a structure different than the adder cell network. This leads to propagation of an error in a more complex way. Table (2.2) summarizes the check bases that can be used for fast adders obtained by the software developed in [10]. Table 2 -2 Check Bases 16 Check Base Kogge & Stone Han & Carlson Brent & Kung Sklansky Carry Unit Lookahead 3 3 3 7 3 7 3 7 3 bits 32 bits 64 bits

20

Booth Multipliers Booth multipliers are also considered as fast multipliers because it reduces the number of partial products by one half by encoding the biggest input operand. For this type of multiplier, the lowest check base for fault secureness is 7 [10].

2.7

Residue Generator
can be implemented by splitting the bits into

The residue of a binary number modulo

bytes of k bits and performing modulo m addition of these bits. This means that residue generators of the form can be implemented with less cost as there is no need for

performing division. Modulo m addition of two k-bit is performed using a k-bit adder in which the carry output is used as a carry input for the next adder. This is basically what Carry EndAround adders do. So a residue generator block can simply be implemented by a tree of k-bit Carry End-Around adders without need to do any division [15]. For instance consider , then applying congruence theory the residue will be calculated as shown in equation (2.8)

Thus, the residue of powers of on. So a full adder can be used to add add

modulo 7 is 1.

and so

, and so on. Another full adder then must be used to

, and so on. In other word, the period of the bits is 3.

Modulo 9 also worth noting as the residue of 1, 8, 64, ... modulo 9 is +1, -1, +1, ...

21

Therefore,

has to be added. This operation can be done using a full adder

and inverting the bit that has to be subtracted. Figure 2.8 and 2.9, show residue generators for a 8-bit number modulo 7 and 9 respectively [10].

Figure 2 -8 8-bit number modulo 7

Figure 2 -9 8-bit number modulo 9 The overall block diagram of the self-checking multiplier using residue codes is shown in figure (2.10).

22

Figure 2 -10 Self-checking Multiplier

23

3. CHAPTER 3 APPLICATION OF RESIDUE CODES FOR ERROR DETECTION IN MIXED-SIGNAL SYSTEMS
3.1 Introduction

This chapter focuses on application of residue calculation for arithmetic and algebraic compaction, to test mixed-signal systems. General aspects of compression techniques are also discussed here. Several low-cost arithmetic and algebraic compactor schemes are introduced. The tolerance bounds for the result of compaction are estimated and the aliasing rate is evaluated.

3.2

General Aspects of Compression Techniques

Conventional testing methods involved bit-by-bit compression of the output with the correct values that has been previously computed. Clearly, this approach requires a significant amount of memory. An alternative approach is to save the information in a compressed format known as a signature [16]. This concept is illustrated in figure 3.1 [17]. If the signature obtained from the device under test does not match the pre-calculated signature of a fault-free circuit, then a fault is detected. A practical compression technique should be easily implemented and should not introduce signal delays.

24

Figure 3 -1 Test Data Analyzer The challenge facing this method is insuring that the faulty and fault-free signatures are different because, a fault may produce offsetting errors. The erroneous output response is said to be an alias of the correct output response. Three methods have been suggested in [7] to measure the aliasing associated with a compression technique: 1. Simulation of the circuit and the compaction technique which requires fault

simulation. If the test sequence is long this method is expensive. 2. In this method, output responses are classified into categories, such as single-bit

error or burst errors, which are errors that lie within a fixed number of patterns of one another.

25

3.

The fraction of all possible erroneous response sequences that cause aliasing are

computed. In this method it is assumed that all possible output sequences are equally likely.

3.3

Ones-Count Compression
, then in ones counting, the

If the output signature of a circuit is shown as signature of the response,

is the number of 1s appearing in . The compressor is a counter . Figure 3.2 describes testing with one-

[7] and the degree of compression is counting compression technique.

Figure 3 -2 One-Count Compression

3.4

Transition-Count Compression

In this method of testing, is the number of transitions in the output data stream. This means that for a sequence of [7]: , the transition count will be obtained from equation (3.1)

26

This implies that the response-compression circuit needs a transition detector, and a counter with shown in figure 3.3. stages. Transition detector consists of a flip-flop and a XOR gate that is

Figure 3 -3 Transition Detector

3.5

Parity-Check Compression

Parity-check compression circuit is also explained in [7]; it consists of D-flip-flop and XOR gate. Its implementation is a linear feedback shift register whose primitive polynomial is . If the initial state of the flip-flop is 0, the signature S is the parity of the circuit response. Same as it was said in the previous chapter, faults that create an even number of errors are not detected with this method. As the number of input streams increases, the probability of aliasing approaches to the value of 0.5. Figure 3.4 illustrates the parity-check compression scheme.

27

Figure 3 -4 Parity Check Compression Using parity-check compression for multiple-output circuits has two disadvantages. If it is implemented by replacing the input XOR gates by a multiple-input gate or a network of XORs, an error internal to a circuit may affect more than one output line and the error gets propagated to an even number of output lines. Also, if a separate parity-check compressor is used in each output, the hardware cost will be high. This means that this technique is not very efficient for testing multiple-output circuits.

3.6
Applying all

Syndrome Testing
test vectors to an n-input combinational circuit is called syndrome testing [7],

syndrome S (or signature) is the normalized number of 1s in the resulting bit stream. It means that if K is the number of minterms in the function f, then . The syndrome of a 3-input

AND gate is 1/8 and for a 3-input OR gate is 7/8. Any function can be realized in such a way that all single stuck-at faults is syndrome detectable.

28

If two circuits

and

have no shared input, and

and

, then the input-

output syndrome relation of the circuit as a function of the type of gates is listed in Table (3.1) [7]. Table 3 -1 Syndrome for circuit having non-reconvergent fanout Gate Type Syndrome S3 for C OR AND NAND NOR XOR

3.7

LFSRs Used as Signature Analyzers

Signature analysis is a compression technique based on the concept of cyclic redundancy checking (CRC) [18]. Signature generator with a single-input LFSR is the simplest scheme of this technique. The contents of this register are the signature after the last input bit has been sampled. Response sequence which is fed to the signature analyzer is denoted by sequence then will be divided by the characteristic polynomial denoted by . This

. This implies

that signature analysis is based on polynomial division; the "remainder" left in the register after completion of the test process is the final signature. This can be represented in the equation form of (3.2). (3.2)
29

Figure (3.5) from [7] explains how a single-input signature analyzer works.

, as was

defined previously, is the reciprocal characteristic polynomial of the LFSR; it is given in the example as:

The input is the 8 bit test sequence 11110101 which is equivalent to . As it is shown in figure 3.5, the result of division will be, . and

Figure 3 -5 Example of single-input signature analyzer

3.8

Multiple-Input Signature Registers

It is possible to test circuits that have multiple outputs using signature analysis technique. The most common way to do that is using a multiple-input (MISR) register which is shown in figure 3.6 [19]. The circuit is assumed to have n inputs; it operates similar to n-input signature analyzer.

30

Figure 3 -6 Multiple input register (MISR)

3.9 Arithmetic Compaction Circuits for Testing Mixed-Signal Systems
Many electronic systems, such as those for audio and image processing, video compression, speech recognition, digital communication etc., deal with signals that are mix of analog and digital nature. It is highly desirable to insure the reliability of these devices by detecting any faults as soon as they occur in the system and make sure that the system is immune to sudden or gradual failure. Gradual failures may remain unnoticed and become a greater threat in the future. To test this type of devices signature analysis method can be applied; analog stimuli can be used to cover nearly the full-scale range (FSR) of the device. Then the output responses in the digital form should be compared with the expected values. The comparison can be done after each test stimuli has been applied or after the complete test set has been run. If comparison is done after each test set is applied, the availability of memory will be an issue. Although performing the comparison after the full set of test stimuli has been applied might lead to undetected errors, since the error escape rate and the test hardware overhead are small, this method is considered more practical for built-in self-test [7]. Compaction methods are based on the estimation of the residue of an arithmetic sum which is referred to as the signature of output when the input is fed by test stimuli. The output signature
31

should be compared with the fault free circuit's signature and the fault signal should be generated if the error is out of the predefined tolerance bound. Erroneous patterns caused by modular operation which is called aliasing may go undetected. In the presence of analog circuits and an analog - to- digital converter aliasing phenomenon provokes, and produces errors which would distort the output codes and the compaction result. Therefore, compaction testing for mixed-signals deals with a set of permissible signatures, and not a single "reference" for digital systems. The cardinality of this set should be kept at a minimum in order to achieve a low aliasing rate [7]. Compaction circuits with an arbitrary modulus have been developed in this study. The set of permissible signatures that are within the tolerance bound from empirical data requires the availability of the reference system. So, the tolerance bound is computed analytically in this work to avoid the complexity.

3.10 Testing Mixed Signal Device
One approach to test mixed-signal system is based on the estimation of metrics such as gain, offset, INL, DNL, SNR, ENOB etc [20]. Although these static and dynamic metrics carry important information about the functionality of the system, however, their calculation involves extensive digital processing which would impose large overhead on the system and is not acceptable for built-in implementation. Figure 3.7 shows the scheme of on-line testing for an analog-to-digital converter device (ADC), using compression technique. As it is shown in the figure, the Test Pattern Generator (TPG) generates digital pattern that is send to the digital-to-analog converter (DAC) which is then feed to the Analog Comparator (AC). When the operational signal that is been fed to the
32

device under test matches the output of the DAC, then a passing signal is generated by the AC unit. This HIT signal activates the Modulo Adder block which is responsible for calculation of the residue which is also referred as a compactor or signature analyzer [7].

Figure 3 -7 On-line Testing of ADC Device Finding a real fault-free ADC device is a main challenge. Characteristic function of an ideal ADC is shown in figure 3.8. Another challenge which complicates the use of algebraic compaction for the scheme is caused by the uncertainty of the output coded voltage when an input voltage is in the interval that contains the middle point of the quantization bin; an interval code will be produced at the output, even though there is no fault. Testing of a 3-bit fault-free MSS with FSR of 8 volt, with a transfer characteristic shown in figure (3.8), using compression technique is analyzed here. Several compaction circuits for testing this ADC device will be presented in the next chapter.

33

Figure 3 -8 Transfer function of a 3-bit MSS The transfer function of the system is such that the transition voltages between the steps, T (k), k= 1,..., 2n-1 (n is the resolution of the MSS) may fluctuate within the specific tolerance bounds. Inequality (3.3) shows this bound.

If n= 3 bits then (3.3) will be simplified to (3.4):

The shaded boxes surrounding the ideal transitions show the bounds. Worst case happens when a and b coincide. If the input signal matches the middle points of the quantization bin, the output can take three values. For example if the stimuli match the middle point of 4 volt, the output will take three possible values 011, 100, 101. Excluding these points it can be assumed that test stimuli are in the neighborhoods of the corresponding transition voltages T (k) of the transfer function. With this assumption the number of acceptable output codes reduces to two per
34

input stimulus which leads to reducing the distortion of the final signature. For instance, if the input is set to be T (4) = 3.5 V, the output code will be 011 or 100. To develop a valid fault model it can be assumed that faults in a MSS would change the transfer function such that the transition points, T (k), move beyond the permissible bound, i.e. (k) < k-1, or T (k)>k. Also we assume that it can only be a single transition within each of the intervals of [k-1, k], Now with the fault model described above, all the faults will be detected by the input stimuli set, which only includes single points from each of the intervals.

35

4. CHAPTER 4 RESIDUE CALCULATOR CIRCUIT ARCHITECTURE FOR MIXED-SIGNAL SYSTEMS
4.1 Operation of Arithmetic and Algebraic Compactor
Algebraic and arithmetic compactors are the two types of compactors that can be applied for testing circuits. Both methods utilize the same theory of computing the residue. The arithmetic compactor is referred to as the modulo sum circuit. Modulo sum is just a special case of a residue code.

4.2 Operation of Arithmetic and Algebraic Compactor
The operation of the algebraic compactor can be explained by a n-input analyzer. Assuming that the MSS produces all n bits simultaneously, a multiple input signature register (MISR) can be considered. In this study a 3-input signature register is examined which receives for example the following sequence of 3-bit data, 4, 2, 1, 0. This sequence of data can be described by expression (4.1) [7]: ( is equal to y+, where  is the primitive element of the field example  is considered as the root of the primitive polynomial . In this . Expression

(4.1) can be implemented using an iterative addition and shift operation by factorizing it:

36

In general form expression (4.2) can be considered as a set of repetitive operation of the form of expression (4.3):

Figure 4 -1 Operation of the 3-input signature register

Figure (4.1) shows the operation of MISR for implementing expression (4.3). The operation can be performed using theories of polynomial division in expression (4.4): that was introduced before as

+

=

+

Figure 4.2 shows the register transfer level (RTL) scheme of 4.1. This circuit will produce as its signature which is equivalent to 010 in vector form.

37

Figure 4 -2 3-Input Residue Calculator in RTL Form Another form of compactor circuit is called an arithmetic compactor which works similarly to the algebraic one. The difference is that here the circuit divides the input sequence by the number where 3 is the primitive element of the arithmetic finite field GF(5) .This is similar to the algebraic circuit that divides the input sequence by the polynomial of G(y) = y- . Considering the same example if the sequence of and is matched with numbers

6, 4, 2, and 1 which are fed to the compactor circuit, performing division of the octal number 6421 with respect to modulo 5. Expression (4.5) illustrates the same compression procedure in an arithmetic circuit. Figure (4.3) shows a symbolic form of this operation. (8(8(8(8.0+6)+4)+2)+1)mod5 (4.5)

38

Figure 4 -3 3-Input Arithmetic Compactor Considering the special case of algebraic and arithmetic compactors when  and 3 are replaced by 0; then for both compactors the same circuits will be obtained which does not have feedbacks. The probability of the undetected error for this circuit is same as the one with feedback. Also a case can be considered where  and 3 are both replaced with 1. To implement the residue calculation circuit (RCC) in a general form, equation (4.6) should be considered. (4.6) Taking to account expression (4.6), RCC can be implemented as it is shown in figure 4.4.

Figure 4 -4 3-Input Ternary Arithmetic Compactor

39

C is a combinational circuit unit which provides feedback signals

based on the

input and the present state signals t and r respectively. Red arrows show the carry propagation. can be obtained from equation (4.7), (4.8), and (4.9).

If this circuit is fed by sequence of 3-bit octonary numbers 6, 4, 2, 1, applying equation (4.6), it can be said that the circuit is computing the residue of the ternary number 6421 .

4.3

Low-Cost Compactor schemes

Now, if the RCC scheme shown in figure (4.4) is used as a compactor for a MSS, any distorted response will be fed back to the compactor, and then the distortion of each response will grow as it is multiplied by rising power of 8 or 3. Equation (4.10) explains this fact. This implies that the distortion of the final signature and consequently the aliasing rate will increase. However, in algebraic compactor, as shift is equivalent to multiplication by , n being the size

of the analyzer, the distortion of the feedback is not a significant problem. This problem with arithmetic compactor can be alleviated by adjusting the modulus such that the error will increase by power of 1 only as it is shown in equation (4.11).

40

So a compactor scheme that multiplies data by raising power of 1 or -1 will reduce the error. When 3 is replaced with -1, the resultant circuit is safe from any offset existing in the incoming data or to unidirectional noise that might exist in the testing medium. The feedback signal is generated based on equation (4.12) in the combinational unit shown by C:

Figure 4.5 shows the alternative compactor which was proved to have the minimum uncertainty.

Figure 4 -5 An Alternative 3-Input Arithmetic Compactor

4.4

Compaction Process
, where n is the resolution of the MSS, is can have which is . The actual output

The process of arithmetic compaction modulo analyzed here. Let

be the number of distinct values the input signal is the value of at time

sufficient to detect all faults of MSS. Assume code corresponding to the input value

will be shown as expression (4.13):

41

is equal to 1, ..., m, and integer number less than x.

is the width of the quantization bin. [x] represents the largest is the static error.

is the ideal output code and

Let the lower and upper tolerance bounds be or, Where and

respectively. So for the fault-free MSS:

Now the result of adding all the output codes will be expression (4.14):

Let

,

, and .

Using the notations introduced above, it can be obtained that

is calculated using the transfer function the ideal MSS. Assuming symmetrical MSS, i.e. , for every i = 1, ..., m.

Now performing the modulo addition operation and introducing new notations shown as equation (4.15), and (4.16):

It can be shown that the MSS will be faulty if inequality (4.17) is hold [7]:
42

Otherwise it can be assumed that the MSS is fault-free and signature. Assuming that the actual signature is the fault-free circuit belongs to one of the intervals of

is the correct

mod L, and then the signature of , or [ .

The residue R is computed in the adder that is previously loaded with the two's complement value of . The two's complement .

So equation (4.17) can be written in the following form:

The ratio of the number of all undetectable errors in the output response, to the number of all possible errors of that response is defined as the estimated aliasing rate for an ADC. For an ideal ADC, the output response contains bits which will be compacted into n bits.

Consequently, the number of faulty bit streams that will go undetected by producing the correct signature is . Considering that there are erroneous streams, according to the

definition of the aliasing rate that was said before, the aliasing rate for the system tested by the modulo adder method will be approximated by expression (4.19).

(4.19)

For a non-ideal ADC the number of faulty streams going undetected because of producing the correct signature would be expressed as the form (4.20).

43

Total number of erroneous streams will be obtained as (4.21):

The aliasing rate

will be obtained from (4.22):

When the nominal value of the test signal lies at the middle point of the quantization bins, equation (4.19) and (4.22) becomes expression (4.23) and (4.24):

When the stimuli that matches the ideal transitions of the transfer characteristic is fed to the ADC expression (4.23) and (4.24) will be simplified to the form of (4.25) and (4.26):

If

is much larger than the value of (m+n), then

can be estimated as

. It is easy to

see that the aliasing rate decreases when the resolution of the device increases or, when the size of the modulo adder increases. It should be noted that if the errors at the output of the ADC are equally likely, changing the value of m does not have much effect on the aliasing rate.

44

5. CHAPTER 5 SIMULATION AND ANALYSIS OF THE RESULTS
5.1 Simulation

As it was discussed in the previous chapter, the only modulus that can be used for testing ADC using compaction method are the ones in the form of . These are the only modulus

that will prevent the growth of error caused by noise in the circuit. Simulation was planned based on the analysis that was done for 3-input arithmetic compactor. Although other modulus can be used for checking arithmetic circuits, for testing ADC modulo 7 and 9 were considered for simulation. Simulation results were generated using ModelSim-Altera and implemented on an FPGA board from Altera. Figure 5.1 shows the result for a random 3-bit input signal B. The content of the signature register is a 3-bit signal Z. The carry-out signal is registered and `000' pattern is applied at the end. The input sequence are, (101), (110), (011), (101) equivalent to 5635 in decimal. Now using arithmetic compaction circuit introduced before, the residue of this number in base 8 modulo 7 would be (5+6+3+5) modulo 7 which is equal to the sequence (101) equal to 5 in decimal.

45

Figure 5 -1 RCC with Modulo 5 Adder Figure 5.2 shows the result of calculating the residue of number modulo 5. The result

of this operation is 0. The VHDL code that generated the combinational unit for this circuit based on the input and present state signal (t and r) can be seen in the appendix section of the report.

Figure 5 -2 Arithmetic Compaction Circuit modulo 5

46

Figure 5.3 shows the low distortion modulo adder which is when modulus is number 9. In this simulation number modulo 9 was tested. The final value of the register is 8 (or -1). This

circuit is the alternative compaction circuit that was introduced in the previous chapter. This scheme is immune to offset of the incoming data as well as noise of the testing environment. The VHDL code that generated the combination unit for this scheme is also provided in the appendix.

Figure 5 -3 Arithmetic Compaction Modulo 9 Now consider a 3-bit ADC under test. It is known that two analog stimuli are enough to detect any fault in the ADC [16]. If these input signals cause the ideal ADC to produce 101 and 110 at the output, then a real non-faulty ADC with intervals of [100,110] and [101,111]. It is assumed in the simulation that a fault introduces an offset of -001 to the output codes of the ADC. Also, these codes are affected by noise which is uniformly distributed such that the first code is increased by 010 and the second code is decreased by 010. The resultant output code will be 101-001+010=110, and 101-001-010=010. In this case the seed value loaded to the signature register would be: signature will be: and =011. Consequently the actual permissible error will produce codes from the

As it can be seen, the actual signature does not drop into these intervals which means that the ADC is faulty. The simulation result can be seen in figure 5.4

47

Figure 5 -4 Testing an ADC with Offset Figure 5.5, 5.6, and 5.7 show the RTL form of the simulated circuit of 5.1, 5.2 and 5.3 respectively. As it is clearer in the RTL form of the circuits, the input signal goes into the combinational unit which feeds into the adder. In each clock cycle the register gets updated and the final residue will be saved as the signature of the circuit.

Figure 5 -5 RTL form of modulo adder with Combinational Unit

48

Figure 5 -6 Compaction Circuit calculating modulo adder of a ternary number

Figure 5 -7 An alternative modulo adder

Figure 5 -8 Implementation of the Modulo adder
49

A compaction process was examined for an ADC which is a mixed-signal system. Several compaction schemes were verified with simulation which proved the validity of the theoretical results. Tolerance bounds for a fault-free ADC signature were analytically evaluated in the previous chapter. Modulo 9 and 7 which are in the form of would detect all single errors [16] with a low aliasing rate. for a 3-bit resolution ADC

50

6. CHAPTER 6 FUTURE WORK AND CONCLUSION
Residue codes which are a class of separable arithmetic codes, are finding more application in digital testing specially self-checking designs. Other types of codes including, parity codes, and Berger codes have been also utilized in previous literature for testing arithmetic operations. High implementation cost related to residue codes has been always a concern. However, because of the simplicity and separability of this type of codes, and the fact that they are closed under operations such as addition and multiplication they are still popular. In particular it has been shown that in case of multipliers it is better to use residue codes for error protection. This project has developed the theoretical knowledge needed to achieve cost efficient, reliable and fault secure circuits based on residue codes. More importantly this work intends to be the platform for studying the effectiveness of arithmetic and algebraic compaction method for testing mixed signal devices such as analog-to-digital converters. Application of residue testing method, for on-line error detecting in an ADC was introduced in this project. Different compaction schemes that can be used for testing digital as well as mixed-signal system were presented. According to this testing method, a faulty circuit can be identified if the result of the output signature does not exist in the predefined permissible interval. Compactor schemes with different modulo adders where analyzed and simulated to find an arithmetic compacting circuit with the minimal uncertainty. The circuits were simulated for a 3 bit data in ModelSIM and the scheme of the RTL form of the circuits were presented in the report. The tolerance bounds for the signature and the aliasing rate of the circuit were obtained. It was shown that the aliasing rate decreases if the resolution of the ADC increases. If the ADC can

51

perform a direct-conversion, the binary counter of this ADC can be used as a signature compactor. Such an ADC in the testing mode is going to reset after a series of conversions is performed for the entire sequence of test stimuli. Modulo of the form are the most important ones for they are considered cheap and will detect all the single

easy to implement. Similarly compaction modulo of the form

errors that would affect all bits except the least significant bits of the word [16]. Future work to complement this work would be to implement the compaction circuits to verify a more accurate evaluation of time delay, overhead, and fault secure property of the circuit. Ultimate goal would be to optimize RCC design so that it can be used for efficient modulo 1 multiplier and testing arithmetic operations.

52

7. APPENDIX
Part of the VHDL code that generated the combinational unit of figure 5.2, and 5.3 in chapter 5 are shown here. Code of the modulo adder circuit is also shown here.

53

54

8. REFERENCES
[1] I.L Sayers, D.J Kinniment, E.G Chester, "Design of a reliable and self-testing VLSI datapath using residue coding technique ," Devices,Vol. 133, pp.129-140, 1986. [2] U. Sparmann, S.M. Reddy, "On the effectiveness of residue code checking for parallel two's complement multipliers," IEEE Transactions on Very Large Scale Integration (VLSI) Systems, Vol. 4, pp.227-239, June 1996. [3] M. Mahoney, DSP-Based Testing of Analog and Mixed-Signal Circuits. Los Alamitos: IEEE Computer Society Press, 1987. [4] C. Stroud, J. Morton, T. Islam, H. Assaly, "A mixed-signal built-in self-test approch for analog circuits," Soutwest Symposium on Mixed-Signal Design, pp.196-201,2003. [5] V. Geurkov, L. Kirischian, "A Concurrent Testing Technique for Analog-to-Digital Converter ," IEEE Mixed-Signals, Sensors and Systems Test Workshop,pp.133-136,2011. [6] B. Schneier. Applied Cryptography. John Wiley & Sons, Inc., second edition, 1996. [7] M. Abramovici, M. Breuer, A. Friedman. Digital Systems Tesing and Testable Design . Wiley-IEEE Press, NewYork, 1994. [8] W. Hong, R. Modugu, M. Choi, "Efficient Online Self-Checking Modulo 2n-1 Multiplier Design," IEEE Transactions on Computer, vol. 60, pp.1354-1365,2011 [9] S. Bayat-Sarmadi, "Concurrent Error Detection in Finitr Field Arithmetic Operations," University of Waterloo, 2007 IEE proceedings I Solid-State and Electron

55

[10] A. I. Noufal and M. Nicolaidis, "A CAD framework for generating self-checking multipliers based on residue codes," IEEE Conference on Design, Automation and Test, pp. 122129, 1999 [11] P.E. Beckmann and B.R. Musicus, "Fast Fault -Tolerant Digital Convolution Using a Polynomial Residue Number Systems," IEEE Transaction on Signal Processing, vol. 41, no. 7, pp. 2300-2313,1993 [12] M.B. Sullivan, "Aplication of Residue Codes for Error Detection in Modern Computers," Texas, 2010 [13] T.R.N. Rao and E. Fujiwara. Error-Control Coding for Computer Systems. Prentice-Hall, 1989 [14] J. Cavanagh, Computer Arithmetic and Verilog HDL Fundamental, CRC Press, Taylor & Francis Group, 2010 [15] U. Sparmann, S.M. Reddy, "On the effectiveness of residue code checking for parallel two's complement multipliers," IEEE Transactions on Very Large Scale Integration (VLSI) Systems, Vol. 4, pp.227-239, June 1996 [16] V. Geurkov, L. Kirischian, "A Concurrent Testing Technique for Analog-to-Digital Converter ," IEEE Mixed-Signals, Sensors and Systems Test Workshop, 2011 [17] S. Das, M. Sudarma, M. Assaf, W. Jone, K. Chakrabarty, and M. Sahinoglu, "Parity Bit Signature in Response Data compaction and Built-In Self-Testing of VLSI Circuits With Nonexhaustive Test Sets,"IEEE Transaction on Instrumentation and Measurment, Vol. 52,pp.1363-1380, October 2003 [18] W. Peterson and E.Weldon, Error Correcting Codes, Cambridge, MA: The MIT Press, 1972
56

[19] S. Z. Hassan, D.J. Lu, and E.J. McCluskey, "Parallel Signature Analyzers," 26th IEEE Computer Society Intn'l. Conf., COMPCON, Spring 1983, pp.440-445, 1983 [20] M.Mahony, DSB-Based Testing of Analog and Mixed-Signal Circuits. Los Alamitos: IEEE Computer Society Press, 1987

57

