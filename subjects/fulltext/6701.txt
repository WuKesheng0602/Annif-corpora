b d J '1cJ 13 J9

TK
':Hi?
, ~"-l~

tJ ~ '!
2':) l \

ENHANCING BROADCAST AUTHENTICATION IN SENSOR NETWORKS

Arayeh Norouzi Honours BSc, Computer Science, York University, Toronto, Canada, 2002 A project presented to Ryerson University

in partial fulfillment of the requirements for the degree of

MASTER OF ENGINEERING
in the Program of

ELECTRICAL AND COMPUTER ENGINEERING
from the

RYERSON UNIVERSITY
Toronto, Ontario, Canada, 2011 ©(Arayeh Norouzi) 2011

n'f'::R~~:~ l~·:;:'Jt:fi.ilY·UBRI'RV'

pP.Oi-EP.TY OF

....

THIS PAGE INTENTIONALLY LEFT BLANK

11

I hereby declare that I am the sole author of this project.

I authorize Ryerson University to lend this project to other institutions or individuals for the purpose of scholarly research.

'--

Arayeh Norouzi

I further authorize Ryerson University to reproduce this project by photocopying or by other means, in total or in part, at the request of other institutions or individuals for the purpose of scholarly research.

"-------

-

~

Arayeh Norouzi

iii

ENHANCING BROADCAST AUTHENTICATION IN SENSOR NET\VORKS

by Arayeh Norouzi Master of Engineering, Electrical and Computer Engineering, Ryerson Univ~rsity, 2011 Supervisor: Dr. Truman Yang

ABSTRACT
Due to the nature of wireless sensor networks, security is a critical problem since resource constrained and usually unattended sensors are much vulnerable to malicious attackers that may impersonate the sender. Therefore authenticating received messages is a crucial matter to protect the system integrity. Generally used TESLA (Timed Efficient Stream Loss-tolerant Authentication) based authentication techniques involve consecutive delays for decryption purposes. These delays render the network vulnerable to different malicious attacks such as Denial of Service attack. As several techniques try to achieve immediate authentication to alleviate these threats, other factors such as reliability and buffer requirements may have been compromised. This project proposes an integration of Low Buffer ,uTESLA protocol and an immediate authentication protocol to achieve a new refined scheme in broadcast authentication in sensor networks. Performance analysis and simulation results demonstrate that the proposed method succeeds to achieve immediate authentication while preserving desired security and low memory requirements in sensor nodes.

iv

TABLE OF CONTENTS
CHAPTER I: INTRODUCTION ................................................................................................ 1
A. B. C. PROJECT OBJECTIVE ...................................................................................................... 1 RELATED WORK ............................................................................................................. 2 PROJECT ORGANIZATION ............................................................................................ 4

CHAPTER II: AUTHENTICATION IN SENSOR NETWORKS .......................................... 5
A. B. C. D. NETWORK SECURITY CONCEPTS ............................................................................... 5 DATA AlTTHENTICATION ............................................................................................. 6 TESLA-BASEDBROADCAST AUTHENTICATION OVERVIEW .............................. 7 SHORTCOMINGS OF TESLA-BASED TECHNIQUES ................................................. 9

CHAPTER III: PROTOCOLS .................................................................................................. 10
A. REDUCINGIlTESLA MEMORY REQUIREMENTS .................................................... 10 B. IMMIDIATEAUTHENTICATION ................................................................................. 10 C. NEW PROTOCOL: RELIABLE, LOW BUFFERING IMMIDIATE AUTHENTICATION ............................................................................................................... 12

CHAPTER IV: OPNET MODELER OVERVIEW ................................................................ 15
A. B. WORKFLOW ................................................................................................................... 15 EDITORS .......................................................................................................................... 15 Project Editor.................................................................................................... ............ 15 Node Editor ................................................. .................................................................. 16 Process Editor .......................................................... .................................... '" .............. 16 OBJECT TYEPS ............................................................................................................... 18 NetworkModel ................................................ .............................................................. 18 Node Model .............................................................. ..................................................... 18 Process Model ....................................................... ........................................................ 19

1. 2. 3.
C.

1. 2. 3.
A. B. C. D.

CIIAPTER V: OPNET SIMULATION .................................................................................... 20
TRANSMITTER............................................................................................................... 21 RECEIVER ....................................................................................................................... 23 FIRST SCENARIO (IMMEDIATE AUTHENTICATION PROTOCOL) ...................... 25 SECOND SCENARIO (PROPOSED PROTOCOL) ........................................................ 27

CHAPTER VI: SIl\IULATOIN RESULT ................................................................................ 30 CHAPTER VII: CONCLUSION ............................................................................................... 37
A. B. CONTRIBUTIONS OF THIS PROJECT ......................................................................... 37 RECOMMENDATIONS FOR FUTURE WORK ............................................................ 38

APPENDICES: SOURCE CODE FOR SECOND SCENARIO ............................................ 40
APPENDIX A: TRANSMITTER SOURCE CODE ................................................................. 40 APPENDIX B: RECEIVER SOURCE CODE .......................................................................... 70

LIST OF REFERENCES ........................................................................................................... 91

v

LIST OF FIGURES
FIGURE 1. FIGURE 2. FIGURE 3. FIGURE 4. FIGURES. FIGURE 6. FIGURE 7. FIGURE 8. FIGURE 9. FIGURE 10. FIGURE 11. FIGURE 12. FIGURE 13. FIGURE 14. FIGURE 15. FIGURE 16. FIGURE 17. FIGURE 18. FIGURE 19. FIGURE 20. FIGURE 21. FIGURE 22. FIGURE 23. FIGURE 24. FIGURE 25. FIGURE 26. TESLA KEY CHAIN (FROM REF.

[5]) ........................................................................... 8

IMMEDIATE AUTHENTICATION PACKET EXAMPLE (FROM REF. [2]) ........................... 12 IMMEDIATE AUTHENTICATION PACKET EXAMPLE ...................................................... 13 IMMEDIATE AUTHENTICATION OF THE NEXT PACKETS TO COME ................................ 14 MODELER WORKFLOW (FROM REF. [38]) ................................................................... 15 HIERARCHICAL LEVELS IN MODELS (FROM REF. [39]) ............................................... 16 THREE-TIERED OPNET HIERARCHy .......................................................................... 17 PROJECT EDITOR - NODE IN NETWORK MODEL .......................................................... 18 NODE EDITOR - MODULES IN NODE MODEL .............................................................. 19 PROCESS EDITOR- STATES IN PROCESS MODEL ......................................................... 19 PROJECT MODEL CONSISTING OF A TRANSMITTER AND A RECEIVER .......................... 21 NODE MODEL FOR THE TRANSMITTER NODE .............................................................. 22 PROCESS MODEL FOR THE TRANSMITTER PROCESSOR MODULE ................................. 23 NODE MODEL FOR THE RECEIVER NODE ..................................................................... 23 PROCESS MODEL FOR THE RECEIVER QUEUE MODULE ........ , ....................................... 24 FLOWCHART OF STATE TRANSITION OF A RECEIVER NODE ......................................... 25 SCENARIO 1 ............................................................................................................... 27 SCENARIO 2 ..................................................................... :......................................... 28 SCENARIO 2 - FUNCTION BLOCK OF THE TRANSMITTER NODE .................................... 29 RESULT BROWSER ...................................................................................................... 30 SCENARIO 1- QUEUE SIZE STABILIZES AT AROUND 330 BITS ..................................... 32 SCENARIO 2 - QUEUE SIZE STABILIZES AT AROUND 70 BITS ....................................... 32 SCENARIO 1 - QUEUING DELAY STABILIZES AT 52.5 SECONDS ................................... 34 SCENARIO 2 - QUEUING DELAY STABILIZES AT 33 SECONDS ...................................... 34 COMPARISON OF AVERAGE QUEUE SIZE IN BOTH SCENARIOS ...................................... 36 COMPARISON OF AVERAGE QUEUING DELAY IN BOTH SCENARIOS .............................. 36

vi

ACKNOWLEDGMENTS

I would like first to express my appreciation to Dr. Truman Yang, my project advisor, and my co-advisor, Dr. Abdolreza Abhari for their guidance through the completion of this project.

I would also like to thank my other professors whose valuable courses I have taken throughout the years at Ryerson University.

Lastly, and most importantly, I wish to thank Farzin, Mauna, Nima and my parents for their patience and their presence. I would love to thank Farzin for his greatest and unconditional support in all aspects of my life, especially during the course of my studies. He is the best thing that has happened to me in life. This project is dedicated to all my family.

vii

THIS PAGE INTENTIONALLY LEFT BLANK

viii

CHAPTER I:

INTRODUCTION

Wireless sensor networks (WSNs) are a novel paradigm for large distributed systems. They consist of many small sensing devices which are spread over large geographic areas and are used to collect and process different data. Sensor networks offer economic solutions to challenging problems such as traffic monitoring, environment data gathering, medical monitoring, industrial automation and homeland security. The sensor nodes in WSN are usually battery-powered and resource-restricted and often operate with more powerful base stations that serve as network bridges and provide computational resources and collect data [6]. Securing wireless sensor networks is an essential and on-going issue due to their critical applications. Nature of wireless communication in sensor networks makes it easily vulnerable to attackers that aim to inject malicious data or change legitimate messages [4, 10]. Therefore these applications need to employ efficient and reliable authentication mechanisms to ensure received data originated from a valid source and was not altered maliciously along the way [3].

Recently proposed TESLA (Timed Efficient Stream Loss-tolerant Authentication) based techniques [2] have embarked on resolving the authentication problem by employing symmetric encryption and achieving the desired security level by mimicking asymmetric encryption through delayed key disclosure. The suggested delay renders the network vulnerable to Denial of Service attack since an adversary can flood the nodes by sending bogus messages and forcing the sensors to buffer the messages until they receive the corresponding delayed keys.

A.

PROJECT OBJECTIVE

The objective of this project is to propose an integrated scheme to be able to perform broadcast authentication in sensor networks without delay while improving receiver buffer requirements. The immediate authentication will increase system resistance against malicious attacks such as Denial of Service attack. Furthermore, reducing receiver buffering offers an advantage to the system due to resource-restrained nature of sensor nodes. In this project two various versions of ,uTesla protocol are incorporated as a new authentication scheme. Analysis

1

and the result of project simulation that has been implemented in a network modeler are included to demonstrate the enhanced buffer size and system delay of the proposed scheme.

B.

RELATED WORK

Many security protocols have been proposed to ensure data integrity, confidentiality and authenticity throughout sensor networks. While some protocols like SNEP (Secure Network Encryption Protocol) mentioned in [3] that propose to provide two-party authentication along with data confidentiality and data freshness, others intend to provide broadcast authentication.

,uTESLA-based techniques and digital signatures are two general approaches to deliver broadcast authentication. However, both these methods are vulnerable to DoS attacks. In signature-based systems an attacker can forge a large number of broadcast messages with digital signatures and force the nodes to verify these signatures and eventually deplete their resources. Similarly due to the delay existing in ,uTES LA-based systems, a receiver cannot authenticate a packet immediately after receiving it and the adversary can flood the system by reusing the same key to forge many packets and exhaust sensor nodes' battery power. On-going research is being done to enhance both schemes.

The approach offered in [8] intends to mitigate DoS attacks against both signature-based and ,uTESLA-based broadcast authentication. The scheme uses an efficiently verifiable weak authenticator along with broadcast authentication. Each sensor performs the expensive signature verification or packet forwarding only when the weak authenticator is verified. A message specific puzzle is formed for the weak authentication and a computationally powerful sender with sufficient power supply is needed for this technique. The formation and solving the puzzle requires all nodes to acquire additional parameters and computational capabilities which are rare commodities in resource-restricted low-battery sensor nodes.

Unlike general TESLA-based protocols that use loosely synchronized clocks, a protocol called TIK (TESLA with Instant Key disclosure) proposed in [16] offers to eliminate the authentication delay by using tightly synchronized clocks within the sensor nodes. Extremely

2

precise timing allows the sender to even disclose the key in the same packet that carries the corresponding message authentication code. This enables the sender to produce receiver-specific keys. The use of tight time synchronization in this system requires a highly reliable network environment and therefore seems not feasible in unattended and usually harsh geographic conditions.

Low capacity sensor nodes reqmre little buffering on the receiver side. Low-Buffer ,uTESLA protocol stated in [1] intends to swap receiver buffering with the sender buffering which is usually a more powerful base station. In this scheme, the Message Authentication Code or MAC that is used for encryption purposes and is a shorter version of the original message is sent instead of the longer message. This will allow the receiver to buffer the MAC only and wait for the message with corresponding key in a later interval to authenticate the packet. Once the message and the key are received, the corresponding MAC is popped from the queue and the message is authenticated.

Mechanism of ,uTESLA authentication technique involves consecutive delays for key revealing purposes. This renders the distributed sensor network vulnerable to outside attacks. A malicious attacker might impersonate the authentic sender and transmit forged packets. This makes immediate authentication a beneficial commodity to remove the risk of various attacks such as DoS attacks. The scheme cited in [2] proposes a new technique to achieve immediate authentication and remove the delay existing in original,uTESLA technique. They, too, propose to replace receiver buffering with sender buffering. They include the hash of the message of a future packet in the current packet. Once the current packet is authenticated on the receiver side, the message in the future packet is also immediately authenticated.

This project intends to incorporate some of offered authentication solutions to attain a refined and highly reliable authentication mechanism in wireless sensor networks. Among all protocols, ,uTESLA-based technique proves to be more viable and realistic in the unfriendly surroundings of the resource-limited sensor nodes. This project embarks on creating an enhanced version of this technique to make the system resilient to DoS by providing instant authentication while considering the low-capacity requirements of the sensor nodes. To achieve this objective, 3

this work specifically intends to integrate Low-Buffer ,uTESLA protocol with the immediate authentication TESLA protocol to produce a more reliable system. This incorporation preserves the desired security of the original TESLA and the sought after immediate authentication while considering low memory requirements of the resource-constrained sensors.

C.

PROJECT ORGANIZATION

This project is organized as follows. Chapter II give an overview of data authentication and TESLA-based authentication mechanism in sensor networks. This chapter also discusses the shortcomings of TESLA-based authentication techniques. Chapter III addresses two different TESLA authentication protocols that propose to implement Low-Buffer ,uTESLA protocol and immediate authentication scheme. Furthermore, this chapter introduces the new integrated protocol that incorporates the two previously stated schemes. An overview of the network modeler OPNET is given in chapter IV. Chapter V describes the OPNET simulation of the new protocol. This chapter describes the two scenarios that have been implemented in the simulator in order to investigate the efficiency and performance of the new scheme compared with the previous protocols. Chapter VI examines the performance of the proposed protocol through analysis and simulation and illustrates result graphs obtained by two scenarios. Chapter VI provides conclusions ofthe project as well as recommendations for future work.

4

CHAPTER II:

AUTHENTICATION IN SENSOR NETWORKS

Sensor network is an unsupervised distributed system that is much vulnerable to outside attacks. Receiving authentic messages from base station is vital and critical in fragile information gathering. Authenticating senders is a way to ensure system integrity and reliability.

A.

NETWORK SECURITY CONCEPTS

Network systems are generally susceptible to different security issues such as interruption, interception and modification. Interruption is an attack on the availability such as cutting a communication link. Interception is an attack on confidentiality where an unauthorized party gains access to an asset such as wiretapping. Modification is an attack on the integrity of the system where an unauthorized party tampers with an asset such as changing values in a file. To alleviate some of these attacks, encryption algorithms and digital signatures are two cryptography techniques that are used to ensure data confidentiality and data integrity respectively. Encryption algorithm scrambles messages such that only the intended receiver can unscramble them. Encrypted message is generated by encryption function and the original message is extracted by decryption function, and a key is used to control these functions. The key is a sequence of random numbers that has a value from 0 to 255 bytes. The encryption algorithm determines key's length. The key ought to be truly random and long enough so that an attacker cannot exhaust all possible combinations. [37]

Encryption algorithms are used to ensure data confidentiality in a system. Symmetric and asymmetric key algorithms are two classes of encryption algorithms. In symmetric scheme, a shared key is used for both encryption and decryption, whereas a pair of keys is used in asymmetric mechanism. A public key is used in the encryption function and a private ,key in the decryption algorithm. Asymmetric cryptography as opposed to symmetric mechanism is more secure while it requires more computation and storage and its process takes longer. The encryption algorithm used in this project is symmetric HMAC (Hash-based Message Authentication Code) which is a hash function that is using a shared key to be produced. 5

However, the desired security that is lacking in symmetric scheme is achieved by disclosing the corresponding key with a delay.

Hash functions or digital signature are used in order to preserve data integrity. A hash function is a method that is applied to a piece of data to turn it to a definite-size small number serving as a digital fingerprint or the message digest. Changing one bit of data results in a complete alteration of the achieved hash value. MD5 and SHA-l are two most-commonly used hash functions. To make the system resilient to interception and modification, every message is accompanied by its hash code. If the sender and the receiver's hash are not equal, the message was altered along the way.

A digital signature is a number attached to a message. A hash function using the pub"lic key of the receiver is used to encrypt the message to produce the signature and the receiver's private key is used to decrypt it. If the message that is obtained by decrypting the signature matches the sent message, the integrity of the data has been preserved and message is considered genume.

B.

DATA AUTHENTICATION

An authentication protocol is a process that is designed to decide if a party is, in fact, who it declares to be. Asymmetric key authentication protocols use public key encryption and they are certificate based. These protocols are ideal for secure communications with a large variable user base that are not known in advance and where it is hard to distribute a shared key. On the contrary, symmetric key authentication protocols use secret key encryption and usually rely on a trusted third party that should be available at the time. This protocol is ideal for networked environments where all service and users are known in advance. [37]

Data could be authenticated through a purely symmetric technique in a two-party communication scenario or in a point-to-point authentication. The sender and receiver share a secret key to compute a cryptographic message authentication code (MAC) over all messages [3,5]. MAC can be efficiently implemented on resource-constrained sensor network nodes. The

6

sender uses the shared key to run the MAC algorithm on the message and sends the result code along with the original message. The receiver computes the algorithm over the received message and accepts the message if the result code is the same as the one received from the sender.

This efficient method is not secure enough when a sender wants to broadcast an authentic message to non-trusting receivers since any of the receivers know the shared MAC key and can impersonate the sender and forge messages to other receivers. Moreover, the traditional asymmetric techniques that use digital signatures for authentication have high computation, communication and storage overhead rendering them impractical for the resource-constrained sensor nodes [8]. The efficiency of the symmetric technique that is preserved by constructing authenticated broadcast from purely symmetric primitives could be integrated with the security of the asymmetric technique that could be mimicked by introducing asymmetry through delayed key disclosure and one-way function key chains. The integrated authentication method or the TESLA-based technique aims for the simultaneous efficiency and security of the sensor networks in a resource constrained environment.

C. TESLA-BASED BROADCAST AUTHENTICATION OVERVIEW
If immediate authentication is not required, TESLA-based authentication technique is the recommended protocol that provides efficient broadcast authentication. All receivers are loosely time synchronized with the sender up to some errors. The sender splits up the time into uniform intervals and assigns a different key to each interval. It forms a one-way key chain by randomly choosing the key for the last interval and repeatedly applying a one-way hash function to derive the keys for the earlier intervals. Keys are revealed by the sender after an assigned disclosure delay of some number of intervals. The MAC of a message which is computed by the key of the current time interval is appended to the message and sent to the receiver. [3,4, 5, 6, 9] The same packet (in case of TESLA) or a special packet (in case of Il TESLA) also reveals the .key for an assigned earlier interval [9].

The receiver that has buffered the message of the earlier interval pops it and verifies the MAC with the revealed key and buffers the current message to wait for the corresponding key 7

that will be disclosed after the next disclosure delay in future. Assuming a key disclosure delay of two time intervals, figure 1 shows that the sender uses key K i+1 to compute the MAC of the message Mj +3 and reveals the key K i- 1 in the same interval. [5]

Ki-1
Interval i -1

...

F(k;) K;

...

F(k i+1) Ki+1

...

F(k i+2} Ki+2

...

F(ki+3J

~

Interval i

Interval i + 1

Interval i +2

Time

GJ

I Mfrl IIMfr21

I Mfr3 1 IMi+4 11 Mfrsil Mi+6 1

Figure 1.

TESLA key chain (From Ref. [5])

Because all sensors are loosely synchronized and the receiver knows the schedule of disclosing keys, it can verify that the MAC key is still secret. When receiver is assured that the MAC key has not been yet published, it buffers the message for later verification. Using selfauthentication, one way hash function and previously released keys each receiver can check if the disclosed key is correct. It can also use the key to verify the MAC of the buffered message. If channel is lossy or jammed and some keys are lost, they can be re-computed using later keys to check the authenticity of the earlier messages.

Prior to data transmission, all necessary initial parameters such as key disclosure delay and the duration of an interval must be deployed among all sensor nodes.

j.lTESLA is an extension to TESLA [2]. The only difference between TESLA and j.l TESLA is how the first key in the key chain which is called key chain commitment is distributed among the sensor nodes. TESLA uses expensive asymmetric cryptography to bootstrap new receivers, while j.lTESLA employs symmetric cryptography with a master key shared between the sender and each receiver to bootstrap the new receivers individually. In this arrangement, each node sends a request to obtain initial parameters. Once the request is received,

8

sender transmits a packet containing the current time for synchronization purposes, the initial key, the key disclosure delay and duration oftime intervals. [9]

D.

SHORTCOMINGS OF TESLA-BASED TECHNIQUES

In Tesla-based techniques the receiver needs to buffer packets until the corresponding keys are disclosed in future packets for authentication purposes [7]. This hinders the nodes to have immediate authentication and to be able to use the received data as soon as they receive them. This may result in storage problems and buffer overflow in receivers. Moreover an adversary can flood the network with bogus messages that can cause the receiver to buffer unnecessary packets resulting in DoS attacks [8]. Denial of Service is the result of any action that prevents any part of a WSN from functioning correctly or in a timely manner. This attack is malicious, meaning it is intentional and not accidental. It disrupts service and is performed remotely or over the network. Furthermore, it is asymmetric since with little effort great harm could be done to the system.

Due to the nature of the system, nodes need to buffer and forward all the messages that they receive in one interval. This renders the whole network vulnerable to a malicious adversary that could intentionally flood the system by merely falsely claiming all sent messages belong to the current interval [5, 6]. This could easily lead to destructive DoS attacks in the system since sensor nodes are exceedingly resource-constrained and wireless transmission is costly. Undoubtedly, all these attacks are due to authentication delay of the broadcast messages.

9

CHAPTER Ill: A.

PROTOCOLS

REDUCING pTESLA MEMORY REQUIREMENTS

First using protocol is Low-Buffer ,uTESLA protocol that is cited in [1]. This scheme intends to decrease the buffering of the receiver nodes by replacing it with little increase of sender buffering. In general, buffering at the sender side is often more acceptable since the sender in WSN is usually a base station such as a powerful laptop whereas the receiving nodes are small resource-constraint devices. Usually it is supposed that the base station is not" susceptible to DoS attacks in these networks. This protocol is established on the basis that the receiver needs to buffer the" message MAC instead of the usually larger message itself. The sender broadcasts only the message MAC first in an earlier interval and then sends the message itself along with the corresponding key in a later interval. The receiver needs to buffer the MAC and wait for the key in a later interval. Upon receiving the key and the original message in a later interval, receiver pops the corresponding MAC message and authenticates the current message with the previously buffered MAC and the currently received key. Since the receiver buffers the message MAC instead of the message, its buffer requirements will be lower hence more efficient.

Sender generates the key chain, buffers the message body, generates the message MAC and broadcasts it. In the later interval sender releases the encrypted buffered message, and the corresponding key. Receiver buffers the MAC, and in a later interval receives the original message and the key and verifies the message integrity by checking the MAC, the corresponding key and the message body.

B.

IMMIDIATE AUTHENTICATION

Second using protocol is the immediate authentication ,uTESLA protocol. Buffering packets until the release of the corresponding delayed key for authentication purposes is a drawback of the original TESLA-based techniques which could also result in Denial of Service (DoS) attacks. Packets are subject to be dropped due to probable insufficient buffer in receiving 10

nodes. A new protocol cited in [2] discusses immediate authentication to allow the receiver to authenticate packets upon their arrival. They suggest replacing receiver buffering with sender buffering to eliminate the delay. Sender buffering which is structurally more powerful and reliable is believed to be more practical and reasonable in a pool of resource constraint receiving nodes in WSN. In this scheme the sender buffers the packets during one disclosure delay and each packet is designed to store the hash value of the data of a later packet. This design enables the data in the later packet to be immediately authenticated through the stored hash value as soon as the earlier packet is authenticated via the MAC of the message. As illustrated in figure 2, the packet for the message Mj in interval Tj is constructed by first appending the hash value of the message Mj +vd to Mj and then by computing the MAC value over the appended values. Each packet consists of the message chunk of the current packet, the hash value of the data ofa later packet, the MAC value over the current message concatenated by the hash value of the message of a later packet.

"d" is the key disclosure delay which is the number of intervals after which a key is disclosed (unit is interval)

"v" is the number of packets sent out per time interval which is assumed constant for simplicity The key of an earlier packet could be released in the same packet (in case of TESLA) or in a special packet (in case of ,uTESLA). The key used in MAC will be revealed as in the original TESLA scheme after an assigned disclosure delay.

When a node receives the packet Pj+vd which also discloses the key K j , the packet Pj which was sent in previous interval could be authenticated. Since Pj contains the hash value of the data Mj + vd , if Pj is authentic, H(Mj + vd)) is also genuine and the message Mj + vd is immediately authenticated.

If a packet is lost or dropped, the later packet can still be authenticated using the MAC value. In this example ifPj is missed, Pj+vd will not be immediately authenticated; however, it

11

still can be authenticated using the MAC value in future. This improves the reliability of the system which is integrated in the proposed idea in this paper.

/

M' J Dj

~

-

Mj+vd Dj+vd H(Mj+2vd)

,

H(Mj+vd) MAC(Ki,Dj) Ki-d

--

MAC(~+d,Dj+vd~

K·1

Figure 2.

Immediate authentication packet example (From Ref. [2])

C. NEW PROTOCOL: RELIABLE, LOW BUFFERING IMMIDIATE AUTHENTICATION
The main idea in Low-Buffer ,uTESLA protocol [1] seems undoubtedly attractive since it intends to reduce the memory requirements for receiving nodes by simply substituting the buffering of the content of a message and the corresponding MAC by storing only the MAC. In this scheme, the more resourceful sender buffers the message chunk instead of the receiver and sends only the MAC of the message. The receiver simply needs to buffer the MAC until the disclosure of the original message along with the corresponding key. This provides full and efficient authentication without much buffering. Although this scheme increases the capacity of the node buffers and decreases the risk of buffer overflow in case of a DoS attack, it does not consider the factor of system reliability to a great extent and does not provide immediate authentication which is the main cause of the DoS attacks [2,8].

The basic observation of the new method is to use the MAC of the message for a more efficient receiver buffering while having the hash value of the data of the next packet stored in an earlier packet to maintain the reliability of the system and achieve immediate authentication. 12

Having the hash value of the data of a later packet in an earlier packet increases the probability of the authentication of a packet even if one of the packets is dropped or lost due to network flaws. At the same time, a later packet can immediately be authenticated through the MAC of its hash value as soon as an earlier packet is authenticated.

The protocol consists of two alternating general phases in terms of packet formatting. In the first phase which is during one specific interval, the current message chunk is concatenated with the hash of the message of a future packet and the MAC algorithm is computed over them using the current interval key. The packets of this form are sent to receivers as labeled "First Interval" in figure 3. In the next phase, during the next interval, the content of the message and the hash of the message of the future packet are sent in separate packets. In this interval the related key is also disclosed in the packet. The receiver applies this key to authenticate all the message packets sent in this interval.

Upon receiving the packets in the first alternating phase, receiver buffers the MAC and waits for next corresponding interval. Once the corresponding packets in the next phase are received, receiver pops the MAC and uses the interval key to authenticate the MAC which computed over the current message and the message in the upcoming packet. Once the MAC is verified, the hash of the data of the next coming packet is also immediately authenticated. As shown in figure 3, the packet in the first interval carries a hash of the data MJ + yd. If this packet is authentic, H(Mj + yd) is also authentic and the data Mj
+ yd

is immediately authenticated. If this

packet is lost, the next upcoming packet is not immediately authenticated; however, it could be verified later using the MAC value.

First Interval

Next Interval

I MAC (Kp(Mj
Figure 3.

I H(Mj+Vd)))I"'~IMj I H(Mj+Vd)I+~
Immediate authentication packet example

13

Packets in the first phase contain the computed MAC over current message concatenated by hash of next message. In the next phase, packets consist of message contents and the key needed for authentication purposes. ("d" and "v" are used as explained in section III-B.)

Interval (i+d)

Next Interval

MAC(KP(M j+vdIH(M j+2vd))) ... ~ Mj+vdIH(Mj+2vd) +IKi+dl
Figure 4. Immediate authentication of the next packets to come

Unlike standard ,uTESLA technique, only the MAC of the message is sent in the first interval instead of sending the large combination of message and the MAC. The receiver does not need to buffer the message and it is able to store only the MAC until the original message and the key arrive. Furthermore, placing the hash of the data of the next packets in previous packets increases the reliability of the system to a great extent. If the next upcoming packet is dropped or lost, it has already been authenticated using the previous combined MAC value. Furthermore, its message could also be retrieved using the hash of the data which was buffered at the time.

14

CHAPTER IV:

OPNET MODELER OVERVIEW

The new protocol is best tried to be simulated and examined in a network simulator called OPNET. The Optimized Network Engineering Tools (OPNET) is a very powerful network simulator that is mainly applied to optimize cost, performance and availability. OPNET is a three-tiered technology with three main domains called network model, node model and the process model. Node model specifies the objects in network domain and the process model specifies objects in the node domain. [38,39]

A.

WORKFLOW

The workflow centers on the Project Editor. Network models are created in this editor and statistics are collected directly from each network object or from the whole network. Simulation originates from this editor and run parameters such as duration of the simulation are configured here.

Figure 5.

Modeler workflow (From Ref. [38])

B.

EDITORS
1.

Project Editor

Network model is created in Project Editor from where network simulation is initialized. In this editor the network topology is specified and nodes and links are configured. After choosing the results and running the simulation, the results are viewed from this editor.

15

2.

Node Editor

Node models are created in Node Editor by specifying internal structures and capabilities. Node models are then used to create node instances within networks in the Project Editor. Nodes are defined by connecting various modules with packet streams and statistic wires. Each node may contain several modules that serve specific purpose, such as generating, queuing, processing, transmitting or receiving packets.

3.

Process Editor

Process models are created in the Process Editor that control the underlying functionality of the node models created in the Node Editor. The purpose of this editor is to develop models of decision-making processes. Process models are represented by finite state machines (FSMs) consisting of several forced or unforced states with state transition among them. Operations performed in each state are described in embedded C or c++ code blocks. [39]

Network Node Module

Process

-- -

.. ..

External System Definition

Figure 6.

Hierarchical levels in models (From Ref. [39])

16

Network Model

fi}1--iID~-~
G,.O
t~.. "¥

Node Model

Process Model

II

II

vr.har

r~lul~. t~~ttU];

·r~tult·

' 'I;: ,.., td~"-l; TI'l1,
I"

FIM

(s,-.",..;I.:'L~«"'tf'.t.

Hior<!

fur.tO(ifl '''/!;IUS · tf'~I;H t'lH~ ¢!\ th~ "a':~H Q~"'e"U\(i" . ., 4}f ~/'l. l""Jr(~ ,t'N)!' &.1., HII4. it ~Q til~ l¢wot .. 1 · .1" .... · 'j

""{'V".

OH

~l;tO::~f1tc"H :

Cn4r
(

~t~~utf~" [ltl; ~n.,. ke:;..." hottl{,,) : t~ (pkt<;OI.H'lUl' M f -

0)

1ncervalur
pkt~<e»"'tr

.. O1.1.Jlk_crce<l.tt (10) I

Figure 7.

Three-tiered OPNET hierarchy
17

Although project is originated from Project editor, creation flow of the project is from Process model to Node model ending with the Network model. Once a model is created and saved, it will be added to a list where can be accessed from an upper level editor. Project is initially created by building a Process model. Once the Process model is finished and saved, it will be appended to a list accessible from the Node editor. A Node model is built by linking to the previously built Process model existing in the list. Similarly, Network model is built by linking the previously created Node model.

C.

OBJECT TYEPS
1.

Network Model

In simulating the current scenario a wireless network topology is applied and several types of nodes are employed accordingly in the Project, Node and Process Editors. A network terminal or device is among different kinds of nodes that may exist in the Project Editor. These nodes have the ability to communicate to other nodes and other capabilities determined by its model.

Fixed Node

Figure 8.

Project Editor - Node in network model

2.

N ode Model

Node Editor that is used to specify the structure of the device models contains different object types. The nodes existing in the node models are composed of several various types of objects or modules. Each module is a black box with a particular function of node's operation. These modules can be connected by different types of connections such as packet stream to support data flow. Processor is a general purpose programmable object that a process model specifies its behaviour. Queue is similar to a processor in addition to providing internal packet queuing facilities consisting of a bank of sub-queues that are ordered lists of packets. Wireless radio transmitter and receiver allow packets to be sent outside and received of and from the 18

node's boundary. Packet Stream connects an output stream of a source module to the input stream of a destination module. This allows packets to be communicated and buffered between the nodes.

JgJj
Queue
Figure 9.

I~l
Packet Stream

Transmitter ReceIver Antenna

Node Editor - Modules in node model

3.

Process Model

The Process Editor is used to specify the behaviour of process models. Process models are instances of processes in the Node Domain that use finite state machine paradigm to illustrate the system behaviour in case of an event. The objects used to build process models are states that represent a process mode. States contain codes that are performed when a state is entered, exited or when an interrupt occurs. These codes include C++ or C program along with the OPNET Porto C language. The OPNET specific language provides predefined procedures such as packet generation, packet send and packet receive.

A red state unlike a green state is an unforced state where the process is blocked immediately upon executing the enter code and the system waits for a new interrupt before continuing. A process can go from a source state to a destination state if a condition is served. An executive statement which specifies an action is performed once the transition is taken. A forced or green state is immediately exited or transited to the next state once it is entered.

Figure 10.

Process Editor - States in process model

19

CHAPTER V:

OPNET SIMULATION

In order to investigate the new proposed protocol, two scenanos are simulated and compared in OPNET. Firstly the ,uTESLA scheme mentioned in [2] that has improved the original,uTESLA technique by facilitating immediate authentication through sending the hash of a future packet with the current packet is implemented in OPNET. Furthermore a second scenario is simulated in the same environment that incorporates the first scenario with the memory efficient ,uTESLA protocol mentioned in [1] by buffering the MAC of the message instead of the original massage in the resource constrained receiver node. The integration of these two methods is hoped to achieve immediate authentication while at the same time optimally reduce receiver buffering requirements.

As in other ,uTESLA implementations, several assumptions are made in the creation of these protocols. Firstly, it is assumed that all the nodes are equipped with initial parameters and functions such as key disclosure delay and the hash function and MAC algorithm needed for encryption and decryption purposes. Furthermore, "v" that is the number of packets sent out per time interval is assumed to be constant and equal to two for simplicity. Similarly, key disclosure delay or "d" is arranged to be two, meaning the key needed for decrypting a packet is revealed after two intervals.

Hash functions are used to ensure data integrity. In this simulation, RSHash is the hash function that is used for hashing the key and the message of the future packet for immediate authentication purposes. The function takes a string as a parameter and iteratively applies some additions and multiplications to its character's ASCII code with two random integer numbers. The result number is the encrypted form of the passed string which could be an interval specific key or the hash of the data of a packet in future.

Encryption algorithms are applied to ensure data confidentiality. Much secure HMAC (Hash-based Message Authentication Code) which is a cryptographic hash function with a secret key is used as the encryption algorithm in this simulation. The hash function used in HMAC 20

algorithm is SHAl. Four functions are used in creation of the HMAC-SHAI. As a result, a "Digest" is produced and passed to the packet generation function. Sender encrypts the message with this code and passes the "Digest" along with packet. Once the receiver owns the key and the original message, it applies the HMAC algorithm to the message with the related key. If the two "Digests" are the same, the packet is authenticated.

To investigate the enhancement of the broadcast authentication in sensor networks in OPNET, wireless network technology is employed. One transmitter node and one receiver node are planted in the Project Editor and they are connected wirelessly as shown in figure 11. Two scenarios are designed and simulated in OPNET to analyze and compare the new protocol's efficiency and performance. Each transmitter and receiver node contains series of c++ code to implement the assigned scenarios. General and expanded depiction of the sender and receiver nodes are demonstrated in the next section without considering the .scenarios and then detailed description of each scenario is followed. The complete OPNET collected code for the second scenario which is the proposed scheme is given in the Appendices section.

Figure 11.

Project Model consisting of a transmitter and a receiver

A.

TRANSMITTER
transmi~ter

Each transmitter node consists of three modules, a processor, a radio

and an

antenna. The processor module in this node is where the simulation is controlled and directed. The underlying strategy is built within the Process Model of the transmitter node. The radio transmitter and the antenna facilitate transition of data in a wireless environment by using radio

Jinks.
21

Figure 12.

Node Model for the transmitter node

The Process Model of the transmitter processor is composed of three states as illustrated in figure 13. Several initial variables are set in the initial state. If the start condition is true, a packet is generated by calling the function sS"""packet_generateO which lies in the function block of the editor. Now the process transits to the "generate" state where packets are continuously generated in a loop until a "stop" interrupt occurs or the simulation time is terminated.

Embedded C or C++ code is placed in various places in Process Model. Header block and function block and both enter and exit parts of each state could contain necessary coding in order for the system to work as desired. The content of header block and function block is available throughout the node and accessible by all the modules ofthe node. Some variables are initialized in the header block and several functions and procedures are defined in the function block of the sending node of both scenarios.

The hash and MAC functions are implemented in the function block in order to be used for packet formatting during the generation of the packets. The "ss"""packet_generate" function is also created in the function block. The formatting of the packets is different in two scenarios; therefore, the code for packet generation at the sender's end and packet processing at the receiver's end differ accordingly and are discussed shortly.

22

,1~

,

J

\

I

I
I

111/4

J

(STOP)

Figure 13.

Process Model for the transmitter processor module

B.

RECEIVER

Each receiver node is composed of a queue, a radio receiver and an antenna as represented in figure 14. The queue processor is the heart of the receiving plot. Packets selectively get inserted in the queue and removed for target authentication. The existing states in this module facilitate optimum and efficient authentication by carrying out the necessary functions. The queue is an OPNET built-in module that performs based on first in first out (FIFO) processing technique.

Figure 14.

Node Model for the receiver node 23

As illustrated in figure 15, the initial state is marked with a black arrow. This state accepts packets from the transmitter and since it is a green or forced state, it automatically moves the process to the next state "PROCESS" at the bottom of the figure. This state examines the packet to see if it is a packet containing key, MAC or message.

In case ofthe first scenario, if the packet is composed of a message, it will be pushed into the queue and the state will be transited back to the initial state. If packet contains a key, the process will be moved to the third state "AUTH" at the top of the figure 15. In the case of the second scenario, the packet is pushed into the queue if it contains a MAC and then transferred to the initial state and it will be moved to the third state if it contains a message. Figure 15 and 16 demonstrate the finite state machine mechanism and the corresponding flowchart illustrating the transitions between states on the receiver side.

46/0

3'9/0
I (ARRtVAt.}

y

I

35/0

Figure 15.

Process Model for the receiver queue module

24

N1NITlAl STATEN PACKET RECEMO

"'PROCESS STATE" OOESPACKET CONTAIN KEY?

No

PUSH PACKET INTO QUEUe

Yes
POP PACKET FROM QUEUE

"AUTHENTICATION

STATE'"
AUTHENTICATE PACKET WITH KEY

Figure 16.

Flowchart of state transition of a receiver node

C. FIRST SCENARIO (IM1\:fEDIATE AUTHENTICATION PROTOCOL)
In this scenario, immediate authentication p TESLA protocol is re-created without considering low memory requirements. In this scheme, in each interval, two data packets are sent 25

along with a separate packet containing the key for the two previous intervals. For the first two intervals the key packet contains no information. As the mechanism of the ,uTESLA suggests, receiver is supposed to buffer these four packets in queue and wait for the related key in the upcoming two intervals. Once a key is received, packets are popped from the queue in FIFO manner and are authenticated with the related key.

Messages are removed from the queue once they are authenticated. System disposes the packets that are not authenticated. Each packet contains the hash of a future packet according to the formula (Mj
+

vd). This facilitates immediate authentication of a packet sent in the future.

Formula 2 and 3 are the formats of the two packets sent in each interval and figure 17 is a sketch of packet transmitting first scenario.

26

(2) Pj : Mj + H(Mj + vd) + MAC (Kj, Mj I H(Mj + vd)) (3) K i : K i-d

K;

..
Interval i +1

F(k j+2}

..
Interval i +2

F(k i+3}

Interval i

Time

Figure 17.

Scenario 1

D.

SECOND SCENARIO (PROPOSED PROTOCOL)

The new proposed integrated protocol is implemented as the second scenario. This arrangement is composed of two alternating intervals in terms of packet formatting. Packets alter their format every two intervals. Two data packets are sent in each interval in the first two intervals. In this packet only the MAC of the massage concatenated by the hash of the future packet is sent. In the next two intervals the corresponding messages of the first four MAC are sent along with the key to the previously sent MAC's.

Sending the MAC of the messages first allows less buffering in the receiver side. Once the corresponding message and key is sent, the receiver pops the MAC from the queue in FIFO manner and authenticates the message. As in first scenario, once the current packet is authenticated, a future packet is also authenticated. Packet formats are outlined in the following lines and a sketch of packet forwarding is presented in figure 18.

27

First alternating format: (4) FI = Pj
:

MAC (Kj

,

Mj

I H(Mj +vd))

Second alternating format: (5) F2 = Pj
(6) Ki: Ki-d
:

Mj + H(Mj +vd)

....
Interval i -1

F(k j )

K;

....
Interval i +1

F(k i+2}

....
Interval i +2

F(k i+3}

Interval i

Time

[EJffiJ

~[5J
Figure 18.

~~
Scenario 2

~~

Similar to first scenario, the function block for the transmitter node consists of implementation of hash function and MAC. In this block, packet generation function employs these procedures when it needs to obtain hash of a message or when it needs to encrypt the message with the MAC algorithm. Figure 19 is a snap shot of part of the function block of the transmitter node in the second scenario. It shows the content of ss~acket_generateO procedure.

In this code, packets are generated according to the design and sent to the receiver node to be processed. This procedure checks to see which format needs to be transmitted. If it is time to send the message, the packet containing the key also needs to be accompanied with the other packets. Otherwise only the MAC of the message concatenated with hash of the future packet is transmitted to the receiver node. This procedure uses formula 4 and 5 to create appropriate packet formats.

28

S 6 7 3

·
FIN (ss-P<lckeLgenerate 0); packet' pkptr;
packet' lnt idx=-l;
I*~ /.~

" ·· " 13
II
i$

pktKeyptr;

14 15

specifications of tile source

Th1

So

functi em creates a packet

on the packet generation r*/ and ,,,nds i t to the 1 ower 1 aye". ~'I

,.
;0
H

16 11

i l' (mac) (

macSentMessagecounter++; if(macSentMessagecounter ~ 2 -- 0) neWMaclnterval - true;

ii
24 25 26 27

if (macSentMessagecounter

i'

mac - false;

~

4 -- 0)

i.

counter++; char nextMessage[4]i char'trMeS,age[4]' char key[ 4]; mainMessaQe - counter + 12345;

·· ,I
3t
H H

2'

H

itoa(mainMe,sage, strMe,sage, 10); 1toa(mainMessaQe + 4, nextMessage, 10); int h - RSHash(nextMessage);
int maCMessaQe

,0 37 ,0
)9

=h

~

mainMessagej

char messageHashed[4J; itoa(maCMessage,messageHashed,lO);
CHMAC_SHAl HMAC_SHAl ;

.0
tI

.> ·· .5 .,.

tl

.,
4$

41

'0 U !l S, 54

}

HMAC_SHA1.HMAC_SHA1((unsigned char ')messageHdshed , sizeof(messageHashed), (unsigned char *)key, si7eof(key), digest) unsigned lang hashedCode - 0; un. i gned 10n9 mult = 1; for (unsigned 1 - 0; 1 < 4' tti) { hashedcade +s mult * dlgest[si2eof(d1gest)-1-i]; mult «- 8;

pkptr -

~p_pk_cr.ate

op_pk_fd_~et

oPJlk_sel1d (pkptr, SSC_STRM_TO_LOW);

(pkprr, 0, OP':JIELD_TYPE_INT£GER, hashedcade, 32);

(0);

.8
>7

.6
S. 60 01
52

55

if(neWMaclnterval)

neWMaclnterval - falsej
print1'("~l'(

hashedKey - RSHash(ltoa(hashedKey, key, 1Q));
\P');

{

}

else

}

6' M 6S 64 67

mes,ageSentpacketcountertt; i1'(messageSentpacketCounter
n~essagelnterval

(

63
~.

- true;
~

~

2 =- 0)

j f (messagesentPacketcounter

10

'1'1 7i
7>

mac: - true;

4 -- 0)

char nextMessage[4];

7_

pktKeyptr - Op_pK_Ct'.ate (0);

n
76
1'7 73 79

int message - counter - 4 + 12345;

itoa(me55age + 4, n~xtMeS$age. 10); jnt hashedNeXtMeSsage - RSHash(nextMessage);
pktKeyPtr, 1, 2, ~pktKeyptr,
op_pk_send (pktKeyPtr, SSC-STRM_TO_LOW);
PktKeYPtr,

., .,
~

SO

0,

message, 32); hashedKeyPacket, 32); hashedNextMessage, 32);

e<

..
et.
e1'
90

es

i 1'(ne..... essagelnterval)

hashedKeypacket = RSHash(itoa(hashedKeyPacket, keyHashed, 10)); neWMessag!Interval - f~15e;
}

{

* 91
~

printf(' Mess.dye \n");
)
FOUT;
"'i>

9f
~

96 ..

Figure 19.

Scenario 2 - Function block of the transmitter node

29

CHAPTER VI:

SIMULATOIN RESULT

The duration of the simulation and other run related parameters could be set before running the project from the Project Editor. After the simulation is completed different results could be filtered in the result browser.

;:'i@ltj;!"liiUJ'. . . . . . · .. IK\·'
DES Graphs DES Parametric Studies Results for: Current Scenario

I

I

I

..:.J

I Arrangement: IDefault
Itl·····

Show resuKs: Found In any selectedfiles

..:.J ..:.J
Edit..

/l

Global Statistics

~""1 Object Statistics ~ . . Campus Network

~·Olm ! ~ . 6 ~O

i . 8. 0

subqueue [0)

I, i i
!!
l!1'O

~!§~~. :~::::~~:=:~tt'll
It 0
i<

I ~.
tK

f!!·Ql

{<

queue size (packets) queuing delay (sec)

<. ~
.· ,,;1 ill
~I

radio_rK

"
:1
I

:.-:

>

r

Ignore Views

1

U~~elect Ali

". ~~

I

~ ----'lJ

II

Figure 20.

Result browser 30

Following figures illustrate the performance of the proposed node authentication protocol explained in (III-C) as the first scenario along with the protocol stated in section (III-B) as the second scenario in the course of 30 minute simulation. Although immediate authentication is achieved by these protocols, it cannot be captured in a graph. As expected, the following graphs show that the queue performance of the receiving node is improved to a good extent proving that the integration of Low-Buffer ,uTESLA version with the previous work is optimal.

As explained previously, two separate projects were implemented in OPNET in order to compare and investigate the enhancement of the proposed scheme. The first project implements the immediate authentication ,uTESLA without considering. sensor buffer requirements. The second project is the implementation of the proposed integrated protocol that incorporates the protocol in the first scenario with the Low-Buffer ,uTESLA scheme in order to improve system performance. Figures 21 and 22 demonstrate the graphs generated by OPNET. They display the average of queue size in bits in the first and second scenarios respectively. The X axis is time in minutes in these graphs and the Y axis is the average queue size in bits. As illustrated in the following two figures, the number of bits waiting in the queue in the new protocol stabilizes with less than one third of the bits in the queue of the first scenario. This shows an improvement of around 73% in queue size in the new protocol.

31

average (in queue queue size (bns))

350

300

~

250

J

/

200

150

100

50

0 Omin

Smin

10min

15min

20min

25min

30mln

Figure 21.

Scenario 1 - Queue size stabilizes at around 330 bits
average (ir. queue.queuesize
(~

100 90 80 70

n
V

lj

1'\./"'\.,.v v .., "

.... .... .... .... .... .... -

"'--

50
50

I 30
I
I·

t

40

~
~

20 10 0 Omin

U

~

. 5min

.....

10min

20mir\

25min

30mln

Figure 22.

Scenario 2 - Queue size stabilizes at around 70 bits

32

Figures 23 and 24 also generated by OPNET simulator, illustrate the average of queuing delay in seconds in the first and second scenario respectively. The X axis is time in minutes and the Y axis is the average queue delay in seconds. As represented in figure 23 and 24, the queuing delay in the new protocol stabilizes with a number much less than the one in first scenario which displays an improvement of around 37% in delay time in the new scheme.

33

52.501 2.5005
52.S
...
..

average (in queue queuing delay (sec))
_...

2.4995 2.4985

-

fIt!ftrlr'ls'1r'1r'

..

...

-.

~~--...;.-..-...;.--...;.-

_.

52.499 r-----'52.498 I-- .'
2.4975 '52.497
'...

_----

,2.4965 52.498
;2.4955
_ ....

52.495

'2.4945
:;2.494
;~.4935

-

.
.

52.493
Omin

Smin

10min

15min

20min

25min

30min

Figure 23 .
~ ~.,

Scenario 1 - Queuing delay stabilizes at 52.5 seconds
~.A'~

·.. - ? -.. - .... ··.···- ... ··- -........ <,.· _ · · · ···· ".<.· 40~--______--______----------a-ve~r~ag~e~(~in~~c~e-~--,q~ue-u-in~g~d_e_la~y~(s_e~c)~)________________________~

;

35+-------------------------------------------------------------------1

30
2S~~----------------------------------------------------------------------~

20+------------------------------------------------------------------------~

15~---------------------------------------------------------------------j

p10~~-------------------------------------------------------------------~

!

5
O+----------,-----------r----------r----------T----------,----------,----~

Smin

:::. 10l1'lin

.)

15min

ct .

20ir-dn;'('..F 'I;25m,n;

;;.;;.30mln

Figure 24.

Scenario 2 - Queuing delay stabilizes at 33 seconds
34

Figure 25 is a combined graph displaying both scenarios' queue size trend in time. Similarly figure 26 is a depiction of both scenarios' queuing delay over time. The two plotted lines in each graph represent the two scenarios initially produced in OPNET. These comparison graphs demonstrate a significant improvement in both buffer size and buffering delay in the receiving node of the proposed scheme.

As the result of this protocol, the buffer requirements of the resource-restricted receiving sensors are well taken care of. Furthermore, the queuing delay which is the time packets need to spent in queue in order to be processed is significantly reduced resulting in a more robust and reliable system. Overall, the new scheme achieved to enhance memory requirements of the low capacity sensing devices while preserving the desirable immediate authentication among sensors.

35

350 , - - - - - - - - - - - - - - - - - - - - - - -

300

+------------~~-----------------------------------

250

+--------~--------------------------------------------

200
Average Queue

+----~-----------------------------------

Size (Bits)

150 +--4D-----------------------------------------m-Scenario 2
100

+---+--------------------------------------------------

50

o
o

.--,----,--,--,--.--.--,,--,--.--,--.---,--.--.-,--,
1 2 3 4 5 10 15 20 25 30 35
Time {Minutes}

40 45

50 55 60

Figure 25 .

Comparison of average queue size in both scenarios

...
50

....

...

- - - - .... - .... - ...

...

"'!"

'!'"

Average Queue 30 Delay (Seconds)

-~-~~~~ !N"""""-

20

(
1 2 3 4 5 10 15 20 25 30 35 40 45
Time (Minutes)

_Scenario 1 -m-Scenario 2

10

o -[ o
Figure 26.

50 S5 60

Comparison of average queuing delay in both scenarios

36

CHAPTER VII:

CONCLUSION

This project proposed a new authentication mechanism for a wireless sensor network designed to ensure system integrity and dependability. This scheme applies a simple symmetric cryptography and improves its generally low security capabilities by revealing the cryptographic key with a delay. Since the delay makes the sensor nodes subject to outside attacks, this protocol attempts to remove authentication delay by sending future messages in earlier packets. This might introduce the need for higher buffer capacity which is a commodity in sensor networks. To alleviate this problem, this mechanism is designed to send smaller version of message in form of MAC to enable low-capacity receiving nodes to buffer less information.

This protocol combines two separate authentication mechanisms to provide robust security coupled with high reliability and utilizes affordable data encryption to ensure data confidentiality. Performance and simulation analysis demonstrated that the buffer size requirements and delay of the proposed system are enhanced to a good extent while immediate authentication is achieved to make the whole system highly resistant to outside malicious attacks such as Denial of Service attack.

A.

CONTRIBUTIONS OF THIS PROJECT

This project accomplished the objective of incorporating desirable immediate authentication with careful consideration of low-buffer requirements of the sensor nodes in wireless sensor networks. It proposed an integration of two protocols in order to enhance broadcast authentication in sensor networks. This scheme combines a version of ,uTESLA technique that provides immediate authentication with a reduced buffer version of the same technique.

The proposed integrated protocol is simulated in OPNET modeler along with one of the previously stated scheme to verify the efficiency and the reliability of the new system. Performance and simulation analysis demonstrated that the queue delay and the queue size of the

37

proposed system are enhanced in comparison with the isolated techniques. As expected, the buffer size is reduced due to the elimination of the message buffering and replacing it with the buffering of message MAC instead. At the same time, immediate authentication which is the principal resolution to DoS attacks is achieved to a great extent due to the appending of the hash of the data of the next upcoming packet. Having the hash of the next data content in the current packet allows immediate authentication of the next packet once the current packet is verified. Also addition of this feature is expected for the betterment of the system reliability since both the message and the hash of the message are sent separately in two different intervals. This increases the chance of receiving the message one way or the other in case of channel loss.

B.

RECOMMENDATIONS FOR FUTURE WORK

This project proposed a real-time authentication protocol; however several assumptions have been made to simplify the simulation in the modeler. For instance, the number of packets sent out per time interval or the parameter "v" that is assumed constant for simplicity could be attempted to be random and variable to re-create a more realistic network environment.

In a real life wireless sensor networks, all nodes should firstly be deployed with the necessary parameter values such as key disclosure delay, duration of time interval, the initial key and the current time and also the necessary hash functions and MAC algorithms. This initial realm of process is yet another issue in sensor networks that is a base for on-going research. In this simulation, it is assumed that all nodes are equipped with all the required initial parameters. Future simulation could include this initial stage to create a thorough scenario for sensor authentication.

Future work should include a complete implementation of a distributed sensor network with more receiving sensors and more than one base station. Besides the base station broadcasting packets, receiver nodes could also be relaying received information to other nodes. As part of this follow-on work, the traffic analysis of all the nodes in the network could be expanded. Various parallel and individual statistics of all the nodes as well as the system as a whole in longer durations could be investigated.
38

In the process of simulating the network more accurately, the environment could be programmed to reflect lifelike events such as loss of packets and malicious jamming. Future work could include various wrongful events that might occur in the course of simulation in order to observe system behavior in case of a more realistic plot. A thorough security solution would address different security challenges, such as detecting misbehaving or compromised nodes.

39

APPENDICES: SOURCE CODE FOR SECOND SCENARIO

APPENDIX A: TRANSMITTER SOURCE CODE
1* Process model c++ form file:simple_source.pr.cpp *1 1* Portions of this file copyright 1986-2009 by OPl\TET Technologies, Inc. *1 1*

========================== NOTE ==========================
This file is automatically generated from simple_source.pr.m during a process model compilation. Do NOT manually edit this file. Manual edits will be lost during the next compilation. =========================== NOTE =========================

*1 1* This variable carries the header into the object file *1
const char simple_sourceyr_cpp [] = "MIL_3_Tfile_Hdr_ 150A 30A modeler 7 4D227972 4D227972 1 rye-udcmybdtq7r Administrator 0 0 none none 00 none 0 0 000000 21b7 3
II.

,

#include <string.h>

1* OPNET system definitions *1
#include <opnet.h>

1* Header Block *1 1* Include files.
#include <string> #include <oms _dist_support.h> #include "hrnac_shal.hpp" #include "sha1.hpp"

*1

1* Special attribute values.

*1

#define SSC- INFINITE- TIME #define WIRELESS STRM

o
40

-1.0

1* Interrupt code values. SSC START #define #define SSC GENERATE SSC STOP #define 1* Node configuration constants. *1 #define SSC- STRMTO -LOW 1* Macro definitions for state *1 1* transitions. START #define DISABLED #define STOP #define PACKET GENERATE #define uchar unsigned char #define

*1

o
1 2

o
*1 (intrpt_code SSC_START) (intrpt_code == SSC_STOP) (intrpt_code SSC_STOP) (intrpt_code SSC_ GENERATE)

1* Function prototypes. *1 static void ss-.racket_generate (void); void HashString(BYTE[lOO], int); void UHash24 (uchar *msg, uchar *secret, int len, uchar *result); unsigned char * IntToByteArray(int value);
unsigned char convertedMessage[ll]; int packetSentCount=O; Ilbool iskeylnterval=false; int macSentMessageCounter=O; int messageSentPacketCounter=O; int mainMessage=O; int hashedKey= 11 0; int hashedKeyPacket=11 0; char key[4]; char keyHashed[4]; booI mac=true; booI newMacInterval=false; bool newMessageInterval = false; I*typedef struct { unsigned char key[20]; unsigned char name[11]; unsigned char message[l1]; int isPacketInserted;lll = buffer the packet 0 }

do not buffer the packet

41

unsigned int RSHashl (char* str, unsigned int len); int packetNumber; int rpt; int counter=O; int pktCounter=O; int interval=O; int key Interval= 1; unsigned int db;

BYTE digest[4]; int idx=O; /* allocate an empty list */ List *lst; /* **************************************************************************

* *
*

General Purpose Hash Function Algorithms Library

*
*

*

* Author: Arash Partow - 2002 * * URL: http://www.partow.net * * URL: http://www.partow.netlprogrammingihashfunctions/index.html * Copyright notice: * * Free use of the General Purpose Hash Function Algorithms Library is * * permitted under the guidelines and in accordance with the most current * * version of the Common Public License. * * http://www.opensource.orgllicenses/cpll.O.php *

*

*

*

****************************************************** ********************1 #ifndefINCLUDE- GENERALHASHFUNCTION- CPP- H #define INCLUDE GENERALHASHFUNCTION CPP H typedef unsigned int (*HashFunction)(const std: :string&);

*

*

int RSHash (const std::string& str);/Iunsigned #endif 42

1* End of Header Block *1
#if !defined (VOSD_NO_FIN) #undefBIN #undefBOUT #defineBIN FIN_LOCAL_FIELDLop_last_line j)assed) = _LINE_ _ op_block_origin; #defineBOUT BIN #defineBINIT FIN_LOCAL_FIELDLop_last_linej)assed) = 0; _op_block_origin = _LINE_; #else #defineBINIT #endif 1* #if !defined (VOSD_NO_FIN) *1

1* State variable definitions *1 class simple_source_state
{ private:

1* Internal state tracking for FSM *1 FSM- SYS- STATE
public: simple_source_state (void);

1* Destructor contains Termination Block *1 ~simple_source_state (void); 1* State Variables *1 Objid own id of the surrounding module. *1 char format_ str [64] the packets generated by this source. *1 , double start time this source will start its packet generation *1 *1
double stop_time this source will stop its packet generation *1

1* Object ID ; 1* Format of 1* Time when 1* activities. 1* Time when 1* activities.

*1
OmsT_Dist_Handle interarrival_distj)tr 1* PDF used to determine the interarrival times of *1

1* generated
packets.

*1
43

OmsT_ Dist_Handle pksize _ dist-.rtr used to determine the sizes of generated packets. */ Boolean generate_unformatted /* Flag that indicates whether the source will generate */ */ or formatted packets. Evhandle next-.rk_evh Event handle for the arrival of next packet. */ next- intarr- time double between the generation ofthe last packet and the */ */ Stathandle bits- sent- hndl Statistic handle for "Traffic Sent (bits/sec)" statistic. */ Stathandle packets_sent_hndl /* Statistic handle for "Traffic Sent (packets/sec)" statistic. */ Stathandle packet_size_ hndl /* Statistic handle for "Packet Size (bits)" statistic. */ Stathandle interarrivals hndl Statistic handle for "Packet Interaarival Time (secs)" */ */ int Number of Packets to process */ max-.racket_count

; /* PDF

/* unformatted
; /*

;/* Time
/* next packet.

; /*

;/*
/* statistic.

/*

/* FSM code */ void simple_source (OP _SIM_CONTEXT_ARG_OPT); /* Diagnostic Block */ void _op_simple_source_diag (OP_SIM_CONTEXT_ARG_OPT); #if defined (VOSD_NEW_BAD_ALLOC) void * operator new (size_t) throw (VOSD_BAD_ALLOC); #else void * operator new (size_t); #endif void operator delete (void *);

/* Memory management };

*/

static VosT_Obtype obtype;

VosT_Obtype simple_source_state::obtype = (VosT_Obtype)OPC_NIL; #define own id #define format str #define start time op_ sv-.rtr->own_id op_ sv-.rtr->format_ str op_sv-.rtr->start_time

44

#define stop_time #define interarrival_dist~tr #define pksize_ dist~tr #define generate_unformatted #define next~k_evh #define next- intarr- time #define bits- sent- hndl #define packets_ sent_hndl #define packet_size_hndl #define interarrivals hndl #define max~acket_count

op_ sv~tr->stop_time op_ sv~tr->interarrival_dist~tr op_ sv~tr->pksize_ dist~tr op_ sv~tr->generate _unformatted op_ sv~tr->next~k_evh
op_sv~tr->next_intarr_time

op_ sv~tr-> bits_sent_ hndl op_ sv~tr->packets_ sent_hndl op_ sv~tr->packet_size_ hndl op_ sv~tr->interarrivals_ hndl op_ sv~tr->max~acket_count

1* These macro definitions will define a local variable called 1* "op_sv~tr" in each function containing a FIN statement. *1 1* This variable points to the state variable data structure, *1 1* and can be used from a C debugger to display their values.

*1

*I #undef FIN- PREAMBLE- DEC #undef FIN- PREAMBLE- CODE #define FIN_PREAMBLE_DEC simple_source_state *op_sv~tr; #define FIN- PREAMBLE- CODE \ op_sv~tr = «simple_source_state *)(OP_SIM_CONTEXT_PTR>_op_mod_state~tr));

1* Function Block *1
#if !defined (VOSD_NO_FIN) enum { _ op_block_origin = _LINE_ + 2}; #endif #include <stdio.h> #include <stdlib.h> #include <string.h> #include <string> static void ss~acket_generate(void) { FIN (ss~acket_generate 0); pkptr; Packet* pktKeyPtr; Packet* int idx=-l; 1* * This function creates a packet based on the packet generation 1* * specifications of the source model and sends it to the lower layer. if (mac)
{

* *I * *I

45

macSentMessageCounter++; if(macSentMessageCounter % 2 == 0) newMacInterval = true; if (macSentMessageCounter % 4 mac = false; counter++; char nextMessage[4]; char strMessage[4]; char key[4J; main!vlessage = counter + 12345; itoa(mainMessage, strMessage, 10); itoa(mainMessage + 4, nextMessage, 1O);114th message after the current message int h RSHash(nextMessage); h + mainMessage;

0)

int macMessage

char messageHashed[ 4]; itoa(macMessage,messageHashed, 10); CHMAC_SHAI HMAC_SHAI ; HMAC_SHAl.HMAC_SHAl«unsigned char *)messageHashed, sizeof(messageHashed), (unsigned char *)key, sizeof(key), digest) ; unsigned long hashedCode = 0; unsigned long mult = 1; for (unsigned i = 0; i < 4; ++i) { hashedCode += mult * digest[sizeof(digest)-l-i]; muIt «= 8; } pkptr op-pk_create (0); op-pk_fd_set (pkptr, 0, OPC_FIELD_TYPE_INTEGER, hashedCode, 32);

if(newMacInterval) { hashedKey RSHash(itoa(hashedKey, key, 10»; newMacInterval = false; } printf("Mac \n");

46

}

else
{

messageSentPacketCounter++; if(messageSentPacketCounter % 2 == 0) newMessageInterval = true; if (messageSentPacketCounter % 4 == 0) mac = true; char nextMessage[4]; pktKeyPtr = op-pk_create (0); int message = counter - 4 + 12345; itoa(message + 4, nextMessage, 10);//4th message after the current message int hashedNextMessage = RSHash(nextMessage);

op-pk_ fd _set (pktKey Ptr, 0, OPC_FIELD_TYPE_INTEGER, message, 32); op-pk_fd_set (pktKeyPtr, 1, OPC_FIELD_TYPE_INTEGER, hashedKeyPacket, 32);

if( newMessageInterval) { hashedKeyPacket = RSHash(itoa(hashedKeyPacket, key Hashed, 10)); newMessageInterval = false;
}

printf("Message \n");

} FOUT;
}

int RSHash(const std::string& str)//unsigned
{

intb =3785;//51; int a = 63689; int hash = 0; 47

for(int i = 0; i < str.lengthO; i++)llstd::size_t { hash = hash * a + str[i]; a = a * b;
} return (hash & Ox7FFFFFFF); I!Returns the hashed string }

1* End Of RS Hash Function *1
void CHMAC- SHAl::HMAC- SHAl(BYTE *text, int text- len, BYTE *key, int key- len, BYTE *digest) {

1* repeated 64 times for values in ipad and opad *1
memset(m_ipad, Ox36, sizeof(mjpad»; memset(m_opad, Ox5c, sizeof(m_opad»; 1* STEP 1 *1 if (key_len > SHAl_BLOCK_SIZE) { CSHA 1: :ResetO; CSHAl::Update«UINT_8 *)key, key_len); CSHAI ::Final(); CSHAI ::GetHash«UINT_8 *)SHAl_Key); } else memcpy(SHAl_Key, key, key_len);

1* STEP 2 *1
for (int i=O; i<sizeof(m_ipad); i++) { m_ipad[i] 1\= SHAl_Key[i]; }

1* STEP 3 *1
memcpy(AppendBufl, m_ipad, sizeof(m_ipad»; memcpy(AppendBufl + sizeof(m_ipad), text, textJen);

1* STEP 4 *1
CSHAI ::ResetO; CSHAI ::Update«UINT_8 *)AppendBufl, sizeof(m_ipad) + text_len); CSHAl::FinalO; CSHA 1::GetHash«UINT_ 8 *)szReport); 48

1* STEP 5 *1
for (int j=O; j<sizeof(m_ opad); j++) { m_opadfj] 1\= SHAl_Key[j]; }

1* STEP 6 *1
memcpy(AppendBuf2, m_opad, sizeof(m_opad)); memcpy(AppendBuf2 + sizeof(m_opad), szReport, SHAl_DIGEST_LENGTH);

I*STEP 7 *1
CSHAI ::ResetO; CSHA1::Update((UINT_S *)AppendBuf2, sizeof(m_opad) + SHA1_DIGEST_LENGTH); CSHAI ::FinalO; CSHAI ::GetHash((UINT_S *)digest);
}

#ifdefSHAl - UTILITY- FUNCTIONS #define SHAI - MAX- FILE- BUFFER 8000 #endif

II Rotate x bits to the left
#ifndef ROL32 #ifdef - MSC- VER #define ROL32Cval32, _nBits) _rotlCva132, _nBits) #else #define ROL32Cva132, _nBits) ((Cva132)«CnBits))I(Cva132»>(32-CnBits)))) #endif #endif #ifdef SHA1_LITTLE_ENDIAN #define SHABLKO(i) (m_block->I[i] = \ (ROL32(m_block->1[i],24) & OxFFOOFFOO) I (ROL32(m_block->I[i],8) & OxOOFFOOFF)) #else #define SHABLKO(i) (m_block->l[i]) #endif #define SHABLK(i) (m_block->l[i&15] = ROL32(m_block->1[(i+13)&15] >1[(i+S)&15] \ 1\ m_block->1[(i+2)&15] 1\ m_block->1[i&15],I))
1\

m_block-

II SHA -1 rounds
49

#define _RO(v,w,x,y,z,i) w=ROL32(w,30); } #define _Rl(v,w,x,y,z,i) w=ROL32(w,30); } #define _R2(v,w,x,y,z,i) w=ROL32(w,30); } #define _R3(v,w,x,y,z,i) w=ROL32(w,30); } #define _R4(v,w,x,y,z,i) w=ROL32(w,30); } CSHA1 ::CSHA10 {

{ z+=«w&(xl\y))",y)+SHABLKO(i)+Ox5A827999+ROL32(v,5); { z+=«w&(xl\y))l\y)+SHABLK(i)+Ox5A827999+ROL32(v,5); { z+=(wl\xl\y)+SHABLK(i)+Ox6ED9EBAl +ROL32(v,5); { z+=«(wlx)&y)l(w&x))+SHABLK(i)+Ox8FlBBCDC+ROL32(v,5); { z+=(wl\xl\y)+SHABLK(i)+OxCA62CID6+ROL32(v,5);

ResetO;
.. }

CSHA1 ::~CSHAIO { ResetO; } void CSHAl::ResetO
{

II SHAI initialization constants m_state[O] = Ox67452301; m_state[l] = OxEFCDAB89; m_state[2] = Ox98BADCFE; m_state[3] = Oxl0325476; m_state[4] = OxC3D2EIFO;
m_count[O] = 0; m_count[l] = 0;

}
void CSHA1::Transform(UINT_32 *state, UINT_8 *buffer) { II Copy state[] to working vars UINT_32 a = state[O], b = state[1], c = state[2], d = state[3], e = state[4]; memcpY(ffi_block, buffer, 64);

II 4 rounds of 20 operations each. Loop unrolled. _RO(a,b,c,d,e, 0); _RO(e,a,b,c,d, 1); _RO(d,e,a,b,c, 2); _RO(c,d,e,a,b, 3); _RO(b,c,d,e,a, 4); _RO(a,b,c,d,e, 5); _RO(e,a,b,c,d, 6); _RO(d,e,a,b,c, 7);
50

_RO(c,d,e,a,b, 8); _RO(b,c,d,e,a, 9); _RO(a,b,c,d,e,lO); _RO(e,a,b,c,d,ll); _RO(d,e,a,b,c,12); _RO(c,d,e,a,b,13); _RO(b,c,d,e,a,14); _RO(a,b,c,d,e,15); _Rl(e,a,b,c,d,16); _Rl(d,e,a,b,c,17); _Rl(c,d,e,a,b,18); _Rl(b,c,d,e,a,19); _ R2( a,b,c,d,e,20); _ R2( e,a,b,c,d,21); _ R2( d,e,a,b,c,22); _ R2( c,d,e,a,b,23); _ R2(b,c,d,e,a,24); _ R2(a,b,c,d,e,25); _ R2( e,a,b,c,d,26); _ R2( d,e,a,b,c,27); _ R2( c,d,e,a,b,28); _ R2(b,c,d,e,a,29); _ R2( a,b,c,d,e,30); _ R2( e,a,b,c,d,31); _ R2( d,e,a,b,c,32); _ R2( c,d,e,a,b,33); _ R2(b,c,d,e,a,34); _ R2( a,b,c,d,e,35); _ R2( e,a,b,c,d,36); _ R2( d,e,a,b,c,3 7); _ R2( c,d,e,a,b,38); _ R2(b,c,d,e,a,39); _R3(a,b,c,d,e,40); _R3(e,a,b,c,d,41); _R3(d,e,a,b,c,42); _R3(c,d,e,a,b,43); _ R3(b,c,d,e,a,44); _ R3(a,b,c,d,e,45); _ R3( e,a,b,c,d,46); _ R3( d,e,a,b,c,4 7); _ R3( c,d,e,a,b,48); _ R3(b,c,d,e,a,49); _ R3( a,b,c,d,e,50); _ R3( e,a,b,c,d,51); _ R3( d,e,a,b,c,52); _ R3( c,d,e,a,b,53); _ R3(b,c,d,e,a,54); _ R3( a,b,c,d,e,55); _ R3( e,a,b,c,d,56); _ R3( d,e,a,b,c,57); _ R3( c,d,e,a,b,58); _ R3(b,c,d,e,a,59); _ R4( a,b,c,d,e,60); _ R4( e,a,b,c,d,61); _ R4( d,e,a,b,c,62); _ R4( c,d,e,a,b,63); _ R4(b,c,d,e,a,64); _ R4(a,b,c,d,e,65); _ R4( e,a,b,c,d,66); _ R4( d,e,a,b,c,67); _ R4( c,d,e,a,b,68); _ R4(b,c,d,e,a,69); _ R4( a,b,c,d,e, 70); _R4( e,a,b,c,d, 71); _R4(d,e,a,b,c,72); _R4(c,d,e,a,b,73); _R4(b,c,d,e,a,74); _R4(a,b,c,d,e,75); _R4(e,a,b,c,d,76); _R4(d,e,a,b,c,77); _R4(c,d,e,a,b,78); _R4(b,c,d,e,a,79);

II Add the working vars back into state state[O] += a; state [1 ] += b; state[2] += c; state[3] += d; state[4] += e; II Wipe variables #ifdef SHA I_WIPE_VARIABLES a = b = c = d = e = 0; #endif } II Use this function to hash in binary data and strings void CSHAl::Update(UINT_8 *data, UINT_32 len)
{

j

=

(m_count[O] » 3) & 63;

if«m_count[O] += len« 3) < (len« 3)) m_count[l]++; m count[l] += (len» 29); if«(j + len) > 63)
{

i = 64 - j;
51

memcpy(&m_bufferO], data, i); Transform(m_state, m_buffer); fore; i + 63 < len; i += 64) Transform(m_state, &data[i));

j = 0;
} else i
=

0;

memcpy(&m_buffer[j], &data[i], len - i);
}

#ifdefSHAl - UTILITY FUNCTIONS II Hash in file contents bool CSHAI ::HashFile(char *szFileName) { unsigned long ulFileSize, ulRest, ulBlocks; unsigned long i; UINT_8 uData[SHA 1_MAX_FILE _BUFFER]; FILE *f1n; if(szFileName == NULL) return false; fln = fopen(szFileName, "rh"); if(fln == NULL) return false; fseek(fln, 0, SEEK_END); ulFileSize = (unsigned 10ng)fteU(fln); fseek(fln, 0, SEEK_SET); if(ulFileSize != 0) { ulBlocks = ulFileSize I SHA1_MAX_FILE_BUFFER; ulRest = ulFileSize % SHAl_MAX_FILE_BUFFER; } else { ulBlocks = 0; ulRest = 0; } for(i = 0; i < ulBlocks; i++) { fread(uData, 1, SHAl_MAX_FILE_BUFFER, fln); Update«UINT_8 *)uData, SHA1_MAX_FILE_BUFFER); } 52

if(ulRest != 0) { fread(uData, 1, ulRest, fin); Update((UINT_S *)uData, ulRest); } fclose(fin); fin = NULL; return true;
} #endif

void CSHAI ::FinalO { UINT_32 i; UINT_S finalcount[8]; for(i = 0; i < 8; i++) finalcount[i] = (UINT_S)((m_count[((i >= 4) ? 0 : 1)] » ((3 - (i & 3» * 8) ) & 255); II Endian independent Update((UINT_S *)"\200", 1); while ((m_count[O] & 504) != 44S) Update((UINT_8 *)"\0", 1); Update(finalcount, 8); II Cause a SHAI TransformO for(i = 0; i < 20; i++)
{

m_digest[i] = (UINT_S)((m_state[i» 2] » ((3 - (i & 3»
}

* 8»

& 255);

II Wipe variables for security reasons #ifdef SHA 1- WIPE- VARIABLES i = 0; memset(m_buffer, 0, 64); memset(m_state, 0,20); memset(m_count, 0, S); memset(finalcount, 0, S); Transform(m_state, m_buffer); #endif
}

#ifdefSHAI - UTILITY- FUNCTIONS 53

II Get the final hash as a pre-formatted string void CSHAI ::ReportHash(char *szReport, unsigned char uReportType) { unsigned char i; char szTemp[16];
if(szReport == NULL) return; if(uReportType == REPORT_HEX) { sprintf(szTemp, "%02X", m_digest[O]); strcat( szReport, szTemp); for(i = 1; i < 20; i++) { sprintf(szTemp, " %02X", m_digest[i]); strcat(szReport, szTemp); }

} else if(uReportType == REPORT_DIGIT) { sprintf(szTemp, "%u", m_digest[O]); strcat(szReport, szTemp);
for(i = 1; i < 20; i++) { sprintf(szTemp, " %u", m_digest[i]); strcat(szReport, szTemp); }

} else strcpy(szReport, "Error: Unknown report type!");
} #endif

I I Get the raw message digest void CSHA1::GetHash(UINT_8 *puDest) { memcpy(puDest, m_digest, 20); }

54

void UHash24 (uchar *msg, uchar *secret, int len, uchar *result)
{

uchar r1 = 0, r2 = 0, r3 = 0, s 1, s2, s3, byteCnt = 0, bitCnt, byte; while (len-- > 0) { if (byteCnt-- == 0) { s 1 = *secret++; s2 = *secret++; s3 = *secret++; byteCnt = 2; } byte = *msg++; for (bitCnt = 0; bitCnt < 8; bitCnt++) { if (byte & 1) { 1* msg not divisible by x *1 r 1 /\= S 1; 1* so add s * 1 *1 r2 /\= s2; r3 /\= s3; } byte>>= 1; 1* divide message by x *1 if (s3 & Ox80) { 1* and multiply secret with x, subtracting the polynomial when necessary to keep its order under 24 *1 s3 «= 1; if (s2 & Ox80) s3 1= 1; s2 «= 1; if(s1 & Ox80) s21= 1; sl «= 1; sl /\= OxIB; 1* x/\24 + x/\4 + x/\3 + x + 1 *1 } else { s3 «= 1; if (s2 & Ox80) s3 1= 1; s2 «= 1; if(sl & Ox80) s21= 1; sl «= 1; } } 1* for each bit in the message *1 } 1* for each byte in the message *I *result++ /\= r1; *result++ /\= r2; *result++ /\= r3; printf("result %s= \n", result);

}

1* End of Function Block *1
55

1* Undefine optional tracing in FINIFOUTIFRET *1 1* The FSM has its own tracing code and the other *1 1* functions should not have any tracing. *1
#undef FIN TRACING #define FIN TRACING #undefFOUTRET TRACING #define FOUTRET TRACING

1* Undefine shortcuts to state variables because the *1 1* following functions are part of the state class *1
#undef own id #undef format str #undef start time #undef stop_time #undef interarrival_dist~tr #undef pksize_ dist~tr #undef generate_unformatted #undef next~k_evh #undef next- intarr- time #undef bits- sent- hndl #undef packets_ sent_hndl #undef packet_size_ hndl #undef interarrivals hndl #undef max~acket_count

1* Access from C kernel using C linkage *1
extern "C" { VosT_Obtype _op_simple_source_init (int * init_block~tr); VosT_Address _op_simple_source_alloc (VosT_Obtype, int); void simple_source (OP_SIM_CONTEXT_ARG_OPT) { ((simple_source_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state~tr)) >simple_source (OP_SIM_CONTEXT_PTR_OPT); } void _op_simple_source_svar (void *, const char *, void **); void _op_simple_source_diag (OP_SIM_CONTEXT_ARG_OPT) { ((simple_source_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state~tr)) > _op_simple_source_diag (OP_SIM_CONTEXT_PTR_OPT); }

56

void _op_simple_source_terminate (OP_SIM_CONTEXT_ARG_OPT) { 1* The destructor is the Termination Block *1 delete (simple_source_state *)(OP_SIM_CONTEXT_PTR->_op_mod_stateytr);
}

} 1* end of 'extern "C'" *1 1* Process model interrupt handling procedure *1
void simple_source_state::simple_source (OP_SIM_CONTEXT_ARG_OPT) { #if !defined (VOSD_NO_FIN) int _ op_block_origin = 0; #endif FIN_MT (simple_source_state::simple_source 0); try { 1* Temporary Variables *1 1* Variables used in the "init" state. *I char interarrival_str [128]; char size_str [128]; Prg_List* pk_ format_names _lptr; char* found _format_str; Boolean format_found; i·, int

1* Variables used in state transitions.
int intrpt_code;

*I

1* End of Temporary Variables *1
FSM_ENTER ("simple_source") FSM_BLOCK_SWITCH {

1*---------------------------------------------------------*1 1** state (init) enter executives **1
FSM_STATE_ENTER_UNFORCED_NOLABEL (0, "init", "simple_source [init enter execs]") FSM_PROFILE_SECTION_IN ("simple_source [init enter execs]", s~ateO_enter_exec) 57

{

1* At this initial state, we read the values of source attributes *1 1* and schedule a selt interrupt that will *1 1* for packet generation. *1 1* Obtain the object id of the surrounding module. *1
IIInitialize hashedKey hashedKey = RSHash(itoa(hashedKey, key, 10»; hashedKey Packet = RSHash(itoa(hashedKey Packet, key Hashed, 10»;
indic~te

our start time

1* Read the values of the packet generation parameters, i.e. the *1 1* attribute values of the surrounding module. *1
op_ima_obLattr_get (own_id, "Packet Interarrival Time ll , interarrival_str); op_ima_obLattr_get (oWll_id, "Packet Size ll , op_ima_obLattr_get (oWll_id, IIPacket Format", op_ima_obLattr_get (own_id, IIStart Time ll , op_ima_obLattr_get (oWll_id, "Stop Time", size_str);

1* Get the maximum packet count, *1 1* set at simulation run-time *1
op_ima_ sim_ attr~et_int32 ("Maximum Packet", &max-'packet_count);

1* Load the PDFs that will be used in computing the packet *1 1* interarrival times and packet sizes. *1
interarrival_dist-.ptr = oms_ dist_load_from_string (interarrival_str);

1* Verify the existence of the packet format to be used for *1 1* generated packets. *1
58

if (strcmp (format_str, "NONE") 0) { 1* We will generate unformatted packets. Set the flag.

*1
generate_unformatted = OPC_TRUE; } else

{

1* We will generate formatted packets. Tum off the flag. *1
generate_unformatted = OPC_FALSE;

/* Get the list of all available packet formats.
*/ pk_format_namesJptr (PrgC_Tfile_Type_Packet_Format); /* Search the list for the requested packet format. */ format_found = OPC_FALSE; for (i = prg_list_size (pk_format_names_lptr); ((format_found == OPC_FALSE) && (i > 0)); i--) { 1* Access the next format name and compare with requested *I 1* format name. prg_tfile_name_list_get

*1
found_format_str = (char *) prg_list_access if (strcmp (found_format_str, format_str) == 0) format_found = OPC_TRUE; } if (format_found == OPC_FALSE) { 1* The requested format does not exist. Generate

*1 1* unformatted packets. *1
generate_unformatted = ope_TRUE; /* Display an appropriate warning. */ op-.rrg_odb-.rrint_major ("Warning from simple packet generator model (simple_source):",

59

"The specified packet format", format_ str, "is not found. Generating unformatted packets instead.", OPC _NIL); } /* Destroy the lits and its elements since we don't need it

*/ /* anymore.
*/ prg_list_free (pk_format_names_lptr); prg_mem_free (pk_ format_names _lptr); }

/* Make sure we have valid start and stop times, i.e. stop time is */ /* not earlier than start time. */ if ((stop_time <= start_time) && (stop_time != S SC_INFINITE_TIME)) { /* Stop time is earlier than start time. Disable the source. */

/* Display an appropriate warning.

*/
op~rg_odb~rint_major

("Warning from simple packet "Although the

generator model (simple_source):", generator is not disabled (start time is set to a finite value),", "a stop time that is not later than the start time is specified.", "Disabling the generator.",OPC_NIL); } /* Schedule a self interrupt that will indicate our start time for */ /* packet generation activities. Ifthe source is disabled,

*/
/* schedule it at current time with the appropriate code value. */ if (start_time == SSC_INFINITE_TIME) { 60

opjntrpt_sehedule_self(op_sim_time } else

0, SSC_STOP);

{ op_intrpt_schedule_self(start_time, SSC_START);

/* In this case, also schedule the interrupt when we will
stop

*/
/* generating packets, unless we are configured to run until

*/ /* the end of the simulation.
*/

if (stop_time != SSC_INFINITE_TIME) { op_intrpt_schedule_self(stop_time, SSC_STOP); }

rpt=o; /* Register the statistics that will be maintained by this model. */ bits_sent_hndl = op_statJeg ("Generator.Traffic Sent OPC_STAT_INDEX_NONE,OPC_STAT_LOCAL); packets_sent_hndl = op_statJeg ("Generator.Traffic Sent OPC_STAT_INDEX_NONE,OPC_STAT_LOCAL); (packets/sec)", packet_size_hndl = op_stat_reg ("Generator. Packet Size (bits)", OPC_STAT_INDEX_NONE,OPC_STAT_LOCAL); interarrivals_hndl = op_stat_reg ("Generator.Packet Interarrival Time (sees)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL); (bits/sec)", } FSM_PROFILE_SECTION_OUT (stateO_enter_exec)

/* * blocking after enter executives of unforced state. **/
FSM_EXIT (l,"simple_source")

/** state (init) exit executives **/
FSM_STATE_EXIT_UNFORCED (0, "init", "simple_source [init exit execs]")

{

/* Determine the code of the interrupt, which is used in evaluating */

61

1* state transition conditions. *1 intrpt_code = op_intrpt_code 0;
} FSM_PROFILE_SECTION_OUT (stateO_exit_exec)

1** state (init) transition processing **1
FSM_PROFILE_SECTION_IN ("simple_source [init trans conditions]", stateO_trans _ conds) FSM_INIT_COND (START) FSM_TEST_COND (DISABLED) FSM_TEST_LOGIC ("init") FSM_PROFILE_SECTION_OUT (stateO_trans_conds) FSM- TRANSIT- SWITCH { FSM_CASE_TRANSIT (0, 1, statel_enter_exec, sS-IJacket_generateO;, "START", "ss-IJacket_generateO", "init", "generate", "tr_O", "simple_source [init -> generate: START I sS-IJacket_generate()]") FSM_CASE_TRANSIT (1, 2, state2_enter_exec, ;, "DISABLED", "", "init", "stop", "tr_l ", "simple_source [init -> stop: DISABLED I ]") }

1*---------------------------------------------------------*1

1* * state (generate) enter executives

**I

FSM_STATE_ENTER__UNFORCED (1, "generate", statel_enter_exec, "simple_source [generate enter execs]") FSM_PROFILE_SECTION_IN ("simple_source [generate enter execs]", state I_enter_exec) { 1* At the enter execs of the "generate" state we schedule the

*1

1* arrival of the next packet.
*1
next_intarr_time = oms_dist_outcome (interarrival_dist-IJtr); rpt++; 1* Make sure that interarrival time is not negative. In that case it *1 1* will be set to 0.

*1
if(next_intarr_time <0) { next_intarr_time = 0; }

62

next~k_evh

=

op_intrpt_schedule_self (op_sim_time

+ next_intarr_time, SSC_GENERATE);
op_ stat_write (interarrivals_ hndl, next_intarr_time); } FSM_PROFILE_SECTION_OUT (state1_enter_exec)

0

/** blocking after enter executives of unforced state. **/ FSM_EXIT (3,"simple_source")

/* * state (generate) exit executives **/ FSM_STATE_EXIT_UNFORCED (1, "generate", "simple_source
[generate exit execs] ") execs] "', state 1_exit_exec)
{ /* Determine the code of the interrupt, which is used in evaluating

*/

/* state transition conditions. */ intrpt_code = op_intrpt_code

0;

} FSM_PROFILE_SECTION_OUT (state1_exit_exec)

/* * state (generate) transition processing **/ FSM_PROFILE_SECTION_IN ("simple_source [generate trans conditions]", state1_trans_conds) FSM- INIT- COND (STOP) . FSM_TEST_ COND (PACKET_GENERATE) FSM_TEST_LOGIC ("generate") FSM_PROFILE_SECTION_OUT (state1_trans_conds)
FSM- TRANSIT- SWITCH
{

FSM_CASE_TRANSIT (0,2, state2_enter_exec, ;, "STOP", "", "generate", "stop", "tr_2", "simple_source [generate -> stop: STOP / ]") FSM_CASE_TRANSIT (1, 1, state1_enter_exec, ss~acket_generateO;, "PACKET_GENERATE", "ss~acket_generateO", "generate", "generate", "tr_3", "simple_source [generate -> generate: PACKET_GENERATE / ss~acket_generateO] ") } 63

/*---------------------------------------------------------*/

/** state (stop) enter executives **/
FSM_STATE_ENTER_UNFORCED (2, "stop", state2_enter_exec, "simple_source [stop enter execs]") FSM_PROFILE_SECTION_IN ("simple_source [stop enter execs]", state2_enter_exec) { /* When we enter into the "stop" state, it is the time for us to */ /* stop generating traffic. We simply cancel the generation of the */ /* next packet and go into a silent mode by not scheduling anything */ /* else. */ if (op_ev_valid (next-pk_evh) == OPC_TRUE) { op_ ev_cancel (next--IJk_ evh); } } FSM_PROFILE_SECTION_OUT (state2_enter_exec)

/** blocking after enter executives of unforced state. **/
FSM_EXIT (5,"simple_source")

/** state (stop) exit executives **/
FSM_STATE_EXIT_UNFORCED (2, "stop", "simple_source [stop exit execs]")

/* * state ( stop) transition processing **/ FSM_TRANSIT_MISSING ("stop") /*---------------------------------------------------------*/

}

FSM_EXIT (O,"simple_source") } 64

catch ( ... ) { Vos_Error_Print (VOSC_ERROR_ABORT, (const char *)VOSC NIL, "Unhandled C++ exception in process model (simple_source)", (const char *)VOSC_NIL, (const char *)VOSC_NIL); } }

void simple_source_state::_op_simple_source_diag (OP_SIM_CONTEXT ARG_OPT) { /* No Diagnostic Block *1 } void simple_source_state::operator delete (void* ptr)

{
FIN (simple_source_state::operator delete (ptr»; Vos_Poolmem_Dealloc (ptr); FOUT } simple_source_state::-simple_source_state (void) {

/* No Termination Block *1

FOUT }

#undef FIN- PREAMBLE- DEC #undefFIN_PREAMBLE_CODE #define FIN_PREAMBLE_DEC #define FIN_PREAMBLE_CODE void

*
65

simple_source_state::operator new (size _t) #if defined (VOSD_NEW_BAD_ ALLOC) throw (VOSD_BAD_ALLOC) #endif { void * new~tr; FIN_MT (simple_source_state::operator new 0);
new~tr = Vos_Alloc_Object (simple_source_state::obtype); #if defined (VOSD_NEW_BAD_ALLOC) if (new~tr == VOSC_NIL) throw VOSD_BAD_ ALLOCO; #endif FRET (new~tr) }

1* State constructor initializes FSM handling */ . 1* by setting the initial state to the first *1 1* block of code to enter. *1
simple_source_state::simple_source_state (void) : _op_current_block (0) { #if defined (OPD- ALLOW- ODB) _op_current_state = " simple__source [init enter execs]"; #endif } VosT_ Obtype _op_simple_source_init (int * init_block~tr) { FIN_MT Lop_simple_source_init (init_block~tr)) simple_source_state::obtype = Vos_Define_Object_Prstate ("proc state vars (simple_source)", sizeof (simple_source_state»; *init_block~tr = 0; FRET (simple_source_state::obtype) } VosT Address _op_simple_source_alloc (VosT_Obtype, int) { #if !defined (VOSD _NO_FIN) int _op_block_origin = 0;

66

#endif simple_source_state * ptr; FIN_MT Cop_simple_source_alloc 0) /* New instance will have FSM handling initialized */ #if defined (VOSD_NEW_BAD_ALLOC) try { ptr = new simple_source_state; } catch (const VOSD_BAD_ALLOC &) { ptr VOSC_NIL; } #else ptr new simple_source_state; #endif FRET «VosT_Address)ptr) }

void _op_simple_source_svar (void * genJ'tr, eonst char * var_name, void ** varJ'J'tr) { simple_source_state *prsJ'tr;

if (var_name OPC NIL) { *varJ'J'tr (void *)OPC_NIL; FOUT } prsJ'tr = (simple_source_state *)genJ'tr; if (strcmp ("ownJd" , var_name) == 0) { *varJ'J'tr (void *) (&prsJ'tr->own_id); FOUT } if (strcmp ("format_str" ,var_name) == 0) { *varj)J'tr = (void *) (prsJ'tr->format_str); FOUT } if (strcmp ("start_time" , var_name) == 0) { *varJ'J'tr = (void *) (&prsJ'tr->start_time);

67

FOUT
} if (strcmp ("stop_time" , var_name) == 0) { *var-.p-.Ptr = (void *) (&prs-'ptr->stop_time);

FOUT
} if(strcmp C'interarrival_dist-'ptr" , var_name) == 0)

{ *var-.p-.ptr = (void *) (&prs-'ptr->interarrival_dist-'ptr);

FOUT
} if (strcmp ("pksize_dist-'ptr" , var_name) == 0) { *var-.p-.Ptr = (void *) (&prs-.ptr->pksize_dist-.ptr);

FOUT
if (strcmp ("generate_unformatted" , var_name) == 0) { *var-.p-.Ptr = (void *) (&prs-'ptr->generate_unformatted);

l

FOUT
} if(strcmp ("next-'pk_evh" , var_name) == 0) { *var-.p-.ptr = (void *) (&prs~tr->next-'pk_evh);

FOUT
} if (strcmp ("next_intarr_time" , var_name) == 0)
{ *var-.p-.Ptr = (void *) (&prs-'ptr->next_intarr_time);

FOUT
} if(strcmp ("bits_sent_hndl" , var_name) == 0) { *var-.p-.Ptr = (void *) (&prs-'ptr->bits_sent_hndl);

FOUT
} if (strcmp ("packets_sent_hndl" , var_name) == 0) { *var-.p-.Ptr = (void *) (&prs-'ptr->packets_sent_hndl);

FOUT
} if (strcmp ("packet_size_hndl" , var_name) == 0) { *var-.p-.Ptr = (void *) (&prs-.ptr->packet_size_hndl);

FOUT
68

} if (strcmp ("interarrivals_hndl" , var_name) == 0) { *var~~tr = (void *) (&prs-'ptr->interarrivals_hndl);

FOUT
}

if (strcmp ("max-'packet_count" ,var_name) == 0)
{
*var~-.ptr =

(void *)

(&prs~tr->max-'packet_count);

FOUT
}
*var~-.ptr

= (void *)OPC_NIL;

FOUT
}

69

APPENDIX B: RECEIVER SOURCE CODE
/* Process model C++ form file: SensorNetwork_Fifo.pr.cpp */ /* Portions of this file copyright 1986-2009 by OPNET Technologies, Inc. */

/*
=====:==:===:=:===:==:============ l'-lOTE ==========================

This file is automatically generated from SensorNetwork_Fifo.pr.m during a process model compilation. Do NOT manually edit this file. Manual edits will be lost during the next compilation. =:=====:==:=======:====-::::.====== NOTE ========================== */

/* This variable carries the header into the object file */ const char SensorNetwork_Fifo-pr_cpp [] = "MIL_3_Tfile_Hdr_ lS0A 30A modeler 7 4D227751 4D227751 1 rye-udcmybdtq7r Administrator 00 none none 0 0 none 0 0000000 21b73
It.

,

#include <string.h>

/* OPNET system definitions */ #include <opnet.h>

1* Header Block *1

#include <string> #include <oms _ dist_support.h> #include "hmac_ sha 1.hpplt #include "shal.hpp" #define ARRIVAL op_intrpt_type 0 == OPC_INTRPT_STRM /* Node configuration constants. */ #define SSC_STRM_TO_LOW 0 int num-pkts, num-pkts 1; 70

int ~index; int num_subqs, num_subqsl; int packetCount=O; int ind=-I; int Service=O; Packet *pkptr3 = OPC_NIL; int receiverCountrPacket=O; int queuePositionHead = oPC_QPOS_HEAD;

int indx; static bool CompareMessages(int message, int KeySentByTransmitter, int nextmessage, int macenqueued);

static void AccessQueueO; BYTE packetKey Enqueued[ 14]; List* listOfStructures = OPC_NIL; BYTE digestReceiver[4]; #ifndeflNCLUDE- GENERALHASHFUNCTION- CPP- H #define INCLUDE_GENERALHASHFUNCTION_CPP_H typedef unsigned int (*HashFunction)( const std: :string&);

int RSHashReceiver (const std::string& str); #endif /* End of Header Block */ #if !defined (VOSD _NO_FIN) #undefBIN #undefBOUT #defineBIN FIN_LOCAL_FIELDCopJast_line-IJassed) = _LINE__ op_block_origin; #defineBOUT BIN #defineBINIT FIN_LOCAL_FIELDCop_last_line-IJassed) = 0; _op_block_origin = _LINE_; #else #defineBINIT #endif /* #if !defined (VOSD_NO_FIN) */

71

1* State variable definitions *1 class SensorNetwork- Fifo- state
{ private:

1* Internal state tracking for FSM *1
FSM- SYS- STATE public: SensorNetwork_Fifo_state (void);

1* Destructor contains Termination Block *1
~SensorNetwork_Fifo_state

(void);

1* State Variables *1
Stathandle Stathandle Stathandle Stathandle Stathandle Stathandle Stathandle Stathandle Stathandle Stathandle bits- rcvd- stathandle bits sec- rcvd- stathandle pkts_rcvd_ stathandle pktssecJcvd_ stathandle ete_delay_ stathandle bitsJcvd_gstathandle bitssecJcvd_gstathandle pktsJcvd_gstathandle pktssec_rcvd_gstathandle ete_delay_gstathandle

1* FSM code *1
void SensorNetwork_Fifo (OP_SIM_CONTEXT_ARG_OPT); 1* Diagnostic Block *1 void _op_SensorNetwork_Fifo_diag (OP_SIM_CONTEXT_ARG_OPT); #if defined (VOSD_NEW_BAD_ ALLOC) void * operator new (size_t) throw (VOSD_BAD_ALLOC); #else void * operator new (size_t); #endif void operator delete (void *);

1* Memory management *1
static VosT_ Obtype obtype;
};

#define bits- rcvd- stathandle #define bitssec- rcvd- stathandle

op_ sv~tr->bits_rcvd_ stathandle op_ sv~tr->bitssec_rcvd_ stathandle

72

#define pktsJcvd_ stathandle #define pktssec _rcvd_ stathandle #define ete _delay_ stathandle #define bitsJcvd_gstathandle #define bitssecJcvd_gstathandle #define pkts_rcvd_gstathandle #define pktssec_rcvd_gstathandle #define ete _delay_gstathandle

op_ sv-.rtr->pkts_rcvd_ stathandle op_ sv-.rtr->pktssecJcvd_ stathandle op_ sv-.rtr->ete_delay_ stathandle op_ sv-.rtr->bitsJcvd_gstathandle op_sv-.rtr->bitssec_rcvd_gstathandle op_ sv-.rtr->pkts_rcvd_gstathandle op_ sv-.rtr->pktssec_rcvd_gstathandle op_ sv-.rtr->ete_delay_gstathandle

These macro definitions will define a local variable called *I "op_ sv-.rtr" in each function containing a FIN statement. */ This variable points to the state variable data structure, *1 and can be used from a C debugger to display their values. */ #undef FIN- PREAMBLE- DEC #undef FIN- PREAMBLE- CODE #define FIN_PREAMBLE_DEC SensorNetwork_Fifo_state *op_sv-.rtr; .. #define FIN- PREAMBLE- CODE \ op_sv-.rtr = ((SensorNetwork_Fifo_state *)(OP_SIM_CONTEXT_PTR>_op_mod_state-.rtr));

1* 1* 1* 1*

1* Function Block *1
#if !defined (VOSD_NO_FIN) enum {_op_block_origin = _LINE_ + 2}; #endif #inc1ude <stdio.h> #inc1ude <stdlib.h> #inc1ude <string.h> #inc1ude <string>

static bool CompareMessages (int message, int KeySentByTransmitter, int nextmessage, int macenqueued) { II FIN (CompareMessages(int packetKey, int enqueuedMessage, int enqueuedMac, int enq ueuedN extMessage )); FIN (CompareMessages(int message, int KeySentByTransmitter, int nextmessage, int mac enqueued) ); char nextMessageArray[4]; char messageArray[4]; char keyArray[4]; itoa(message, messageArray, 10);

73

Ilitoa(message [++counter] ,nextMessage, 10); itoa(nextmessage, nextMessageArray, 10); int h = RSHashReceiver(nextMessageArray); int macMessage = h + message; char messageHashed[4]; itoa(macMessage,messageHashed, 10); CHMAC_SHAReceiver HMAC_SHAI ; HMAC_SHAl.HMAC_SHAReceiver((unsigned char *)messageHashed, sizeof(messageHashed), (unsigned char *)itoa(KeySentByTransmitter,keyArray, 10), sizeof(keyArray), digestReceiver) ;

unsigned long hashedCode = 0; unsigned long mult = 1; for (unsigned i = 0; i < 4; ++i) { hashedCode += muit * digestReceiver[sizeof(digestReceiver)-l-i]; mult «= 8; } bool rtn = true; FRET(rtn);
}

int RSHashReceiver(const std::string& str) { int b = 3785; int a = 63689; int hash = 0; for(int i = 0; i < str.lengthO; i++) { hash = hash * a + str[i]; a = a * b;
}

return (hash & Ox7FFFFFFF); IlReturns the hashed string} 1* End Of RS Hash Function *1 } void CHMAC_SHAReceiver::HMAC_SHAReceiver(BYTE *text, int text_len, BYTE *key, int key_len, BYTE *digest) {

74

1* repeated 64 times for values in ipad and opad *1
memset(m_ipad, Ox36, sizeof(mjpad»; memset(m_opad, Ox5c, sizeof(m_opad»;

1* STEP 1 *1
if (key_len> SHAl_BLOCK_SIZE) { CSHAReceiver: :ResetReceiverO; CSHAReceiver:: UpdateReceiver( (UINT_ 8 *)key, keyJen); CSHAReceiver::FinaIReceiverO; CSHAReceiver::GetHashReceiver((UINT_8 *)SHAI_Key);
} else

memcpy(SHAl_Key, key, key_len);

1* STEP 2 *1
for (int i=O; i<sizeof(mjpad); i++) { mjpad[i] "= SHAl_Key[i]; }

1* STEP 3 *1
memcpy(AppendBufl, m_ipad, sizeof(m_ipad»; memcpy(AppendBufl + sizeof(mjpad), text, text_len);

1* STEP 4 *1
CSHAReceiver::ResetReceiverO; CSHAReceiver::UpdateReceiver((UINT_8 *)AppendBufl, sizeof(mjpad) + textJen); CSHAReceiver: :FinalReceiverO; CSHAReceiver: :GetHashReceiver( (UINT_8 *)szReport);

1* STEP 5 *1
for (intj=O; j<sizeof(m_opad); j++) { m_opad[j] "= SHAl_Key[j]; }

1* STEP 6 *1
memcpy(AppendBuf2, m_opad, sizeof(m_opad»; me~cpy(AppendBuf2 + sizeof(m_opad), szReport, SHAl_DIGEST_LENGTH);
75

I*STEP 7 *1 CSHAReceiver: :ResetReceiverO; CSHAReceiver:: UpdateReceiver( (UINT_ 8 *)A ppendB uf2, sizeof(m_opad) + SHAl_DIGEST_LENGTH); CSHAReceiver: :FinalReceiverO;
CSHAReceiver: :GetHashReceiver((UINT_ 8 *)digest);
}

#ifdefSHAl - UTILITY- FUNCTIONS #define SHAI - MAX- FILE- BUFFER 8000 #endif

II Rotate x bits to the left #ifndef ROL32 #ifdef - MSC- VER #define ROL32Lva132, _nBits) JotlLval32, _nBits) #else #define ROL32Lva132, _nBits) ((LvaI32)«LnBits))I(Lva132»>(32-LnBits)))) #endif #endif
#ifdef SHAI - LITTLE- ENDIAN #define SHABLKO(i) (m_block->l[i] = \ (ROL32(m_block->I[i],24) & OxFFOOFFOO) I (ROL32(m_block->I[i],8) & OxOOFFOOFF)) #else #define SHABLKO(i) (m_block->l[i]) #endif #define SHABLK(i) (m_block->I[i&15] = ROL32(m_block->1[(i+13)&15] "m_block>1[(i+8)&15] \ "m_block->l[(i+2)&15]" m_block->I[i&15],1))

II SHA-l rounds #define _RO(v,w,x,y,z,i) { z+=((w&(x"y))"y)+SHABLKO(i)+Ox5A827999+ROL32(v,5); w=ROL32(w,30); } #define _Rl(v,w,x,y,z,i) { z+=((w&(x"y))"y)+SHABLK(i)+Ox5A827999+ROL32(v,5); w=ROL32(w,30); } #define _R2(v,w,x,y,z,i) { z+=(w"x"y)+SHABLK(i)+Ox6ED9EBAl +ROL32(v,5); w=ROL32(w,30); } #define _R3(v,w,x,y,z,i) { z+=(((wlx)&y)l(w&x))+SHABLK(i)+Ox8FlBBCDC+ROL32(v,5); w=ROL32(w,30); } #define _R4(v,w,x,y,z,i) { z+=(w"x"y)+SHABLK(i)+OxCA62CID6+ROL32(v,5); w=ROL32(w,30); }

76

CSHAReceiver: :CSHAReceiverO {

ResetReceiverO;

}
CSHAReceiver::~CSHAReceiverO

{

ResetReceiver();

}
void CSHAReceiver::ResetReceiverO { II SHA1 initialization constants m_state[O] = Ox67452301; m_state[l] = OxEFCDAB89; m_state[2] = Ox98BADCFE; m_state[3] = Ox10325476; m_state[4] = OxC3D2EIFO; m_count[O] = 0; m_count[l] = 0;

}
void CSHAReceiver::TransformReceiver(UINT_32 *state, UINT_8 *buffer) { /1 Copy state[] to working vars UINT_32 a = state[O], b state[I], c = state[2], d = state[3], e = state[4]; memcpy(m_block, buffer, 64);

114 rounds 0[20 operations each. Loop unroUed. _RO(a,b,c,d,e, 0); _RO(e,a,b,c,d, 1); _RO(d,e,a,b,c, 2); _RO(c,d,e,a,b, 3); _RO(b,c,d,e,a, 4); _RO(a,b,c,d,e, 5); _RO(e,a,b,c,d, 6); _RO(d,e,a,b,c, 7); _RO(c,d,e,a,b, 8); _RO(b,c,d,e,a, 9); _RO(a,b,c,d,e,lO); _RO(e,a,b,c,d, 1 1); _RO(d,e,a,b,c,12); _RO(c,d,e,a,b,13); _RO(b,c,d,e,a,14); _RO(a,b,c,d,e, 15); _Rl(e,a,b,c,d,16); _Rl(d,e,a,b,c,17); _Rl(c,d,e,a,b,18); _Rl(b,c,d,e,a,19); _ R2(a,b,c,d,e,20); _R2( e,a,b,c,d,21); _ R2(d,e,a,b,c,22); _ R2( c,d,e,a,b,23); _R2(b,c,d,e,a,24); _ R2(a,b,c,d,e,25); _R2( e,a,b,c,d,26); _ R2(d,e,a,b,c,27); _ R2(c,d,e,a,b,28); _R2(b,c,d,e,a,29); _ R2(a,b,c,d,e,30); _ R2( e,a,b,c,d,31); _R2( d,e,a,b,c,32); _ R2( c,d,e,a,b,33); _R2(b,c,d,e,a,34); _ R2(a,b,c,d,e,35); _R2(e,a,b,c,d,36); _R2(d,e,a,b,c,37); _R2(c,d,e,a,b,38); _R2(b,c,d,e,a,39); _R3(a,b,c,d,e,40); _R3(e,a,b,c,d,41); _ R3( d,e,a,b,c,42); _ R3(c,d,e,a,b,43); _ R3(b,c,d,e,a,44); _R3(a,b,c,d,e,45); _ R3( e,a,b,c,d,46); _ R3( d,e,a,b,c,47); _R;3( c,d,e,a,b,48); _ R3(b,c,d,e,a,49); _R3( a,b,c,d,e,50); _ R3(e,a,b,c,d,51);
77

_R3( d,e,a,b,c,52); _ R3( c,d,e,a,b,53); _ R3(b,c,d,e,a,54); _ R3( a,b,c,d,e,55); _R3( e,a,b,c,d,56); _ R3( d,e,a,b,c,57); _ R3( c,d,e,a,b,58); _R3(b,c,d,e,a,59); _ R4(a,b,c,d,e,60); _ R4( e,a,b,c,d,6l); _ R4( d,e,a,b,c,62); _R4( c,d,e,a,b,63); _ R4(b,c,d,e,a,64); _ R4( a,b,c,d,e,65); _R4( e,a,b,c,d,66); _ R4( d,e,a,b,c,67); _ R4( c,d,e,a,b,68); _R4(b,c,d,e,a,69); _ R4(a,b,c,d,e,70); _R4( e,a,b,c,d,7l); _ R4( d,e,a,b,c, 72); _ R4( c,d,e,a,b,73); _R4(b,c,d,e,a,74); _R4(a,b,c,d,e,75); _ R4( e,a,b,c,d,76); _R4( d,e,a,b,c, 77); _ R4( c,d,e,a,b,78); _ R4(b,c,d,e,a,79);
II Add the working vars back into state state[O] += a; state[l] += b; state[2] += c; state[3] += d; state[4] += e; II Wipe variables #ifdefSHAl - WIPE- VARIABLES a = b = c = d = e = 0; #endif } II Use this function to hash in binary data and strings void CSHAReceiver::UpdateReceiver(UINT_8 *data, UINT_32 len)

{
j = (m_count[O] » 3) & 63;
if((m_count[O] += len« 3) < (len« 3» m_count[l]++; m_count[l] += (len» 29); if((j + len) > 63) { i = 64 - j; memcpy(&m_buffer[j], data, i); TransformReceiver(m_state, m_buffer); fore; i + 63 < len; i += 64) TransformReceiver(m_state, &data[i));

j = 0;

} else i = 0;
memcpy(&m_buffer[j], &data[i], len - i); } 78

#ifdefSHAl UTILITY FUNCTIONS II Hash in file contents bool CSHAReceiver::HashFileReceiver(char *szFileName) { unsigned long ulFileSize, ulRest, ulBlocks; unsigned long i; UINT_8 uData[SHAI_MAX_FILE_BUFFER]; FILE *fln; if(szFileName == NULL) return false; fln fopen(szFileName, "rb"); if(fln == NULL) return false; fseek(fln, 0, SEEK_END); ulFileSize = (unsigned long)ftell(fln); fseek(fln, 0, SEEK SET); if(ulFileSize I=:; 0) { ulBlocks ulFileSize I SHAl_MAX_FILE_BUFFER; ulRest ulFileSize % SHAl_MAX_FILE_BUFFER;
}

else { ulBlocks = 0; ulRest == 0;
}

for(i {

=

0; i < ulBlocks; i++) fread(uData, 1, SHAl_MAX_FILE_BUFFER, fln); UpdateReceiver«(UINT_8 *)uData, SHAI_MAX_FILE_BUFFER);

}

if(ulRest != 0) { fread(uData, 1, ulRest, fln); UpdateReceiver«UINT_8 *)uData, ulRest); } fclose(fln); fln = NULL; return true;
}

#endif

79

void CSHAReceiver: :FinalReceiverO { UINT_32 i; UINT_8 finalcount[8]; for(i = 0; i < 8; i++) finalcount[i] = (UINT_8)((m_count[((i >= 4) ? 0 : 1)] » ((3 - (i & 3» * 8) ) & 255); II Endian independent UpdateReceiver((UINT_8 *)"\200", 1); while ((m_count[O] & 504) != 448) UpdateReceiver((UINT_8 *)"\0", 1); UpdateReceiver(finalcount, 8); II Cause a SHAI TransformO for(i {
}
=

0; i < 20; i++) m_digest[i] = (UINT_8)((m_state[i» 2] » ((3 - (i & 3» * 8) ) & 255);

II Wipe variables for security reasons #ifdef SHA 1- WIPE- VARIABLES i = 0; memset(m_buffer, 0, 64); memset(m_state, 0, 20); memset(m_count, 0,8); memset(finalcount, 0, 8); TransformReceiver(m_state, m_buffer); #endif }
#ifdefSHAI - UTILITY- FUNCTIONS II Get the final hash as a pre-formatted string void CSHAReceiver::ReportHashReceiver(char *szReport, unsigned char uReportType)
{

unsigned char i; char szTemp[16]; if( szReport == NULL) return; if(uReportType == REPORT_HEX) { sprintf(szTemp, "%02X", m_digest[O]); 80

strcat( szReport, szTem p ); for(i = 1; i < 20; i++) { sprintf(szTemp, " %02X", m_digest[i]); strcat(szReport, szTemp); }

} else if(uReportType == REPORT_DIGIT)
{

sprintf(szTemp, "%u", m_digest[O]); strcat(szReport, szTemp); for(i = 1; i < 20; i++) { sprintf(szTemp, " %u", m_digest[i]); sttcat(szReport, szTemp); } } else strcpy(szReport, "Error: Unknown report type!");
} #endif

II Get the raw message digest
void CSHAReceiver::GetHashReceiver(UINT_8 *puDest) { memcpy(puDest, m_digest, 20); }

1* End of Function Block *1 1* Undefine optional tracing in FIN/FOUT/FRET *1 1* The FSM has its own tracing code and the other *1 1* functions should not have any tracing. *I
#undefFIN TRACING #define FIN TRACING #undef FOUTRET TRACING #define FOUTRET TRACING

1* Undefine shortcuts to state variables because the *1 1* following functions are part of the state class *1
#undef bits- rcvd- stathandle #undef bitssec- rcvd- stathandle #undef pk~s_rcvd_ stathandle 81

#undef pktssec_rcvd_stathandle #undef ete_delay_ stathandle #undef bits_rcvd_gstathandle #undef bits secJcvd_gstathandle #undef pkts _rcvd_gstathandle #undef pktssec_rcvd_gstathandle #undef ete_delay_gstathandle

1* Access from C kernel using C linkage *1
extern "C" { VosT_Obtype _op_SensorNetwork_Fifo_init (int * init_block~tr); VosT_Address _op_SensorNetwork_Fifo_alloc (VosT_Obtype, int); void SensorNetwork_Fifo (OP _SIM_CONTEXT_ARG_OPT) { ((SensorNetwork_Fifo_state *)(OP_SIM_CONTEXT_PTR>_op_mod_state~tr))->SensorNetwork_Fifo (OP _SIM_CONTEXT_PTR_OPT); } void _op_SensorNetwork_Fifo_svar (void *, const char *, void **); void _op_SensorNetwork_Fifo_diag (OP _SIM_CONTEXT_ARG_OPT) { ((SensorNetwork_Fifo_state *)(OP_SIM_CONTEXT_PTR>_op_mod_state~tr))->_op_SensorNetwork_Fifo_diag (OP _SIM_CONTEXT_PTR_OPT); } void _ op_ SensorNetwork_Fifo_ ternlinate (OP _ SIM_CONTEXT_ ARG_OPT) { 1* The destructor is the Termination Block *1 delete (SensorNetwork_Fifo_state *)(OP_SIM_CONTEXT_PTR>_op_mod_state~tr); }

} 1* end of 'extern "c'" *1

1* Process model interrupt handling procedure *1

void SensorNetwork_Fifo_state::SensorNetwork_Fifo (OP_SIM_CONTEXT_ARG_OPT) {

82

#if !defined (VOSD_NO_FIN) int _op_block_origin 0; #endif FIN_ MT (SensorNetwork_Fifo_state:: SensorNetwork_Fifo 0); try { 1* Temporary Variables *1 IlPacket* pkptr; double pk_size; double ete_delay; 1* End of Temporary Variables *1

FSM_ENTER ("SensorNetwork_Fifo") FSM- BLOCK- SWITCH {

1*---------------------------------------------------------*1 1** state (INS_TAIL) enter executives **1
FSM_STATE_ENTER_UNFORCED (0, "INS_TAIL", stateO_enter_exec, "SensorNetwork_Fifo [INS_TAIL enter execs]") FSM_PROFILE_SECTlON_IN ("SensorNetwork_Fifo [INS_TAIL enter execs]", stateO_enter_exec)
{

1* Obtain the incoming packet.

*1
*/

pkptr3 0P..JJk_get (op_intrpt_stnn 0); ++packetCount;

1* Cac1ulate metrics to be updated.

pk_size = (double) op..JJk_total_size_get (pkptr3); ete_delay = op_subCLstat (0, OPC_QSTAT_DELAY); if( pk_size
{

96)

Service = 1;
}

else
{

{

op..JJk_destroy (pkptr3); 83

printf (" Queue - opyk_destroyed ");
}

Service = 0;
} }

FSM_PROFILE_SECTION_OUT (stateO_enter_exec)

1** blocking after enter executives of unforced state. **1
FSM_EXIT (l,"SensorNetwork_Fifo")

1** state (INS_TAIL) exit executives **1
FSM_STATE_EXIT_UNFORCED (0, "INS_TAIL", "SensorNetwork_Fifo [INS_TAIL exit execs]")

1* * state (INS_TAIL) transition processing **I
FSM_PROFILE_SECTION_IN ("SensorNetwork_Fifo [INS_TAIL trans conditions]", stateO_trans_ conds) FSM_INIT_COND (Service) FSM_TEST_COND (!Service) FSM_TEST_LOGIC ("INS_TAIL") FSM_PROFILE_SECTION_OUT (stateO_trans_conds) FSM- TRANSIT- SWITCH { FSM_CASE_TRANSIT (0, 1, state1_enter_exec,;, "Service", "", "INS_TAIL", "SEND_HEAD", "tr_4", "SensorNetwork_Fifo [INS_TAIL -> SEND_HEAD: Service I ]") FSM_CASE_TRANSIT (1, 2, state2_enter_exec, ;, "!Service", "", "INS_TAIL", "BRANCH", "tr_5", "SensorNetwork_Fifo [INS_TAIL -> BRANCH: !Service I ]") } 1*---------------------------------------------------- -----*/

1* * state (SEND_HEAD) enter executives **/
FSM_STATE_ENTER_UNFORCED (1, "SEND_HEAD", statel_enter_exec, "SensorNetwork_Fifo [SEND_HEAD enter execs]") FSM_PROFILE_SECTION_IN ("SensorNetwork_Fifo [SEND_HEAD enter execs]", state I_enter_exec) { Objid sub~objid; int privateKey=O; 84

int message; int nextmessage; int macenqueued=O; Packet *queuedPacket; op_ima_obLattr_get (opjd_self 0, "subqueue", &subCLobjid); num_subqs = op_topo_child_count (subCLobjid, OPC_ OBJTYPE_ SUBQ);

op~k_fd_get

(pkptr3, 0, &message); op~k_fd_get (pkptr3, 1, &privateKey); op~k_fd_get (pkptr3, 2, &nextmessage); queuedPacket = op_subuk_access (0, queuePositionHead); op~k_fd_get (queuedPacket, 0, &macenqueued);

if (CompareMessages(message, privateKey, nextmessage, mac enqueued) ) else queuePositionHead += OPC_ QPOS _HEAD;

} FSM_PROFILE_ SECTI ON_OUT (state I_enter_exec)

1** blocking after enter executives of unforced state. **1
FSM- EXIT (3,"SensorNetwork- Fifo")

1** state (SEND_HEAD) exit executives **1
FSM_STATE_EXIT_UNFORCED (1, "SEND_HEAD", "SensorNetwork_Fifo [SEND_HEAD exit execs]")

1** state (SEND_HEAD) transition processing **1
FSM TRANSIT_FORCE (2, state2_cnter_exec, ;, "default", "", "SEND_HEAD", "BRANCH", "_0", "ScnsorNetwork_Fifo [SEND_HEAD -> BRANCH: default I]")

/*---------------------------------------------------- -----*1
/** state (BRANCH) cnter executivcs **/ FSM_STATE_ENTER_FORCED (2, "BRANCH", statc2_cntcr_cxec, "SensorNetwork_Fifo [DRANCI I entcr cxecs] It)

85

FSM_PROFILE_SECTION_IN ("SensorNetwork_Fifo [BRANCH enter execs]", state2_enter_exec) { /* Initilaize the statistic handles to keep /* track of traffic sinked by this process. */ */

bitsJcvd_stathandle = op_statJeg ("Traffic Received OPC_STAT_INDEX_NONE,OPC_STAT_LOCAL); (bits)", bitssec_rcvd_stathandle = op_statJeg ("Traffic Received (bits/sec)", OPC_STAT_INDEX_NONE,OPC_STAT_LOCAL); pktsJcvd_stathandle = op_statJeg ("Traffic Received OPC_STAT_INDEX_NONE,OPC_STAT_LOCAL); (packets)", pktssec _rcvd_stathandle = op_stat_reg ("Traffic Received (packets/sec)",OPC_STAT_INDEX_NONE,OPC_STAT_LOCAL); ete..:...delay_stathandle = op_stat_reg ("End-to-End Delay OPC_STAT_INDEX_NONE,OPC_STAT_LOCAL); (seconds)", //head = OPC_QPOS_HEAD; } FSM_PROFILE_SECTION_OUT (state2_enter_exec) /** state (BRANCH) exit executives **/ FSM_STATE_EXIT_FORCED (2, "BRANCH", "SensorNetwork_Fifo [BRANCH exit execs]")

/** state (BRANCH) transition processing **/ FSM_TRANSIT_ONLY ((ARRIVAL), 0, stateO_enter_exec, ;, BRANCH, "ARRIVAL", "", "BRANCH", "INS_TAIL", " _2", "SensorNetwork_Fifo [BRANCH -> INS_TAIL: ARRIVAL / ]") /*---------------------------------------------------------*/
}

FSM_EXIT (2,"SensorNetwork_Fifo") } catch (oo.) { Vos_EITor_Print (VOSC_ERROR_ABORT, (const char *)VOSC_NIL, "Unhandled C++ exception in process model (SensorNetwork_Fifo)", (const char *)VOSC_NIL, (const char *)VOSC_NIL); } }

86

void SensorNetwork_Fifo_state::_op_SensorNetwork_Fifo_diag (OP_SIM_CONTEXT_ARG_OPT) { /* No Diagnostic Block */ } void SensorNetwork_Fifo_state::operator delete (void* ptr) { FIN (SensorNetwork_Fifo_state::operator delete (ptr)); Vos_Poolmem_Dealloc (ptr); FOUT

}
SensorNetwork_Fifo_state::~SensorNetwork_Fifo_state

(void)

{
FIN (SensorNetwork_Fifo_state: :~SensorNetwork_Fifo_state

0)

/* No Termination Block */

FOUT }

#undef FIN_PREAMBLE_DEC #undef FIN_PREAMBLE_CODE #define FIN_PREAMBLE_DEC #define FIN_PREAMBLE_CODE void * SensorNetwork_Fifo_state::operator new (size_t) #if defined (VOSD_NEW_BAD_ALLOC) tmow(VOSD_BAD_ALLOC) #endif { void * new-ptr; FIN_MT (SensorNetwork_Fifo_state::operator new 0); new-ptr = Vos_Alloc_Object (SensorNetwork_Fifo_state::obtype); #if defined (VOSD_NEW_BAD _ ALLOC) if (new-ptr == VOSC_NIL) tmow VOSD_BAD_ ALLOCO; 87

#endif FRET (newytr) }

1* State constructor initializes FSM handling *1 1* by setting the initial state to the first *1 1* block of code to enter. *1
SensorNetwork_Fifo_state::SensorNetwork_Fifo_state (void) : _op_current_block (4) { #if defined (OPD_ALLOW_ ODB) _op_current_state = "SensorNetwork_Fifo [BRANCH enter execs]"; #endif } . VosT_Obtype _op_SensorNetwork_Fifojnit (int * init_blockytr) { FIN_ MT Lop_ SensorNetwork_Fifo_init (init_blockytr» SensorNetwork_Fifo_state::obtype = Vos_Define_Object_Prstate ("proc state vars (SensorNetwork_Fifo)", size of (SensorNetwork_Fifo_state »; *init_blockytr =: 4; FRET (SensorNetwork_Fifo_ state::obtype) } VosT Address _op_SensorNetwork_Fifo_alloc (VosT_Obtype, int)
{

#if !defined (VOSD _NO_FIN) int _op_block_origin =: 0; #endif SensorNetwork_Fifo_state * ptr; FIN_MT Lop_SensorNetwork_Fifo_alloc 0)

1* New instance will have FSM handling initialized *1 #if defined (VOSD_NEW_BAD_ALLOC) try { ptr = new SensorNetwork_Fifo_state; } catch (const VOSD_BAD_ALLOC &) { ptr =: VOSC_NIL; } #else

88

ptr #endif

new SensorNetwork_Fifo_state;

FRET «VosT_Address)ptr) }

void _op_SensorNetwork_Fifo_svar (void * gen-ptr, const char * var_name, void ** var-p-ptr) { SensorNetwork- Fifo- state *prs-ptr;

if (var_name == OPC_NIL) { *var-p-ptr = (void *)OPC_NIL; .. FOUT } prs-ptr = (SensorNetwork_Fifo_state *)gen-ptr;

if (strcmp ("bitsJcvd_stathandle" , var_name) {

0)

*var-P-.Ptr = (void *) (&prs-ptr->bitsJcvd_stathandle); FOUT } if (strcmp ("bitssecJcvd_stathandle" , var_name) === 0) { *var-p-ptr = (void *) (&prs-'ptr->bitssec_rcvd_stathandle); FOUT } if (strcmp ("pkts_rcvd_stathandle" ,var_name) == 0) { *var-p-.ptr == (void *) (&prs-'ptr->pkts_rcvd_stathandle); FOUT } if (strcmp ("pktssecJcvd_stathandle" ,var_name) == 0) { *var-P-ptr (void *) (&prs-ptr->pktssec_rcvd_ stathandle); FOUT } if (strcmp ("ete_delay_stathandle" ,var_name) === 0) { *var-P-.Ptr::;;;: (void *) (&prs-ptr->ete_delay_stathandle); FOUT }

89

if (strcmp ("bits_rcvd_gstathandle" ,var_name) == 0)
{
*var~~tr

= (void *) (&prs~tr->bitsJcvd_gstathandle);

FOUT
}

if (strcmp ("bitssecJcvd_gstathandle" , var_name) == 0)
{

*var~~tr = (void *) (&prs~tr->bitssec_rcvd_gstathandle);

FOUT
} if (strcmp ("pktsJcvd_gstathandle" ,var_name) == 0)
{
*var~~tr =

(void *) (&prs~tr->pkts_rcvd_gstathandle);

FOUT
}

if (strcmp ("pktssec_rcvd_gstathandle" ,var_name) == 0) { *var~~tr = (void *) (&prsytr->pktssecJcvd_gstathandle);

FOUT
}

if (strcmp ("ete_delay_gstathandle" ,var_name) == 0)
{
*vary~tr =

(void *) (&prs~tr->ete_de1ay _gstathandle);

FOUT
}

*varyytr = (void *)OPC_NIL;

FOUT
}

90

LIST OF REFERENCES
1. A.E. Hegazy, A.M. Darwish, R. EI-Fouly, "Reducing !!TESLA memory requirements", Second International Conference on Systems and Networks Communications, ICSNC, pp.33,2007 2. Adrian Perrig, Ran Canetti, Dawn Song, J.D. Tygar, "Efficient and Secure Source Authentication for Multicast", In Network and Distributed System Security Symposium, NDSS, 35 - 46,2001 3. Adrian Perrig, Robert Szewczyk, Victor Wen, David Culler, J. D. Tygar, "SPINS: Security Protocols for Sensor Networks, Wireless Networks", 8, 521.534, 2002 4. Adrian· Perrig, Ran Canetti, J.D. Tygar, Dawn Song, "The TESLA Broadcast Authentication Protocol", RSA CryptoBytes, volume 5,2002 5. Mark Luk, Adrian Perrig, Bram Whillock, " Seven Cardinal Properties of Sensor Network Broadcast Authentication", Proceedings of the Fourth ACM Workshop on Security of ad hoc and Sensor Networks, SASN. pp. 147-156,2006 6. Donggang Liu, Peng Ning, Sencun Zhu, Sushil Jajodia, "Practical Broadcast Authentication in Sensor Networks", The Second Annual International Conference in, 118 - 129, July 2005 7. Kui Ren, Member, IEEE, Wenjing Lou, Member, IEEE, Kai Zeng, Student Member,

IEEE, and Patrick J. Moran, "On Broadcast Authentication in Wireless Sensor
Networks", IEEE Transcations on Wireless Communications, Vol. 6, No. 11, November 2007 8. Peng Ning, An Liu, Wenliang Du, "Mitigating DoS Attacks against Broadcast Authentication in Wireless Sensor Networks", ACM Transactions on Sensor Networks, Volume 4, Issue 1, January 2008 9. [9] Donggang Liu and Peng Ning, "Multi-Level !!TESLA: Broadcast
Authent~cation

for

Distributed Sensor Networks", ACM Transactions on Embedded Computing Systems, Volume 3 Issue 4, November 2004 10. El Kaissi, Rouba Zakaria, "DAWWSEN: A Defense Mechanism Against Wormhole Attacks in Wireless Sensor Networks", The Second International Conference on Innovations in Information Technology, 2005 91

11. Grigorios Katsis, "Multistage security mechanism for hybrid, large scale wireless sensor networks", Master's thesis, Naval Postgraduate School, June 2007 12. Arayeh Norouzi, Abdolreza Abhari, Truman Yang, "Enhancing Broadcast Authentication in Sensor Networks", Proceedings of the 2010 Spring Simulation Multi-conference, 2010 13. Wenliang Du, Ronghua Wang, Peng Ning, "An Efficient Scheme for Authenticating Public Keys in Sensor Networks", Proceedings of the 6th ACM international symposium on Mobile ad hoc networking and computing, 2005 14. Wen-Huei Chen and Yu-Jen Chen, "A Bootstrapping Scheme for Inter-Sensor Authentication within Sensor Networks", IEEE Communication Letters, Vol. 9, No. 10, October 2005 15. Yih-Chun Hu, Adrian Perrig, David B. Johnson, "Wormhole Attacks in Wireless Networks", Selected Areas in Communications, IEEE Journal, Volume: 24 Issue: 2, 370 380, Feb. 2006 16. Yih-Chun Hu, Adrian Perrig, David B. Johnson, "Packet Leashes: A Defense against Wormhole Attacks in Wireless Ad Hoc Networks", Joint Conference of the IEEE Computer and Communications, 1976 - 1986 vol.3, April 2003 17. David R. Raymond, Scott F. Midkiff, "Denial-of-Service in Wireless Sensor Networks: Attacks and Defenses", IEEE Pervasive Computing 7 (1), pp. 74-81, March 2008 18. Veronika Kondratieva and Seung-\Voo Seo, Member, IEEE, "Optimized Hash Tree for Authentication in Sensor Networks", IEEE Communication Letters, Vol. 11, No.2, February 2007 19. Elain Shi, Agrian Perrig, "Designing Secure Sensor Networks", Wireless

Communications, IEEE, Volume: 11 Issue:6, Pages: 38 - 43, Dec 2004 20. Wen-Huei Chen, Yu-Jen Chen, "A
C-~Tesla

Protocol for Sensor Networks", Journal of

Informatics & Electronics, Vol.2, No.2, pp.29-32, March 2008 21. Zinaida Benenson, Nils Gedicke, Ossi Raivio, "Realizing Robust User Authentication in Sensor Networks", 2005 22. Mathias Bohge, Wade Trappe, "TESLA Certificates: An Authentication Tool for Networks of Compute-Constrained Devices", In Proc. Of 2003 workshop on Wireless Security, August 2003

92

23. Zinaida Benenson, Felix U'artner, Dogan Kesdogan,"User Authentication in Sensor Networks (Extended Abstract)", In Proceedings ofInformatik 2004, Workshop on Sensor Networks, 2004 24. Roberto Di Pietro, Luigi V. Mancini, Alessandro Mei, "Energy efficient node-to-node authentication and communication confidentiality in wireless sensor networks", Wireless Networks 12 (6), pp. 709-721, November 2006 25. Huei-Ru Tseng, Rong-Hong Jan, and Wuu Yang, "An Improved Dynamic User Authentication Scheme for Wireless Sensor Networks", Gobal Telecommunications Conference, IEEE, 86 - 990, November 2007 26. [26] Jeffery Undercoffer, Sasikanth Avancha, Anupam Joshi, John Pinkston, "Security for Sensor Networks", Chapter 12, 253-275,2004 27. Kui Ren, Wenjing Lou, Yanchao Zhang, "Mulit-user Broadcast Authentication in Wireless Sensor Networks", Sensor, Mesh and Ad Hoc Communications and Networks, 2007, 223 - 232, June 2007 28. Ronghua Wang, Wenliang Du, Peng Ning, "Containing Denial-of-Service Attacks in Broadcast Authentication in Sensor Networks", Proceedings of the 8th ACM international symposium on Mobile ad hoc networking and computing, 2007 29. Xiaojian Tian, Duncan S. Wong, Member, IEEE, and Robert W. Zhu, Student Member,
IEEE,

"Analysis and Improvement of an Authenticated Key exchange Protocol for

Sensor Networks", IEEE Communications Letters, Vol. 9, No. 11, November 2005 30. Jian Wang, Z Y Xia, Lein Ham, "Storage-Optimal Key Sharing with Authentication in Sensor Networks", lET Conference Publications (496 CP), pp. 134,2005 31. Xuefei Cao , Weidong Kou, Lanjun Dang, Bin Zhao, "IMBAS: Identity-based multi-user broadcast authentication in wireless sensor networks", Computer Communications 31, 659-667,2008 32. F. L. Lewis, "Wireless Sensor Networks", To appear in Smart Environments: Technologies, Protocols, and Applications ed. D.J. Cook and S.K. Das, John Wiley, New York, 2004 33. Mike Chen, Weidong Cui, Victor Wen, "Security and Deployment Issues in a Sensor Network", International Journal Of Communications, Issue 1, Volume 2,2008

93

34. Taojun Wu, Yi Cui, Brano Kusy, Akos Ledeczi, Janos Sallai, Nathan Skirvin, Jan Werner, Yuan Xue, "A Fast and Efficient Source Authentication Solution for Broadcasting in Wireless Sensor Networks", Proceedings of New Technologies, Mobility and Security, ifip, IEEE, May, 2007 35. Harald Vogt, "Exploring Message Authentication in Sensor Networks", Lecture Notes in Computer Science 3313, pp. 19-30, 2005 36. Li Zhou, Chinya V. Ravishankar, "Dynamic Merkle Trees for Verifying Privileges in Sensor Networks", Communications, 2006. ICC '06, IEEE, Volume: 5,2276 - 2282, June 2006 37. Truman Yang, "Computer Network Security Lecture Notes", Ryerson University, 2008 38. Tommy Svensson, Alex Popescu, "OPNET Modeler", Master Thesis, Blekinge Institute of Technology, June 2003 39. OPNET Modeler Help

,

,'

94

